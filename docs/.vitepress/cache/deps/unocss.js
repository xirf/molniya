import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@babel/parser/lib/index.js
var require_lib = __commonJS({
  "node_modules/@babel/parser/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _objectWithoutPropertiesLoose(r, e2) {
      if (null == r) return {};
      var t = {};
      for (var n2 in r) if ({}.hasOwnProperty.call(r, n2)) {
        if (-1 !== e2.indexOf(n2)) continue;
        t[n2] = r[n2];
      }
      return t;
    }
    var Position = class {
      constructor(line, col, index) {
        this.line = void 0;
        this.column = void 0;
        this.index = void 0;
        this.line = line;
        this.column = col;
        this.index = index;
      }
    };
    var SourceLocation = class {
      constructor(start, end) {
        this.start = void 0;
        this.end = void 0;
        this.filename = void 0;
        this.identifierName = void 0;
        this.start = start;
        this.end = end;
      }
    };
    function createPositionWithColumnOffset(position3, columnOffset) {
      const {
        line,
        column,
        index
      } = position3;
      return new Position(line, column + columnOffset, index + columnOffset);
    }
    var code2 = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
    var ModuleErrors = {
      ImportMetaOutsideModule: {
        message: `import.meta may appear only with 'sourceType: "module"'`,
        code: code2
      },
      ImportOutsideModule: {
        message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
        code: code2
      }
    };
    var NodeDescriptions = {
      ArrayPattern: "array destructuring pattern",
      AssignmentExpression: "assignment expression",
      AssignmentPattern: "assignment expression",
      ArrowFunctionExpression: "arrow function expression",
      ConditionalExpression: "conditional expression",
      CatchClause: "catch clause",
      ForOfStatement: "for-of statement",
      ForInStatement: "for-in statement",
      ForStatement: "for-loop",
      FormalParameters: "function parameter list",
      Identifier: "identifier",
      ImportSpecifier: "import specifier",
      ImportDefaultSpecifier: "import default specifier",
      ImportNamespaceSpecifier: "import namespace specifier",
      ObjectPattern: "object destructuring pattern",
      ParenthesizedExpression: "parenthesized expression",
      RestElement: "rest element",
      UpdateExpression: {
        true: "prefix operation",
        false: "postfix operation"
      },
      VariableDeclarator: "variable declaration",
      YieldExpression: "yield expression"
    };
    var toNodeDescription = (node) => node.type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[`${node.prefix}`] : NodeDescriptions[node.type];
    var StandardErrors = {
      AccessorIsGenerator: ({
        kind
      }) => `A ${kind}ter cannot be a generator.`,
      ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
      AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
      AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
      AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
      AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
      AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
      AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
      BadGetterArity: "A 'get' accessor must not have any formal parameters.",
      BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
      BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
      ConstructorClassField: "Classes may not have a field named 'constructor'.",
      ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
      ConstructorIsAccessor: "Class constructor may not be an accessor.",
      ConstructorIsAsync: "Constructor can't be an async function.",
      ConstructorIsGenerator: "Constructor can't be a generator.",
      DeclarationMissingInitializer: ({
        kind
      }) => `Missing initializer in ${kind} declaration.`,
      DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
      DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
      DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
      DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
      DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
      DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
      DecoratorStaticBlock: "Decorators can't be used with a static block.",
      DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
      DeletePrivateField: "Deleting a private field is not allowed.",
      DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
      DuplicateConstructor: "Duplicate constructor in the same class.",
      DuplicateDefaultExport: "Only one default export allowed per module.",
      DuplicateExport: ({
        exportName
      }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
      DuplicateProto: "Redefinition of __proto__ property.",
      DuplicateRegExpFlags: "Duplicate regular expression flag.",
      ElementAfterRest: "Rest element must be last element.",
      EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
      ExportBindingIsString: ({
        localName,
        exportName
      }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
      ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
      ForInOfLoopInitializer: ({
        type
      }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
      ForInUsing: "For-in loop may not start with 'using' declaration.",
      ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
      ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
      GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
      IllegalBreakContinue: ({
        type
      }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
      IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
      IllegalReturn: "'return' outside of function.",
      ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
      ImportBindingIsString: ({
        importName
      }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
      ImportCallArity: `\`import()\` requires exactly one or two arguments.`,
      ImportCallNotNewExpression: "Cannot use new with import(...).",
      ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
      ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
      ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
      ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
      IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
      InvalidBigIntLiteral: "Invalid BigIntLiteral.",
      InvalidCodePoint: "Code point out of bounds.",
      InvalidCoverInitializedName: "Invalid shorthand property initializer.",
      InvalidDecimal: "Invalid decimal.",
      InvalidDigit: ({
        radix
      }) => `Expected number in radix ${radix}.`,
      InvalidEscapeSequence: "Bad character escape sequence.",
      InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
      InvalidEscapedReservedWord: ({
        reservedWord
      }) => `Escape sequence in keyword ${reservedWord}.`,
      InvalidIdentifier: ({
        identifierName
      }) => `Invalid identifier ${identifierName}.`,
      InvalidLhs: ({
        ancestor
      }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
      InvalidLhsBinding: ({
        ancestor
      }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
      InvalidLhsOptionalChaining: ({
        ancestor
      }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
      InvalidNumber: "Invalid number.",
      InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
      InvalidOrUnexpectedToken: ({
        unexpected
      }) => `Unexpected character '${unexpected}'.`,
      InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
      InvalidPrivateFieldResolution: ({
        identifierName
      }) => `Private name #${identifierName} is not defined.`,
      InvalidPropertyBindingPattern: "Binding member expression.",
      InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
      InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
      LabelRedeclaration: ({
        labelName
      }) => `Label '${labelName}' is already declared.`,
      LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
      LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
      MalformedRegExpFlags: "Invalid regular expression flag.",
      MissingClassName: "A class name is required.",
      MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
      MissingSemicolon: "Missing semicolon.",
      MissingPlugin: ({
        missingPlugin
      }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name50) => JSON.stringify(name50)).join(", ")}.`,
      MissingOneOfPlugins: ({
        missingPlugin
      }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name50) => JSON.stringify(name50)).join(", ")}.`,
      MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
      MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
      ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
      ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
      ModuleAttributesWithDuplicateKeys: ({
        key
      }) => `Duplicate key "${key}" is not allowed in module attributes.`,
      ModuleExportNameHasLoneSurrogate: ({
        surrogateCharCode
      }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
      ModuleExportUndefined: ({
        localName
      }) => `Export '${localName}' is not defined.`,
      MultipleDefaultsInSwitch: "Multiple default clauses.",
      NewlineAfterThrow: "Illegal newline after throw.",
      NoCatchOrFinally: "Missing catch or finally clause.",
      NumberIdentifier: "Identifier directly after number.",
      NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
      ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
      OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
      OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
      OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
      ParamDupe: "Argument name clash.",
      PatternHasAccessor: "Object pattern can't contain getter or setter.",
      PatternHasMethod: "Object pattern can't contain methods.",
      PrivateInExpectedIn: ({
        identifierName
      }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
      PrivateNameRedeclaration: ({
        identifierName
      }) => `Duplicate private name #${identifierName}.`,
      RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      RecordNoProto: "'__proto__' is not allowed in Record expressions.",
      RestTrailingComma: "Unexpected trailing comma after rest element.",
      SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
      SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
      SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
      StaticPrototype: "Classes may not have static property named prototype.",
      SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
      SuperPrivateField: "Private fields can't be accessed on super.",
      TrailingDecorator: "Decorators must be attached to a class element.",
      TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
      UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
      UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
      UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
      UnexpectedKeyword: ({
        keyword: keyword2
      }) => `Unexpected keyword '${keyword2}'.`,
      UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
      UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
      UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
      UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
      UnexpectedPrivateField: "Unexpected private name.",
      UnexpectedReservedWord: ({
        reservedWord
      }) => `Unexpected reserved word '${reservedWord}'.`,
      UnexpectedSuper: "'super' is only allowed in object methods and classes.",
      UnexpectedToken: ({
        expected,
        unexpected
      }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
      UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
      UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script` or in the bare case statement.",
      UnsupportedBind: "Binding should be performed on object property.",
      UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
      UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
      UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
      UnsupportedMetaProperty: ({
        target,
        onlyValidPropertyName
      }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
      UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
      UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
      UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
      UnterminatedComment: "Unterminated comment.",
      UnterminatedRegExp: "Unterminated regular expression.",
      UnterminatedString: "Unterminated string constant.",
      UnterminatedTemplate: "Unterminated template.",
      UsingDeclarationExport: "Using declaration cannot be exported.",
      UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
      VarRedeclaration: ({
        identifierName
      }) => `Identifier '${identifierName}' has already been declared.`,
      YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
      YieldInParameter: "Yield expression is not allowed in formal parameters.",
      YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.",
      ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
    };
    var StrictModeErrors = {
      StrictDelete: "Deleting local variable in strict mode.",
      StrictEvalArguments: ({
        referenceName
      }) => `Assigning to '${referenceName}' in strict mode.`,
      StrictEvalArgumentsBinding: ({
        bindingName
      }) => `Binding '${bindingName}' in strict mode.`,
      StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
      StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
      StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
      StrictWith: "'with' in strict mode."
    };
    var ParseExpressionErrors = {
      ParseExpressionEmptyInput: "Unexpected parseExpression() input: The input is empty or contains only comments.",
      ParseExpressionExpectsEOF: ({
        unexpected
      }) => `Unexpected parseExpression() input: The input should contain exactly one expression, but the first expression is followed by the unexpected character \`${String.fromCodePoint(unexpected)}\`.`
    };
    var UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
    var PipelineOperatorErrors = Object.assign({
      PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
      PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
      PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
      PipeTopicUnconfiguredToken: ({
        token
      }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
      PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
      PipeUnparenthesizedBody: ({
        type
      }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
        type
      })}; please wrap it in parentheses.`
    }, {
      PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
      PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
      PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
      PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
      PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
      PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
    });
    var _excluded = ["message"];
    function defineHidden(obj, key, value) {
      Object.defineProperty(obj, key, {
        enumerable: false,
        configurable: true,
        value
      });
    }
    function toParseErrorConstructor({
      toMessage,
      code: code3,
      reasonCode,
      syntaxPlugin
    }) {
      const hasMissingPlugin = reasonCode === "MissingPlugin" || reasonCode === "MissingOneOfPlugins";
      {
        const oldReasonCodes = {
          AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
          AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
          ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference",
          SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
          SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
          SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
        };
        if (oldReasonCodes[reasonCode]) {
          reasonCode = oldReasonCodes[reasonCode];
        }
      }
      return function constructor(loc, details) {
        const error = new SyntaxError();
        error.code = code3;
        error.reasonCode = reasonCode;
        error.loc = loc;
        error.pos = loc.index;
        error.syntaxPlugin = syntaxPlugin;
        if (hasMissingPlugin) {
          error.missingPlugin = details.missingPlugin;
        }
        defineHidden(error, "clone", function clone3(overrides = {}) {
          var _overrides$loc;
          const {
            line,
            column,
            index
          } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;
          return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));
        });
        defineHidden(error, "details", details);
        Object.defineProperty(error, "message", {
          configurable: true,
          get() {
            const message = `${toMessage(details)} (${loc.line}:${loc.column})`;
            this.message = message;
            return message;
          },
          set(value) {
            Object.defineProperty(this, "message", {
              value,
              writable: true
            });
          }
        });
        return error;
      };
    }
    function ParseErrorEnum(argument, syntaxPlugin) {
      if (Array.isArray(argument)) {
        return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
      }
      const ParseErrorConstructors = {};
      for (const reasonCode of Object.keys(argument)) {
        const template = argument[reasonCode];
        const _ref = typeof template === "string" ? {
          message: () => template
        } : typeof template === "function" ? {
          message: template
        } : template, {
          message
        } = _ref, rest = _objectWithoutPropertiesLoose(_ref, _excluded);
        const toMessage = typeof message === "string" ? () => message : message;
        ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
          code: "BABEL_PARSER_SYNTAX_ERROR",
          reasonCode,
          toMessage
        }, syntaxPlugin ? {
          syntaxPlugin
        } : {}, rest));
      }
      return ParseErrorConstructors;
    }
    var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum(ParseExpressionErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
    function createDefaultOptions() {
      return {
        sourceType: "script",
        sourceFilename: void 0,
        startIndex: 0,
        startColumn: 0,
        startLine: 1,
        allowAwaitOutsideFunction: false,
        allowReturnOutsideFunction: false,
        allowNewTargetOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowSuperOutsideMethod: false,
        allowUndeclaredExports: false,
        allowYieldOutsideFunction: false,
        plugins: [],
        strictMode: null,
        ranges: false,
        tokens: false,
        createImportExpressions: false,
        createParenthesizedExpressions: false,
        errorRecovery: false,
        attachComment: true,
        annexB: true
      };
    }
    function getOptions(opts) {
      const options = createDefaultOptions();
      if (opts == null) {
        return options;
      }
      if (opts.annexB != null && opts.annexB !== false) {
        throw new Error("The `annexB` option can only be set to `false`.");
      }
      for (const key of Object.keys(options)) {
        if (opts[key] != null) options[key] = opts[key];
      }
      if (options.startLine === 1) {
        if (opts.startIndex == null && options.startColumn > 0) {
          options.startIndex = options.startColumn;
        } else if (opts.startColumn == null && options.startIndex > 0) {
          options.startColumn = options.startIndex;
        }
      } else if (opts.startColumn == null || opts.startIndex == null) {
        if (opts.startIndex != null) {
          throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
        }
      }
      return options;
    }
    var {
      defineProperty: defineProperty2
    } = Object;
    var toUnenumerable = (object, key) => {
      if (object) {
        defineProperty2(object, key, {
          enumerable: false,
          value: object[key]
        });
      }
    };
    function toESTreeLocation(node) {
      toUnenumerable(node.loc.start, "index");
      toUnenumerable(node.loc.end, "index");
      return node;
    }
    var estree = (superClass) => class ESTreeParserMixin extends superClass {
      parse() {
        const file = toESTreeLocation(super.parse());
        if (this.optionFlags & 256) {
          file.tokens = file.tokens.map(toESTreeLocation);
        }
        return file;
      }
      parseRegExpLiteral({
        pattern,
        flags
      }) {
        let regex = null;
        try {
          regex = new RegExp(pattern, flags);
        } catch (_) {
        }
        const node = this.estreeParseLiteral(regex);
        node.regex = {
          pattern,
          flags
        };
        return node;
      }
      parseBigIntLiteral(value) {
        let bigInt;
        try {
          bigInt = BigInt(value);
        } catch (_unused) {
          bigInt = null;
        }
        const node = this.estreeParseLiteral(bigInt);
        node.bigint = String(node.value || value);
        return node;
      }
      parseDecimalLiteral(value) {
        const decimal = null;
        const node = this.estreeParseLiteral(decimal);
        node.decimal = String(node.value || value);
        return node;
      }
      estreeParseLiteral(value) {
        return this.parseLiteral(value, "Literal");
      }
      parseStringLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      parseNumericLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      parseNullLiteral() {
        return this.estreeParseLiteral(null);
      }
      parseBooleanLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      estreeParseChainExpression(node, endLoc) {
        const chain = this.startNodeAtNode(node);
        chain.expression = node;
        return this.finishNodeAt(chain, "ChainExpression", endLoc);
      }
      directiveToStmt(directive) {
        const expression = directive.value;
        delete directive.value;
        this.castNodeTo(expression, "Literal");
        expression.raw = expression.extra.raw;
        expression.value = expression.extra.expressionValue;
        const stmt = this.castNodeTo(directive, "ExpressionStatement");
        stmt.expression = expression;
        stmt.directive = expression.extra.rawValue;
        delete expression.extra;
        return stmt;
      }
      fillOptionalPropertiesForTSESLint(node) {
      }
      cloneEstreeStringLiteral(node) {
        const {
          start,
          end,
          loc,
          range,
          raw,
          value
        } = node;
        const cloned = Object.create(node.constructor.prototype);
        cloned.type = "Literal";
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        cloned.raw = raw;
        cloned.value = value;
        return cloned;
      }
      initFunction(node, isAsync) {
        super.initFunction(node, isAsync);
        node.expression = false;
      }
      checkDeclaration(node) {
        if (node != null && this.isObjectProperty(node)) {
          this.checkDeclaration(node.value);
        } else {
          super.checkDeclaration(node);
        }
      }
      getObjectOrClassMethodParams(method) {
        return method.value.params;
      }
      isValidDirective(stmt) {
        var _stmt$expression$extr;
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
      }
      parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
        const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
        node.body = directiveStatements.concat(node.body);
        delete node.directives;
      }
      parsePrivateName() {
        const node = super.parsePrivateName();
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return node;
          }
        }
        return this.convertPrivateNameToPrivateIdentifier(node);
      }
      convertPrivateNameToPrivateIdentifier(node) {
        const name50 = super.getPrivateNameSV(node);
        node = node;
        delete node.id;
        node.name = name50;
        return this.castNodeTo(node, "PrivateIdentifier");
      }
      isPrivateName(node) {
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return super.isPrivateName(node);
          }
        }
        return node.type === "PrivateIdentifier";
      }
      getPrivateNameSV(node) {
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return super.getPrivateNameSV(node);
          }
        }
        return node.name;
      }
      parseLiteral(value, type) {
        const node = super.parseLiteral(value, type);
        node.raw = node.extra.raw;
        delete node.extra;
        return node;
      }
      parseFunctionBody(node, allowExpression, isMethod = false) {
        super.parseFunctionBody(node, allowExpression, isMethod);
        node.expression = node.body.type !== "BlockStatement";
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        let funcNode = this.startNode();
        funcNode.kind = node.kind;
        funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        delete funcNode.kind;
        const {
          typeParameters
        } = node;
        if (typeParameters) {
          delete node.typeParameters;
          funcNode.typeParameters = typeParameters;
          this.resetStartLocationFromNode(funcNode, typeParameters);
        }
        const valueNode = this.castNodeTo(funcNode, "FunctionExpression");
        node.value = valueNode;
        if (type === "ClassPrivateMethod") {
          node.computed = false;
        }
        if (type === "ObjectMethod") {
          if (node.kind === "method") {
            node.kind = "init";
          }
          node.shorthand = false;
          return this.finishNode(node, "Property");
        } else {
          return this.finishNode(node, "MethodDefinition");
        }
      }
      nameIsConstructor(key) {
        if (key.type === "Literal") return key.value === "constructor";
        return super.nameIsConstructor(key);
      }
      parseClassProperty(...args) {
        const propertyNode = super.parseClassProperty(...args);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return propertyNode;
          }
        }
        {
          this.castNodeTo(propertyNode, "PropertyDefinition");
        }
        return propertyNode;
      }
      parseClassPrivateProperty(...args) {
        const propertyNode = super.parseClassPrivateProperty(...args);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return propertyNode;
          }
        }
        {
          this.castNodeTo(propertyNode, "PropertyDefinition");
        }
        propertyNode.computed = false;
        return propertyNode;
      }
      parseClassAccessorProperty(node) {
        const accessorPropertyNode = super.parseClassAccessorProperty(node);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return accessorPropertyNode;
          }
        }
        if (accessorPropertyNode.abstract && this.hasPlugin("typescript")) {
          delete accessorPropertyNode.abstract;
          this.castNodeTo(accessorPropertyNode, "TSAbstractAccessorProperty");
        } else {
          this.castNodeTo(accessorPropertyNode, "AccessorProperty");
        }
        return accessorPropertyNode;
      }
      parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
        if (node) {
          node.kind = "init";
          this.castNodeTo(node, "Property");
        }
        return node;
      }
      finishObjectProperty(node) {
        node.kind = "init";
        return this.finishNode(node, "Property");
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        return type === "Property" ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
      }
      isAssignable(node, isBinding) {
        if (node != null && this.isObjectProperty(node)) {
          return this.isAssignable(node.value, isBinding);
        }
        return super.isAssignable(node, isBinding);
      }
      toAssignable(node, isLHS = false) {
        if (node != null && this.isObjectProperty(node)) {
          const {
            key,
            value
          } = node;
          if (this.isPrivateName(key)) {
            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
          }
          this.toAssignable(value, isLHS);
        } else {
          super.toAssignable(node, isLHS);
        }
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === "Property" && (prop.kind === "get" || prop.kind === "set")) {
          this.raise(Errors.PatternHasAccessor, prop.key);
        } else if (prop.type === "Property" && prop.method) {
          this.raise(Errors.PatternHasMethod, prop.key);
        } else {
          super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
        }
      }
      finishCallExpression(unfinished, optional) {
        const node = super.finishCallExpression(unfinished, optional);
        if (node.callee.type === "Import") {
          var _ref, _ref2;
          this.castNodeTo(node, "ImportExpression");
          node.source = node.arguments[0];
          node.options = (_ref = node.arguments[1]) != null ? _ref : null;
          node.attributes = (_ref2 = node.arguments[1]) != null ? _ref2 : null;
          delete node.arguments;
          delete node.callee;
        } else if (node.type === "OptionalCallExpression") {
          this.castNodeTo(node, "CallExpression");
        } else {
          node.optional = false;
        }
        return node;
      }
      toReferencedArguments(node) {
        if (node.type === "ImportExpression") {
          return;
        }
        super.toReferencedArguments(node);
      }
      parseExport(unfinished, decorators) {
        const exportStartLoc = this.state.lastTokStartLoc;
        const node = super.parseExport(unfinished, decorators);
        switch (node.type) {
          case "ExportAllDeclaration":
            node.exported = null;
            break;
          case "ExportNamedDeclaration":
            if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
              this.castNodeTo(node, "ExportAllDeclaration");
              node.exported = node.specifiers[0].exported;
              delete node.specifiers;
            }
          case "ExportDefaultDeclaration":
            {
              var _declaration$decorato;
              const {
                declaration
              } = node;
              if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {
                this.resetStartLocation(node, exportStartLoc);
              }
            }
            break;
        }
        return node;
      }
      stopParseSubscript(base, state) {
        const node = super.stopParseSubscript(base, state);
        if (state.optionalChainMember) {
          return this.estreeParseChainExpression(node, base.loc.end);
        }
        return node;
      }
      parseMember(base, startLoc, state, computed, optional) {
        const node = super.parseMember(base, startLoc, state, computed, optional);
        if (node.type === "OptionalMemberExpression") {
          this.castNodeTo(node, "MemberExpression");
        } else {
          node.optional = false;
        }
        return node;
      }
      isOptionalMemberExpression(node) {
        if (node.type === "ChainExpression") {
          return node.expression.type === "MemberExpression";
        }
        return super.isOptionalMemberExpression(node);
      }
      hasPropertyAsPrivateName(node) {
        if (node.type === "ChainExpression") {
          node = node.expression;
        }
        return super.hasPropertyAsPrivateName(node);
      }
      isObjectProperty(node) {
        return node.type === "Property" && node.kind === "init" && !node.method;
      }
      isObjectMethod(node) {
        return node.type === "Property" && (node.method || node.kind === "get" || node.kind === "set");
      }
      castNodeTo(node, type) {
        const result = super.castNodeTo(node, type);
        this.fillOptionalPropertiesForTSESLint(result);
        return result;
      }
      cloneIdentifier(node) {
        const cloned = super.cloneIdentifier(node);
        this.fillOptionalPropertiesForTSESLint(cloned);
        return cloned;
      }
      cloneStringLiteral(node) {
        if (node.type === "Literal") {
          return this.cloneEstreeStringLiteral(node);
        }
        return super.cloneStringLiteral(node);
      }
      finishNodeAt(node, type, endLoc) {
        return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
      }
      finishNode(node, type) {
        const result = super.finishNode(node, type);
        this.fillOptionalPropertiesForTSESLint(result);
        return result;
      }
      resetStartLocation(node, startLoc) {
        super.resetStartLocation(node, startLoc);
        toESTreeLocation(node);
      }
      resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        super.resetEndLocation(node, endLoc);
        toESTreeLocation(node);
      }
    };
    var TokContext = class {
      constructor(token, preserveSpace) {
        this.token = void 0;
        this.preserveSpace = void 0;
        this.token = token;
        this.preserveSpace = !!preserveSpace;
      }
    };
    var types = {
      brace: new TokContext("{"),
      j_oTag: new TokContext("<tag"),
      j_cTag: new TokContext("</tag"),
      j_expr: new TokContext("<tag>...</tag>", true)
    };
    {
      types.template = new TokContext("`", true);
    }
    var beforeExpr = true;
    var startsExpr = true;
    var isLoop = true;
    var isAssign = true;
    var prefix = true;
    var postfix = true;
    var ExportedTokenType = class {
      constructor(label, conf = {}) {
        this.label = void 0;
        this.keyword = void 0;
        this.beforeExpr = void 0;
        this.startsExpr = void 0;
        this.rightAssociative = void 0;
        this.isLoop = void 0;
        this.isAssign = void 0;
        this.prefix = void 0;
        this.postfix = void 0;
        this.binop = void 0;
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.rightAssociative = !!conf.rightAssociative;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop != null ? conf.binop : null;
        {
          this.updateContext = null;
        }
      }
    };
    var keywords$1 = /* @__PURE__ */ new Map();
    function createKeyword(name50, options = {}) {
      options.keyword = name50;
      const token = createToken(name50, options);
      keywords$1.set(name50, token);
      return token;
    }
    function createBinop(name50, binop) {
      return createToken(name50, {
        beforeExpr,
        binop
      });
    }
    var tokenTypeCounter = -1;
    var tokenTypes2 = [];
    var tokenLabels = [];
    var tokenBinops = [];
    var tokenBeforeExprs = [];
    var tokenStartsExprs = [];
    var tokenPrefixes = [];
    function createToken(name50, options = {}) {
      var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
      ++tokenTypeCounter;
      tokenLabels.push(name50);
      tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
      tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
      tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
      tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
      tokenTypes2.push(new ExportedTokenType(name50, options));
      return tokenTypeCounter;
    }
    function createKeywordLike(name50, options = {}) {
      var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
      ++tokenTypeCounter;
      keywords$1.set(name50, tokenTypeCounter);
      tokenLabels.push(name50);
      tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
      tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
      tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
      tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
      tokenTypes2.push(new ExportedTokenType("name", options));
      return tokenTypeCounter;
    }
    var tt = {
      bracketL: createToken("[", {
        beforeExpr,
        startsExpr
      }),
      bracketHashL: createToken("#[", {
        beforeExpr,
        startsExpr
      }),
      bracketBarL: createToken("[|", {
        beforeExpr,
        startsExpr
      }),
      bracketR: createToken("]"),
      bracketBarR: createToken("|]"),
      braceL: createToken("{", {
        beforeExpr,
        startsExpr
      }),
      braceBarL: createToken("{|", {
        beforeExpr,
        startsExpr
      }),
      braceHashL: createToken("#{", {
        beforeExpr,
        startsExpr
      }),
      braceR: createToken("}"),
      braceBarR: createToken("|}"),
      parenL: createToken("(", {
        beforeExpr,
        startsExpr
      }),
      parenR: createToken(")"),
      comma: createToken(",", {
        beforeExpr
      }),
      semi: createToken(";", {
        beforeExpr
      }),
      colon: createToken(":", {
        beforeExpr
      }),
      doubleColon: createToken("::", {
        beforeExpr
      }),
      dot: createToken("."),
      question: createToken("?", {
        beforeExpr
      }),
      questionDot: createToken("?."),
      arrow: createToken("=>", {
        beforeExpr
      }),
      template: createToken("template"),
      ellipsis: createToken("...", {
        beforeExpr
      }),
      backQuote: createToken("`", {
        startsExpr
      }),
      dollarBraceL: createToken("${", {
        beforeExpr,
        startsExpr
      }),
      templateTail: createToken("...`", {
        startsExpr
      }),
      templateNonTail: createToken("...${", {
        beforeExpr,
        startsExpr
      }),
      at: createToken("@"),
      hash: createToken("#", {
        startsExpr
      }),
      interpreterDirective: createToken("#!..."),
      eq: createToken("=", {
        beforeExpr,
        isAssign
      }),
      assign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      slashAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      xorAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      moduloAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      incDec: createToken("++/--", {
        prefix,
        postfix,
        startsExpr
      }),
      bang: createToken("!", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      tilde: createToken("~", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      doubleCaret: createToken("^^", {
        startsExpr
      }),
      doubleAt: createToken("@@", {
        startsExpr
      }),
      pipeline: createBinop("|>", 0),
      nullishCoalescing: createBinop("??", 1),
      logicalOR: createBinop("||", 1),
      logicalAND: createBinop("&&", 2),
      bitwiseOR: createBinop("|", 3),
      bitwiseXOR: createBinop("^", 4),
      bitwiseAND: createBinop("&", 5),
      equality: createBinop("==/!=/===/!==", 6),
      lt: createBinop("</>/<=/>=", 7),
      gt: createBinop("</>/<=/>=", 7),
      relational: createBinop("</>/<=/>=", 7),
      bitShift: createBinop("<</>>/>>>", 8),
      bitShiftL: createBinop("<</>>/>>>", 8),
      bitShiftR: createBinop("<</>>/>>>", 8),
      plusMin: createToken("+/-", {
        beforeExpr,
        binop: 9,
        prefix,
        startsExpr
      }),
      modulo: createToken("%", {
        binop: 10,
        startsExpr
      }),
      star: createToken("*", {
        binop: 10
      }),
      slash: createBinop("/", 10),
      exponent: createToken("**", {
        beforeExpr,
        binop: 11,
        rightAssociative: true
      }),
      _in: createKeyword("in", {
        beforeExpr,
        binop: 7
      }),
      _instanceof: createKeyword("instanceof", {
        beforeExpr,
        binop: 7
      }),
      _break: createKeyword("break"),
      _case: createKeyword("case", {
        beforeExpr
      }),
      _catch: createKeyword("catch"),
      _continue: createKeyword("continue"),
      _debugger: createKeyword("debugger"),
      _default: createKeyword("default", {
        beforeExpr
      }),
      _else: createKeyword("else", {
        beforeExpr
      }),
      _finally: createKeyword("finally"),
      _function: createKeyword("function", {
        startsExpr
      }),
      _if: createKeyword("if"),
      _return: createKeyword("return", {
        beforeExpr
      }),
      _switch: createKeyword("switch"),
      _throw: createKeyword("throw", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _try: createKeyword("try"),
      _var: createKeyword("var"),
      _const: createKeyword("const"),
      _with: createKeyword("with"),
      _new: createKeyword("new", {
        beforeExpr,
        startsExpr
      }),
      _this: createKeyword("this", {
        startsExpr
      }),
      _super: createKeyword("super", {
        startsExpr
      }),
      _class: createKeyword("class", {
        startsExpr
      }),
      _extends: createKeyword("extends", {
        beforeExpr
      }),
      _export: createKeyword("export"),
      _import: createKeyword("import", {
        startsExpr
      }),
      _null: createKeyword("null", {
        startsExpr
      }),
      _true: createKeyword("true", {
        startsExpr
      }),
      _false: createKeyword("false", {
        startsExpr
      }),
      _typeof: createKeyword("typeof", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _void: createKeyword("void", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _delete: createKeyword("delete", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _do: createKeyword("do", {
        isLoop,
        beforeExpr
      }),
      _for: createKeyword("for", {
        isLoop
      }),
      _while: createKeyword("while", {
        isLoop
      }),
      _as: createKeywordLike("as", {
        startsExpr
      }),
      _assert: createKeywordLike("assert", {
        startsExpr
      }),
      _async: createKeywordLike("async", {
        startsExpr
      }),
      _await: createKeywordLike("await", {
        startsExpr
      }),
      _defer: createKeywordLike("defer", {
        startsExpr
      }),
      _from: createKeywordLike("from", {
        startsExpr
      }),
      _get: createKeywordLike("get", {
        startsExpr
      }),
      _let: createKeywordLike("let", {
        startsExpr
      }),
      _meta: createKeywordLike("meta", {
        startsExpr
      }),
      _of: createKeywordLike("of", {
        startsExpr
      }),
      _sent: createKeywordLike("sent", {
        startsExpr
      }),
      _set: createKeywordLike("set", {
        startsExpr
      }),
      _source: createKeywordLike("source", {
        startsExpr
      }),
      _static: createKeywordLike("static", {
        startsExpr
      }),
      _using: createKeywordLike("using", {
        startsExpr
      }),
      _yield: createKeywordLike("yield", {
        startsExpr
      }),
      _asserts: createKeywordLike("asserts", {
        startsExpr
      }),
      _checks: createKeywordLike("checks", {
        startsExpr
      }),
      _exports: createKeywordLike("exports", {
        startsExpr
      }),
      _global: createKeywordLike("global", {
        startsExpr
      }),
      _implements: createKeywordLike("implements", {
        startsExpr
      }),
      _intrinsic: createKeywordLike("intrinsic", {
        startsExpr
      }),
      _infer: createKeywordLike("infer", {
        startsExpr
      }),
      _is: createKeywordLike("is", {
        startsExpr
      }),
      _mixins: createKeywordLike("mixins", {
        startsExpr
      }),
      _proto: createKeywordLike("proto", {
        startsExpr
      }),
      _require: createKeywordLike("require", {
        startsExpr
      }),
      _satisfies: createKeywordLike("satisfies", {
        startsExpr
      }),
      _keyof: createKeywordLike("keyof", {
        startsExpr
      }),
      _readonly: createKeywordLike("readonly", {
        startsExpr
      }),
      _unique: createKeywordLike("unique", {
        startsExpr
      }),
      _abstract: createKeywordLike("abstract", {
        startsExpr
      }),
      _declare: createKeywordLike("declare", {
        startsExpr
      }),
      _enum: createKeywordLike("enum", {
        startsExpr
      }),
      _module: createKeywordLike("module", {
        startsExpr
      }),
      _namespace: createKeywordLike("namespace", {
        startsExpr
      }),
      _interface: createKeywordLike("interface", {
        startsExpr
      }),
      _type: createKeywordLike("type", {
        startsExpr
      }),
      _opaque: createKeywordLike("opaque", {
        startsExpr
      }),
      name: createToken("name", {
        startsExpr
      }),
      placeholder: createToken("%%", {
        startsExpr
      }),
      string: createToken("string", {
        startsExpr
      }),
      num: createToken("num", {
        startsExpr
      }),
      bigint: createToken("bigint", {
        startsExpr
      }),
      decimal: createToken("decimal", {
        startsExpr
      }),
      regexp: createToken("regexp", {
        startsExpr
      }),
      privateName: createToken("#name", {
        startsExpr
      }),
      eof: createToken("eof"),
      jsxName: createToken("jsxName"),
      jsxText: createToken("jsxText", {
        beforeExpr
      }),
      jsxTagStart: createToken("jsxTagStart", {
        startsExpr
      }),
      jsxTagEnd: createToken("jsxTagEnd")
    };
    function tokenIsIdentifier(token) {
      return token >= 93 && token <= 133;
    }
    function tokenKeywordOrIdentifierIsKeyword(token) {
      return token <= 92;
    }
    function tokenIsKeywordOrIdentifier(token) {
      return token >= 58 && token <= 133;
    }
    function tokenIsLiteralPropertyName(token) {
      return token >= 58 && token <= 137;
    }
    function tokenComesBeforeExpression(token) {
      return tokenBeforeExprs[token];
    }
    function tokenCanStartExpression(token) {
      return tokenStartsExprs[token];
    }
    function tokenIsAssignment(token) {
      return token >= 29 && token <= 33;
    }
    function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
      return token >= 129 && token <= 131;
    }
    function tokenIsLoop(token) {
      return token >= 90 && token <= 92;
    }
    function tokenIsKeyword(token) {
      return token >= 58 && token <= 92;
    }
    function tokenIsOperator(token) {
      return token >= 39 && token <= 59;
    }
    function tokenIsPostfix(token) {
      return token === 34;
    }
    function tokenIsPrefix(token) {
      return tokenPrefixes[token];
    }
    function tokenIsTSTypeOperator(token) {
      return token >= 121 && token <= 123;
    }
    function tokenIsTSDeclarationStart(token) {
      return token >= 124 && token <= 130;
    }
    function tokenLabelName(token) {
      return tokenLabels[token];
    }
    function tokenOperatorPrecedence(token) {
      return tokenBinops[token];
    }
    function tokenIsRightAssociative(token) {
      return token === 57;
    }
    function tokenIsTemplate(token) {
      return token >= 24 && token <= 25;
    }
    function getExportedToken(token) {
      return tokenTypes2[token];
    }
    {
      tokenTypes2[8].updateContext = (context) => {
        context.pop();
      };
      tokenTypes2[5].updateContext = tokenTypes2[7].updateContext = tokenTypes2[23].updateContext = (context) => {
        context.push(types.brace);
      };
      tokenTypes2[22].updateContext = (context) => {
        if (context[context.length - 1] === types.template) {
          context.pop();
        } else {
          context.push(types.template);
        }
      };
      tokenTypes2[143].updateContext = (context) => {
        context.push(types.j_expr, types.j_oTag);
      };
    }
    var nonASCIIidentifierStartChars = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
    var nonASCIIidentifierChars = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code3, set) {
      let pos = 65536;
      for (let i = 0, length2 = set.length; i < length2; i += 2) {
        pos += set[i];
        if (pos > code3) return false;
        pos += set[i + 1];
        if (pos >= code3) return true;
      }
      return false;
    }
    function isIdentifierStart2(code3) {
      if (code3 < 65) return code3 === 36;
      if (code3 <= 90) return true;
      if (code3 < 97) return code3 === 95;
      if (code3 <= 122) return true;
      if (code3 <= 65535) {
        return code3 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code3));
      }
      return isInAstralSet(code3, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code3) {
      if (code3 < 48) return code3 === 36;
      if (code3 < 58) return true;
      if (code3 < 65) return false;
      if (code3 <= 90) return true;
      if (code3 < 97) return code3 === 95;
      if (code3 <= 122) return true;
      if (code3 <= 65535) {
        return code3 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code3));
      }
      return isInAstralSet(code3, astralIdentifierStartCodes) || isInAstralSet(code3, astralIdentifierCodes);
    }
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords2 = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword2(word) {
      return keywords2.has(word);
    }
    function isIteratorStart(current, next, next2) {
      return current === 64 && next === 64 && isIdentifierStart2(next2);
    }
    var reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
    function canBeReservedWord(word) {
      return reservedWordLikeSet.has(word);
    }
    var Scope = class {
      constructor(flags) {
        this.flags = 0;
        this.names = /* @__PURE__ */ new Map();
        this.firstLexicalName = "";
        this.flags = flags;
      }
    };
    var ScopeHandler = class {
      constructor(parser, inModule) {
        this.parser = void 0;
        this.scopeStack = [];
        this.inModule = void 0;
        this.undefinedExports = /* @__PURE__ */ new Map();
        this.parser = parser;
        this.inModule = inModule;
      }
      get inTopLevel() {
        return (this.currentScope().flags & 1) > 0;
      }
      get inFunction() {
        return (this.currentVarScopeFlags() & 2) > 0;
      }
      get allowSuper() {
        return (this.currentThisScopeFlags() & 16) > 0;
      }
      get allowDirectSuper() {
        return (this.currentThisScopeFlags() & 32) > 0;
      }
      get allowNewTarget() {
        return (this.currentThisScopeFlags() & 512) > 0;
      }
      get inClass() {
        return (this.currentThisScopeFlags() & 64) > 0;
      }
      get inClassAndNotInNonArrowFunction() {
        const flags = this.currentThisScopeFlags();
        return (flags & 64) > 0 && (flags & 2) === 0;
      }
      get inStaticBlock() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & 128) {
            return true;
          }
          if (flags & (1667 | 64)) {
            return false;
          }
        }
      }
      get inNonArrowFunction() {
        return (this.currentThisScopeFlags() & 2) > 0;
      }
      get inBareCaseStatement() {
        return (this.currentScope().flags & 256) > 0;
      }
      get treatFunctionsAsVar() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }
      createScope(flags) {
        return new Scope(flags);
      }
      enter(flags) {
        this.scopeStack.push(this.createScope(flags));
      }
      exit() {
        const scope = this.scopeStack.pop();
        return scope.flags;
      }
      treatFunctionsAsVarInScope(scope) {
        return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);
      }
      declareName(name50, bindingType, loc) {
        let scope = this.currentScope();
        if (bindingType & 8 || bindingType & 16) {
          this.checkRedeclarationInScope(scope, name50, bindingType, loc);
          let type = scope.names.get(name50) || 0;
          if (bindingType & 16) {
            type = type | 4;
          } else {
            if (!scope.firstLexicalName) {
              scope.firstLexicalName = name50;
            }
            type = type | 2;
          }
          scope.names.set(name50, type);
          if (bindingType & 8) {
            this.maybeExportDefined(scope, name50);
          }
        } else if (bindingType & 4) {
          for (let i = this.scopeStack.length - 1; i >= 0; --i) {
            scope = this.scopeStack[i];
            this.checkRedeclarationInScope(scope, name50, bindingType, loc);
            scope.names.set(name50, (scope.names.get(name50) || 0) | 1);
            this.maybeExportDefined(scope, name50);
            if (scope.flags & 1667) break;
          }
        }
        if (this.parser.inModule && scope.flags & 1) {
          this.undefinedExports.delete(name50);
        }
      }
      maybeExportDefined(scope, name50) {
        if (this.parser.inModule && scope.flags & 1) {
          this.undefinedExports.delete(name50);
        }
      }
      checkRedeclarationInScope(scope, name50, bindingType, loc) {
        if (this.isRedeclaredInScope(scope, name50, bindingType)) {
          this.parser.raise(Errors.VarRedeclaration, loc, {
            identifierName: name50
          });
        }
      }
      isRedeclaredInScope(scope, name50, bindingType) {
        if (!(bindingType & 1)) return false;
        if (bindingType & 8) {
          return scope.names.has(name50);
        }
        const type = scope.names.get(name50);
        if (bindingType & 16) {
          return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;
        }
        return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name50) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;
      }
      checkLocalExport(id) {
        const {
          name: name50
        } = id;
        const topLevelScope = this.scopeStack[0];
        if (!topLevelScope.names.has(name50)) {
          this.undefinedExports.set(name50, id.loc.start);
        }
      }
      currentScope() {
        return this.scopeStack[this.scopeStack.length - 1];
      }
      currentVarScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & 1667) {
            return flags;
          }
        }
      }
      currentThisScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & (1667 | 64) && !(flags & 4)) {
            return flags;
          }
        }
      }
    };
    var FlowScope = class extends Scope {
      constructor(...args) {
        super(...args);
        this.declareFunctions = /* @__PURE__ */ new Set();
      }
    };
    var FlowScopeHandler = class extends ScopeHandler {
      createScope(flags) {
        return new FlowScope(flags);
      }
      declareName(name50, bindingType, loc) {
        const scope = this.currentScope();
        if (bindingType & 2048) {
          this.checkRedeclarationInScope(scope, name50, bindingType, loc);
          this.maybeExportDefined(scope, name50);
          scope.declareFunctions.add(name50);
          return;
        }
        super.declareName(name50, bindingType, loc);
      }
      isRedeclaredInScope(scope, name50, bindingType) {
        if (super.isRedeclaredInScope(scope, name50, bindingType)) return true;
        if (bindingType & 2048 && !scope.declareFunctions.has(name50)) {
          const type = scope.names.get(name50);
          return (type & 4) > 0 || (type & 2) > 0;
        }
        return false;
      }
      checkLocalExport(id) {
        if (!this.scopeStack[0].declareFunctions.has(id.name)) {
          super.checkLocalExport(id);
        }
      }
    };
    var reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
    var FlowErrors = ParseErrorEnum`flow`({
      AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
      AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
      AssignReservedType: ({
        reservedType
      }) => `Cannot overwrite reserved type ${reservedType}.`,
      DeclareClassElement: "The `declare` modifier can only appear on class fields.",
      DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
      DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
      EnumBooleanMemberNotInitialized: ({
        memberName,
        enumName
      }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
      EnumDuplicateMemberName: ({
        memberName,
        enumName
      }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
      EnumInconsistentMemberValues: ({
        enumName
      }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
      EnumInvalidExplicitType: ({
        invalidEnumType,
        enumName
      }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
      EnumInvalidExplicitTypeUnknownSupplied: ({
        enumName
      }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
      EnumInvalidMemberInitializerPrimaryType: ({
        enumName,
        memberName,
        explicitType
      }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
      EnumInvalidMemberInitializerSymbolType: ({
        enumName,
        memberName
      }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
      EnumInvalidMemberInitializerUnknownType: ({
        enumName,
        memberName
      }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
      EnumInvalidMemberName: ({
        enumName,
        memberName,
        suggestion
      }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
      EnumNumberMemberNotInitialized: ({
        enumName,
        memberName
      }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
      EnumStringMemberInconsistentlyInitialized: ({
        enumName
      }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
      GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
      ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
      InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
      InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
      InexactVariance: "Explicit inexact syntax cannot have variance.",
      InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
      MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
      NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
      NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
      PatternIsOptional: Object.assign({
        message: "A binding pattern parameter cannot be optional in an implementation signature."
      }, {
        reasonCode: "OptionalBindingPattern"
      }),
      SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
      SpreadVariance: "Spread properties cannot have variance.",
      ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
      ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
      ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
      ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
      ThisParamNoDefault: "The `this` parameter may not have a default value.",
      TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
      UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
      UnexpectedReservedType: ({
        reservedType
      }) => `Unexpected reserved type ${reservedType}.`,
      UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
      UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
      UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
      UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
      UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
      UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
      UnsupportedDeclareExportKind: ({
        unsupportedExportKind,
        suggestion
      }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
      UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
      UnterminatedFlowComment: "Unterminated flow-comment."
    });
    function isEsModuleType(bodyElement) {
      return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
    }
    function hasTypeImportKind(node) {
      return node.importKind === "type" || node.importKind === "typeof";
    }
    var exportSuggestions = {
      const: "declare export var",
      let: "declare export var",
      type: "export type",
      interface: "export interface"
    };
    function partition(list, test) {
      const list1 = [];
      const list2 = [];
      for (let i = 0; i < list.length; i++) {
        (test(list[i], i, list) ? list1 : list2).push(list[i]);
      }
      return [list1, list2];
    }
    var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
    var flow = (superClass) => class FlowParserMixin extends superClass {
      constructor(...args) {
        super(...args);
        this.flowPragma = void 0;
      }
      getScopeHandler() {
        return FlowScopeHandler;
      }
      shouldParseTypes() {
        return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
      }
      finishToken(type, val) {
        if (type !== 134 && type !== 13 && type !== 28) {
          if (this.flowPragma === void 0) {
            this.flowPragma = null;
          }
        }
        super.finishToken(type, val);
      }
      addComment(comment) {
        if (this.flowPragma === void 0) {
          const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
          if (!matches) ;
          else if (matches[1] === "flow") {
            this.flowPragma = "flow";
          } else if (matches[1] === "noflow") {
            this.flowPragma = "noflow";
          } else {
            throw new Error("Unexpected flow pragma");
          }
        }
        super.addComment(comment);
      }
      flowParseTypeInitialiser(tok) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(tok || 14);
        const type = this.flowParseType();
        this.state.inType = oldInType;
        return type;
      }
      flowParsePredicate() {
        const node = this.startNode();
        const moduloLoc = this.state.startLoc;
        this.next();
        this.expectContextual(110);
        if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {
          this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);
        }
        if (this.eat(10)) {
          node.value = super.parseExpression();
          this.expect(11);
          return this.finishNode(node, "DeclaredPredicate");
        } else {
          return this.finishNode(node, "InferredPredicate");
        }
      }
      flowParseTypeAndPredicateInitialiser() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(14);
        let type = null;
        let predicate = null;
        if (this.match(54)) {
          this.state.inType = oldInType;
          predicate = this.flowParsePredicate();
        } else {
          type = this.flowParseType();
          this.state.inType = oldInType;
          if (this.match(54)) {
            predicate = this.flowParsePredicate();
          }
        }
        return [type, predicate];
      }
      flowParseDeclareClass(node) {
        this.next();
        this.flowParseInterfaceish(node, true);
        return this.finishNode(node, "DeclareClass");
      }
      flowParseDeclareFunction(node) {
        this.next();
        const id = node.id = this.parseIdentifier();
        const typeNode = this.startNode();
        const typeContainer = this.startNode();
        if (this.match(47)) {
          typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          typeNode.typeParameters = null;
        }
        this.expect(10);
        const tmp = this.flowParseFunctionTypeParams();
        typeNode.params = tmp.params;
        typeNode.rest = tmp.rest;
        typeNode.this = tmp._this;
        this.expect(11);
        [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
        typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
        id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
        this.resetEndLocation(id);
        this.semicolon();
        this.scope.declareName(node.id.name, 2048, node.id.loc.start);
        return this.finishNode(node, "DeclareFunction");
      }
      flowParseDeclare(node, insideModule) {
        if (this.match(80)) {
          return this.flowParseDeclareClass(node);
        } else if (this.match(68)) {
          return this.flowParseDeclareFunction(node);
        } else if (this.match(74)) {
          return this.flowParseDeclareVariable(node);
        } else if (this.eatContextual(127)) {
          if (this.match(16)) {
            return this.flowParseDeclareModuleExports(node);
          } else {
            if (insideModule) {
              this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);
            }
            return this.flowParseDeclareModule(node);
          }
        } else if (this.isContextual(130)) {
          return this.flowParseDeclareTypeAlias(node);
        } else if (this.isContextual(131)) {
          return this.flowParseDeclareOpaqueType(node);
        } else if (this.isContextual(129)) {
          return this.flowParseDeclareInterface(node);
        } else if (this.match(82)) {
          return this.flowParseDeclareExportDeclaration(node, insideModule);
        } else {
          this.unexpected();
        }
      }
      flowParseDeclareVariable(node) {
        this.next();
        node.id = this.flowParseTypeAnnotatableIdentifier(true);
        this.scope.declareName(node.id.name, 5, node.id.loc.start);
        this.semicolon();
        return this.finishNode(node, "DeclareVariable");
      }
      flowParseDeclareModule(node) {
        this.scope.enter(0);
        if (this.match(134)) {
          node.id = super.parseExprAtom();
        } else {
          node.id = this.parseIdentifier();
        }
        const bodyNode = node.body = this.startNode();
        const body = bodyNode.body = [];
        this.expect(5);
        while (!this.match(8)) {
          let bodyNode2 = this.startNode();
          if (this.match(83)) {
            this.next();
            if (!this.isContextual(130) && !this.match(87)) {
              this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);
            }
            super.parseImport(bodyNode2);
          } else {
            this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);
            bodyNode2 = this.flowParseDeclare(bodyNode2, true);
          }
          body.push(bodyNode2);
        }
        this.scope.exit();
        this.expect(8);
        this.finishNode(bodyNode, "BlockStatement");
        let kind = null;
        let hasModuleExport = false;
        body.forEach((bodyElement) => {
          if (isEsModuleType(bodyElement)) {
            if (kind === "CommonJS") {
              this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
            }
            kind = "ES";
          } else if (bodyElement.type === "DeclareModuleExports") {
            if (hasModuleExport) {
              this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);
            }
            if (kind === "ES") {
              this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
            }
            kind = "CommonJS";
            hasModuleExport = true;
          }
        });
        node.kind = kind || "CommonJS";
        return this.finishNode(node, "DeclareModule");
      }
      flowParseDeclareExportDeclaration(node, insideModule) {
        this.expect(82);
        if (this.eat(65)) {
          if (this.match(68) || this.match(80)) {
            node.declaration = this.flowParseDeclare(this.startNode());
          } else {
            node.declaration = this.flowParseType();
            this.semicolon();
          }
          node.default = true;
          return this.finishNode(node, "DeclareExportDeclaration");
        } else {
          if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
            const label = this.state.value;
            throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {
              unsupportedExportKind: label,
              suggestion: exportSuggestions[label]
            });
          }
          if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {
            node.declaration = this.flowParseDeclare(this.startNode());
            node.default = false;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
            node = this.parseExport(node, null);
            if (node.type === "ExportNamedDeclaration") {
              node.default = false;
              delete node.exportKind;
              return this.castNodeTo(node, "DeclareExportDeclaration");
            } else {
              return this.castNodeTo(node, "DeclareExportAllDeclaration");
            }
          }
        }
        this.unexpected();
      }
      flowParseDeclareModuleExports(node) {
        this.next();
        this.expectContextual(111);
        node.typeAnnotation = this.flowParseTypeAnnotation();
        this.semicolon();
        return this.finishNode(node, "DeclareModuleExports");
      }
      flowParseDeclareTypeAlias(node) {
        this.next();
        const finished = this.flowParseTypeAlias(node);
        this.castNodeTo(finished, "DeclareTypeAlias");
        return finished;
      }
      flowParseDeclareOpaqueType(node) {
        this.next();
        const finished = this.flowParseOpaqueType(node, true);
        this.castNodeTo(finished, "DeclareOpaqueType");
        return finished;
      }
      flowParseDeclareInterface(node) {
        this.next();
        this.flowParseInterfaceish(node, false);
        return this.finishNode(node, "DeclareInterface");
      }
      flowParseInterfaceish(node, isClass) {
        node.id = this.flowParseRestrictedIdentifier(!isClass, true);
        this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.extends = [];
        if (this.eat(81)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (!isClass && this.eat(12));
        }
        if (isClass) {
          node.implements = [];
          node.mixins = [];
          if (this.eatContextual(117)) {
            do {
              node.mixins.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          if (this.eatContextual(113)) {
            do {
              node.implements.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
        }
        node.body = this.flowParseObjectType({
          allowStatic: isClass,
          allowExact: false,
          allowSpread: false,
          allowProto: isClass,
          allowInexact: false
        });
      }
      flowParseInterfaceExtends() {
        const node = this.startNode();
        node.id = this.flowParseQualifiedTypeIdentifier();
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        } else {
          node.typeParameters = null;
        }
        return this.finishNode(node, "InterfaceExtends");
      }
      flowParseInterface(node) {
        this.flowParseInterfaceish(node, false);
        return this.finishNode(node, "InterfaceDeclaration");
      }
      checkNotUnderscore(word) {
        if (word === "_") {
          this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);
        }
      }
      checkReservedType(word, startLoc, declaration) {
        if (!reservedTypes.has(word)) return;
        this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {
          reservedType: word
        });
      }
      flowParseRestrictedIdentifier(liberal, declaration) {
        this.checkReservedType(this.state.value, this.state.startLoc, declaration);
        return this.parseIdentifier(liberal);
      }
      flowParseTypeAlias(node) {
        node.id = this.flowParseRestrictedIdentifier(false, true);
        this.scope.declareName(node.id.name, 8201, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.right = this.flowParseTypeInitialiser(29);
        this.semicolon();
        return this.finishNode(node, "TypeAlias");
      }
      flowParseOpaqueType(node, declare) {
        this.expectContextual(130);
        node.id = this.flowParseRestrictedIdentifier(true, true);
        this.scope.declareName(node.id.name, 8201, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.supertype = null;
        if (this.match(14)) {
          node.supertype = this.flowParseTypeInitialiser(14);
        }
        node.impltype = null;
        if (!declare) {
          node.impltype = this.flowParseTypeInitialiser(29);
        }
        this.semicolon();
        return this.finishNode(node, "OpaqueType");
      }
      flowParseTypeParameter(requireDefault = false) {
        const nodeStartLoc = this.state.startLoc;
        const node = this.startNode();
        const variance = this.flowParseVariance();
        const ident = this.flowParseTypeAnnotatableIdentifier();
        node.name = ident.name;
        node.variance = variance;
        node.bound = ident.typeAnnotation;
        if (this.match(29)) {
          this.eat(29);
          node.default = this.flowParseType();
        } else {
          if (requireDefault) {
            this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);
          }
        }
        return this.finishNode(node, "TypeParameter");
      }
      flowParseTypeParameterDeclaration() {
        const oldInType = this.state.inType;
        const node = this.startNode();
        node.params = [];
        this.state.inType = true;
        if (this.match(47) || this.match(143)) {
          this.next();
        } else {
          this.unexpected();
        }
        let defaultRequired = false;
        do {
          const typeParameter = this.flowParseTypeParameter(defaultRequired);
          node.params.push(typeParameter);
          if (typeParameter.default) {
            defaultRequired = true;
          }
          if (!this.match(48)) {
            this.expect(12);
          }
        } while (!this.match(48));
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterDeclaration");
      }
      flowInTopLevelContext(cb) {
        if (this.curContext() !== types.brace) {
          const oldContext = this.state.context;
          this.state.context = [oldContext[0]];
          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        } else {
          return cb();
        }
      }
      flowParseTypeParameterInstantiationInExpression() {
        if (this.reScan_lt() !== 47) return;
        return this.flowParseTypeParameterInstantiation();
      }
      flowParseTypeParameterInstantiation() {
        const node = this.startNode();
        const oldInType = this.state.inType;
        this.state.inType = true;
        node.params = [];
        this.flowInTopLevelContext(() => {
          this.expect(47);
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = false;
          while (!this.match(48)) {
            node.params.push(this.flowParseType());
            if (!this.match(48)) {
              this.expect(12);
            }
          }
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        });
        this.state.inType = oldInType;
        if (!this.state.inType && this.curContext() === types.brace) {
          this.reScan_lt_gt();
        }
        this.expect(48);
        return this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseTypeParameterInstantiationCallOrNew() {
        if (this.reScan_lt() !== 47) return;
        const node = this.startNode();
        const oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expect(47);
        while (!this.match(48)) {
          node.params.push(this.flowParseTypeOrImplicitInstantiation());
          if (!this.match(48)) {
            this.expect(12);
          }
        }
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseInterfaceType() {
        const node = this.startNode();
        this.expectContextual(129);
        node.extends = [];
        if (this.eat(81)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
        node.body = this.flowParseObjectType({
          allowStatic: false,
          allowExact: false,
          allowSpread: false,
          allowProto: false,
          allowInexact: false
        });
        return this.finishNode(node, "InterfaceTypeAnnotation");
      }
      flowParseObjectPropertyKey() {
        return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(true);
      }
      flowParseObjectTypeIndexer(node, isStatic, variance) {
        node.static = isStatic;
        if (this.lookahead().type === 14) {
          node.id = this.flowParseObjectPropertyKey();
          node.key = this.flowParseTypeInitialiser();
        } else {
          node.id = null;
          node.key = this.flowParseType();
        }
        this.expect(3);
        node.value = this.flowParseTypeInitialiser();
        node.variance = variance;
        return this.finishNode(node, "ObjectTypeIndexer");
      }
      flowParseObjectTypeInternalSlot(node, isStatic) {
        node.static = isStatic;
        node.id = this.flowParseObjectPropertyKey();
        this.expect(3);
        this.expect(3);
        if (this.match(47) || this.match(10)) {
          node.method = true;
          node.optional = false;
          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
        } else {
          node.method = false;
          if (this.eat(17)) {
            node.optional = true;
          }
          node.value = this.flowParseTypeInitialiser();
        }
        return this.finishNode(node, "ObjectTypeInternalSlot");
      }
      flowParseObjectTypeMethodish(node) {
        node.params = [];
        node.rest = null;
        node.typeParameters = null;
        node.this = null;
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        this.expect(10);
        if (this.match(78)) {
          node.this = this.flowParseFunctionTypeParam(true);
          node.this.name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          node.params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          node.rest = this.flowParseFunctionTypeParam(false);
        }
        this.expect(11);
        node.returnType = this.flowParseTypeInitialiser();
        return this.finishNode(node, "FunctionTypeAnnotation");
      }
      flowParseObjectTypeCallProperty(node, isStatic) {
        const valueNode = this.startNode();
        node.static = isStatic;
        node.value = this.flowParseObjectTypeMethodish(valueNode);
        return this.finishNode(node, "ObjectTypeCallProperty");
      }
      flowParseObjectType({
        allowStatic,
        allowExact,
        allowSpread,
        allowProto,
        allowInexact
      }) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const nodeStart = this.startNode();
        nodeStart.callProperties = [];
        nodeStart.properties = [];
        nodeStart.indexers = [];
        nodeStart.internalSlots = [];
        let endDelim;
        let exact;
        let inexact = false;
        if (allowExact && this.match(6)) {
          this.expect(6);
          endDelim = 9;
          exact = true;
        } else {
          this.expect(5);
          endDelim = 8;
          exact = false;
        }
        nodeStart.exact = exact;
        while (!this.match(endDelim)) {
          let isStatic = false;
          let protoStartLoc = null;
          let inexactStartLoc = null;
          const node = this.startNode();
          if (allowProto && this.isContextual(118)) {
            const lookahead = this.lookahead();
            if (lookahead.type !== 14 && lookahead.type !== 17) {
              this.next();
              protoStartLoc = this.state.startLoc;
              allowStatic = false;
            }
          }
          if (allowStatic && this.isContextual(106)) {
            const lookahead = this.lookahead();
            if (lookahead.type !== 14 && lookahead.type !== 17) {
              this.next();
              isStatic = true;
            }
          }
          const variance = this.flowParseVariance();
          if (this.eat(0)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (this.eat(0)) {
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
            } else {
              nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
            }
          } else if (this.match(10) || this.match(47)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
          } else {
            let kind = "init";
            if (this.isContextual(99) || this.isContextual(104)) {
              const lookahead = this.lookahead();
              if (tokenIsLiteralPropertyName(lookahead.type)) {
                kind = this.state.value;
                this.next();
              }
            }
            const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
            if (propOrInexact === null) {
              inexact = true;
              inexactStartLoc = this.state.lastTokStartLoc;
            } else {
              nodeStart.properties.push(propOrInexact);
            }
          }
          this.flowObjectTypeSemicolon();
          if (inexactStartLoc && !this.match(8) && !this.match(9)) {
            this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);
          }
        }
        this.expect(endDelim);
        if (allowSpread) {
          nodeStart.inexact = inexact;
        }
        const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
        this.state.inType = oldInType;
        return out;
      }
      flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
        if (this.eat(21)) {
          const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
          if (isInexactToken) {
            if (!allowSpread) {
              this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);
            } else if (!allowInexact) {
              this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);
            }
            if (variance) {
              this.raise(FlowErrors.InexactVariance, variance);
            }
            return null;
          }
          if (!allowSpread) {
            this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);
          }
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc);
          }
          if (variance) {
            this.raise(FlowErrors.SpreadVariance, variance);
          }
          node.argument = this.flowParseType();
          return this.finishNode(node, "ObjectTypeSpreadProperty");
        } else {
          node.key = this.flowParseObjectPropertyKey();
          node.static = isStatic;
          node.proto = protoStartLoc != null;
          node.kind = kind;
          let optional = false;
          if (this.match(47) || this.match(10)) {
            node.method = true;
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
            if (kind === "get" || kind === "set") {
              this.flowCheckGetterSetterParams(node);
            }
            if (!allowSpread && node.key.name === "constructor" && node.value.this) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this);
            }
          } else {
            if (kind !== "init") this.unexpected();
            node.method = false;
            if (this.eat(17)) {
              optional = true;
            }
            node.value = this.flowParseTypeInitialiser();
            node.variance = variance;
          }
          node.optional = optional;
          return this.finishNode(node, "ObjectTypeProperty");
        }
      }
      flowCheckGetterSetterParams(property4) {
        const paramCount = property4.kind === "get" ? 0 : 1;
        const length2 = property4.value.params.length + (property4.value.rest ? 1 : 0);
        if (property4.value.this) {
          this.raise(property4.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property4.value.this);
        }
        if (length2 !== paramCount) {
          this.raise(property4.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, property4);
        }
        if (property4.kind === "set" && property4.value.rest) {
          this.raise(Errors.BadSetterRestParameter, property4);
        }
      }
      flowObjectTypeSemicolon() {
        if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
          this.unexpected();
        }
      }
      flowParseQualifiedTypeIdentifier(startLoc, id) {
        startLoc != null ? startLoc : startLoc = this.state.startLoc;
        let node = id || this.flowParseRestrictedIdentifier(true);
        while (this.eat(16)) {
          const node2 = this.startNodeAt(startLoc);
          node2.qualification = node;
          node2.id = this.flowParseRestrictedIdentifier(true);
          node = this.finishNode(node2, "QualifiedTypeIdentifier");
        }
        return node;
      }
      flowParseGenericType(startLoc, id) {
        const node = this.startNodeAt(startLoc);
        node.typeParameters = null;
        node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        }
        return this.finishNode(node, "GenericTypeAnnotation");
      }
      flowParseTypeofType() {
        const node = this.startNode();
        this.expect(87);
        node.argument = this.flowParsePrimaryType();
        return this.finishNode(node, "TypeofTypeAnnotation");
      }
      flowParseTupleType() {
        const node = this.startNode();
        node.types = [];
        this.expect(0);
        while (this.state.pos < this.length && !this.match(3)) {
          node.types.push(this.flowParseType());
          if (this.match(3)) break;
          this.expect(12);
        }
        this.expect(3);
        return this.finishNode(node, "TupleTypeAnnotation");
      }
      flowParseFunctionTypeParam(first) {
        let name50 = null;
        let optional = false;
        let typeAnnotation = null;
        const node = this.startNode();
        const lh = this.lookahead();
        const isThis = this.state.type === 78;
        if (lh.type === 14 || lh.type === 17) {
          if (isThis && !first) {
            this.raise(FlowErrors.ThisParamMustBeFirst, node);
          }
          name50 = this.parseIdentifier(isThis);
          if (this.eat(17)) {
            optional = true;
            if (isThis) {
              this.raise(FlowErrors.ThisParamMayNotBeOptional, node);
            }
          }
          typeAnnotation = this.flowParseTypeInitialiser();
        } else {
          typeAnnotation = this.flowParseType();
        }
        node.name = name50;
        node.optional = optional;
        node.typeAnnotation = typeAnnotation;
        return this.finishNode(node, "FunctionTypeParam");
      }
      reinterpretTypeAsFunctionTypeParam(type) {
        const node = this.startNodeAt(type.loc.start);
        node.name = null;
        node.optional = false;
        node.typeAnnotation = type;
        return this.finishNode(node, "FunctionTypeParam");
      }
      flowParseFunctionTypeParams(params = []) {
        let rest = null;
        let _this = null;
        if (this.match(78)) {
          _this = this.flowParseFunctionTypeParam(true);
          _this.name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          rest = this.flowParseFunctionTypeParam(false);
        }
        return {
          params,
          rest,
          _this
        };
      }
      flowIdentToTypeAnnotation(startLoc, node, id) {
        switch (id.name) {
          case "any":
            return this.finishNode(node, "AnyTypeAnnotation");
          case "bool":
          case "boolean":
            return this.finishNode(node, "BooleanTypeAnnotation");
          case "mixed":
            return this.finishNode(node, "MixedTypeAnnotation");
          case "empty":
            return this.finishNode(node, "EmptyTypeAnnotation");
          case "number":
            return this.finishNode(node, "NumberTypeAnnotation");
          case "string":
            return this.finishNode(node, "StringTypeAnnotation");
          case "symbol":
            return this.finishNode(node, "SymbolTypeAnnotation");
          default:
            this.checkNotUnderscore(id.name);
            return this.flowParseGenericType(startLoc, id);
        }
      }
      flowParsePrimaryType() {
        const startLoc = this.state.startLoc;
        const node = this.startNode();
        let tmp;
        let type;
        let isGroupedType = false;
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        switch (this.state.type) {
          case 5:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: false,
              allowSpread: true,
              allowProto: false,
              allowInexact: true
            });
          case 6:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: true,
              allowSpread: true,
              allowProto: false,
              allowInexact: false
            });
          case 0:
            this.state.noAnonFunctionType = false;
            type = this.flowParseTupleType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            return type;
          case 47: {
            const node2 = this.startNode();
            node2.typeParameters = this.flowParseTypeParameterDeclaration();
            this.expect(10);
            tmp = this.flowParseFunctionTypeParams();
            node2.params = tmp.params;
            node2.rest = tmp.rest;
            node2.this = tmp._this;
            this.expect(11);
            this.expect(19);
            node2.returnType = this.flowParseType();
            return this.finishNode(node2, "FunctionTypeAnnotation");
          }
          case 10: {
            const node2 = this.startNode();
            this.next();
            if (!this.match(11) && !this.match(21)) {
              if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                const token = this.lookahead().type;
                isGroupedType = token !== 17 && token !== 14;
              } else {
                isGroupedType = true;
              }
            }
            if (isGroupedType) {
              this.state.noAnonFunctionType = false;
              type = this.flowParseType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                this.expect(11);
                return type;
              } else {
                this.eat(12);
              }
            }
            if (type) {
              tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
            } else {
              tmp = this.flowParseFunctionTypeParams();
            }
            node2.params = tmp.params;
            node2.rest = tmp.rest;
            node2.this = tmp._this;
            this.expect(11);
            this.expect(19);
            node2.returnType = this.flowParseType();
            node2.typeParameters = null;
            return this.finishNode(node2, "FunctionTypeAnnotation");
          }
          case 134:
            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
          case 85:
          case 86:
            node.value = this.match(85);
            this.next();
            return this.finishNode(node, "BooleanLiteralTypeAnnotation");
          case 53:
            if (this.state.value === "-") {
              this.next();
              if (this.match(135)) {
                return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
              }
              if (this.match(136)) {
                return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
              }
              throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);
            }
            this.unexpected();
            return;
          case 135:
            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
          case 136:
            return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
          case 88:
            this.next();
            return this.finishNode(node, "VoidTypeAnnotation");
          case 84:
            this.next();
            return this.finishNode(node, "NullLiteralTypeAnnotation");
          case 78:
            this.next();
            return this.finishNode(node, "ThisTypeAnnotation");
          case 55:
            this.next();
            return this.finishNode(node, "ExistsTypeAnnotation");
          case 87:
            return this.flowParseTypeofType();
          default:
            if (tokenIsKeyword(this.state.type)) {
              const label = tokenLabelName(this.state.type);
              this.next();
              return super.createIdentifier(node, label);
            } else if (tokenIsIdentifier(this.state.type)) {
              if (this.isContextual(129)) {
                return this.flowParseInterfaceType();
              }
              return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
            }
        }
        this.unexpected();
      }
      flowParsePostfixType() {
        const startLoc = this.state.startLoc;
        let type = this.flowParsePrimaryType();
        let seenOptionalIndexedAccess = false;
        while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
          const node = this.startNodeAt(startLoc);
          const optional = this.eat(18);
          seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
          this.expect(0);
          if (!optional && this.match(3)) {
            node.elementType = type;
            this.next();
            type = this.finishNode(node, "ArrayTypeAnnotation");
          } else {
            node.objectType = type;
            node.indexType = this.flowParseType();
            this.expect(3);
            if (seenOptionalIndexedAccess) {
              node.optional = optional;
              type = this.finishNode(node, "OptionalIndexedAccessType");
            } else {
              type = this.finishNode(node, "IndexedAccessType");
            }
          }
        }
        return type;
      }
      flowParsePrefixType() {
        const node = this.startNode();
        if (this.eat(17)) {
          node.typeAnnotation = this.flowParsePrefixType();
          return this.finishNode(node, "NullableTypeAnnotation");
        } else {
          return this.flowParsePostfixType();
        }
      }
      flowParseAnonFunctionWithoutParens() {
        const param = this.flowParsePrefixType();
        if (!this.state.noAnonFunctionType && this.eat(19)) {
          const node = this.startNodeAt(param.loc.start);
          node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
          node.rest = null;
          node.this = null;
          node.returnType = this.flowParseType();
          node.typeParameters = null;
          return this.finishNode(node, "FunctionTypeAnnotation");
        }
        return param;
      }
      flowParseIntersectionType() {
        const node = this.startNode();
        this.eat(45);
        const type = this.flowParseAnonFunctionWithoutParens();
        node.types = [type];
        while (this.eat(45)) {
          node.types.push(this.flowParseAnonFunctionWithoutParens());
        }
        return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
      }
      flowParseUnionType() {
        const node = this.startNode();
        this.eat(43);
        const type = this.flowParseIntersectionType();
        node.types = [type];
        while (this.eat(43)) {
          node.types.push(this.flowParseIntersectionType());
        }
        return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
      }
      flowParseType() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const type = this.flowParseUnionType();
        this.state.inType = oldInType;
        return type;
      }
      flowParseTypeOrImplicitInstantiation() {
        if (this.state.type === 132 && this.state.value === "_") {
          const startLoc = this.state.startLoc;
          const node = this.parseIdentifier();
          return this.flowParseGenericType(startLoc, node);
        } else {
          return this.flowParseType();
        }
      }
      flowParseTypeAnnotation() {
        const node = this.startNode();
        node.typeAnnotation = this.flowParseTypeInitialiser();
        return this.finishNode(node, "TypeAnnotation");
      }
      flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
        const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
        if (this.match(14)) {
          ident.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(ident);
        }
        return ident;
      }
      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
        return node.expression;
      }
      flowParseVariance() {
        let variance = null;
        if (this.match(53)) {
          variance = this.startNode();
          if (this.state.value === "+") {
            variance.kind = "plus";
          } else {
            variance.kind = "minus";
          }
          this.next();
          return this.finishNode(variance, "Variance");
        }
        return variance;
      }
      parseFunctionBody(node, allowExpressionBody, isMethod = false) {
        if (allowExpressionBody) {
          this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
          return;
        }
        super.parseFunctionBody(node, false, isMethod);
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        if (this.match(14)) {
          const typeNode = this.startNode();
          [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
          node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
        }
        return super.parseFunctionBodyAndFinish(node, type, isMethod);
      }
      parseStatementLike(flags) {
        if (this.state.strict && this.isContextual(129)) {
          const lookahead = this.lookahead();
          if (tokenIsKeywordOrIdentifier(lookahead.type)) {
            const node = this.startNode();
            this.next();
            return this.flowParseInterface(node);
          }
        } else if (this.isContextual(126)) {
          const node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }
        const stmt = super.parseStatementLike(flags);
        if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
          this.flowPragma = null;
        }
        return stmt;
      }
      parseExpressionStatement(node, expr, decorators) {
        if (expr.type === "Identifier") {
          if (expr.name === "declare") {
            if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
              return this.flowParseDeclare(node);
            }
          } else if (tokenIsIdentifier(this.state.type)) {
            if (expr.name === "interface") {
              return this.flowParseInterface(node);
            } else if (expr.name === "type") {
              return this.flowParseTypeAlias(node);
            } else if (expr.name === "opaque") {
              return this.flowParseOpaqueType(node, false);
            }
          }
        }
        return super.parseExpressionStatement(node, expr, decorators);
      }
      shouldParseExportDeclaration() {
        const {
          type
        } = this.state;
        if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
          return !this.state.containsEsc;
        }
        return super.shouldParseExportDeclaration();
      }
      isExportDefaultSpecifier() {
        const {
          type
        } = this.state;
        if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
          return this.state.containsEsc;
        }
        return super.isExportDefaultSpecifier();
      }
      parseExportDefaultExpression() {
        if (this.isContextual(126)) {
          const node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }
        return super.parseExportDefaultExpression();
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.match(17)) return expr;
        if (this.state.maybeInArrowParameters) {
          const nextCh = this.lookaheadCharCode();
          if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
            this.setOptionalParametersError(refExpressionErrors);
            return expr;
          }
        }
        this.expect(17);
        const state = this.state.clone();
        const originalNoArrowAt = this.state.noArrowAt;
        const node = this.startNodeAt(startLoc);
        let {
          consequent,
          failed
        } = this.tryParseConditionalConsequent();
        let [valid, invalid] = this.getArrowLikeExpressions(consequent);
        if (failed || invalid.length > 0) {
          const noArrowAt = [...originalNoArrowAt];
          if (invalid.length > 0) {
            this.state = state;
            this.state.noArrowAt = noArrowAt;
            for (let i = 0; i < invalid.length; i++) {
              noArrowAt.push(invalid[i].start);
            }
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
            [valid, invalid] = this.getArrowLikeExpressions(consequent);
          }
          if (failed && valid.length > 1) {
            this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);
          }
          if (failed && valid.length === 1) {
            this.state = state;
            noArrowAt.push(valid[0].start);
            this.state.noArrowAt = noArrowAt;
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
          }
        }
        this.getArrowLikeExpressions(consequent, true);
        this.state.noArrowAt = originalNoArrowAt;
        this.expect(14);
        node.test = expr;
        node.consequent = consequent;
        node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0));
        return this.finishNode(node, "ConditionalExpression");
      }
      tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        const consequent = this.parseMaybeAssignAllowIn();
        const failed = !this.match(14);
        this.state.noArrowParamsConversionAt.pop();
        return {
          consequent,
          failed
        };
      }
      getArrowLikeExpressions(node, disallowInvalid) {
        const stack = [node];
        const arrows = [];
        while (stack.length !== 0) {
          const node2 = stack.pop();
          if (node2.type === "ArrowFunctionExpression" && node2.body.type !== "BlockStatement") {
            if (node2.typeParameters || !node2.returnType) {
              this.finishArrowValidation(node2);
            } else {
              arrows.push(node2);
            }
            stack.push(node2.body);
          } else if (node2.type === "ConditionalExpression") {
            stack.push(node2.consequent);
            stack.push(node2.alternate);
          }
        }
        if (disallowInvalid) {
          arrows.forEach((node2) => this.finishArrowValidation(node2));
          return [arrows, []];
        }
        return partition(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));
      }
      finishArrowValidation(node) {
        var _node$extra;
        this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
        this.scope.enter(514 | 4);
        super.checkParams(node, false, true);
        this.scope.exit();
      }
      forwardNoArrowParamsConversionAt(node, parse54) {
        let result;
        if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          result = parse54();
          this.state.noArrowParamsConversionAt.pop();
        } else {
          result = parse54();
        }
        return result;
      }
      parseParenItem(node, startLoc) {
        const newNode = super.parseParenItem(node, startLoc);
        if (this.eat(17)) {
          newNode.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(14)) {
          const typeCastNode = this.startNodeAt(startLoc);
          typeCastNode.expression = newNode;
          typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TypeCastExpression");
        }
        return newNode;
      }
      assertModuleNodeAllowed(node) {
        if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
          return;
        }
        super.assertModuleNodeAllowed(node);
      }
      parseExportDeclaration(node) {
        if (this.isContextual(130)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          if (this.match(5)) {
            node.specifiers = this.parseExportSpecifiers(true);
            super.parseExportFrom(node);
            return null;
          } else {
            return this.flowParseTypeAlias(declarationNode);
          }
        } else if (this.isContextual(131)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseOpaqueType(declarationNode, false);
        } else if (this.isContextual(129)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseInterface(declarationNode);
        } else if (this.isContextual(126)) {
          node.exportKind = "value";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(declarationNode);
        } else {
          return super.parseExportDeclaration(node);
        }
      }
      eatExportStar(node) {
        if (super.eatExportStar(node)) return true;
        if (this.isContextual(130) && this.lookahead().type === 55) {
          node.exportKind = "type";
          this.next();
          this.next();
          return true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(node) {
        const {
          startLoc
        } = this.state;
        const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
        if (hasNamespace && node.exportKind === "type") {
          this.unexpected(startLoc);
        }
        return hasNamespace;
      }
      parseClassId(node, isStatement, optionalId) {
        super.parseClassId(node, isStatement, optionalId);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
      }
      parseClassMember(classBody, member, state) {
        const {
          startLoc
        } = this.state;
        if (this.isContextual(125)) {
          if (super.parseClassMemberFromModifier(classBody, member)) {
            return;
          }
          member.declare = true;
        }
        super.parseClassMember(classBody, member, state);
        if (member.declare) {
          if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
            this.raise(FlowErrors.DeclareClassElement, startLoc);
          } else if (member.value) {
            this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);
          }
        }
      }
      isIterator(word) {
        return word === "iterator" || word === "asyncIterator";
      }
      readIterator() {
        const word = super.readWord1();
        const fullWord = "@@" + word;
        if (!this.isIterator(word) || !this.state.inType) {
          this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {
            identifierName: fullWord
          });
        }
        this.finishToken(132, fullWord);
      }
      getTokenFromCode(code3) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code3 === 123 && next === 124) {
          this.finishOp(6, 2);
        } else if (this.state.inType && (code3 === 62 || code3 === 60)) {
          this.finishOp(code3 === 62 ? 48 : 47, 1);
        } else if (this.state.inType && code3 === 63) {
          if (next === 46) {
            this.finishOp(18, 2);
          } else {
            this.finishOp(17, 1);
          }
        } else if (isIteratorStart(code3, next, this.input.charCodeAt(this.state.pos + 2))) {
          this.state.pos += 2;
          this.readIterator();
        } else {
          super.getTokenFromCode(code3);
        }
      }
      isAssignable(node, isBinding) {
        if (node.type === "TypeCastExpression") {
          return this.isAssignable(node.expression, isBinding);
        } else {
          return super.isAssignable(node, isBinding);
        }
      }
      toAssignable(node, isLHS = false) {
        if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {
          node.left = this.typeCastToParameter(node.left);
        }
        super.toAssignable(node, isLHS);
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }
        super.toAssignableList(exprList, trailingCommaLoc, isLHS);
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        for (let i = 0; i < exprList.length; i++) {
          var _expr$extra;
          const expr = exprList[i];
          if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
            this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);
          }
        }
        return exprList;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
        if (canBePattern && !this.state.maybeInArrowParameters) {
          this.toReferencedList(node.elements);
        }
        return node;
      }
      isValidLVal(type, isParenthesized, binding) {
        return type === "TypeCastExpression" || super.isValidLVal(type, isParenthesized, binding);
      }
      parseClassProperty(node) {
        if (this.match(14)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        if (this.match(14)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassPrivateProperty(node);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(14) || super.isClassProperty();
      }
      isNonstaticConstructor(method) {
        return !this.match(14) && super.isNonstaticConstructor(method);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        if (method.params && isConstructor) {
          const params = method.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, method);
          }
        } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
          const params = method.value.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, method);
          }
        }
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && (this.match(47) || this.match(51))) {
          {
            node.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression();
          }
        }
        if (this.isContextual(113)) {
          this.next();
          const implemented = node.implements = [];
          do {
            const node2 = this.startNode();
            node2.id = this.flowParseRestrictedIdentifier(true);
            if (this.match(47)) {
              node2.typeParameters = this.flowParseTypeParameterInstantiation();
            } else {
              node2.typeParameters = null;
            }
            implemented.push(this.finishNode(node2, "ClassImplements"));
          } while (this.eat(12));
        }
      }
      checkGetterSetterParams(method) {
        super.checkGetterSetterParams(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length > 0) {
          const param = params[0];
          if (this.isThisParam(param) && method.kind === "get") {
            this.raise(FlowErrors.GetterMayNotHaveThisParam, param);
          } else if (this.isThisParam(param)) {
            this.raise(FlowErrors.SetterMayNotHaveThisParam, param);
          }
        }
      }
      parsePropertyNamePrefixOperator(node) {
        node.variance = this.flowParseVariance();
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        if (prop.variance) {
          this.unexpected(prop.variance.loc.start);
        }
        delete prop.variance;
        let typeParameters;
        if (this.match(47) && !isAccessor) {
          typeParameters = this.flowParseTypeParameterDeclaration();
          if (!this.match(10)) this.unexpected();
        }
        const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
        if (typeParameters) {
          (result.value || result).typeParameters = typeParameters;
        }
        return result;
      }
      parseFunctionParamType(param) {
        if (this.eat(17)) {
          if (param.type !== "Identifier") {
            this.raise(FlowErrors.PatternIsOptional, param);
          }
          if (this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamMayNotBeOptional, param);
          }
          param.optional = true;
        }
        if (this.match(14)) {
          param.typeAnnotation = this.flowParseTypeAnnotation();
        } else if (this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamAnnotationRequired, param);
        }
        if (this.match(29) && this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamNoDefault, param);
        }
        this.resetEndLocation(param);
        return param;
      }
      parseMaybeDefault(startLoc, left) {
        const node = super.parseMaybeDefault(startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);
        }
        return node;
      }
      checkImportReflection(node) {
        super.checkImportReflection(node);
        if (node.module && node.importKind !== "value") {
          this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
        }
      }
      parseImportSpecifierLocal(node, specifier, type) {
        specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
        node.specifiers.push(this.finishImportSpecifier(specifier, type));
      }
      isPotentialImportPhase(isExport) {
        if (super.isPotentialImportPhase(isExport)) return true;
        if (this.isContextual(130)) {
          if (!isExport) return true;
          const ch = this.lookaheadCharCode();
          return ch === 123 || ch === 42;
        }
        return !isExport && this.isContextual(87);
      }
      applyImportPhase(node, isExport, phase, loc) {
        super.applyImportPhase(node, isExport, phase, loc);
        if (isExport) {
          if (!phase && this.match(65)) {
            return;
          }
          node.exportKind = phase === "type" ? phase : "value";
        } else {
          if (phase === "type" && this.match(55)) this.unexpected();
          node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
        }
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        const firstIdent = specifier.imported;
        let specifierTypeKind = null;
        if (firstIdent.type === "Identifier") {
          if (firstIdent.name === "type") {
            specifierTypeKind = "type";
          } else if (firstIdent.name === "typeof") {
            specifierTypeKind = "typeof";
          }
        }
        let isBinding = false;
        if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
          const as_ident = this.parseIdentifier(true);
          if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = as_ident;
            specifier.importKind = specifierTypeKind;
            specifier.local = this.cloneIdentifier(as_ident);
          } else {
            specifier.imported = firstIdent;
            specifier.importKind = null;
            specifier.local = this.parseIdentifier();
          }
        } else {
          if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = this.parseIdentifier(true);
            specifier.importKind = specifierTypeKind;
          } else {
            if (importedIsString) {
              throw this.raise(Errors.ImportBindingIsString, specifier, {
                importName: firstIdent.value
              });
            }
            specifier.imported = firstIdent;
            specifier.importKind = null;
          }
          if (this.eatContextual(93)) {
            specifier.local = this.parseIdentifier();
          } else {
            isBinding = true;
            specifier.local = this.cloneIdentifier(specifier.imported);
          }
        }
        const specifierIsTypeImport = hasTypeImportKind(specifier);
        if (isInTypeOnlyImport && specifierIsTypeImport) {
          this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);
        }
        if (isInTypeOnlyImport || specifierIsTypeImport) {
          this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
        }
        if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
          this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
        }
        return this.finishImportSpecifier(specifier, "ImportSpecifier");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 78:
            return this.parseIdentifier(true);
          default:
            return super.parseBindingAtom();
        }
      }
      parseFunctionParams(node, isConstructor) {
        const kind = node.kind;
        if (kind !== "get" && kind !== "set" && this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.parseFunctionParams(node, isConstructor);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (this.match(14)) {
          decl.id.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(decl.id);
        }
      }
      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(14)) {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          node.returnType = this.flowParseTypeAnnotation();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        }
        return super.parseAsyncArrowFromCallExpression(node, call);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx;
        let state = null;
        let jsx2;
        if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
          state = this.state.clone();
          jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!jsx2.error) return jsx2.node;
          const {
            context
          } = this.state;
          const currentContext = context[context.length - 1];
          if (currentContext === types.j_oTag || currentContext === types.j_expr) {
            context.pop();
          }
        }
        if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {
          var _jsx2, _jsx3;
          state = state || this.state.clone();
          let typeParameters;
          const arrow = this.tryParse((abort) => {
            var _arrowExpression$extr;
            typeParameters = this.flowParseTypeParameterDeclaration();
            const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
              const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
              this.resetStartLocationFromNode(result, typeParameters);
              return result;
            });
            if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized) abort();
            const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
            if (expr.type !== "ArrowFunctionExpression") abort();
            expr.typeParameters = typeParameters;
            this.resetStartLocationFromNode(expr, typeParameters);
            return arrowExpression2;
          }, state);
          let arrowExpression = null;
          if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
            if (!arrow.error && !arrow.aborted) {
              if (arrow.node.async) {
                this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);
              }
              return arrow.node;
            }
            arrowExpression = arrow.node;
          }
          if ((_jsx2 = jsx2) != null && _jsx2.node) {
            this.state = jsx2.failState;
            return jsx2.node;
          }
          if (arrowExpression) {
            this.state = arrow.failState;
            return arrowExpression;
          }
          if ((_jsx3 = jsx2) != null && _jsx3.thrown) throw jsx2.error;
          if (arrow.thrown) throw arrow.error;
          throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);
        }
        return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      }
      parseArrow(node) {
        if (this.match(14)) {
          const result = this.tryParse(() => {
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            const typeNode = this.startNode();
            [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (this.canInsertSemicolon()) this.unexpected();
            if (!this.match(19)) this.unexpected();
            return typeNode;
          });
          if (result.thrown) return null;
          if (result.error) this.state = result.failState;
          node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
        }
        return super.parseArrow(node);
      }
      shouldParseArrow(params) {
        return this.match(14) || super.shouldParseArrow(params);
      }
      setArrowFunctionParameters(node, params) {
        if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
          node.params = params;
        } else {
          super.setArrowFunctionParameters(node, params);
        }
      }
      checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        if (isArrowFunction && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
          return;
        }
        for (let i = 0; i < node.params.length; i++) {
          if (this.isThisParam(node.params[i]) && i > 0) {
            this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);
          }
        }
        super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        return super.parseParenAndDistinguishExpression(canBeArrow && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
      }
      parseSubscripts(base, startLoc, noCalls) {
        if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.includes(startLoc.index)) {
          this.next();
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          node.arguments = super.parseCallExpressionArguments(11);
          base = this.finishNode(node, "CallExpression");
        } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
          const state = this.state.clone();
          const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
          if (!arrow.error && !arrow.aborted) return arrow.node;
          const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);
          if (result.node && !result.error) return result.node;
          if (arrow.node) {
            this.state = arrow.failState;
            return arrow.node;
          }
          if (result.node) {
            this.state = result.failState;
            return result.node;
          }
          throw arrow.error || result.error;
        }
        return super.parseSubscripts(base, startLoc, noCalls);
      }
      parseSubscript(base, startLoc, noCalls, subscriptState) {
        if (this.match(18) && this.isLookaheadToken_lt()) {
          subscriptState.optionalChainMember = true;
          if (noCalls) {
            subscriptState.stop = true;
            return base;
          }
          this.next();
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
          this.expect(10);
          node.arguments = this.parseCallExpressionArguments(11);
          node.optional = true;
          return this.finishCallExpression(node, true);
        } else if (!noCalls && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          const result = this.tryParse(() => {
            node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
            this.expect(10);
            node.arguments = super.parseCallExpressionArguments(11);
            if (subscriptState.optionalChainMember) {
              node.optional = false;
            }
            return this.finishCallExpression(node, subscriptState.optionalChainMember);
          });
          if (result.node) {
            if (result.error) this.state = result.failState;
            return result.node;
          }
        }
        return super.parseSubscript(base, startLoc, noCalls, subscriptState);
      }
      parseNewCallee(node) {
        super.parseNewCallee(node);
        let targs = null;
        if (this.shouldParseTypes() && this.match(47)) {
          targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
        }
        node.typeArguments = targs;
      }
      parseAsyncArrowWithTypeParameters(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.parseFunctionParams(node, false);
        if (!this.parseArrow(node)) return;
        return super.parseArrowExpression(node, void 0, true);
      }
      readToken_mult_modulo(code3) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code3 === 42 && next === 47 && this.state.hasFlowComment) {
          this.state.hasFlowComment = false;
          this.state.pos += 2;
          this.nextToken();
          return;
        }
        super.readToken_mult_modulo(code3);
      }
      readToken_pipe_amp(code3) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code3 === 124 && next === 125) {
          this.finishOp(9, 2);
          return;
        }
        super.readToken_pipe_amp(code3);
      }
      parseTopLevel(file, program) {
        const fileNode = super.parseTopLevel(file, program);
        if (this.state.hasFlowComment) {
          this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());
        }
        return fileNode;
      }
      skipBlockComment() {
        if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
          if (this.state.hasFlowComment) {
            throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);
          }
          this.hasFlowCommentCompletion();
          const commentSkip = this.skipFlowComment();
          if (commentSkip) {
            this.state.pos += commentSkip;
            this.state.hasFlowComment = true;
          }
          return;
        }
        return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
      }
      skipFlowComment() {
        const {
          pos
        } = this.state;
        let shiftToFirstNonWhiteSpace = 2;
        while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
          shiftToFirstNonWhiteSpace++;
        }
        const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
        const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
        if (ch2 === 58 && ch3 === 58) {
          return shiftToFirstNonWhiteSpace + 2;
        }
        if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
          return shiftToFirstNonWhiteSpace + 12;
        }
        if (ch2 === 58 && ch3 !== 58) {
          return shiftToFirstNonWhiteSpace;
        }
        return false;
      }
      hasFlowCommentCompletion() {
        const end = this.input.indexOf("*/", this.state.pos);
        if (end === -1) {
          throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
        }
      }
      flowEnumErrorBooleanMemberNotInitialized(loc, {
        enumName,
        memberName
      }) {
        this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {
          memberName,
          enumName
        });
      }
      flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
        return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);
      }
      flowEnumErrorNumberMemberNotInitialized(loc, details) {
        this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);
      }
      flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {
        this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);
      }
      flowEnumMemberInit() {
        const startLoc = this.state.startLoc;
        const endOfInit = () => this.match(12) || this.match(8);
        switch (this.state.type) {
          case 135: {
            const literal = this.parseNumericLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "number",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          case 134: {
            const literal = this.parseStringLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "string",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          case 85:
          case 86: {
            const literal = this.parseBooleanLiteral(this.match(85));
            if (endOfInit()) {
              return {
                type: "boolean",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          default:
            return {
              type: "invalid",
              loc: startLoc
            };
        }
      }
      flowEnumMemberRaw() {
        const loc = this.state.startLoc;
        const id = this.parseIdentifier(true);
        const init = this.eat(29) ? this.flowEnumMemberInit() : {
          type: "none",
          loc
        };
        return {
          id,
          init
        };
      }
      flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
        const {
          explicitType
        } = context;
        if (explicitType === null) {
          return;
        }
        if (explicitType !== expectedType) {
          this.flowEnumErrorInvalidMemberInitializer(loc, context);
        }
      }
      flowEnumMembers({
        enumName,
        explicitType
      }) {
        const seenNames = /* @__PURE__ */ new Set();
        const members = {
          booleanMembers: [],
          numberMembers: [],
          stringMembers: [],
          defaultedMembers: []
        };
        let hasUnknownMembers = false;
        while (!this.match(8)) {
          if (this.eat(21)) {
            hasUnknownMembers = true;
            break;
          }
          const memberNode = this.startNode();
          const {
            id,
            init
          } = this.flowEnumMemberRaw();
          const memberName = id.name;
          if (memberName === "") {
            continue;
          }
          if (/^[a-z]/.test(memberName)) {
            this.raise(FlowErrors.EnumInvalidMemberName, id, {
              memberName,
              suggestion: memberName[0].toUpperCase() + memberName.slice(1),
              enumName
            });
          }
          if (seenNames.has(memberName)) {
            this.raise(FlowErrors.EnumDuplicateMemberName, id, {
              memberName,
              enumName
            });
          }
          seenNames.add(memberName);
          const context = {
            enumName,
            explicitType,
            memberName
          };
          memberNode.id = id;
          switch (init.type) {
            case "boolean": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
              memberNode.init = init.value;
              members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
              break;
            }
            case "number": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
              memberNode.init = init.value;
              members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
              break;
            }
            case "string": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
              memberNode.init = init.value;
              members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
              break;
            }
            case "invalid": {
              throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
            }
            case "none": {
              switch (explicitType) {
                case "boolean":
                  this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                  break;
                case "number":
                  this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                  break;
                default:
                  members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
              }
            }
          }
          if (!this.match(8)) {
            this.expect(12);
          }
        }
        return {
          members,
          hasUnknownMembers
        };
      }
      flowEnumStringMembers(initializedMembers, defaultedMembers, {
        enumName
      }) {
        if (initializedMembers.length === 0) {
          return defaultedMembers;
        } else if (defaultedMembers.length === 0) {
          return initializedMembers;
        } else if (defaultedMembers.length > initializedMembers.length) {
          for (const member of initializedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
              enumName
            });
          }
          return defaultedMembers;
        } else {
          for (const member of defaultedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
              enumName
            });
          }
          return initializedMembers;
        }
      }
      flowEnumParseExplicitType({
        enumName
      }) {
        if (!this.eatContextual(102)) return null;
        if (!tokenIsIdentifier(this.state.type)) {
          throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
            enumName
          });
        }
        const {
          value
        } = this.state;
        this.next();
        if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
          this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {
            enumName,
            invalidEnumType: value
          });
        }
        return value;
      }
      flowEnumBody(node, id) {
        const enumName = id.name;
        const nameLoc = id.loc.start;
        const explicitType = this.flowEnumParseExplicitType({
          enumName
        });
        this.expect(5);
        const {
          members,
          hasUnknownMembers
        } = this.flowEnumMembers({
          enumName,
          explicitType
        });
        node.hasUnknownMembers = hasUnknownMembers;
        switch (explicitType) {
          case "boolean":
            node.explicitType = true;
            node.members = members.booleanMembers;
            this.expect(8);
            return this.finishNode(node, "EnumBooleanBody");
          case "number":
            node.explicitType = true;
            node.members = members.numberMembers;
            this.expect(8);
            return this.finishNode(node, "EnumNumberBody");
          case "string":
            node.explicitType = true;
            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName
            });
            this.expect(8);
            return this.finishNode(node, "EnumStringBody");
          case "symbol":
            node.members = members.defaultedMembers;
            this.expect(8);
            return this.finishNode(node, "EnumSymbolBody");
          default: {
            const empty = () => {
              node.members = [];
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");
            };
            node.explicitType = false;
            const boolsLen = members.booleanMembers.length;
            const numsLen = members.numberMembers.length;
            const strsLen = members.stringMembers.length;
            const defaultedLen = members.defaultedMembers.length;
            if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
              return empty();
            } else if (!boolsLen && !numsLen) {
              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName
              });
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");
            } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node.members = members.booleanMembers;
              this.expect(8);
              return this.finishNode(node, "EnumBooleanBody");
            } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node.members = members.numberMembers;
              this.expect(8);
              return this.finishNode(node, "EnumNumberBody");
            } else {
              this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {
                enumName
              });
              return empty();
            }
          }
        }
      }
      flowParseEnumDeclaration(node) {
        const id = this.parseIdentifier();
        node.id = id;
        node.body = this.flowEnumBody(this.startNode(), id);
        return this.finishNode(node, "EnumDeclaration");
      }
      jsxParseOpeningElementAfterName(node) {
        if (this.shouldParseTypes()) {
          if (this.match(47) || this.match(51)) {
            node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
          }
        }
        return super.jsxParseOpeningElementAfterName(node);
      }
      isLookaheadToken_lt() {
        const next = this.nextTokenStart();
        if (this.input.charCodeAt(next) === 60) {
          const afterNext = this.input.charCodeAt(next + 1);
          return afterNext !== 60 && afterNext !== 61;
        }
        return false;
      }
      reScan_lt_gt() {
        const {
          type
        } = this.state;
        if (type === 47) {
          this.state.pos -= 1;
          this.readToken_lt();
        } else if (type === 48) {
          this.state.pos -= 1;
          this.readToken_gt();
        }
      }
      reScan_lt() {
        const {
          type
        } = this.state;
        if (type === 51) {
          this.state.pos -= 2;
          this.finishOp(47, 1);
          return 47;
        }
        return type;
      }
      maybeUnwrapTypeCastExpression(node) {
        return node.type === "TypeCastExpression" ? node.expression : node;
      }
    };
    var entities = {
      __proto__: null,
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: "",
      iexcl: "",
      cent: "",
      pound: "",
      curren: "",
      yen: "",
      brvbar: "",
      sect: "",
      uml: "",
      copy: "",
      ordf: "",
      laquo: "",
      not: "",
      shy: "",
      reg: "",
      macr: "",
      deg: "",
      plusmn: "",
      sup2: "",
      sup3: "",
      acute: "",
      micro: "",
      para: "",
      middot: "",
      cedil: "",
      sup1: "",
      ordm: "",
      raquo: "",
      frac14: "",
      frac12: "",
      frac34: "",
      iquest: "",
      Agrave: "",
      Aacute: "",
      Acirc: "",
      Atilde: "",
      Auml: "",
      Aring: "",
      AElig: "",
      Ccedil: "",
      Egrave: "",
      Eacute: "",
      Ecirc: "",
      Euml: "",
      Igrave: "",
      Iacute: "",
      Icirc: "",
      Iuml: "",
      ETH: "",
      Ntilde: "",
      Ograve: "",
      Oacute: "",
      Ocirc: "",
      Otilde: "",
      Ouml: "",
      times: "",
      Oslash: "",
      Ugrave: "",
      Uacute: "",
      Ucirc: "",
      Uuml: "",
      Yacute: "",
      THORN: "",
      szlig: "",
      agrave: "",
      aacute: "",
      acirc: "",
      atilde: "",
      auml: "",
      aring: "",
      aelig: "",
      ccedil: "",
      egrave: "",
      eacute: "",
      ecirc: "",
      euml: "",
      igrave: "",
      iacute: "",
      icirc: "",
      iuml: "",
      eth: "",
      ntilde: "",
      ograve: "",
      oacute: "",
      ocirc: "",
      otilde: "",
      ouml: "",
      divide: "",
      oslash: "",
      ugrave: "",
      uacute: "",
      ucirc: "",
      uuml: "",
      yacute: "",
      thorn: "",
      yuml: "",
      OElig: "",
      oelig: "",
      Scaron: "",
      scaron: "",
      Yuml: "",
      fnof: "",
      circ: "",
      tilde: "",
      Alpha: "",
      Beta: "",
      Gamma: "",
      Delta: "",
      Epsilon: "",
      Zeta: "",
      Eta: "",
      Theta: "",
      Iota: "",
      Kappa: "",
      Lambda: "",
      Mu: "",
      Nu: "",
      Xi: "",
      Omicron: "",
      Pi: "",
      Rho: "",
      Sigma: "",
      Tau: "",
      Upsilon: "",
      Phi: "",
      Chi: "",
      Psi: "",
      Omega: "",
      alpha: "",
      beta: "",
      gamma: "",
      delta: "",
      epsilon: "",
      zeta: "",
      eta: "",
      theta: "",
      iota: "",
      kappa: "",
      lambda: "",
      mu: "",
      nu: "",
      xi: "",
      omicron: "",
      pi: "",
      rho: "",
      sigmaf: "",
      sigma: "",
      tau: "",
      upsilon: "",
      phi: "",
      chi: "",
      psi: "",
      omega: "",
      thetasym: "",
      upsih: "",
      piv: "",
      ensp: "",
      emsp: "",
      thinsp: "",
      zwnj: "",
      zwj: "",
      lrm: "",
      rlm: "",
      ndash: "",
      mdash: "",
      lsquo: "",
      rsquo: "",
      sbquo: "",
      ldquo: "",
      rdquo: "",
      bdquo: "",
      dagger: "",
      Dagger: "",
      bull: "",
      hellip: "",
      permil: "",
      prime: "",
      Prime: "",
      lsaquo: "",
      rsaquo: "",
      oline: "",
      frasl: "",
      euro: "",
      image: "",
      weierp: "",
      real: "",
      trade: "",
      alefsym: "",
      larr: "",
      uarr: "",
      rarr: "",
      darr: "",
      harr: "",
      crarr: "",
      lArr: "",
      uArr: "",
      rArr: "",
      dArr: "",
      hArr: "",
      forall: "",
      part: "",
      exist: "",
      empty: "",
      nabla: "",
      isin: "",
      notin: "",
      ni: "",
      prod: "",
      sum: "",
      minus: "",
      lowast: "",
      radic: "",
      prop: "",
      infin: "",
      ang: "",
      and: "",
      or: "",
      cap: "",
      cup: "",
      int: "",
      there4: "",
      sim: "",
      cong: "",
      asymp: "",
      ne: "",
      equiv: "",
      le: "",
      ge: "",
      sub: "",
      sup: "",
      nsub: "",
      sube: "",
      supe: "",
      oplus: "",
      otimes: "",
      perp: "",
      sdot: "",
      lceil: "",
      rceil: "",
      lfloor: "",
      rfloor: "",
      lang: "",
      rang: "",
      loz: "",
      spades: "",
      clubs: "",
      hearts: "",
      diams: ""
    };
    var lineBreak = /\r\n|[\r\n\u2028\u2029]/;
    var lineBreakG = new RegExp(lineBreak.source, "g");
    function isNewLine(code3) {
      switch (code3) {
        case 10:
        case 13:
        case 8232:
        case 8233:
          return true;
        default:
          return false;
      }
    }
    function hasNewLine(input, start, end) {
      for (let i = start; i < end; i++) {
        if (isNewLine(input.charCodeAt(i))) {
          return true;
        }
      }
      return false;
    }
    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
    function isWhitespace(code3) {
      switch (code3) {
        case 9:
        case 11:
        case 12:
        case 32:
        case 160:
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return true;
        default:
          return false;
      }
    }
    var JsxErrors = ParseErrorEnum`jsx`({
      AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
      MissingClosingTagElement: ({
        openingTagName
      }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
      MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
      UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
      UnexpectedToken: ({
        unexpected,
        HTMLEntity
      }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
      UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
      UnterminatedJsxContent: "Unterminated JSX contents.",
      UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
    });
    function isFragment(object) {
      return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
    }
    function getQualifiedJSXName(object) {
      if (object.type === "JSXIdentifier") {
        return object.name;
      }
      if (object.type === "JSXNamespacedName") {
        return object.namespace.name + ":" + object.name.name;
      }
      if (object.type === "JSXMemberExpression") {
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
      }
      throw new Error("Node had unexpected type: " + object.type);
    }
    var jsx = (superClass) => class JSXParserMixin extends superClass {
      jsxReadToken() {
        let out = "";
        let chunkStart = this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);
          }
          const ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 60:
            case 123:
              if (this.state.pos === this.state.start) {
                if (ch === 60 && this.state.canStartJSXElement) {
                  ++this.state.pos;
                  this.finishToken(143);
                } else {
                  super.getTokenFromCode(ch);
                }
                return;
              }
              out += this.input.slice(chunkStart, this.state.pos);
              this.finishToken(142, out);
              return;
            case 38:
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
              break;
            case 62:
            case 125:
            default:
              if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadNewLine(true);
                chunkStart = this.state.pos;
              } else {
                ++this.state.pos;
              }
          }
        }
      }
      jsxReadNewLine(normalizeCRLF) {
        const ch = this.input.charCodeAt(this.state.pos);
        let out;
        ++this.state.pos;
        if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos;
          out = normalizeCRLF ? "\n" : "\r\n";
        } else {
          out = String.fromCharCode(ch);
        }
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        return out;
      }
      jsxReadString(quote) {
        let out = "";
        let chunkStart = ++this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(Errors.UnterminatedString, this.state.startLoc);
          }
          const ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote) break;
          if (ch === 38) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadNewLine(false);
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
        }
        out += this.input.slice(chunkStart, this.state.pos++);
        this.finishToken(134, out);
      }
      jsxReadEntity() {
        const startPos = ++this.state.pos;
        if (this.codePointAtPos(this.state.pos) === 35) {
          ++this.state.pos;
          let radix = 10;
          if (this.codePointAtPos(this.state.pos) === 120) {
            radix = 16;
            ++this.state.pos;
          }
          const codePoint = this.readInt(radix, void 0, false, "bail");
          if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
            ++this.state.pos;
            return String.fromCodePoint(codePoint);
          }
        } else {
          let count = 0;
          let semi = false;
          while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59)) {
            ++this.state.pos;
          }
          if (semi) {
            const desc = this.input.slice(startPos, this.state.pos);
            const entity = entities[desc];
            ++this.state.pos;
            if (entity) {
              return entity;
            }
          }
        }
        this.state.pos = startPos;
        return "&";
      }
      jsxReadWord() {
        let ch;
        const start = this.state.pos;
        do {
          ch = this.input.charCodeAt(++this.state.pos);
        } while (isIdentifierChar(ch) || ch === 45);
        this.finishToken(141, this.input.slice(start, this.state.pos));
      }
      jsxParseIdentifier() {
        const node = this.startNode();
        if (this.match(141)) {
          node.name = this.state.value;
        } else if (tokenIsKeyword(this.state.type)) {
          node.name = tokenLabelName(this.state.type);
        } else {
          this.unexpected();
        }
        this.next();
        return this.finishNode(node, "JSXIdentifier");
      }
      jsxParseNamespacedName() {
        const startLoc = this.state.startLoc;
        const name50 = this.jsxParseIdentifier();
        if (!this.eat(14)) return name50;
        const node = this.startNodeAt(startLoc);
        node.namespace = name50;
        node.name = this.jsxParseIdentifier();
        return this.finishNode(node, "JSXNamespacedName");
      }
      jsxParseElementName() {
        const startLoc = this.state.startLoc;
        let node = this.jsxParseNamespacedName();
        if (node.type === "JSXNamespacedName") {
          return node;
        }
        while (this.eat(16)) {
          const newNode = this.startNodeAt(startLoc);
          newNode.object = node;
          newNode.property = this.jsxParseIdentifier();
          node = this.finishNode(newNode, "JSXMemberExpression");
        }
        return node;
      }
      jsxParseAttributeValue() {
        let node;
        switch (this.state.type) {
          case 5:
            node = this.startNode();
            this.setContext(types.brace);
            this.next();
            node = this.jsxParseExpressionContainer(node, types.j_oTag);
            if (node.expression.type === "JSXEmptyExpression") {
              this.raise(JsxErrors.AttributeIsEmpty, node);
            }
            return node;
          case 143:
          case 134:
            return this.parseExprAtom();
          default:
            throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);
        }
      }
      jsxParseEmptyExpression() {
        const node = this.startNodeAt(this.state.lastTokEndLoc);
        return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
      }
      jsxParseSpreadChild(node) {
        this.next();
        node.expression = this.parseExpression();
        this.setContext(types.j_expr);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node, "JSXSpreadChild");
      }
      jsxParseExpressionContainer(node, previousContext) {
        if (this.match(8)) {
          node.expression = this.jsxParseEmptyExpression();
        } else {
          const expression = this.parseExpression();
          node.expression = expression;
        }
        this.setContext(previousContext);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node, "JSXExpressionContainer");
      }
      jsxParseAttribute() {
        const node = this.startNode();
        if (this.match(5)) {
          this.setContext(types.brace);
          this.next();
          this.expect(21);
          node.argument = this.parseMaybeAssignAllowIn();
          this.setContext(types.j_oTag);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node, "JSXSpreadAttribute");
        }
        node.name = this.jsxParseNamespacedName();
        node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
        return this.finishNode(node, "JSXAttribute");
      }
      jsxParseOpeningElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        if (this.eat(144)) {
          return this.finishNode(node, "JSXOpeningFragment");
        }
        node.name = this.jsxParseElementName();
        return this.jsxParseOpeningElementAfterName(node);
      }
      jsxParseOpeningElementAfterName(node) {
        const attributes = [];
        while (!this.match(56) && !this.match(144)) {
          attributes.push(this.jsxParseAttribute());
        }
        node.attributes = attributes;
        node.selfClosing = this.eat(56);
        this.expect(144);
        return this.finishNode(node, "JSXOpeningElement");
      }
      jsxParseClosingElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        if (this.eat(144)) {
          return this.finishNode(node, "JSXClosingFragment");
        }
        node.name = this.jsxParseElementName();
        this.expect(144);
        return this.finishNode(node, "JSXClosingElement");
      }
      jsxParseElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        const children = [];
        const openingElement = this.jsxParseOpeningElementAt(startLoc);
        let closingElement = null;
        if (!openingElement.selfClosing) {
          contents: for (; ; ) {
            switch (this.state.type) {
              case 143:
                startLoc = this.state.startLoc;
                this.next();
                if (this.eat(56)) {
                  closingElement = this.jsxParseClosingElementAt(startLoc);
                  break contents;
                }
                children.push(this.jsxParseElementAt(startLoc));
                break;
              case 142:
                children.push(this.parseLiteral(this.state.value, "JSXText"));
                break;
              case 5: {
                const node2 = this.startNode();
                this.setContext(types.brace);
                this.next();
                if (this.match(21)) {
                  children.push(this.jsxParseSpreadChild(node2));
                } else {
                  children.push(this.jsxParseExpressionContainer(node2, types.j_expr));
                }
                break;
              }
              default:
                this.unexpected();
            }
          }
          if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
            this.raise(JsxErrors.MissingClosingTagFragment, closingElement);
          } else if (!isFragment(openingElement) && isFragment(closingElement)) {
            this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
              openingTagName: getQualifiedJSXName(openingElement.name)
            });
          } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
                openingTagName: getQualifiedJSXName(openingElement.name)
              });
            }
          }
        }
        if (isFragment(openingElement)) {
          node.openingFragment = openingElement;
          node.closingFragment = closingElement;
        } else {
          node.openingElement = openingElement;
          node.closingElement = closingElement;
        }
        node.children = children;
        if (this.match(47)) {
          throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);
        }
        return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
      }
      jsxParseElement() {
        const startLoc = this.state.startLoc;
        this.next();
        return this.jsxParseElementAt(startLoc);
      }
      setContext(newContext) {
        const {
          context
        } = this.state;
        context[context.length - 1] = newContext;
      }
      parseExprAtom(refExpressionErrors) {
        if (this.match(143)) {
          return this.jsxParseElement();
        } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
          this.replaceToken(143);
          return this.jsxParseElement();
        } else {
          return super.parseExprAtom(refExpressionErrors);
        }
      }
      skipSpace() {
        const curContext = this.curContext();
        if (!curContext.preserveSpace) super.skipSpace();
      }
      getTokenFromCode(code3) {
        const context = this.curContext();
        if (context === types.j_expr) {
          this.jsxReadToken();
          return;
        }
        if (context === types.j_oTag || context === types.j_cTag) {
          if (isIdentifierStart2(code3)) {
            this.jsxReadWord();
            return;
          }
          if (code3 === 62) {
            ++this.state.pos;
            this.finishToken(144);
            return;
          }
          if ((code3 === 34 || code3 === 39) && context === types.j_oTag) {
            this.jsxReadString(code3);
            return;
          }
        }
        if (code3 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
          ++this.state.pos;
          this.finishToken(143);
          return;
        }
        super.getTokenFromCode(code3);
      }
      updateContext(prevType) {
        const {
          context,
          type
        } = this.state;
        if (type === 56 && prevType === 143) {
          context.splice(-2, 2, types.j_cTag);
          this.state.canStartJSXElement = false;
        } else if (type === 143) {
          context.push(types.j_oTag);
        } else if (type === 144) {
          const out = context[context.length - 1];
          if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
            context.pop();
            this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
          } else {
            this.setContext(types.j_expr);
            this.state.canStartJSXElement = true;
          }
        } else {
          this.state.canStartJSXElement = tokenComesBeforeExpression(type);
        }
      }
    };
    var TypeScriptScope = class extends Scope {
      constructor(...args) {
        super(...args);
        this.tsNames = /* @__PURE__ */ new Map();
      }
    };
    var TypeScriptScopeHandler = class extends ScopeHandler {
      constructor(...args) {
        super(...args);
        this.importsStack = [];
      }
      createScope(flags) {
        this.importsStack.push(/* @__PURE__ */ new Set());
        return new TypeScriptScope(flags);
      }
      enter(flags) {
        if (flags === 1024) {
          this.importsStack.push(/* @__PURE__ */ new Set());
        }
        super.enter(flags);
      }
      exit() {
        const flags = super.exit();
        if (flags === 1024) {
          this.importsStack.pop();
        }
        return flags;
      }
      hasImport(name50, allowShadow) {
        const len = this.importsStack.length;
        if (this.importsStack[len - 1].has(name50)) {
          return true;
        }
        if (!allowShadow && len > 1) {
          for (let i = 0; i < len - 1; i++) {
            if (this.importsStack[i].has(name50)) return true;
          }
        }
        return false;
      }
      declareName(name50, bindingType, loc) {
        if (bindingType & 4096) {
          if (this.hasImport(name50, true)) {
            this.parser.raise(Errors.VarRedeclaration, loc, {
              identifierName: name50
            });
          }
          this.importsStack[this.importsStack.length - 1].add(name50);
          return;
        }
        const scope = this.currentScope();
        let type = scope.tsNames.get(name50) || 0;
        if (bindingType & 1024) {
          this.maybeExportDefined(scope, name50);
          scope.tsNames.set(name50, type | 16);
          return;
        }
        super.declareName(name50, bindingType, loc);
        if (bindingType & 2) {
          if (!(bindingType & 1)) {
            this.checkRedeclarationInScope(scope, name50, bindingType, loc);
            this.maybeExportDefined(scope, name50);
          }
          type = type | 1;
        }
        if (bindingType & 256) {
          type = type | 2;
        }
        if (bindingType & 512) {
          type = type | 4;
        }
        if (bindingType & 128) {
          type = type | 8;
        }
        if (type) scope.tsNames.set(name50, type);
      }
      isRedeclaredInScope(scope, name50, bindingType) {
        const type = scope.tsNames.get(name50);
        if ((type & 2) > 0) {
          if (bindingType & 256) {
            const isConst = !!(bindingType & 512);
            const wasConst = (type & 4) > 0;
            return isConst !== wasConst;
          }
          return true;
        }
        if (bindingType & 128 && (type & 8) > 0) {
          if (scope.names.get(name50) & 2) {
            return !!(bindingType & 1);
          } else {
            return false;
          }
        }
        if (bindingType & 2 && (type & 1) > 0) {
          return true;
        }
        return super.isRedeclaredInScope(scope, name50, bindingType);
      }
      checkLocalExport(id) {
        const {
          name: name50
        } = id;
        if (this.hasImport(name50)) return;
        const len = this.scopeStack.length;
        for (let i = len - 1; i >= 0; i--) {
          const scope = this.scopeStack[i];
          const type = scope.tsNames.get(name50);
          if ((type & 1) > 0 || (type & 16) > 0) {
            return;
          }
        }
        super.checkLocalExport(id);
      }
    };
    var ProductionParameterHandler = class {
      constructor() {
        this.stacks = [];
      }
      enter(flags) {
        this.stacks.push(flags);
      }
      exit() {
        this.stacks.pop();
      }
      currentFlags() {
        return this.stacks[this.stacks.length - 1];
      }
      get hasAwait() {
        return (this.currentFlags() & 2) > 0;
      }
      get hasYield() {
        return (this.currentFlags() & 1) > 0;
      }
      get hasReturn() {
        return (this.currentFlags() & 4) > 0;
      }
      get hasIn() {
        return (this.currentFlags() & 8) > 0;
      }
    };
    function functionFlags(isAsync, isGenerator) {
      return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
    }
    var BaseParser = class {
      constructor() {
        this.sawUnambiguousESM = false;
        this.ambiguousScriptDifferentAst = false;
      }
      sourceToOffsetPos(sourcePos) {
        return sourcePos + this.startIndex;
      }
      offsetToSourcePos(offsetPos) {
        return offsetPos - this.startIndex;
      }
      hasPlugin(pluginConfig) {
        if (typeof pluginConfig === "string") {
          return this.plugins.has(pluginConfig);
        } else {
          const [pluginName, pluginOptions] = pluginConfig;
          if (!this.hasPlugin(pluginName)) {
            return false;
          }
          const actualOptions = this.plugins.get(pluginName);
          for (const key of Object.keys(pluginOptions)) {
            if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
              return false;
            }
          }
          return true;
        }
      }
      getPluginOption(plugin, name50) {
        var _this$plugins$get;
        return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name50];
      }
    };
    function setTrailingComments(node, comments) {
      if (node.trailingComments === void 0) {
        node.trailingComments = comments;
      } else {
        node.trailingComments.unshift(...comments);
      }
    }
    function setLeadingComments(node, comments) {
      if (node.leadingComments === void 0) {
        node.leadingComments = comments;
      } else {
        node.leadingComments.unshift(...comments);
      }
    }
    function setInnerComments(node, comments) {
      if (node.innerComments === void 0) {
        node.innerComments = comments;
      } else {
        node.innerComments.unshift(...comments);
      }
    }
    function adjustInnerComments(node, elements, commentWS) {
      let lastElement = null;
      let i = elements.length;
      while (lastElement === null && i > 0) {
        lastElement = elements[--i];
      }
      if (lastElement === null || lastElement.start > commentWS.start) {
        setInnerComments(node, commentWS.comments);
      } else {
        setTrailingComments(lastElement, commentWS.comments);
      }
    }
    var CommentsParser = class extends BaseParser {
      addComment(comment) {
        if (this.filename) comment.loc.filename = this.filename;
        const {
          commentsLen
        } = this.state;
        if (this.comments.length !== commentsLen) {
          this.comments.length = commentsLen;
        }
        this.comments.push(comment);
        this.state.commentsLen++;
      }
      processComment(node) {
        const {
          commentStack
        } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0) return;
        let i = commentStackLength - 1;
        const lastCommentWS = commentStack[i];
        if (lastCommentWS.start === node.end) {
          lastCommentWS.leadingNode = node;
          i--;
        }
        const {
          start: nodeStart
        } = node;
        for (; i >= 0; i--) {
          const commentWS = commentStack[i];
          const commentEnd = commentWS.end;
          if (commentEnd > nodeStart) {
            commentWS.containingNode = node;
            this.finalizeComment(commentWS);
            commentStack.splice(i, 1);
          } else {
            if (commentEnd === nodeStart) {
              commentWS.trailingNode = node;
            }
            break;
          }
        }
      }
      finalizeComment(commentWS) {
        var _node$options;
        const {
          comments
        } = commentWS;
        if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
          if (commentWS.leadingNode !== null) {
            setTrailingComments(commentWS.leadingNode, comments);
          }
          if (commentWS.trailingNode !== null) {
            setLeadingComments(commentWS.trailingNode, comments);
          }
        } else {
          const {
            containingNode: node,
            start: commentStart
          } = commentWS;
          if (this.input.charCodeAt(this.offsetToSourcePos(commentStart) - 1) === 44) {
            switch (node.type) {
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                adjustInnerComments(node, node.properties, commentWS);
                break;
              case "CallExpression":
              case "OptionalCallExpression":
                adjustInnerComments(node, node.arguments, commentWS);
                break;
              case "ImportExpression":
                adjustInnerComments(node, [node.source, (_node$options = node.options) != null ? _node$options : null], commentWS);
                break;
              case "FunctionDeclaration":
              case "FunctionExpression":
              case "ArrowFunctionExpression":
              case "ObjectMethod":
              case "ClassMethod":
              case "ClassPrivateMethod":
                adjustInnerComments(node, node.params, commentWS);
                break;
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                adjustInnerComments(node, node.elements, commentWS);
                break;
              case "ExportNamedDeclaration":
              case "ImportDeclaration":
                adjustInnerComments(node, node.specifiers, commentWS);
                break;
              case "TSEnumDeclaration":
                {
                  adjustInnerComments(node, node.members, commentWS);
                }
                break;
              case "TSEnumBody":
                adjustInnerComments(node, node.members, commentWS);
                break;
              default: {
                setInnerComments(node, comments);
              }
            }
          } else {
            setInnerComments(node, comments);
          }
        }
      }
      finalizeRemainingComments() {
        const {
          commentStack
        } = this.state;
        for (let i = commentStack.length - 1; i >= 0; i--) {
          this.finalizeComment(commentStack[i]);
        }
        this.state.commentStack = [];
      }
      resetPreviousNodeTrailingComments(node) {
        const {
          commentStack
        } = this.state;
        const {
          length: length2
        } = commentStack;
        if (length2 === 0) return;
        const commentWS = commentStack[length2 - 1];
        if (commentWS.leadingNode === node) {
          commentWS.leadingNode = null;
        }
      }
      takeSurroundingComments(node, start, end) {
        const {
          commentStack
        } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0) return;
        let i = commentStackLength - 1;
        for (; i >= 0; i--) {
          const commentWS = commentStack[i];
          const commentEnd = commentWS.end;
          const commentStart = commentWS.start;
          if (commentStart === end) {
            commentWS.leadingNode = node;
          } else if (commentEnd === start) {
            commentWS.trailingNode = node;
          } else if (commentEnd < start) {
            break;
          }
        }
      }
    };
    var State = class _State {
      constructor() {
        this.flags = 1024;
        this.startIndex = void 0;
        this.curLine = void 0;
        this.lineStart = void 0;
        this.startLoc = void 0;
        this.endLoc = void 0;
        this.errors = [];
        this.potentialArrowAt = -1;
        this.noArrowAt = [];
        this.noArrowParamsConversionAt = [];
        this.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        this.labels = [];
        this.commentsLen = 0;
        this.commentStack = [];
        this.pos = 0;
        this.type = 140;
        this.value = null;
        this.start = 0;
        this.end = 0;
        this.lastTokEndLoc = null;
        this.lastTokStartLoc = null;
        this.context = [types.brace];
        this.firstInvalidTemplateEscapePos = null;
        this.strictErrors = /* @__PURE__ */ new Map();
        this.tokensLength = 0;
      }
      get strict() {
        return (this.flags & 1) > 0;
      }
      set strict(v) {
        if (v) this.flags |= 1;
        else this.flags &= -2;
      }
      init({
        strictMode,
        sourceType,
        startIndex,
        startLine,
        startColumn
      }) {
        this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
        this.startIndex = startIndex;
        this.curLine = startLine;
        this.lineStart = -startColumn;
        this.startLoc = this.endLoc = new Position(startLine, startColumn, startIndex);
      }
      get maybeInArrowParameters() {
        return (this.flags & 2) > 0;
      }
      set maybeInArrowParameters(v) {
        if (v) this.flags |= 2;
        else this.flags &= -3;
      }
      get inType() {
        return (this.flags & 4) > 0;
      }
      set inType(v) {
        if (v) this.flags |= 4;
        else this.flags &= -5;
      }
      get noAnonFunctionType() {
        return (this.flags & 8) > 0;
      }
      set noAnonFunctionType(v) {
        if (v) this.flags |= 8;
        else this.flags &= -9;
      }
      get hasFlowComment() {
        return (this.flags & 16) > 0;
      }
      set hasFlowComment(v) {
        if (v) this.flags |= 16;
        else this.flags &= -17;
      }
      get isAmbientContext() {
        return (this.flags & 32) > 0;
      }
      set isAmbientContext(v) {
        if (v) this.flags |= 32;
        else this.flags &= -33;
      }
      get inAbstractClass() {
        return (this.flags & 64) > 0;
      }
      set inAbstractClass(v) {
        if (v) this.flags |= 64;
        else this.flags &= -65;
      }
      get inDisallowConditionalTypesContext() {
        return (this.flags & 128) > 0;
      }
      set inDisallowConditionalTypesContext(v) {
        if (v) this.flags |= 128;
        else this.flags &= -129;
      }
      get soloAwait() {
        return (this.flags & 256) > 0;
      }
      set soloAwait(v) {
        if (v) this.flags |= 256;
        else this.flags &= -257;
      }
      get inFSharpPipelineDirectBody() {
        return (this.flags & 512) > 0;
      }
      set inFSharpPipelineDirectBody(v) {
        if (v) this.flags |= 512;
        else this.flags &= -513;
      }
      get canStartJSXElement() {
        return (this.flags & 1024) > 0;
      }
      set canStartJSXElement(v) {
        if (v) this.flags |= 1024;
        else this.flags &= -1025;
      }
      get containsEsc() {
        return (this.flags & 2048) > 0;
      }
      set containsEsc(v) {
        if (v) this.flags |= 2048;
        else this.flags &= -2049;
      }
      get hasTopLevelAwait() {
        return (this.flags & 4096) > 0;
      }
      set hasTopLevelAwait(v) {
        if (v) this.flags |= 4096;
        else this.flags &= -4097;
      }
      curPosition() {
        return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
      }
      clone() {
        const state = new _State();
        state.flags = this.flags;
        state.startIndex = this.startIndex;
        state.curLine = this.curLine;
        state.lineStart = this.lineStart;
        state.startLoc = this.startLoc;
        state.endLoc = this.endLoc;
        state.errors = this.errors.slice();
        state.potentialArrowAt = this.potentialArrowAt;
        state.noArrowAt = this.noArrowAt.slice();
        state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();
        state.topicContext = this.topicContext;
        state.labels = this.labels.slice();
        state.commentsLen = this.commentsLen;
        state.commentStack = this.commentStack.slice();
        state.pos = this.pos;
        state.type = this.type;
        state.value = this.value;
        state.start = this.start;
        state.end = this.end;
        state.lastTokEndLoc = this.lastTokEndLoc;
        state.lastTokStartLoc = this.lastTokStartLoc;
        state.context = this.context.slice();
        state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;
        state.strictErrors = this.strictErrors;
        state.tokensLength = this.tokensLength;
        return state;
      }
    };
    var _isDigit = function isDigit2(code3) {
      return code3 >= 48 && code3 <= 57;
    };
    var forbiddenNumericSeparatorSiblings = {
      decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
      hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
    };
    var isAllowedNumericSeparatorSibling = {
      bin: (ch) => ch === 48 || ch === 49,
      oct: (ch) => ch >= 48 && ch <= 55,
      dec: (ch) => ch >= 48 && ch <= 57,
      hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
    };
    function readStringContents(type, input, pos, lineStart, curLine, errors) {
      const initialPos = pos;
      const initialLineStart = lineStart;
      const initialCurLine = curLine;
      let out = "";
      let firstInvalidLoc = null;
      let chunkStart = pos;
      const {
        length: length2
      } = input;
      for (; ; ) {
        if (pos >= length2) {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
          out += input.slice(chunkStart, pos);
          break;
        }
        const ch = input.charCodeAt(pos);
        if (isStringEnd(type, ch, input, pos)) {
          out += input.slice(chunkStart, pos);
          break;
        }
        if (ch === 92) {
          out += input.slice(chunkStart, pos);
          const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
          if (res.ch === null && !firstInvalidLoc) {
            firstInvalidLoc = {
              pos,
              lineStart,
              curLine
            };
          } else {
            out += res.ch;
          }
          ({
            pos,
            lineStart,
            curLine
          } = res);
          chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
          ++pos;
          ++curLine;
          lineStart = pos;
        } else if (ch === 10 || ch === 13) {
          if (type === "template") {
            out += input.slice(chunkStart, pos) + "\n";
            ++pos;
            if (ch === 13 && input.charCodeAt(pos) === 10) {
              ++pos;
            }
            ++curLine;
            chunkStart = lineStart = pos;
          } else {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
          }
        } else {
          ++pos;
        }
      }
      return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
        containsInvalid: !!firstInvalidLoc
      };
    }
    function isStringEnd(type, ch, input, pos) {
      if (type === "template") {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
      }
      return ch === (type === "double" ? 34 : 39);
    }
    function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
      const throwOnInvalid = !inTemplate;
      pos++;
      const res = (ch2) => ({
        pos,
        ch: ch2,
        lineStart,
        curLine
      });
      const ch = input.charCodeAt(pos++);
      switch (ch) {
        case 110:
          return res("\n");
        case 114:
          return res("\r");
        case 120: {
          let code3;
          ({
            code: code3,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
          return res(code3 === null ? null : String.fromCharCode(code3));
        }
        case 117: {
          let code3;
          ({
            code: code3,
            pos
          } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
          return res(code3 === null ? null : String.fromCodePoint(code3));
        }
        case 116:
          return res("	");
        case 98:
          return res("\b");
        case 118:
          return res("\v");
        case 102:
          return res("\f");
        case 13:
          if (input.charCodeAt(pos) === 10) {
            ++pos;
          }
        case 10:
          lineStart = pos;
          ++curLine;
        case 8232:
        case 8233:
          return res("");
        case 56:
        case 57:
          if (inTemplate) {
            return res(null);
          } else {
            errors.strictNumericEscape(pos - 1, lineStart, curLine);
          }
        default:
          if (ch >= 48 && ch <= 55) {
            const startPos = pos - 1;
            const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
            let octalStr = match[0];
            let octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            pos += octalStr.length - 1;
            const next = input.charCodeAt(pos);
            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return res(null);
              } else {
                errors.strictNumericEscape(startPos, lineStart, curLine);
              }
            }
            return res(String.fromCharCode(octal));
          }
          return res(String.fromCharCode(ch));
      }
    }
    function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
      const initialPos = pos;
      let n2;
      ({
        n: n2,
        pos
      } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
      if (n2 === null) {
        if (throwOnInvalid) {
          errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        } else {
          pos = initialPos - 1;
        }
      }
      return {
        code: n2,
        pos
      };
    }
    function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
      const start = pos;
      const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
      let invalid = false;
      let total = 0;
      for (let i = 0, e2 = len == null ? Infinity : len; i < e2; ++i) {
        const code3 = input.charCodeAt(pos);
        let val;
        if (code3 === 95 && allowNumSeparator !== "bail") {
          const prev = input.charCodeAt(pos - 1);
          const next = input.charCodeAt(pos + 1);
          if (!allowNumSeparator) {
            if (bailOnError) return {
              n: null,
              pos
            };
            errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
          } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
            if (bailOnError) return {
              n: null,
              pos
            };
            errors.unexpectedNumericSeparator(pos, lineStart, curLine);
          }
          ++pos;
          continue;
        }
        if (code3 >= 97) {
          val = code3 - 97 + 10;
        } else if (code3 >= 65) {
          val = code3 - 65 + 10;
        } else if (_isDigit(code3)) {
          val = code3 - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          if (val <= 9 && bailOnError) {
            return {
              n: null,
              pos
            };
          } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
            val = 0;
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }
        ++pos;
        total = total * radix + val;
      }
      if (pos === start || len != null && pos - start !== len || invalid) {
        return {
          n: null,
          pos
        };
      }
      return {
        n: total,
        pos
      };
    }
    function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
      const ch = input.charCodeAt(pos);
      let code3;
      if (ch === 123) {
        ++pos;
        ({
          code: code3,
          pos
        } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        if (code3 !== null && code3 > 1114111) {
          if (throwOnInvalid) {
            errors.invalidCodePoint(pos, lineStart, curLine);
          } else {
            return {
              code: null,
              pos
            };
          }
        }
      } else {
        ({
          code: code3,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
      }
      return {
        code: code3,
        pos
      };
    }
    function buildPosition(pos, lineStart, curLine) {
      return new Position(curLine, pos - lineStart, pos);
    }
    var VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
    var Token = class {
      constructor(state) {
        const startIndex = state.startIndex || 0;
        this.type = state.type;
        this.value = state.value;
        this.start = startIndex + state.start;
        this.end = startIndex + state.end;
        this.loc = new SourceLocation(state.startLoc, state.endLoc);
      }
    };
    var Tokenizer = class extends CommentsParser {
      constructor(options, input) {
        super();
        this.isLookahead = void 0;
        this.tokens = [];
        this.errorHandlers_readInt = {
          invalidDigit: (pos, lineStart, curLine, radix) => {
            if (!(this.optionFlags & 2048)) return false;
            this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {
              radix
            });
            return true;
          },
          numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
          unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
        };
        this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
          invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
          invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
        });
        this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: (pos, lineStart, curLine) => {
            this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));
          },
          unterminated: (pos, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));
          }
        });
        this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
          unterminated: (pos, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));
          }
        });
        this.state = new State();
        this.state.init(options);
        this.input = input;
        this.length = input.length;
        this.comments = [];
        this.isLookahead = false;
      }
      pushToken(token) {
        this.tokens.length = this.state.tokensLength;
        this.tokens.push(token);
        ++this.state.tokensLength;
      }
      next() {
        this.checkKeywordEscapes();
        if (this.optionFlags & 256) {
          this.pushToken(new Token(this.state));
        }
        this.state.lastTokEndLoc = this.state.endLoc;
        this.state.lastTokStartLoc = this.state.startLoc;
        this.nextToken();
      }
      eat(type) {
        if (this.match(type)) {
          this.next();
          return true;
        } else {
          return false;
        }
      }
      match(type) {
        return this.state.type === type;
      }
      createLookaheadState(state) {
        return {
          pos: state.pos,
          value: null,
          type: state.type,
          start: state.start,
          end: state.end,
          context: [this.curContext()],
          inType: state.inType,
          startLoc: state.startLoc,
          lastTokEndLoc: state.lastTokEndLoc,
          curLine: state.curLine,
          lineStart: state.lineStart,
          curPosition: state.curPosition
        };
      }
      lookahead() {
        const old = this.state;
        this.state = this.createLookaheadState(old);
        this.isLookahead = true;
        this.nextToken();
        this.isLookahead = false;
        const curr = this.state;
        this.state = old;
        return curr;
      }
      nextTokenStart() {
        return this.nextTokenStartSince(this.state.pos);
      }
      nextTokenStartSince(pos) {
        skipWhiteSpace.lastIndex = pos;
        return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
      }
      lookaheadCharCode() {
        return this.lookaheadCharCodeSince(this.state.pos);
      }
      lookaheadCharCodeSince(pos) {
        return this.input.charCodeAt(this.nextTokenStartSince(pos));
      }
      nextTokenInLineStart() {
        return this.nextTokenInLineStartSince(this.state.pos);
      }
      nextTokenInLineStartSince(pos) {
        skipWhiteSpaceInLine.lastIndex = pos;
        return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
      }
      lookaheadInLineCharCode() {
        return this.input.charCodeAt(this.nextTokenInLineStart());
      }
      codePointAtPos(pos) {
        let cp = this.input.charCodeAt(pos);
        if ((cp & 64512) === 55296 && ++pos < this.input.length) {
          const trail = this.input.charCodeAt(pos);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        return cp;
      }
      setStrict(strict) {
        this.state.strict = strict;
        if (strict) {
          this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at));
          this.state.strictErrors.clear();
        }
      }
      curContext() {
        return this.state.context[this.state.context.length - 1];
      }
      nextToken() {
        this.skipSpace();
        this.state.start = this.state.pos;
        if (!this.isLookahead) this.state.startLoc = this.state.curPosition();
        if (this.state.pos >= this.length) {
          this.finishToken(140);
          return;
        }
        this.getTokenFromCode(this.codePointAtPos(this.state.pos));
      }
      skipBlockComment(commentEnd) {
        let startLoc;
        if (!this.isLookahead) startLoc = this.state.curPosition();
        const start = this.state.pos;
        const end = this.input.indexOf(commentEnd, start + 2);
        if (end === -1) {
          throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
        }
        this.state.pos = end + commentEnd.length;
        lineBreakG.lastIndex = start + 2;
        while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
          ++this.state.curLine;
          this.state.lineStart = lineBreakG.lastIndex;
        }
        if (this.isLookahead) return;
        const comment = {
          type: "CommentBlock",
          value: this.input.slice(start + 2, end),
          start: this.sourceToOffsetPos(start),
          end: this.sourceToOffsetPos(end + commentEnd.length),
          loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.optionFlags & 256) this.pushToken(comment);
        return comment;
      }
      skipLineComment(startSkip) {
        const start = this.state.pos;
        let startLoc;
        if (!this.isLookahead) startLoc = this.state.curPosition();
        let ch = this.input.charCodeAt(this.state.pos += startSkip);
        if (this.state.pos < this.length) {
          while (!isNewLine(ch) && ++this.state.pos < this.length) {
            ch = this.input.charCodeAt(this.state.pos);
          }
        }
        if (this.isLookahead) return;
        const end = this.state.pos;
        const value = this.input.slice(start + startSkip, end);
        const comment = {
          type: "CommentLine",
          value,
          start: this.sourceToOffsetPos(start),
          end: this.sourceToOffsetPos(end),
          loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.optionFlags & 256) this.pushToken(comment);
        return comment;
      }
      skipSpace() {
        const spaceStart = this.state.pos;
        const comments = this.optionFlags & 4096 ? [] : null;
        loop: while (this.state.pos < this.length) {
          const ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                ++this.state.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos;
              ++this.state.curLine;
              this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  const comment = this.skipBlockComment("*/");
                  if (comment !== void 0) {
                    this.addComment(comment);
                    comments == null || comments.push(comment);
                  }
                  break;
                }
                case 47: {
                  const comment = this.skipLineComment(2);
                  if (comment !== void 0) {
                    this.addComment(comment);
                    comments == null || comments.push(comment);
                  }
                  break;
                }
                default:
                  break loop;
              }
              break;
            default:
              if (isWhitespace(ch)) {
                ++this.state.pos;
              } else if (ch === 45 && !this.inModule && this.optionFlags & 8192) {
                const pos = this.state.pos;
                if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                  const comment = this.skipLineComment(3);
                  if (comment !== void 0) {
                    this.addComment(comment);
                    comments == null || comments.push(comment);
                  }
                } else {
                  break loop;
                }
              } else if (ch === 60 && !this.inModule && this.optionFlags & 8192) {
                const pos = this.state.pos;
                if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                  const comment = this.skipLineComment(4);
                  if (comment !== void 0) {
                    this.addComment(comment);
                    comments == null || comments.push(comment);
                  }
                } else {
                  break loop;
                }
              } else {
                break loop;
              }
          }
        }
        if ((comments == null ? void 0 : comments.length) > 0) {
          const end = this.state.pos;
          const commentWhitespace = {
            start: this.sourceToOffsetPos(spaceStart),
            end: this.sourceToOffsetPos(end),
            comments,
            leadingNode: null,
            trailingNode: null,
            containingNode: null
          };
          this.state.commentStack.push(commentWhitespace);
        }
      }
      finishToken(type, val) {
        this.state.end = this.state.pos;
        this.state.endLoc = this.state.curPosition();
        const prevType = this.state.type;
        this.state.type = type;
        this.state.value = val;
        if (!this.isLookahead) {
          this.updateContext(prevType);
        }
      }
      replaceToken(type) {
        this.state.type = type;
        this.updateContext();
      }
      readToken_numberSign() {
        if (this.state.pos === 0 && this.readToken_interpreter()) {
          return;
        }
        const nextPos = this.state.pos + 1;
        const next = this.codePointAtPos(nextPos);
        if (next >= 48 && next <= 57) {
          throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());
        }
        if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
          this.expectPlugin("recordAndTuple");
          if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
            throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
          }
          this.state.pos += 2;
          if (next === 123) {
            this.finishToken(7);
          } else {
            this.finishToken(1);
          }
        } else if (isIdentifierStart2(next)) {
          ++this.state.pos;
          this.finishToken(139, this.readWord1(next));
        } else if (next === 92) {
          ++this.state.pos;
          this.finishToken(139, this.readWord1());
        } else {
          this.finishOp(27, 1);
        }
      }
      readToken_dot() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next >= 48 && next <= 57) {
          this.readNumber(true);
          return;
        }
        if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
          this.state.pos += 3;
          this.finishToken(21);
        } else {
          ++this.state.pos;
          this.finishToken(16);
        }
      }
      readToken_slash() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(31, 2);
        } else {
          this.finishOp(56, 1);
        }
      }
      readToken_interpreter() {
        if (this.state.pos !== 0 || this.length < 2) return false;
        let ch = this.input.charCodeAt(this.state.pos + 1);
        if (ch !== 33) return false;
        const start = this.state.pos;
        this.state.pos += 1;
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
        const value = this.input.slice(start + 2, this.state.pos);
        this.finishToken(28, value);
        return true;
      }
      readToken_mult_modulo(code3) {
        let type = code3 === 42 ? 55 : 54;
        let width2 = 1;
        let next = this.input.charCodeAt(this.state.pos + 1);
        if (code3 === 42 && next === 42) {
          width2++;
          next = this.input.charCodeAt(this.state.pos + 2);
          type = 57;
        }
        if (next === 61 && !this.state.inType) {
          width2++;
          type = code3 === 37 ? 33 : 30;
        }
        this.finishOp(type, width2);
      }
      readToken_pipe_amp(code3) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code3) {
          if (this.input.charCodeAt(this.state.pos + 2) === 61) {
            this.finishOp(30, 3);
          } else {
            this.finishOp(code3 === 124 ? 41 : 42, 2);
          }
          return;
        }
        if (code3 === 124) {
          if (next === 62) {
            this.finishOp(39, 2);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 125) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            }
            this.state.pos += 2;
            this.finishToken(9);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 93) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            }
            this.state.pos += 2;
            this.finishToken(4);
            return;
          }
        }
        if (next === 61) {
          this.finishOp(30, 2);
          return;
        }
        this.finishOp(code3 === 124 ? 43 : 45, 1);
      }
      readToken_caret() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61 && !this.state.inType) {
          this.finishOp(32, 2);
        } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "^^"
        }])) {
          this.finishOp(37, 2);
          const lookaheadCh = this.input.codePointAt(this.state.pos);
          if (lookaheadCh === 94) {
            this.unexpected();
          }
        } else {
          this.finishOp(44, 1);
        }
      }
      readToken_atSign() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 64 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "@@"
        }])) {
          this.finishOp(38, 2);
        } else {
          this.finishOp(26, 1);
        }
      }
      readToken_plus_min(code3) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code3) {
          this.finishOp(34, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(30, 2);
        } else {
          this.finishOp(53, 1);
        }
      }
      readToken_lt() {
        const {
          pos
        } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 60) {
          if (this.input.charCodeAt(pos + 2) === 61) {
            this.finishOp(30, 3);
            return;
          }
          this.finishOp(51, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(47, 1);
      }
      readToken_gt() {
        const {
          pos
        } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 62) {
          const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(pos + size) === 61) {
            this.finishOp(30, size + 1);
            return;
          }
          this.finishOp(52, size);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(48, 1);
      }
      readToken_eq_excl(code3) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
          return;
        }
        if (code3 === 61 && next === 62) {
          this.state.pos += 2;
          this.finishToken(19);
          return;
        }
        this.finishOp(code3 === 61 ? 29 : 35, 1);
      }
      readToken_question() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        const next2 = this.input.charCodeAt(this.state.pos + 2);
        if (next === 63) {
          if (next2 === 61) {
            this.finishOp(30, 3);
          } else {
            this.finishOp(40, 2);
          }
        } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
          this.state.pos += 2;
          this.finishToken(18);
        } else {
          ++this.state.pos;
          this.finishToken(17);
        }
      }
      getTokenFromCode(code3) {
        switch (code3) {
          case 46:
            this.readToken_dot();
            return;
          case 40:
            ++this.state.pos;
            this.finishToken(10);
            return;
          case 41:
            ++this.state.pos;
            this.finishToken(11);
            return;
          case 59:
            ++this.state.pos;
            this.finishToken(13);
            return;
          case 44:
            ++this.state.pos;
            this.finishToken(12);
            return;
          case 91:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
              }
              this.state.pos += 2;
              this.finishToken(2);
            } else {
              ++this.state.pos;
              this.finishToken(0);
            }
            return;
          case 93:
            ++this.state.pos;
            this.finishToken(3);
            return;
          case 123:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
              }
              this.state.pos += 2;
              this.finishToken(6);
            } else {
              ++this.state.pos;
              this.finishToken(5);
            }
            return;
          case 125:
            ++this.state.pos;
            this.finishToken(8);
            return;
          case 58:
            if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
              this.finishOp(15, 2);
            } else {
              ++this.state.pos;
              this.finishToken(14);
            }
            return;
          case 63:
            this.readToken_question();
            return;
          case 96:
            this.readTemplateToken();
            return;
          case 48: {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }
            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }
            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            this.readNumber(false);
            return;
          case 34:
          case 39:
            this.readString(code3);
            return;
          case 47:
            this.readToken_slash();
            return;
          case 37:
          case 42:
            this.readToken_mult_modulo(code3);
            return;
          case 124:
          case 38:
            this.readToken_pipe_amp(code3);
            return;
          case 94:
            this.readToken_caret();
            return;
          case 43:
          case 45:
            this.readToken_plus_min(code3);
            return;
          case 60:
            this.readToken_lt();
            return;
          case 62:
            this.readToken_gt();
            return;
          case 61:
          case 33:
            this.readToken_eq_excl(code3);
            return;
          case 126:
            this.finishOp(36, 1);
            return;
          case 64:
            this.readToken_atSign();
            return;
          case 35:
            this.readToken_numberSign();
            return;
          case 92:
            this.readWord();
            return;
          default:
            if (isIdentifierStart2(code3)) {
              this.readWord(code3);
              return;
            }
        }
        throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {
          unexpected: String.fromCodePoint(code3)
        });
      }
      finishOp(type, size) {
        const str = this.input.slice(this.state.pos, this.state.pos + size);
        this.state.pos += size;
        this.finishToken(type, str);
      }
      readRegexp() {
        const startLoc = this.state.startLoc;
        const start = this.state.start + 1;
        let escaped, inClass;
        let {
          pos
        } = this.state;
        for (; ; ++pos) {
          if (pos >= this.length) {
            throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
          }
          const ch = this.input.charCodeAt(pos);
          if (isNewLine(ch)) {
            throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
          }
          if (escaped) {
            escaped = false;
          } else {
            if (ch === 91) {
              inClass = true;
            } else if (ch === 93 && inClass) {
              inClass = false;
            } else if (ch === 47 && !inClass) {
              break;
            }
            escaped = ch === 92;
          }
        }
        const content = this.input.slice(start, pos);
        ++pos;
        let mods = "";
        const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
        while (pos < this.length) {
          const cp = this.codePointAtPos(pos);
          const char = String.fromCharCode(cp);
          if (VALID_REGEX_FLAGS.has(cp)) {
            if (cp === 118) {
              if (mods.includes("u")) {
                this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
              }
            } else if (cp === 117) {
              if (mods.includes("v")) {
                this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
              }
            }
            if (mods.includes(char)) {
              this.raise(Errors.DuplicateRegExpFlags, nextPos());
            }
          } else if (isIdentifierChar(cp) || cp === 92) {
            this.raise(Errors.MalformedRegExpFlags, nextPos());
          } else {
            break;
          }
          ++pos;
          mods += char;
        }
        this.state.pos = pos;
        this.finishToken(138, {
          pattern: content,
          flags: mods
        });
      }
      readInt(radix, len, forceLen = false, allowNumSeparator = true) {
        const {
          n: n2,
          pos
        } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
        this.state.pos = pos;
        return n2;
      }
      readRadixNumber(radix) {
        const start = this.state.pos;
        const startLoc = this.state.curPosition();
        let isBigInt = false;
        this.state.pos += 2;
        const val = this.readInt(radix);
        if (val == null) {
          this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {
            radix
          });
        }
        const next = this.input.charCodeAt(this.state.pos);
        if (next === 110) {
          ++this.state.pos;
          isBigInt = true;
        } else if (next === 109) {
          throw this.raise(Errors.InvalidDecimal, startLoc);
        }
        if (isIdentifierStart2(this.codePointAtPos(this.state.pos))) {
          throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
        }
        if (isBigInt) {
          const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
          this.finishToken(136, str);
          return;
        }
        this.finishToken(135, val);
      }
      readNumber(startsWithDot) {
        const start = this.state.pos;
        const startLoc = this.state.curPosition();
        let isFloat = false;
        let isBigInt = false;
        let hasExponent = false;
        let isOctal = false;
        if (!startsWithDot && this.readInt(10) === null) {
          this.raise(Errors.InvalidNumber, this.state.curPosition());
        }
        const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (hasLeadingZero) {
          const integer2 = this.input.slice(start, this.state.pos);
          this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);
          if (!this.state.strict) {
            const underscorePos = integer2.indexOf("_");
            if (underscorePos > 0) {
              this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));
            }
          }
          isOctal = hasLeadingZero && !/[89]/.test(integer2);
        }
        let next = this.input.charCodeAt(this.state.pos);
        if (next === 46 && !isOctal) {
          ++this.state.pos;
          this.readInt(10);
          isFloat = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if ((next === 69 || next === 101) && !isOctal) {
          next = this.input.charCodeAt(++this.state.pos);
          if (next === 43 || next === 45) {
            ++this.state.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(Errors.InvalidOrMissingExponent, startLoc);
          }
          isFloat = true;
          hasExponent = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if (next === 110) {
          if (isFloat || hasLeadingZero) {
            this.raise(Errors.InvalidBigIntLiteral, startLoc);
          }
          ++this.state.pos;
          isBigInt = true;
        }
        if (next === 109) {
          this.expectPlugin("decimal", this.state.curPosition());
          if (hasExponent || hasLeadingZero) {
            this.raise(Errors.InvalidDecimal, startLoc);
          }
          ++this.state.pos;
          var isDecimal = true;
        }
        if (isIdentifierStart2(this.codePointAtPos(this.state.pos))) {
          throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
        }
        const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
        if (isBigInt) {
          this.finishToken(136, str);
          return;
        }
        if (isDecimal) {
          this.finishToken(137, str);
          return;
        }
        const val = isOctal ? parseInt(str, 8) : parseFloat(str);
        this.finishToken(135, val);
      }
      readCodePoint(throwOnInvalid) {
        const {
          code: code3,
          pos
        } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
        this.state.pos = pos;
        return code3;
      }
      readString(quote) {
        const {
          str,
          pos,
          curLine,
          lineStart
        } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        this.finishToken(134, str);
      }
      readTemplateContinuation() {
        if (!this.match(8)) {
          this.unexpected(null, 8);
        }
        this.state.pos--;
        this.readTemplateToken();
      }
      readTemplateToken() {
        const opening = this.input[this.state.pos];
        const {
          str,
          firstInvalidLoc,
          pos,
          curLine,
          lineStart
        } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        if (firstInvalidLoc) {
          this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, this.sourceToOffsetPos(firstInvalidLoc.pos));
        }
        if (this.input.codePointAt(pos) === 96) {
          this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
        } else {
          this.state.pos++;
          this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
        }
      }
      recordStrictModeErrors(toParseError, at) {
        const index = at.index;
        if (this.state.strict && !this.state.strictErrors.has(index)) {
          this.raise(toParseError, at);
        } else {
          this.state.strictErrors.set(index, [toParseError, at]);
        }
      }
      readWord1(firstCode) {
        this.state.containsEsc = false;
        let word = "";
        const start = this.state.pos;
        let chunkStart = this.state.pos;
        if (firstCode !== void 0) {
          this.state.pos += firstCode <= 65535 ? 1 : 2;
        }
        while (this.state.pos < this.length) {
          const ch = this.codePointAtPos(this.state.pos);
          if (isIdentifierChar(ch)) {
            this.state.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.state.containsEsc = true;
            word += this.input.slice(chunkStart, this.state.pos);
            const escStart = this.state.curPosition();
            const identifierCheck = this.state.pos === start ? isIdentifierStart2 : isIdentifierChar;
            if (this.input.charCodeAt(++this.state.pos) !== 117) {
              this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());
              chunkStart = this.state.pos - 1;
              continue;
            }
            ++this.state.pos;
            const esc = this.readCodePoint(true);
            if (esc !== null) {
              if (!identifierCheck(esc)) {
                this.raise(Errors.EscapedCharNotAnIdentifier, escStart);
              }
              word += String.fromCodePoint(esc);
            }
            chunkStart = this.state.pos;
          } else {
            break;
          }
        }
        return word + this.input.slice(chunkStart, this.state.pos);
      }
      readWord(firstCode) {
        const word = this.readWord1(firstCode);
        const type = keywords$1.get(word);
        if (type !== void 0) {
          this.finishToken(type, tokenLabelName(type));
        } else {
          this.finishToken(132, word);
        }
      }
      checkKeywordEscapes() {
        const {
          type
        } = this.state;
        if (tokenIsKeyword(type) && this.state.containsEsc) {
          this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {
            reservedWord: tokenLabelName(type)
          });
        }
      }
      raise(toParseError, at, details = {}) {
        const loc = at instanceof Position ? at : at.loc.start;
        const error = toParseError(loc, details);
        if (!(this.optionFlags & 2048)) throw error;
        if (!this.isLookahead) this.state.errors.push(error);
        return error;
      }
      raiseOverwrite(toParseError, at, details = {}) {
        const loc = at instanceof Position ? at : at.loc.start;
        const pos = loc.index;
        const errors = this.state.errors;
        for (let i = errors.length - 1; i >= 0; i--) {
          const error = errors[i];
          if (error.loc.index === pos) {
            return errors[i] = toParseError(loc, details);
          }
          if (error.loc.index < pos) break;
        }
        return this.raise(toParseError, at, details);
      }
      updateContext(prevType) {
      }
      unexpected(loc, type) {
        throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {
          expected: type ? tokenLabelName(type) : null
        });
      }
      expectPlugin(pluginName, loc) {
        if (this.hasPlugin(pluginName)) {
          return true;
        }
        throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {
          missingPlugin: [pluginName]
        });
      }
      expectOnePlugin(pluginNames) {
        if (!pluginNames.some((name50) => this.hasPlugin(name50))) {
          throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {
            missingPlugin: pluginNames
          });
        }
      }
      errorBuilder(error) {
        return (pos, lineStart, curLine) => {
          this.raise(error, buildPosition(pos, lineStart, curLine));
        };
      }
    };
    var ClassScope = class {
      constructor() {
        this.privateNames = /* @__PURE__ */ new Set();
        this.loneAccessors = /* @__PURE__ */ new Map();
        this.undefinedPrivateNames = /* @__PURE__ */ new Map();
      }
    };
    var ClassScopeHandler = class {
      constructor(parser) {
        this.parser = void 0;
        this.stack = [];
        this.undefinedPrivateNames = /* @__PURE__ */ new Map();
        this.parser = parser;
      }
      current() {
        return this.stack[this.stack.length - 1];
      }
      enter() {
        this.stack.push(new ClassScope());
      }
      exit() {
        const oldClassScope = this.stack.pop();
        const current = this.current();
        for (const [name50, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
          if (current) {
            if (!current.undefinedPrivateNames.has(name50)) {
              current.undefinedPrivateNames.set(name50, loc);
            }
          } else {
            this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
              identifierName: name50
            });
          }
        }
      }
      declarePrivateName(name50, elementType, loc) {
        const {
          privateNames,
          loneAccessors,
          undefinedPrivateNames
        } = this.current();
        let redefined = privateNames.has(name50);
        if (elementType & 3) {
          const accessor = redefined && loneAccessors.get(name50);
          if (accessor) {
            const oldStatic = accessor & 4;
            const newStatic = elementType & 4;
            const oldKind = accessor & 3;
            const newKind = elementType & 3;
            redefined = oldKind === newKind || oldStatic !== newStatic;
            if (!redefined) loneAccessors.delete(name50);
          } else if (!redefined) {
            loneAccessors.set(name50, elementType);
          }
        }
        if (redefined) {
          this.parser.raise(Errors.PrivateNameRedeclaration, loc, {
            identifierName: name50
          });
        }
        privateNames.add(name50);
        undefinedPrivateNames.delete(name50);
      }
      usePrivateName(name50, loc) {
        let classScope;
        for (classScope of this.stack) {
          if (classScope.privateNames.has(name50)) return;
        }
        if (classScope) {
          classScope.undefinedPrivateNames.set(name50, loc);
        } else {
          this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
            identifierName: name50
          });
        }
      }
    };
    var ExpressionScope = class {
      constructor(type = 0) {
        this.type = type;
      }
      canBeArrowParameterDeclaration() {
        return this.type === 2 || this.type === 1;
      }
      isCertainlyParameterDeclaration() {
        return this.type === 3;
      }
    };
    var ArrowHeadParsingScope = class extends ExpressionScope {
      constructor(type) {
        super(type);
        this.declarationErrors = /* @__PURE__ */ new Map();
      }
      recordDeclarationError(ParsingErrorClass, at) {
        const index = at.index;
        this.declarationErrors.set(index, [ParsingErrorClass, at]);
      }
      clearDeclarationError(index) {
        this.declarationErrors.delete(index);
      }
      iterateErrors(iterator) {
        this.declarationErrors.forEach(iterator);
      }
    };
    var ExpressionScopeHandler = class {
      constructor(parser) {
        this.parser = void 0;
        this.stack = [new ExpressionScope()];
        this.parser = parser;
      }
      enter(scope) {
        this.stack.push(scope);
      }
      exit() {
        this.stack.pop();
      }
      recordParameterInitializerError(toParseError, node) {
        const origin = node.loc.start;
        const {
          stack
        } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while (!scope.isCertainlyParameterDeclaration()) {
          if (scope.canBeArrowParameterDeclaration()) {
            scope.recordDeclarationError(toParseError, origin);
          } else {
            return;
          }
          scope = stack[--i];
        }
        this.parser.raise(toParseError, origin);
      }
      recordArrowParameterBindingError(error, node) {
        const {
          stack
        } = this;
        const scope = stack[stack.length - 1];
        const origin = node.loc.start;
        if (scope.isCertainlyParameterDeclaration()) {
          this.parser.raise(error, origin);
        } else if (scope.canBeArrowParameterDeclaration()) {
          scope.recordDeclarationError(error, origin);
        } else {
          return;
        }
      }
      recordAsyncArrowParametersError(at) {
        const {
          stack
        } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while (scope.canBeArrowParameterDeclaration()) {
          if (scope.type === 2) {
            scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);
          }
          scope = stack[--i];
        }
      }
      validateAsPattern() {
        const {
          stack
        } = this;
        const currentScope = stack[stack.length - 1];
        if (!currentScope.canBeArrowParameterDeclaration()) return;
        currentScope.iterateErrors(([toParseError, loc]) => {
          this.parser.raise(toParseError, loc);
          let i = stack.length - 2;
          let scope = stack[i];
          while (scope.canBeArrowParameterDeclaration()) {
            scope.clearDeclarationError(loc.index);
            scope = stack[--i];
          }
        });
      }
    };
    function newParameterDeclarationScope() {
      return new ExpressionScope(3);
    }
    function newArrowHeadScope() {
      return new ArrowHeadParsingScope(1);
    }
    function newAsyncArrowScope() {
      return new ArrowHeadParsingScope(2);
    }
    function newExpressionScope() {
      return new ExpressionScope();
    }
    var UtilParser = class extends Tokenizer {
      addExtra(node, key, value, enumerable = true) {
        if (!node) return;
        let {
          extra
        } = node;
        if (extra == null) {
          extra = {};
          node.extra = extra;
        }
        if (enumerable) {
          extra[key] = value;
        } else {
          Object.defineProperty(extra, key, {
            enumerable,
            value
          });
        }
      }
      isContextual(token) {
        return this.state.type === token && !this.state.containsEsc;
      }
      isUnparsedContextual(nameStart, name50) {
        if (this.input.startsWith(name50, nameStart)) {
          const nextCh = this.input.charCodeAt(nameStart + name50.length);
          return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
        }
        return false;
      }
      isLookaheadContextual(name50) {
        const next = this.nextTokenStart();
        return this.isUnparsedContextual(next, name50);
      }
      eatContextual(token) {
        if (this.isContextual(token)) {
          this.next();
          return true;
        }
        return false;
      }
      expectContextual(token, toParseError) {
        if (!this.eatContextual(token)) {
          if (toParseError != null) {
            throw this.raise(toParseError, this.state.startLoc);
          }
          this.unexpected(null, token);
        }
      }
      canInsertSemicolon() {
        return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
      }
      hasPrecedingLineBreak() {
        return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
      }
      hasFollowingLineBreak() {
        return hasNewLine(this.input, this.state.end, this.nextTokenStart());
      }
      isLineTerminator() {
        return this.eat(13) || this.canInsertSemicolon();
      }
      semicolon(allowAsi = true) {
        if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;
        this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);
      }
      expect(type, loc) {
        if (!this.eat(type)) {
          this.unexpected(loc, type);
        }
      }
      tryParse(fn, oldState = this.state.clone()) {
        const abortSignal = {
          node: null
        };
        try {
          const node = fn((node2 = null) => {
            abortSignal.node = node2;
            throw abortSignal;
          });
          if (this.state.errors.length > oldState.errors.length) {
            const failState = this.state;
            this.state = oldState;
            this.state.tokensLength = failState.tokensLength;
            return {
              node,
              error: failState.errors[oldState.errors.length],
              thrown: false,
              aborted: false,
              failState
            };
          }
          return {
            node,
            error: null,
            thrown: false,
            aborted: false,
            failState: null
          };
        } catch (error) {
          const failState = this.state;
          this.state = oldState;
          if (error instanceof SyntaxError) {
            return {
              node: null,
              error,
              thrown: true,
              aborted: false,
              failState
            };
          }
          if (error === abortSignal) {
            return {
              node: abortSignal.node,
              error: null,
              thrown: false,
              aborted: true,
              failState
            };
          }
          throw error;
        }
      }
      checkExpressionErrors(refExpressionErrors, andThrow) {
        if (!refExpressionErrors) return false;
        const {
          shorthandAssignLoc,
          doubleProtoLoc,
          privateKeyLoc,
          optionalParametersLoc
        } = refExpressionErrors;
        const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
        if (!andThrow) {
          return hasErrors;
        }
        if (shorthandAssignLoc != null) {
          this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
        }
        if (doubleProtoLoc != null) {
          this.raise(Errors.DuplicateProto, doubleProtoLoc);
        }
        if (privateKeyLoc != null) {
          this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
        }
        if (optionalParametersLoc != null) {
          this.unexpected(optionalParametersLoc);
        }
      }
      isLiteralPropertyName() {
        return tokenIsLiteralPropertyName(this.state.type);
      }
      isPrivateName(node) {
        return node.type === "PrivateName";
      }
      getPrivateNameSV(node) {
        return node.id.name;
      }
      hasPropertyAsPrivateName(node) {
        return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
      }
      isObjectProperty(node) {
        return node.type === "ObjectProperty";
      }
      isObjectMethod(node) {
        return node.type === "ObjectMethod";
      }
      initializeScopes(inModule = this.options.sourceType === "module") {
        const oldLabels = this.state.labels;
        this.state.labels = [];
        const oldExportedIdentifiers = this.exportedIdentifiers;
        this.exportedIdentifiers = /* @__PURE__ */ new Set();
        const oldInModule = this.inModule;
        this.inModule = inModule;
        const oldScope = this.scope;
        const ScopeHandler2 = this.getScopeHandler();
        this.scope = new ScopeHandler2(this, inModule);
        const oldProdParam = this.prodParam;
        this.prodParam = new ProductionParameterHandler();
        const oldClassScope = this.classScope;
        this.classScope = new ClassScopeHandler(this);
        const oldExpressionScope = this.expressionScope;
        this.expressionScope = new ExpressionScopeHandler(this);
        return () => {
          this.state.labels = oldLabels;
          this.exportedIdentifiers = oldExportedIdentifiers;
          this.inModule = oldInModule;
          this.scope = oldScope;
          this.prodParam = oldProdParam;
          this.classScope = oldClassScope;
          this.expressionScope = oldExpressionScope;
        };
      }
      enterInitialScopes() {
        let paramFlags = 0;
        if (this.inModule || this.optionFlags & 1) {
          paramFlags |= 2;
        }
        if (this.optionFlags & 32) {
          paramFlags |= 1;
        }
        if (this.optionFlags & 2) {
          paramFlags |= 4;
        }
        let scopeFlags = 1;
        if (this.optionFlags & 4) {
          scopeFlags |= 512;
        }
        this.scope.enter(scopeFlags);
        this.prodParam.enter(paramFlags);
      }
      checkDestructuringPrivate(refExpressionErrors) {
        const {
          privateKeyLoc
        } = refExpressionErrors;
        if (privateKeyLoc !== null) {
          this.expectPlugin("destructuringPrivate", privateKeyLoc);
        }
      }
    };
    var ExpressionErrors = class {
      constructor() {
        this.shorthandAssignLoc = null;
        this.doubleProtoLoc = null;
        this.privateKeyLoc = null;
        this.optionalParametersLoc = null;
      }
    };
    var Node = class {
      constructor(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        this.loc = new SourceLocation(loc);
        if ((parser == null ? void 0 : parser.optionFlags) & 128) this.range = [pos, 0];
        if (parser != null && parser.filename) this.loc.filename = parser.filename;
      }
    };
    var NodePrototype = Node.prototype;
    {
      NodePrototype.__clone = function() {
        const newNode = new Node(void 0, this.start, this.loc.start);
        const keys = Object.keys(this);
        for (let i = 0, length2 = keys.length; i < length2; i++) {
          const key = keys[i];
          if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
            newNode[key] = this[key];
          }
        }
        return newNode;
      };
    }
    var NodeUtils = class extends UtilParser {
      startNode() {
        const loc = this.state.startLoc;
        return new Node(this, loc.index, loc);
      }
      startNodeAt(loc) {
        return new Node(this, loc.index, loc);
      }
      startNodeAtNode(type) {
        return this.startNodeAt(type.loc.start);
      }
      finishNode(node, type) {
        return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
      }
      finishNodeAt(node, type, endLoc) {
        node.type = type;
        node.end = endLoc.index;
        node.loc.end = endLoc;
        if (this.optionFlags & 128) node.range[1] = endLoc.index;
        if (this.optionFlags & 4096) {
          this.processComment(node);
        }
        return node;
      }
      resetStartLocation(node, startLoc) {
        node.start = startLoc.index;
        node.loc.start = startLoc;
        if (this.optionFlags & 128) node.range[0] = startLoc.index;
      }
      resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        node.end = endLoc.index;
        node.loc.end = endLoc;
        if (this.optionFlags & 128) node.range[1] = endLoc.index;
      }
      resetStartLocationFromNode(node, locationNode) {
        this.resetStartLocation(node, locationNode.loc.start);
      }
      castNodeTo(node, type) {
        node.type = type;
        return node;
      }
      cloneIdentifier(node) {
        const {
          type,
          start,
          end,
          loc,
          range,
          name: name50
        } = node;
        const cloned = Object.create(NodePrototype);
        cloned.type = type;
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        cloned.name = name50;
        if (node.extra) cloned.extra = node.extra;
        return cloned;
      }
      cloneStringLiteral(node) {
        const {
          type,
          start,
          end,
          loc,
          range,
          extra
        } = node;
        const cloned = Object.create(NodePrototype);
        cloned.type = type;
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        cloned.extra = extra;
        cloned.value = node.value;
        return cloned;
      }
    };
    var unwrapParenthesizedExpression = (node) => {
      return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
    };
    var LValParser = class extends NodeUtils {
      toAssignable(node, isLHS = false) {
        var _node$extra, _node$extra3;
        let parenthesized = void 0;
        if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
          parenthesized = unwrapParenthesizedExpression(node);
          if (isLHS) {
            if (parenthesized.type === "Identifier") {
              this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);
            } else if (parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized)) {
              this.raise(Errors.InvalidParenthesizedAssignment, node);
            }
          } else {
            this.raise(Errors.InvalidParenthesizedAssignment, node);
          }
        }
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            this.castNodeTo(node, "ObjectPattern");
            for (let i = 0, length2 = node.properties.length, last = length2 - 1; i < length2; i++) {
              var _node$extra2;
              const prop = node.properties[i];
              const isLast = i === last;
              this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
              if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
                this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);
              }
            }
            break;
          case "ObjectProperty": {
            const {
              key,
              value
            } = node;
            if (this.isPrivateName(key)) {
              this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }
            this.toAssignable(value, isLHS);
            break;
          }
          case "SpreadElement": {
            throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
          }
          case "ArrayExpression":
            this.castNodeTo(node, "ArrayPattern");
            this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
            break;
          case "AssignmentExpression":
            if (node.operator !== "=") {
              this.raise(Errors.MissingEqInAssignment, node.left.loc.end);
            }
            this.castNodeTo(node, "AssignmentPattern");
            delete node.operator;
            this.toAssignable(node.left, isLHS);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(parenthesized, isLHS);
            break;
        }
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === "ObjectMethod") {
          this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);
        } else if (prop.type === "SpreadElement") {
          this.castNodeTo(prop, "RestElement");
          const arg = prop.argument;
          this.checkToRestConversion(arg, false);
          this.toAssignable(arg, isLHS);
          if (!isLast) {
            this.raise(Errors.RestTrailingComma, prop);
          }
        } else {
          this.toAssignable(prop, isLHS);
        }
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        const end = exprList.length - 1;
        for (let i = 0; i <= end; i++) {
          const elt = exprList[i];
          if (!elt) continue;
          this.toAssignableListItem(exprList, i, isLHS);
          if (elt.type === "RestElement") {
            if (i < end) {
              this.raise(Errors.RestTrailingComma, elt);
            } else if (trailingCommaLoc) {
              this.raise(Errors.RestTrailingComma, trailingCommaLoc);
            }
          }
        }
      }
      toAssignableListItem(exprList, index, isLHS) {
        const node = exprList[index];
        if (node.type === "SpreadElement") {
          this.castNodeTo(node, "RestElement");
          const arg = node.argument;
          this.checkToRestConversion(arg, true);
          this.toAssignable(arg, isLHS);
        } else {
          this.toAssignable(node, isLHS);
        }
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            return true;
          case "ObjectExpression": {
            const last = node.properties.length - 1;
            return node.properties.every((prop, i) => {
              return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
            });
          }
          case "ObjectProperty":
            return this.isAssignable(node.value);
          case "SpreadElement":
            return this.isAssignable(node.argument);
          case "ArrayExpression":
            return node.elements.every((element) => element === null || this.isAssignable(element));
          case "AssignmentExpression":
            return node.operator === "=";
          case "ParenthesizedExpression":
            return this.isAssignable(node.expression);
          case "MemberExpression":
          case "OptionalMemberExpression":
            return !isBinding;
          default:
            return false;
        }
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        return exprList;
      }
      toReferencedListDeep(exprList, isParenthesizedExpr) {
        this.toReferencedList(exprList, isParenthesizedExpr);
        for (const expr of exprList) {
          if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
            this.toReferencedListDeep(expr.elements);
          }
        }
      }
      parseSpread(refExpressionErrors) {
        const node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
        return this.finishNode(node, "SpreadElement");
      }
      parseRestBinding() {
        const node = this.startNode();
        this.next();
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 0: {
            const node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(3, 93, 1);
            return this.finishNode(node, "ArrayPattern");
          }
          case 5:
            return this.parseObjectLike(8, true);
        }
        return this.parseIdentifier();
      }
      parseBindingList(close, closeCharCode, flags) {
        const allowEmpty = flags & 1;
        const elts = [];
        let first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
          }
          if (allowEmpty && this.match(12)) {
            elts.push(null);
          } else if (this.eat(close)) {
            break;
          } else if (this.match(21)) {
            let rest = this.parseRestBinding();
            if (this.hasPlugin("flow") || flags & 2) {
              rest = this.parseFunctionParamType(rest);
            }
            elts.push(rest);
            if (!this.checkCommaAfterRest(closeCharCode)) {
              this.expect(close);
              break;
            }
          } else {
            const decorators = [];
            if (flags & 2) {
              if (this.match(26) && this.hasPlugin("decorators")) {
                this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);
              }
              while (this.match(26)) {
                decorators.push(this.parseDecorator());
              }
            }
            elts.push(this.parseBindingElement(flags, decorators));
          }
        }
        return elts;
      }
      parseBindingRestProperty(prop) {
        this.next();
        prop.argument = this.parseIdentifier();
        this.checkCommaAfterRest(125);
        return this.finishNode(prop, "RestElement");
      }
      parseBindingProperty() {
        const {
          type,
          startLoc
        } = this.state;
        if (type === 21) {
          return this.parseBindingRestProperty(this.startNode());
        }
        const prop = this.startNode();
        if (type === 139) {
          this.expectPlugin("destructuringPrivate", startLoc);
          this.classScope.usePrivateName(this.state.value, startLoc);
          prop.key = this.parsePrivateName();
        } else {
          this.parsePropertyName(prop);
        }
        prop.method = false;
        return this.parseObjPropValue(prop, startLoc, false, false, true, false);
      }
      parseBindingElement(flags, decorators) {
        const left = this.parseMaybeDefault();
        if (this.hasPlugin("flow") || flags & 2) {
          this.parseFunctionParamType(left);
        }
        if (decorators.length) {
          left.decorators = decorators;
          this.resetStartLocationFromNode(left, decorators[0]);
        }
        const elt = this.parseMaybeDefault(left.loc.start, left);
        return elt;
      }
      parseFunctionParamType(param) {
        return param;
      }
      parseMaybeDefault(startLoc, left) {
        startLoc != null ? startLoc : startLoc = this.state.startLoc;
        left = left != null ? left : this.parseBindingAtom();
        if (!this.eat(29)) return left;
        const node = this.startNodeAt(startLoc);
        node.left = left;
        node.right = this.parseMaybeAssignAllowIn();
        return this.finishNode(node, "AssignmentPattern");
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        switch (type) {
          case "AssignmentPattern":
            return "left";
          case "RestElement":
            return "argument";
          case "ObjectProperty":
            return "value";
          case "ParenthesizedExpression":
            return "expression";
          case "ArrayPattern":
            return "elements";
          case "ObjectPattern":
            return "properties";
        }
        return false;
      }
      isOptionalMemberExpression(expression) {
        return expression.type === "OptionalMemberExpression";
      }
      checkLVal(expression, ancestor, binding = 64, checkClashes = false, strictModeChanged = false, hasParenthesizedAncestor = false) {
        var _expression$extra;
        const type = expression.type;
        if (this.isObjectMethod(expression)) return;
        const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);
        if (isOptionalMemberExpression || type === "MemberExpression") {
          if (isOptionalMemberExpression) {
            this.expectPlugin("optionalChainingAssign", expression.loc.start);
            if (ancestor.type !== "AssignmentExpression") {
              this.raise(Errors.InvalidLhsOptionalChaining, expression, {
                ancestor
              });
            }
          }
          if (binding !== 64) {
            this.raise(Errors.InvalidPropertyBindingPattern, expression);
          }
          return;
        }
        if (type === "Identifier") {
          this.checkIdentifier(expression, binding, strictModeChanged);
          const {
            name: name50
          } = expression;
          if (checkClashes) {
            if (checkClashes.has(name50)) {
              this.raise(Errors.ParamDupe, expression);
            } else {
              checkClashes.add(name50);
            }
          }
          return;
        }
        const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
        if (validity === true) return;
        if (validity === false) {
          const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
          this.raise(ParseErrorClass, expression, {
            ancestor
          });
          return;
        }
        let key, isParenthesizedExpression;
        if (typeof validity === "string") {
          key = validity;
          isParenthesizedExpression = type === "ParenthesizedExpression";
        } else {
          [key, isParenthesizedExpression] = validity;
        }
        const nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" ? {
          type
        } : ancestor;
        const val = expression[key];
        if (Array.isArray(val)) {
          for (const child of val) {
            if (child) {
              this.checkLVal(child, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);
            }
          }
        } else if (val) {
          this.checkLVal(val, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);
        }
      }
      checkIdentifier(at, bindingType, strictModeChanged = false) {
        if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
          if (bindingType === 64) {
            this.raise(Errors.StrictEvalArguments, at, {
              referenceName: at.name
            });
          } else {
            this.raise(Errors.StrictEvalArgumentsBinding, at, {
              bindingName: at.name
            });
          }
        }
        if (bindingType & 8192 && at.name === "let") {
          this.raise(Errors.LetInLexicalBinding, at);
        }
        if (!(bindingType & 64)) {
          this.declareNameFromIdentifier(at, bindingType);
        }
      }
      declareNameFromIdentifier(identifier, binding) {
        this.scope.declareName(identifier.name, binding, identifier.loc.start);
      }
      checkToRestConversion(node, allowPattern) {
        switch (node.type) {
          case "ParenthesizedExpression":
            this.checkToRestConversion(node.expression, allowPattern);
            break;
          case "Identifier":
          case "MemberExpression":
            break;
          case "ArrayExpression":
          case "ObjectExpression":
            if (allowPattern) break;
          default:
            this.raise(Errors.InvalidRestAssignmentPattern, node);
        }
      }
      checkCommaAfterRest(close) {
        if (!this.match(12)) {
          return false;
        }
        this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);
        return true;
      }
    };
    function nonNull(x) {
      if (x == null) {
        throw new Error(`Unexpected ${x} value.`);
      }
      return x;
    }
    function assert(x) {
      if (!x) {
        throw new Error("Assert fail");
      }
    }
    var TSErrors = ParseErrorEnum`typescript`({
      AbstractMethodHasImplementation: ({
        methodName
      }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
      AbstractPropertyHasInitializer: ({
        propertyName
      }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
      AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
      AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
      AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
      ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
      ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
      ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
      ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
      DeclareAccessor: ({
        kind
      }) => `'declare' is not allowed in ${kind}ters.`,
      DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
      DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
      DuplicateAccessibilityModifier: ({
        modifier
      }) => `Accessibility modifier already seen: '${modifier}'.`,
      DuplicateModifier: ({
        modifier
      }) => `Duplicate modifier: '${modifier}'.`,
      EmptyHeritageClauseType: ({
        token
      }) => `'${token}' list cannot be empty.`,
      EmptyTypeArguments: "Type argument list cannot be empty.",
      EmptyTypeParameters: "Type parameter list cannot be empty.",
      ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
      ImportAliasHasImportType: "An import alias can not use 'import type'.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
      IncompatibleModifiers: ({
        modifiers: modifiers2
      }) => `'${modifiers2[0]}' modifier cannot be used with '${modifiers2[1]}' modifier.`,
      IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
      IndexSignatureHasAccessibility: ({
        modifier
      }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
      IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
      IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
      IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
      InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
      InvalidHeritageClauseType: ({
        token
      }) => `'${token}' list can only include identifiers or qualified-names with optional type arguments.`,
      InvalidModifierOnAwaitUsingDeclaration: (modifier) => `'${modifier}' modifier cannot appear on an await using declaration.`,
      InvalidModifierOnTypeMember: ({
        modifier
      }) => `'${modifier}' modifier cannot appear on a type member.`,
      InvalidModifierOnTypeParameter: ({
        modifier
      }) => `'${modifier}' modifier cannot appear on a type parameter.`,
      InvalidModifierOnTypeParameterPositions: ({
        modifier
      }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
      InvalidModifierOnUsingDeclaration: (modifier) => `'${modifier}' modifier cannot appear on a using declaration.`,
      InvalidModifiersOrder: ({
        orderedModifiers
      }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
      InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
      InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
      MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
      NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
      NonClassMethodPropertyHasAbstractModifier: "'abstract' modifier can only appear on a class, method, or property declaration.",
      OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
      OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
      PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
      PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
      PrivateElementHasAccessibility: ({
        modifier
      }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
      ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
      ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
      ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
      SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
      SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
      SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
      SingleTypeParameterWithoutTrailingComma: ({
        typeParameterName
      }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
      StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
      TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
      TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
      TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
      TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
      UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
      UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
      UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
      UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
      UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
      UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
      UnsupportedSignatureParameterKind: ({
        type
      }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,
      UsingDeclarationInAmbientContext: (kind) => `'${kind}' declarations are not allowed in ambient contexts.`
    });
    function keywordTypeFromName(value) {
      switch (value) {
        case "any":
          return "TSAnyKeyword";
        case "boolean":
          return "TSBooleanKeyword";
        case "bigint":
          return "TSBigIntKeyword";
        case "never":
          return "TSNeverKeyword";
        case "number":
          return "TSNumberKeyword";
        case "object":
          return "TSObjectKeyword";
        case "string":
          return "TSStringKeyword";
        case "symbol":
          return "TSSymbolKeyword";
        case "undefined":
          return "TSUndefinedKeyword";
        case "unknown":
          return "TSUnknownKeyword";
        default:
          return void 0;
      }
    }
    function tsIsAccessModifier(modifier) {
      return modifier === "private" || modifier === "public" || modifier === "protected";
    }
    function tsIsVarianceAnnotations(modifier) {
      return modifier === "in" || modifier === "out";
    }
    var typescript = (superClass) => class TypeScriptParserMixin extends superClass {
      constructor(...args) {
        super(...args);
        this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["in", "out"],
          disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameter
        });
        this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["const"],
          disallowedModifiers: ["in", "out"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        });
        this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["in", "out", "const"],
          disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameter
        });
      }
      getScopeHandler() {
        return TypeScriptScopeHandler;
      }
      tsIsIdentifier() {
        return tokenIsIdentifier(this.state.type);
      }
      tsTokenCanFollowModifier() {
        return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
      }
      tsNextTokenOnSameLineAndCanFollowModifier() {
        this.next();
        if (this.hasPrecedingLineBreak()) {
          return false;
        }
        return this.tsTokenCanFollowModifier();
      }
      tsNextTokenCanFollowModifier() {
        if (this.match(106)) {
          this.next();
          return this.tsTokenCanFollowModifier();
        }
        return this.tsNextTokenOnSameLineAndCanFollowModifier();
      }
      tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock, hasSeenStaticModifier) {
        if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
          return void 0;
        }
        const modifier = this.state.value;
        if (allowedModifiers.includes(modifier)) {
          if (hasSeenStaticModifier && this.match(106)) {
            return void 0;
          }
          if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
            return void 0;
          }
          if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
            return modifier;
          }
        }
        return void 0;
      }
      tsParseModifiers({
        allowedModifiers,
        disallowedModifiers,
        stopOnStartOfClassStaticBlock,
        errorTemplate = TSErrors.InvalidModifierOnTypeMember
      }, modified) {
        const enforceOrder = (loc, modifier, before, after) => {
          if (modifier === before && modified[after]) {
            this.raise(TSErrors.InvalidModifiersOrder, loc, {
              orderedModifiers: [before, after]
            });
          }
        };
        const incompatible = (loc, modifier, mod1, mod2) => {
          if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
            this.raise(TSErrors.IncompatibleModifiers, loc, {
              modifiers: [mod1, mod2]
            });
          }
        };
        for (; ; ) {
          const {
            startLoc
          } = this.state;
          const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock, modified.static);
          if (!modifier) break;
          if (tsIsAccessModifier(modifier)) {
            if (modified.accessibility) {
              this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {
                modifier
              });
            } else {
              enforceOrder(startLoc, modifier, modifier, "override");
              enforceOrder(startLoc, modifier, modifier, "static");
              enforceOrder(startLoc, modifier, modifier, "readonly");
              modified.accessibility = modifier;
            }
          } else if (tsIsVarianceAnnotations(modifier)) {
            if (modified[modifier]) {
              this.raise(TSErrors.DuplicateModifier, startLoc, {
                modifier
              });
            }
            modified[modifier] = true;
            enforceOrder(startLoc, modifier, "in", "out");
          } else {
            if (hasOwnProperty.call(modified, modifier)) {
              this.raise(TSErrors.DuplicateModifier, startLoc, {
                modifier
              });
            } else {
              enforceOrder(startLoc, modifier, "static", "readonly");
              enforceOrder(startLoc, modifier, "static", "override");
              enforceOrder(startLoc, modifier, "override", "readonly");
              enforceOrder(startLoc, modifier, "abstract", "override");
              incompatible(startLoc, modifier, "declare", "override");
              incompatible(startLoc, modifier, "static", "abstract");
            }
            modified[modifier] = true;
          }
          if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
            this.raise(errorTemplate, startLoc, {
              modifier
            });
          }
        }
      }
      tsIsListTerminator(kind) {
        switch (kind) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(8);
          case "HeritageClauseElement":
            return this.match(5);
          case "TupleElementTypes":
            return this.match(3);
          case "TypeParametersOrArguments":
            return this.match(48);
        }
      }
      tsParseList(kind, parseElement) {
        const result = [];
        while (!this.tsIsListTerminator(kind)) {
          result.push(parseElement());
        }
        return result;
      }
      tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
        return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
      }
      tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
        const result = [];
        let trailingCommaPos = -1;
        for (; ; ) {
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          trailingCommaPos = -1;
          const element = parseElement();
          if (element == null) {
            return void 0;
          }
          result.push(element);
          if (this.eat(12)) {
            trailingCommaPos = this.state.lastTokStartLoc.index;
            continue;
          }
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          if (expectSuccess) {
            this.expect(12);
          }
          return void 0;
        }
        if (refTrailingCommaPos) {
          refTrailingCommaPos.value = trailingCommaPos;
        }
        return result;
      }
      tsParseBracketedList(kind, parseElement, bracket3, skipFirstToken, refTrailingCommaPos) {
        if (!skipFirstToken) {
          if (bracket3) {
            this.expect(0);
          } else {
            this.expect(47);
          }
        }
        const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
        if (bracket3) {
          this.expect(3);
        } else {
          this.expect(48);
        }
        return result;
      }
      tsParseImportType() {
        const node = this.startNode();
        this.expect(83);
        this.expect(10);
        if (!this.match(134)) {
          this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);
          {
            node.argument = super.parseExprAtom();
          }
        } else {
          {
            node.argument = this.parseStringLiteral(this.state.value);
          }
        }
        if (this.eat(12)) {
          node.options = this.tsParseImportTypeOptions();
        } else {
          node.options = null;
        }
        this.expect(11);
        if (this.eat(16)) {
          node.qualifier = this.tsParseEntityName(1 | 2);
        }
        if (this.match(47)) {
          {
            node.typeParameters = this.tsParseTypeArguments();
          }
        }
        return this.finishNode(node, "TSImportType");
      }
      tsParseImportTypeOptions() {
        const node = this.startNode();
        this.expect(5);
        const withProperty = this.startNode();
        if (this.isContextual(76)) {
          withProperty.method = false;
          withProperty.key = this.parseIdentifier(true);
          withProperty.computed = false;
          withProperty.shorthand = false;
        } else {
          this.unexpected(null, 76);
        }
        this.expect(14);
        withProperty.value = this.tsParseImportTypeWithPropertyValue();
        node.properties = [this.finishObjectProperty(withProperty)];
        this.expect(8);
        return this.finishNode(node, "ObjectExpression");
      }
      tsParseImportTypeWithPropertyValue() {
        const node = this.startNode();
        const properties5 = [];
        this.expect(5);
        while (!this.match(8)) {
          const type = this.state.type;
          if (tokenIsIdentifier(type) || type === 134) {
            properties5.push(super.parsePropertyDefinition(null));
          } else {
            this.unexpected();
          }
          this.eat(12);
        }
        node.properties = properties5;
        this.next();
        return this.finishNode(node, "ObjectExpression");
      }
      tsParseEntityName(flags) {
        let entity;
        if (flags & 1 && this.match(78)) {
          if (flags & 2) {
            entity = this.parseIdentifier(true);
          } else {
            const node = this.startNode();
            this.next();
            entity = this.finishNode(node, "ThisExpression");
          }
        } else {
          entity = this.parseIdentifier(!!(flags & 1));
        }
        while (this.eat(16)) {
          const node = this.startNodeAtNode(entity);
          node.left = entity;
          node.right = this.parseIdentifier(!!(flags & 1));
          entity = this.finishNode(node, "TSQualifiedName");
        }
        return entity;
      }
      tsParseTypeReference() {
        const node = this.startNode();
        node.typeName = this.tsParseEntityName(1);
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
          {
            node.typeParameters = this.tsParseTypeArguments();
          }
        }
        return this.finishNode(node, "TSTypeReference");
      }
      tsParseThisTypePredicate(lhs) {
        this.next();
        const node = this.startNodeAtNode(lhs);
        node.parameterName = lhs;
        node.typeAnnotation = this.tsParseTypeAnnotation(false);
        node.asserts = false;
        return this.finishNode(node, "TSTypePredicate");
      }
      tsParseThisTypeNode() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "TSThisType");
      }
      tsParseTypeQuery() {
        const node = this.startNode();
        this.expect(87);
        if (this.match(83)) {
          node.exprName = this.tsParseImportType();
        } else {
          {
            node.exprName = this.tsParseEntityName(1 | 2);
          }
        }
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
          {
            node.typeParameters = this.tsParseTypeArguments();
          }
        }
        return this.finishNode(node, "TSTypeQuery");
      }
      tsParseTypeParameter(parseModifiers) {
        const node = this.startNode();
        parseModifiers(node);
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsEatThenParseType(81);
        node.default = this.tsEatThenParseType(29);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsTryParseTypeParameters(parseModifiers) {
        if (this.match(47)) {
          return this.tsParseTypeParameters(parseModifiers);
        }
      }
      tsParseTypeParameters(parseModifiers) {
        const node = this.startNode();
        if (this.match(47) || this.match(143)) {
          this.next();
        } else {
          this.unexpected();
        }
        const refTrailingCommaPos = {
          value: -1
        };
        node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
        if (node.params.length === 0) {
          this.raise(TSErrors.EmptyTypeParameters, node);
        }
        if (refTrailingCommaPos.value !== -1) {
          this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
        }
        return this.finishNode(node, "TSTypeParameterDeclaration");
      }
      tsFillSignature(returnToken, signature) {
        const returnTokenRequired = returnToken === 19;
        const paramsKey = "parameters";
        const returnTypeKey = "typeAnnotation";
        signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        this.expect(10);
        signature[paramsKey] = this.tsParseBindingListForSignature();
        if (returnTokenRequired) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
      }
      tsParseBindingListForSignature() {
        const list = super.parseBindingList(11, 41, 2);
        for (const pattern of list) {
          const {
            type
          } = pattern;
          if (type === "AssignmentPattern" || type === "TSParameterProperty") {
            this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {
              type
            });
          }
        }
        return list;
      }
      tsParseTypeMemberSemicolon() {
        if (!this.eat(12) && !this.isLineTerminator()) {
          this.expect(13);
        }
      }
      tsParseSignatureMember(kind, node) {
        this.tsFillSignature(14, node);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, kind);
      }
      tsIsUnambiguouslyIndexSignature() {
        this.next();
        if (tokenIsIdentifier(this.state.type)) {
          this.next();
          return this.match(14);
        }
        return false;
      }
      tsTryParseIndexSignature(node) {
        if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
          return;
        }
        this.expect(0);
        const id = this.parseIdentifier();
        id.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id);
        this.expect(3);
        node.parameters = [id];
        const type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, "TSIndexSignature");
      }
      tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(17)) node.optional = true;
        if (this.match(10) || this.match(47)) {
          if (readonly) {
            this.raise(TSErrors.ReadonlyForMethodSignature, node);
          }
          const method = node;
          if (method.kind && this.match(47)) {
            this.raise(TSErrors.AccessorCannotHaveTypeParameters, this.state.curPosition());
          }
          this.tsFillSignature(14, method);
          this.tsParseTypeMemberSemicolon();
          const paramsKey = "parameters";
          const returnTypeKey = "typeAnnotation";
          if (method.kind === "get") {
            if (method[paramsKey].length > 0) {
              this.raise(Errors.BadGetterArity, this.state.curPosition());
              if (this.isThisParam(method[paramsKey][0])) {
                this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
              }
            }
          } else if (method.kind === "set") {
            if (method[paramsKey].length !== 1) {
              this.raise(Errors.BadSetterArity, this.state.curPosition());
            } else {
              const firstParameter = method[paramsKey][0];
              if (this.isThisParam(firstParameter)) {
                this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
              }
              if (firstParameter.type === "Identifier" && firstParameter.optional) {
                this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter, this.state.curPosition());
              }
              if (firstParameter.type === "RestElement") {
                this.raise(TSErrors.SetAccessorCannotHaveRestParameter, this.state.curPosition());
              }
            }
            if (method[returnTypeKey]) {
              this.raise(TSErrors.SetAccessorCannotHaveReturnType, method[returnTypeKey]);
            }
          } else {
            method.kind = "method";
          }
          return this.finishNode(method, "TSMethodSignature");
        } else {
          const property4 = node;
          if (readonly) property4.readonly = true;
          const type = this.tsTryParseTypeAnnotation();
          if (type) property4.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(property4, "TSPropertySignature");
        }
      }
      tsParseTypeMember() {
        const node = this.startNode();
        if (this.match(10) || this.match(47)) {
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
        }
        if (this.match(77)) {
          const id = this.startNode();
          this.next();
          if (this.match(10) || this.match(47)) {
            return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
          } else {
            node.key = this.createIdentifier(id, "new");
            return this.tsParsePropertyOrMethodSignature(node, false);
          }
        }
        this.tsParseModifiers({
          allowedModifiers: ["readonly"],
          disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
        }, node);
        const idx = this.tsTryParseIndexSignature(node);
        if (idx) {
          return idx;
        }
        super.parsePropertyName(node);
        if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
          node.kind = node.key.name;
          super.parsePropertyName(node);
          if (!this.match(10) && !this.match(47)) {
            this.unexpected(null, 10);
          }
        }
        return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
      }
      tsParseTypeLiteral() {
        const node = this.startNode();
        node.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node, "TSTypeLiteral");
      }
      tsParseObjectTypeMembers() {
        this.expect(5);
        const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        this.expect(8);
        return members;
      }
      tsIsStartOfMappedType() {
        this.next();
        if (this.eat(53)) {
          return this.isContextual(122);
        }
        if (this.isContextual(122)) {
          this.next();
        }
        if (!this.match(0)) {
          return false;
        }
        this.next();
        if (!this.tsIsIdentifier()) {
          return false;
        }
        this.next();
        return this.match(58);
      }
      tsParseMappedType() {
        const node = this.startNode();
        this.expect(5);
        if (this.match(53)) {
          node.readonly = this.state.value;
          this.next();
          this.expectContextual(122);
        } else if (this.eatContextual(122)) {
          node.readonly = true;
        }
        this.expect(0);
        {
          const typeParameter = this.startNode();
          typeParameter.name = this.tsParseTypeParameterName();
          typeParameter.constraint = this.tsExpectThenParseType(58);
          node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        }
        node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
        this.expect(3);
        if (this.match(53)) {
          node.optional = this.state.value;
          this.next();
          this.expect(17);
        } else if (this.eat(17)) {
          node.optional = true;
        }
        node.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(8);
        return this.finishNode(node, "TSMappedType");
      }
      tsParseTupleType() {
        const node = this.startNode();
        node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
        let seenOptionalElement = false;
        node.elementTypes.forEach((elementNode) => {
          const {
            type
          } = elementNode;
          if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
            this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);
          }
          seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
        });
        return this.finishNode(node, "TSTupleType");
      }
      tsParseTupleElementType() {
        const restStartLoc = this.state.startLoc;
        const rest = this.eat(21);
        const {
          startLoc
        } = this.state;
        let labeled;
        let label;
        let optional;
        let type;
        const isWord = tokenIsKeywordOrIdentifier(this.state.type);
        const chAfterWord = isWord ? this.lookaheadCharCode() : null;
        if (chAfterWord === 58) {
          labeled = true;
          optional = false;
          label = this.parseIdentifier(true);
          this.expect(14);
          type = this.tsParseType();
        } else if (chAfterWord === 63) {
          optional = true;
          const wordName = this.state.value;
          const typeOrLabel = this.tsParseNonArrayType();
          if (this.lookaheadCharCode() === 58) {
            labeled = true;
            label = this.createIdentifier(this.startNodeAt(startLoc), wordName);
            this.expect(17);
            this.expect(14);
            type = this.tsParseType();
          } else {
            labeled = false;
            type = typeOrLabel;
            this.expect(17);
          }
        } else {
          type = this.tsParseType();
          optional = this.eat(17);
          labeled = this.eat(14);
        }
        if (labeled) {
          let labeledNode;
          if (label) {
            labeledNode = this.startNodeAt(startLoc);
            labeledNode.optional = optional;
            labeledNode.label = label;
            labeledNode.elementType = type;
            if (this.eat(17)) {
              labeledNode.optional = true;
              this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);
            }
          } else {
            labeledNode = this.startNodeAt(startLoc);
            labeledNode.optional = optional;
            this.raise(TSErrors.InvalidTupleMemberLabel, type);
            labeledNode.label = type;
            labeledNode.elementType = this.tsParseType();
          }
          type = this.finishNode(labeledNode, "TSNamedTupleMember");
        } else if (optional) {
          const optionalTypeNode = this.startNodeAt(startLoc);
          optionalTypeNode.typeAnnotation = type;
          type = this.finishNode(optionalTypeNode, "TSOptionalType");
        }
        if (rest) {
          const restNode = this.startNodeAt(restStartLoc);
          restNode.typeAnnotation = type;
          type = this.finishNode(restNode, "TSRestType");
        }
        return type;
      }
      tsParseParenthesizedType() {
        const node = this.startNode();
        this.expect(10);
        node.typeAnnotation = this.tsParseType();
        this.expect(11);
        return this.finishNode(node, "TSParenthesizedType");
      }
      tsParseFunctionOrConstructorType(type, abstract) {
        const node = this.startNode();
        if (type === "TSConstructorType") {
          node.abstract = !!abstract;
          if (abstract) this.next();
          this.next();
        }
        this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));
        return this.finishNode(node, type);
      }
      tsParseLiteralTypeNode() {
        const node = this.startNode();
        switch (this.state.type) {
          case 135:
          case 136:
          case 134:
          case 85:
          case 86:
            node.literal = super.parseExprAtom();
            break;
          default:
            this.unexpected();
        }
        return this.finishNode(node, "TSLiteralType");
      }
      tsParseTemplateLiteralType() {
        {
          const node = this.startNode();
          node.literal = super.parseTemplate(false);
          return this.finishNode(node, "TSLiteralType");
        }
      }
      parseTemplateSubstitution() {
        if (this.state.inType) return this.tsParseType();
        return super.parseTemplateSubstitution();
      }
      tsParseThisTypeOrThisTypePredicate() {
        const thisKeyword = this.tsParseThisTypeNode();
        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
          return this.tsParseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      }
      tsParseNonArrayType() {
        switch (this.state.type) {
          case 134:
          case 135:
          case 136:
          case 85:
          case 86:
            return this.tsParseLiteralTypeNode();
          case 53:
            if (this.state.value === "-") {
              const node = this.startNode();
              const nextToken = this.lookahead();
              if (nextToken.type !== 135 && nextToken.type !== 136) {
                this.unexpected();
              }
              node.literal = this.parseMaybeUnary();
              return this.finishNode(node, "TSLiteralType");
            }
            break;
          case 78:
            return this.tsParseThisTypeOrThisTypePredicate();
          case 87:
            return this.tsParseTypeQuery();
          case 83:
            return this.tsParseImportType();
          case 5:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
          case 0:
            return this.tsParseTupleType();
          case 10:
            return this.tsParseParenthesizedType();
          case 25:
          case 24:
            return this.tsParseTemplateLiteralType();
          default: {
            const {
              type
            } = this.state;
            if (tokenIsIdentifier(type) || type === 88 || type === 84) {
              const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
              if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                const node = this.startNode();
                this.next();
                return this.finishNode(node, nodeType);
              }
              return this.tsParseTypeReference();
            }
          }
        }
        this.unexpected();
      }
      tsParseArrayTypeOrHigher() {
        const {
          startLoc
        } = this.state;
        let type = this.tsParseNonArrayType();
        while (!this.hasPrecedingLineBreak() && this.eat(0)) {
          if (this.match(3)) {
            const node = this.startNodeAt(startLoc);
            node.elementType = type;
            this.expect(3);
            type = this.finishNode(node, "TSArrayType");
          } else {
            const node = this.startNodeAt(startLoc);
            node.objectType = type;
            node.indexType = this.tsParseType();
            this.expect(3);
            type = this.finishNode(node, "TSIndexedAccessType");
          }
        }
        return type;
      }
      tsParseTypeOperator() {
        const node = this.startNode();
        const operator = this.state.value;
        this.next();
        node.operator = operator;
        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
        if (operator === "readonly") {
          this.tsCheckTypeAnnotationForReadOnly(node);
        }
        return this.finishNode(node, "TSTypeOperator");
      }
      tsCheckTypeAnnotationForReadOnly(node) {
        switch (node.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;
          default:
            this.raise(TSErrors.UnexpectedReadonly, node);
        }
      }
      tsParseInferType() {
        const node = this.startNode();
        this.expectContextual(115);
        const typeParameter = this.startNode();
        typeParameter.name = this.tsParseTypeParameterName();
        typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
        node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        return this.finishNode(node, "TSInferType");
      }
      tsParseConstraintForInferType() {
        if (this.eat(81)) {
          const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
          if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
            return constraint;
          }
        }
      }
      tsParseTypeOperatorOrHigher() {
        const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
        return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
      }
      tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        const node = this.startNode();
        const hasLeadingOperator = this.eat(operator);
        const types2 = [];
        do {
          types2.push(parseConstituentType());
        } while (this.eat(operator));
        if (types2.length === 1 && !hasLeadingOperator) {
          return types2[0];
        }
        node.types = types2;
        return this.finishNode(node, kind);
      }
      tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
      }
      tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
      }
      tsIsStartOfFunctionType() {
        if (this.match(47)) {
          return true;
        }
        return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      }
      tsSkipParameterStart() {
        if (tokenIsIdentifier(this.state.type) || this.match(78)) {
          this.next();
          return true;
        }
        if (this.match(5)) {
          const {
            errors
          } = this.state;
          const previousErrorCount = errors.length;
          try {
            this.parseObjectLike(8, true);
            return errors.length === previousErrorCount;
          } catch (_unused) {
            return false;
          }
        }
        if (this.match(0)) {
          this.next();
          const {
            errors
          } = this.state;
          const previousErrorCount = errors.length;
          try {
            super.parseBindingList(3, 93, 1);
            return errors.length === previousErrorCount;
          } catch (_unused2) {
            return false;
          }
        }
        return false;
      }
      tsIsUnambiguouslyStartOfFunctionType() {
        this.next();
        if (this.match(11) || this.match(21)) {
          return true;
        }
        if (this.tsSkipParameterStart()) {
          if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
            return true;
          }
          if (this.match(11)) {
            this.next();
            if (this.match(19)) {
              return true;
            }
          }
        }
        return false;
      }
      tsParseTypeOrTypePredicateAnnotation(returnToken) {
        return this.tsInType(() => {
          const t = this.startNode();
          this.expect(returnToken);
          const node = this.startNode();
          const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
          if (asserts && this.match(78)) {
            let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
            if (thisTypePredicate.type === "TSThisType") {
              node.parameterName = thisTypePredicate;
              node.asserts = true;
              node.typeAnnotation = null;
              thisTypePredicate = this.finishNode(node, "TSTypePredicate");
            } else {
              this.resetStartLocationFromNode(thisTypePredicate, node);
              thisTypePredicate.asserts = true;
            }
            t.typeAnnotation = thisTypePredicate;
            return this.finishNode(t, "TSTypeAnnotation");
          }
          const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
          if (!typePredicateVariable) {
            if (!asserts) {
              return this.tsParseTypeAnnotation(false, t);
            }
            node.parameterName = this.parseIdentifier();
            node.asserts = asserts;
            node.typeAnnotation = null;
            t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
            return this.finishNode(t, "TSTypeAnnotation");
          }
          const type = this.tsParseTypeAnnotation(false);
          node.parameterName = typePredicateVariable;
          node.typeAnnotation = type;
          node.asserts = asserts;
          t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
          return this.finishNode(t, "TSTypeAnnotation");
        });
      }
      tsTryParseTypeOrTypePredicateAnnotation() {
        if (this.match(14)) {
          return this.tsParseTypeOrTypePredicateAnnotation(14);
        }
      }
      tsTryParseTypeAnnotation() {
        if (this.match(14)) {
          return this.tsParseTypeAnnotation();
        }
      }
      tsTryParseType() {
        return this.tsEatThenParseType(14);
      }
      tsParseTypePredicatePrefix() {
        const id = this.parseIdentifier();
        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
          this.next();
          return id;
        }
      }
      tsParseTypePredicateAsserts() {
        if (this.state.type !== 109) {
          return false;
        }
        const containsEsc = this.state.containsEsc;
        this.next();
        if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
          return false;
        }
        if (containsEsc) {
          this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
            reservedWord: "asserts"
          });
        }
        return true;
      }
      tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
        this.tsInType(() => {
          if (eatColon) this.expect(14);
          t.typeAnnotation = this.tsParseType();
        });
        return this.finishNode(t, "TSTypeAnnotation");
      }
      tsParseType() {
        assert(this.state.inType);
        const type = this.tsParseNonConditionalType();
        if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
          return type;
        }
        const node = this.startNodeAtNode(type);
        node.checkType = type;
        node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
        this.expect(17);
        node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        this.expect(14);
        node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        return this.finishNode(node, "TSConditionalType");
      }
      isAbstractConstructorSignature() {
        return this.isContextual(124) && this.isLookaheadContextual("new");
      }
      tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
          return this.tsParseFunctionOrConstructorType("TSFunctionType");
        }
        if (this.match(77)) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType");
        } else if (this.isAbstractConstructorSignature()) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
        }
        return this.tsParseUnionTypeOrHigher();
      }
      tsParseTypeAssertion() {
        if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);
        }
        const node = this.startNode();
        node.typeAnnotation = this.tsInType(() => {
          this.next();
          return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
        });
        this.expect(48);
        node.expression = this.parseMaybeUnary();
        return this.finishNode(node, "TSTypeAssertion");
      }
      tsParseHeritageClause(token) {
        const originalStartLoc = this.state.startLoc;
        const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
          {
            const node = this.startNode();
            node.expression = this.tsParseEntityName(1 | 2);
            if (this.match(47)) {
              node.typeParameters = this.tsParseTypeArguments();
            }
            return this.finishNode(node, "TSExpressionWithTypeArguments");
          }
        });
        if (!delimitedList.length) {
          this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {
            token
          });
        }
        return delimitedList;
      }
      tsParseInterfaceDeclaration(node, properties5 = {}) {
        if (this.hasFollowingLineBreak()) return null;
        this.expectContextual(129);
        if (properties5.declare) node.declare = true;
        if (tokenIsIdentifier(this.state.type)) {
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, 130);
        } else {
          node.id = null;
          this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);
        }
        node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        if (this.eat(81)) {
          node.extends = this.tsParseHeritageClause("extends");
        }
        const body = this.startNode();
        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node.body = this.finishNode(body, "TSInterfaceBody");
        return this.finishNode(node, "TSInterfaceDeclaration");
      }
      tsParseTypeAliasDeclaration(node) {
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, 2);
        node.typeAnnotation = this.tsInType(() => {
          node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
          this.expect(29);
          if (this.isContextual(114) && this.lookaheadCharCode() !== 46) {
            const node2 = this.startNode();
            this.next();
            return this.finishNode(node2, "TSIntrinsicKeyword");
          }
          return this.tsParseType();
        });
        this.semicolon();
        return this.finishNode(node, "TSTypeAliasDeclaration");
      }
      tsInTopLevelContext(cb) {
        if (this.curContext() !== types.brace) {
          const oldContext = this.state.context;
          this.state.context = [oldContext[0]];
          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        } else {
          return cb();
        }
      }
      tsInType(cb) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        try {
          return cb();
        } finally {
          this.state.inType = oldInType;
        }
      }
      tsInDisallowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = true;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsInAllowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = false;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsEatThenParseType(token) {
        if (this.match(token)) {
          return this.tsNextThenParseType();
        }
      }
      tsExpectThenParseType(token) {
        return this.tsInType(() => {
          this.expect(token);
          return this.tsParseType();
        });
      }
      tsNextThenParseType() {
        return this.tsInType(() => {
          this.next();
          return this.tsParseType();
        });
      }
      tsParseEnumMember() {
        const node = this.startNode();
        node.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
        if (this.eat(29)) {
          node.initializer = super.parseMaybeAssignAllowIn();
        }
        return this.finishNode(node, "TSEnumMember");
      }
      tsParseEnumDeclaration(node, properties5 = {}) {
        if (properties5.const) node.const = true;
        if (properties5.declare) node.declare = true;
        this.expectContextual(126);
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, node.const ? 8971 : 8459);
        {
          this.expect(5);
          node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
          this.expect(8);
        }
        return this.finishNode(node, "TSEnumDeclaration");
      }
      tsParseEnumBody() {
        const node = this.startNode();
        this.expect(5);
        node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(8);
        return this.finishNode(node, "TSEnumBody");
      }
      tsParseModuleBlock() {
        const node = this.startNode();
        this.scope.enter(0);
        this.expect(5);
        super.parseBlockOrModuleBlockBody(node.body = [], void 0, true, 8);
        this.scope.exit();
        return this.finishNode(node, "TSModuleBlock");
      }
      tsParseModuleOrNamespaceDeclaration(node, nested = false) {
        node.id = this.parseIdentifier();
        if (!nested) {
          this.checkIdentifier(node.id, 1024);
        }
        if (this.eat(16)) {
          const inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, true);
          node.body = inner;
        } else {
          this.scope.enter(1024);
          this.prodParam.enter(0);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseAmbientExternalModuleDeclaration(node) {
        if (this.isContextual(112)) {
          node.kind = "global";
          {
            node.global = true;
          }
          node.id = this.parseIdentifier();
        } else if (this.match(134)) {
          node.kind = "module";
          node.id = super.parseStringLiteral(this.state.value);
        } else {
          this.unexpected();
        }
        if (this.match(5)) {
          this.scope.enter(1024);
          this.prodParam.enter(0);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {
        {
          node.isExport = isExport || false;
        }
        node.id = maybeDefaultIdentifier || this.parseIdentifier();
        this.checkIdentifier(node.id, 4096);
        this.expect(29);
        const moduleReference = this.tsParseModuleReference();
        if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
          this.raise(TSErrors.ImportAliasHasImportType, moduleReference);
        }
        node.moduleReference = moduleReference;
        this.semicolon();
        return this.finishNode(node, "TSImportEqualsDeclaration");
      }
      tsIsExternalModuleReference() {
        return this.isContextual(119) && this.lookaheadCharCode() === 40;
      }
      tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
      }
      tsParseExternalModuleReference() {
        const node = this.startNode();
        this.expectContextual(119);
        this.expect(10);
        if (!this.match(134)) {
          this.unexpected();
        }
        node.expression = super.parseExprAtom();
        this.expect(11);
        this.sawUnambiguousESM = true;
        return this.finishNode(node, "TSExternalModuleReference");
      }
      tsLookAhead(f) {
        const state = this.state.clone();
        const res = f();
        this.state = state;
        return res;
      }
      tsTryParseAndCatch(f) {
        const result = this.tryParse((abort) => f() || abort());
        if (result.aborted || !result.node) return;
        if (result.error) this.state = result.failState;
        return result.node;
      }
      tsTryParse(f) {
        const state = this.state.clone();
        const result = f();
        if (result !== void 0 && result !== false) {
          return result;
        }
        this.state = state;
      }
      tsTryParseDeclare(node) {
        if (this.isLineTerminator()) {
          return;
        }
        const startType = this.state.type;
        return this.tsInAmbientContext(() => {
          switch (startType) {
            case 68:
              node.declare = true;
              return super.parseFunctionStatement(node, false, false);
            case 80:
              node.declare = true;
              return this.parseClass(node, true, false);
            case 126:
              return this.tsParseEnumDeclaration(node, {
                declare: true
              });
            case 112:
              return this.tsParseAmbientExternalModuleDeclaration(node);
            case 100:
              if (this.state.containsEsc) {
                return;
              }
            case 75:
            case 74:
              if (!this.match(75) || !this.isLookaheadContextual("enum")) {
                node.declare = true;
                return this.parseVarStatement(node, this.state.value, true);
              }
              this.expect(75);
              return this.tsParseEnumDeclaration(node, {
                const: true,
                declare: true
              });
            case 107:
              if (this.hasPlugin("explicitResourceManagement") && this.isUsing()) {
                this.raise(TSErrors.InvalidModifierOnUsingDeclaration, this.state.startLoc, "declare");
                node.declare = true;
                return this.parseVarStatement(node, "using", true);
              }
              break;
            case 96:
              if (this.hasPlugin("explicitResourceManagement") && this.isAwaitUsing()) {
                this.raise(TSErrors.InvalidModifierOnAwaitUsingDeclaration, this.state.startLoc, "declare");
                node.declare = true;
                this.next();
                return this.parseVarStatement(node, "await using", true);
              }
              break;
            case 129: {
              const result = this.tsParseInterfaceDeclaration(node, {
                declare: true
              });
              if (result) return result;
            }
            default:
              if (tokenIsIdentifier(startType)) {
                return this.tsParseDeclaration(node, this.state.value, true, null);
              }
          }
        });
      }
      tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
      }
      tsParseExpressionStatement(node, expr, decorators) {
        switch (expr.name) {
          case "declare": {
            const declaration = this.tsTryParseDeclare(node);
            if (declaration) {
              declaration.declare = true;
            }
            return declaration;
          }
          case "global":
            if (this.match(5)) {
              this.scope.enter(1024);
              this.prodParam.enter(0);
              const mod = node;
              mod.kind = "global";
              {
                node.global = true;
              }
              mod.id = expr;
              mod.body = this.tsParseModuleBlock();
              this.scope.exit();
              this.prodParam.exit();
              return this.finishNode(mod, "TSModuleDeclaration");
            }
            break;
          default:
            return this.tsParseDeclaration(node, expr.name, false, decorators);
        }
      }
      tsParseDeclaration(node, value, next, decorators) {
        switch (value) {
          case "abstract":
            if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
              return this.tsParseAbstractDeclaration(node, decorators);
            }
            break;
          case "module":
            if (this.tsCheckLineTerminator(next)) {
              if (this.match(134)) {
                return this.tsParseAmbientExternalModuleDeclaration(node);
              } else if (tokenIsIdentifier(this.state.type)) {
                node.kind = "module";
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }
            }
            break;
          case "namespace":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              node.kind = "namespace";
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }
            break;
          case "type":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              return this.tsParseTypeAliasDeclaration(node);
            }
            break;
        }
      }
      tsCheckLineTerminator(next) {
        if (next) {
          if (this.hasFollowingLineBreak()) return false;
          this.next();
          return true;
        }
        return !this.isLineTerminator();
      }
      tsTryParseGenericAsyncArrowFunction(startLoc) {
        if (!this.match(47)) return;
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = true;
        const res = this.tsTryParseAndCatch(() => {
          const node = this.startNodeAt(startLoc);
          node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          super.parseFunctionParams(node);
          node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
          this.expect(19);
          return node;
        });
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        if (!res) return;
        return super.parseArrowExpression(res, null, true);
      }
      tsParseTypeArgumentsInExpression() {
        if (this.reScan_lt() !== 47) return;
        return this.tsParseTypeArguments();
      }
      tsParseTypeArguments() {
        const node = this.startNode();
        node.params = this.tsInType(() => this.tsInTopLevelContext(() => {
          this.expect(47);
          return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
        }));
        if (node.params.length === 0) {
          this.raise(TSErrors.EmptyTypeArguments, node);
        } else if (!this.state.inType && this.curContext() === types.brace) {
          this.reScan_lt_gt();
        }
        this.expect(48);
        return this.finishNode(node, "TSTypeParameterInstantiation");
      }
      tsIsDeclarationStart() {
        return tokenIsTSDeclarationStart(this.state.type);
      }
      isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart()) return false;
        return super.isExportDefaultSpecifier();
      }
      parseBindingElement(flags, decorators) {
        const startLoc = decorators.length ? decorators[0].loc.start : this.state.startLoc;
        const modified = {};
        this.tsParseModifiers({
          allowedModifiers: ["public", "private", "protected", "override", "readonly"]
        }, modified);
        const accessibility2 = modified.accessibility;
        const override = modified.override;
        const readonly = modified.readonly;
        if (!(flags & 4) && (accessibility2 || readonly || override)) {
          this.raise(TSErrors.UnexpectedParameterModifier, startLoc);
        }
        const left = this.parseMaybeDefault();
        if (flags & 2) {
          this.parseFunctionParamType(left);
        }
        const elt = this.parseMaybeDefault(left.loc.start, left);
        if (accessibility2 || readonly || override) {
          const pp = this.startNodeAt(startLoc);
          if (decorators.length) {
            pp.decorators = decorators;
          }
          if (accessibility2) pp.accessibility = accessibility2;
          if (readonly) pp.readonly = readonly;
          if (override) pp.override = override;
          if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
            this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);
          }
          pp.parameter = elt;
          return this.finishNode(pp, "TSParameterProperty");
        }
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      }
      isSimpleParameter(node) {
        return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
      }
      tsDisallowOptionalPattern(node) {
        for (const param of node.params) {
          if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) {
            this.raise(TSErrors.PatternIsOptional, param);
          }
        }
      }
      setArrowFunctionParameters(node, params, trailingCommaLoc) {
        super.setArrowFunctionParameters(node, params, trailingCommaLoc);
        this.tsDisallowOptionalPattern(node);
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        if (this.match(14)) {
          node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
        }
        const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
        if (bodilessType && !this.match(5) && this.isLineTerminator()) {
          return this.finishNode(node, bodilessType);
        }
        if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
          this.raise(TSErrors.DeclareFunctionHasImplementation, node);
          if (node.declare) {
            return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
          }
        }
        this.tsDisallowOptionalPattern(node);
        return super.parseFunctionBodyAndFinish(node, type, isMethod);
      }
      registerFunctionStatementId(node) {
        if (!node.body && node.id) {
          this.checkIdentifier(node.id, 1024);
        } else {
          super.registerFunctionStatementId(node);
        }
      }
      tsCheckForInvalidTypeCasts(items) {
        items.forEach((node) => {
          if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
            this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);
          }
        });
      }
      toReferencedList(exprList, isInParens) {
        this.tsCheckForInvalidTypeCasts(exprList);
        return exprList;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
        if (node.type === "ArrayExpression") {
          this.tsCheckForInvalidTypeCasts(node.elements);
        }
        return node;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        if (!this.hasPrecedingLineBreak() && this.match(35)) {
          this.state.canStartJSXElement = false;
          this.next();
          const nonNullExpression = this.startNodeAt(startLoc);
          nonNullExpression.expression = base;
          return this.finishNode(nonNullExpression, "TSNonNullExpression");
        }
        let isOptionalCall = false;
        if (this.match(18) && this.lookaheadCharCode() === 60) {
          if (noCalls) {
            state.stop = true;
            return base;
          }
          state.optionalChainMember = isOptionalCall = true;
          this.next();
        }
        if (this.match(47) || this.match(51)) {
          let missingParenErrorLoc;
          const result = this.tsTryParseAndCatch(() => {
            if (!noCalls && this.atPossibleAsyncArrow(base)) {
              const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
              if (asyncArrowFn) {
                return asyncArrowFn;
              }
            }
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            if (!typeArguments) return;
            if (isOptionalCall && !this.match(10)) {
              missingParenErrorLoc = this.state.curPosition();
              return;
            }
            if (tokenIsTemplate(this.state.type)) {
              const result2 = super.parseTaggedTemplateExpression(base, startLoc, state);
              {
                result2.typeParameters = typeArguments;
              }
              return result2;
            }
            if (!noCalls && this.eat(10)) {
              const node2 = this.startNodeAt(startLoc);
              node2.callee = base;
              node2.arguments = this.parseCallExpressionArguments(11);
              this.tsCheckForInvalidTypeCasts(node2.arguments);
              {
                node2.typeParameters = typeArguments;
              }
              if (state.optionalChainMember) {
                node2.optional = isOptionalCall;
              }
              return this.finishCallExpression(node2, state.optionalChainMember);
            }
            const tokenType2 = this.state.type;
            if (tokenType2 === 48 || tokenType2 === 52 || tokenType2 !== 10 && tokenCanStartExpression(tokenType2) && !this.hasPrecedingLineBreak()) {
              return;
            }
            const node = this.startNodeAt(startLoc);
            node.expression = base;
            {
              node.typeParameters = typeArguments;
            }
            return this.finishNode(node, "TSInstantiationExpression");
          });
          if (missingParenErrorLoc) {
            this.unexpected(missingParenErrorLoc, 10);
          }
          if (result) {
            if (result.type === "TSInstantiationExpression") {
              if (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) {
                this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);
              }
              if (!this.match(16) && !this.match(18)) {
                result.expression = super.stopParseSubscript(base, state);
              }
            }
            return result;
          }
        }
        return super.parseSubscript(base, startLoc, noCalls, state);
      }
      parseNewCallee(node) {
        var _callee$extra;
        super.parseNewCallee(node);
        const {
          callee
        } = node;
        if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
          {
            node.typeParameters = callee.typeParameters;
          }
          node.callee = callee.expression;
        }
      }
      parseExprOp(left, leftStartLoc, minPrec) {
        let isSatisfies;
        if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
          const node = this.startNodeAt(leftStartLoc);
          node.expression = left;
          node.typeAnnotation = this.tsInType(() => {
            this.next();
            if (this.match(75)) {
              if (isSatisfies) {
                this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {
                  keyword: "const"
                });
              }
              return this.tsParseTypeReference();
            }
            return this.tsParseType();
          });
          this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
          this.reScan_lt_gt();
          return this.parseExprOp(node, leftStartLoc, minPrec);
        }
        return super.parseExprOp(left, leftStartLoc, minPrec);
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (!this.state.isAmbientContext) {
          super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
        }
      }
      checkImportReflection(node) {
        super.checkImportReflection(node);
        if (node.module && node.importKind !== "value") {
          this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
        }
      }
      checkDuplicateExports() {
      }
      isPotentialImportPhase(isExport) {
        if (super.isPotentialImportPhase(isExport)) return true;
        if (this.isContextual(130)) {
          const ch = this.lookaheadCharCode();
          return isExport ? ch === 123 || ch === 42 : ch !== 61;
        }
        return !isExport && this.isContextual(87);
      }
      applyImportPhase(node, isExport, phase, loc) {
        super.applyImportPhase(node, isExport, phase, loc);
        if (isExport) {
          node.exportKind = phase === "type" ? "type" : "value";
        } else {
          node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
        }
      }
      parseImport(node) {
        if (this.match(134)) {
          node.importKind = "value";
          return super.parseImport(node);
        }
        let importNode;
        if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
          node.importKind = "value";
          return this.tsParseImportEqualsDeclaration(node);
        } else if (this.isContextual(130)) {
          const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
          if (this.lookaheadCharCode() === 61) {
            return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
          } else {
            importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);
          }
        } else {
          importNode = super.parseImport(node);
        }
        if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
          this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);
        }
        return importNode;
      }
      parseExport(node, decorators) {
        if (this.match(83)) {
          const nodeImportEquals = node;
          this.next();
          let maybeDefaultIdentifier = null;
          if (this.isContextual(130) && this.isPotentialImportPhase(false)) {
            maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, false);
          } else {
            nodeImportEquals.importKind = "value";
          }
          const declaration = this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, true);
          {
            return declaration;
          }
        } else if (this.eat(29)) {
          const assign = node;
          assign.expression = super.parseExpression();
          this.semicolon();
          this.sawUnambiguousESM = true;
          return this.finishNode(assign, "TSExportAssignment");
        } else if (this.eatContextual(93)) {
          const decl = node;
          this.expectContextual(128);
          decl.id = this.parseIdentifier();
          this.semicolon();
          return this.finishNode(decl, "TSNamespaceExportDeclaration");
        } else {
          return super.parseExport(node, decorators);
        }
      }
      isAbstractClass() {
        return this.isContextual(124) && this.isLookaheadContextual("class");
      }
      parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          const cls = this.startNode();
          this.next();
          cls.abstract = true;
          return this.parseClass(cls, true, true);
        }
        if (this.match(129)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return super.parseExportDefaultExpression();
      }
      parseVarStatement(node, kind, allowMissingInitializer = false) {
        const {
          isAmbientContext
        } = this.state;
        const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
        if (!isAmbientContext) return declaration;
        if (!node.declare && (kind === "using" || kind === "await using")) {
          this.raiseOverwrite(TSErrors.UsingDeclarationInAmbientContext, node, kind);
          return declaration;
        }
        for (const {
          id,
          init
        } of declaration.declarations) {
          if (!init) continue;
          if (kind === "var" || kind === "let" || !!id.typeAnnotation) {
            this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);
          } else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) {
            this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);
          }
        }
        return declaration;
      }
      parseStatementContent(flags, decorators) {
        if (this.match(75) && this.isLookaheadContextual("enum")) {
          const node = this.startNode();
          this.expect(75);
          return this.tsParseEnumDeclaration(node, {
            const: true
          });
        }
        if (this.isContextual(126)) {
          return this.tsParseEnumDeclaration(this.startNode());
        }
        if (this.isContextual(129)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return super.parseStatementContent(flags, decorators);
      }
      parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      }
      tsHasSomeModifiers(member, modifiers2) {
        return modifiers2.some((modifier) => {
          if (tsIsAccessModifier(modifier)) {
            return member.accessibility === modifier;
          }
          return !!member[modifier];
        });
      }
      tsIsStartOfStaticBlocks() {
        return this.isContextual(106) && this.lookaheadCharCode() === 123;
      }
      parseClassMember(classBody, member, state) {
        const modifiers2 = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
        this.tsParseModifiers({
          allowedModifiers: modifiers2,
          disallowedModifiers: ["in", "out"],
          stopOnStartOfClassStaticBlock: true,
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        }, member);
        const callParseClassMemberWithIsStatic = () => {
          if (this.tsIsStartOfStaticBlocks()) {
            this.next();
            this.next();
            if (this.tsHasSomeModifiers(member, modifiers2)) {
              this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());
            }
            super.parseClassStaticBlock(classBody, member);
          } else {
            this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
          }
        };
        if (member.declare) {
          this.tsInAmbientContext(callParseClassMemberWithIsStatic);
        } else {
          callParseClassMemberWithIsStatic();
        }
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const idx = this.tsTryParseIndexSignature(member);
        if (idx) {
          classBody.body.push(idx);
          if (member.abstract) {
            this.raise(TSErrors.IndexSignatureHasAbstract, member);
          }
          if (member.accessibility) {
            this.raise(TSErrors.IndexSignatureHasAccessibility, member, {
              modifier: member.accessibility
            });
          }
          if (member.declare) {
            this.raise(TSErrors.IndexSignatureHasDeclare, member);
          }
          if (member.override) {
            this.raise(TSErrors.IndexSignatureHasOverride, member);
          }
          return;
        }
        if (!this.state.inAbstractClass && member.abstract) {
          this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);
        }
        if (member.override) {
          if (!state.hadSuperClass) {
            this.raise(TSErrors.OverrideNotInSubClass, member);
          }
        }
        super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parsePostMemberNameModifiers(methodOrProp) {
        const optional = this.eat(17);
        if (optional) methodOrProp.optional = true;
        if (methodOrProp.readonly && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);
        }
        if (methodOrProp.declare && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);
        }
      }
      parseExpressionStatement(node, expr, decorators) {
        const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr, decorators) : void 0;
        return decl || super.parseExpressionStatement(node, expr, decorators);
      }
      shouldParseExportDeclaration() {
        if (this.tsIsDeclarationStart()) return true;
        return super.shouldParseExportDeclaration();
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.match(17)) return expr;
        if (this.state.maybeInArrowParameters) {
          const nextCh = this.lookaheadCharCode();
          if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
            this.setOptionalParametersError(refExpressionErrors);
            return expr;
          }
        }
        return super.parseConditional(expr, startLoc, refExpressionErrors);
      }
      parseParenItem(node, startLoc) {
        const newNode = super.parseParenItem(node, startLoc);
        if (this.eat(17)) {
          newNode.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(14)) {
          const typeCastNode = this.startNodeAt(startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TSTypeCastExpression");
        }
        return node;
      }
      parseExportDeclaration(node) {
        if (!this.state.isAmbientContext && this.isContextual(125)) {
          return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
        }
        const startLoc = this.state.startLoc;
        const isDeclare = this.eatContextual(125);
        if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {
          throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
        }
        const isIdentifier = tokenIsIdentifier(this.state.type);
        const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
        if (!declaration) return null;
        if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
          node.exportKind = "type";
        }
        if (isDeclare && declaration.type !== "TSImportEqualsDeclaration") {
          this.resetStartLocation(declaration, startLoc);
          declaration.declare = true;
        }
        return declaration;
      }
      parseClassId(node, isStatement, optionalId, bindingType) {
        if ((!isStatement || optionalId) && this.isContextual(113)) {
          return;
        }
        super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        if (typeParameters) node.typeParameters = typeParameters;
      }
      parseClassPropertyAnnotation(node) {
        if (!node.optional) {
          if (this.eat(35)) {
            node.definite = true;
          } else if (this.eat(17)) {
            node.optional = true;
          }
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
      }
      parseClassProperty(node) {
        this.parseClassPropertyAnnotation(node);
        if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
          this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);
        }
        if (node.abstract && this.match(29)) {
          const {
            key
          } = node;
          this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {
            propertyName: key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`
          });
        }
        return super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        if (node.abstract) {
          this.raise(TSErrors.PrivateElementHasAbstract, node);
        }
        if (node.accessibility) {
          this.raise(TSErrors.PrivateElementHasAccessibility, node, {
            modifier: node.accessibility
          });
        }
        this.parseClassPropertyAnnotation(node);
        return super.parseClassPrivateProperty(node);
      }
      parseClassAccessorProperty(node) {
        this.parseClassPropertyAnnotation(node);
        if (node.optional) {
          this.raise(TSErrors.AccessorCannotBeOptional, node);
        }
        return super.parseClassAccessorProperty(node);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters && isConstructor) {
          this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);
        }
        const {
          declare = false,
          kind
        } = method;
        if (declare && (kind === "get" || kind === "set")) {
          this.raise(TSErrors.DeclareAccessor, method, {
            kind
          });
        }
        if (typeParameters) method.typeParameters = typeParameters;
        super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) method.typeParameters = typeParameters;
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      declareClassPrivateMethodInScope(node, kind) {
        if (node.type === "TSDeclareMethod") return;
        if (node.type === "MethodDefinition" && node.value.body == null) {
          return;
        }
        super.declareClassPrivateMethodInScope(node, kind);
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && (this.match(47) || this.match(51))) {
          {
            node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
          }
        }
        if (this.eatContextual(113)) {
          node.implements = this.tsParseHeritageClause("implements");
        }
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) prop.typeParameters = typeParameters;
        return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
      }
      parseFunctionParams(node, isConstructor) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) node.typeParameters = typeParameters;
        super.parseFunctionParams(node, isConstructor);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
          decl.definite = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          decl.id.typeAnnotation = type;
          this.resetEndLocation(decl.id);
        }
      }
      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(14)) {
          node.returnType = this.tsParseTypeAnnotation();
        }
        return super.parseAsyncArrowFromCallExpression(node, call);
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
        let state;
        let jsx2;
        let typeCast;
        if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
          state = this.state.clone();
          jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!jsx2.error) return jsx2.node;
          const {
            context
          } = this.state;
          const currentContext = context[context.length - 1];
          if (currentContext === types.j_oTag || currentContext === types.j_expr) {
            context.pop();
          }
        }
        if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
          return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        }
        if (!state || state === this.state) state = this.state.clone();
        let typeParameters;
        const arrow = this.tryParse((abort) => {
          var _expr$extra, _typeParameters;
          typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
          if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
            abort();
          }
          if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
            this.resetStartLocationFromNode(expr, typeParameters);
          }
          expr.typeParameters = typeParameters;
          return expr;
        }, state);
        if (!arrow.error && !arrow.aborted) {
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if (!jsx2) {
          assert(!this.hasPlugin("jsx"));
          typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!typeCast.error) return typeCast.node;
        }
        if ((_jsx2 = jsx2) != null && _jsx2.node) {
          this.state = jsx2.failState;
          return jsx2.node;
        }
        if (arrow.node) {
          this.state = arrow.failState;
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if ((_typeCast = typeCast) != null && _typeCast.node) {
          this.state = typeCast.failState;
          return typeCast.node;
        }
        throw ((_jsx3 = jsx2) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);
      }
      reportReservedArrowTypeParam(node) {
        var _node$extra2;
        if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra2 = node.extra) != null && _node$extra2.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedArrowTypeParam, node);
        }
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        if (!this.hasPlugin("jsx") && this.match(47)) {
          return this.tsParseTypeAssertion();
        }
        return super.parseMaybeUnary(refExpressionErrors, sawUnary);
      }
      parseArrow(node) {
        if (this.match(14)) {
          const result = this.tryParse((abort) => {
            const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
            if (this.canInsertSemicolon() || !this.match(19)) abort();
            return returnType;
          });
          if (result.aborted) return;
          if (!result.thrown) {
            if (result.error) this.state = result.failState;
            node.returnType = result.node;
          }
        }
        return super.parseArrow(node);
      }
      parseFunctionParamType(param) {
        if (this.eat(17)) {
          param.optional = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) param.typeAnnotation = type;
        this.resetEndLocation(param);
        return param;
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "TSTypeCastExpression":
            return this.isAssignable(node.expression, isBinding);
          case "TSParameterProperty":
            return true;
          default:
            return super.isAssignable(node, isBinding);
        }
      }
      toAssignable(node, isLHS = false) {
        switch (node.type) {
          case "ParenthesizedExpression":
            this.toAssignableParenthesizedExpression(node, isLHS);
            break;
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            if (isLHS) {
              this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);
            } else {
              this.raise(TSErrors.UnexpectedTypeCastInParameter, node);
            }
            this.toAssignable(node.expression, isLHS);
            break;
          case "AssignmentExpression":
            if (!isLHS && node.left.type === "TSTypeCastExpression") {
              node.left = this.typeCastToParameter(node.left);
            }
          default:
            super.toAssignable(node, isLHS);
        }
      }
      toAssignableParenthesizedExpression(node, isLHS) {
        switch (node.expression.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
          case "ParenthesizedExpression":
            this.toAssignable(node.expression, isLHS);
            break;
          default:
            super.toAssignable(node, isLHS);
        }
      }
      checkToRestConversion(node, allowPattern) {
        switch (node.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSTypeAssertion":
          case "TSNonNullExpression":
            this.checkToRestConversion(node.expression, false);
            break;
          default:
            super.checkToRestConversion(node, allowPattern);
        }
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        switch (type) {
          case "TSTypeCastExpression":
            return true;
          case "TSParameterProperty":
            return "parameter";
          case "TSNonNullExpression":
            return "expression";
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSTypeAssertion":
            return (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true];
          default:
            return super.isValidLVal(type, isUnparenthesizedInAssign, binding);
        }
      }
      parseBindingAtom() {
        if (this.state.type === 78) {
          return this.parseIdentifier(true);
        }
        return super.parseBindingAtom();
      }
      parseMaybeDecoratorArguments(expr, startLoc) {
        if (this.match(47) || this.match(51)) {
          const typeArguments = this.tsParseTypeArgumentsInExpression();
          if (this.match(10)) {
            const call = super.parseMaybeDecoratorArguments(expr, startLoc);
            {
              call.typeParameters = typeArguments;
            }
            return call;
          }
          this.unexpected(null, 10);
        }
        return super.parseMaybeDecoratorArguments(expr, startLoc);
      }
      checkCommaAfterRest(close) {
        if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
          this.next();
          return false;
        }
        return super.checkCommaAfterRest(close);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(35) || this.match(14) || super.isClassProperty();
      }
      parseMaybeDefault(startLoc, left) {
        const node = super.parseMaybeDefault(startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);
        }
        return node;
      }
      getTokenFromCode(code3) {
        if (this.state.inType) {
          if (code3 === 62) {
            this.finishOp(48, 1);
            return;
          }
          if (code3 === 60) {
            this.finishOp(47, 1);
            return;
          }
        }
        super.getTokenFromCode(code3);
      }
      reScan_lt_gt() {
        const {
          type
        } = this.state;
        if (type === 47) {
          this.state.pos -= 1;
          this.readToken_lt();
        } else if (type === 48) {
          this.state.pos -= 1;
          this.readToken_gt();
        }
      }
      reScan_lt() {
        const {
          type
        } = this.state;
        if (type === 51) {
          this.state.pos -= 2;
          this.finishOp(47, 1);
          return 47;
        }
        return type;
      }
      toAssignableListItem(exprList, index, isLHS) {
        const node = exprList[index];
        if (node.type === "TSTypeCastExpression") {
          exprList[index] = this.typeCastToParameter(node);
        }
        super.toAssignableListItem(exprList, index, isLHS);
      }
      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
        return node.expression;
      }
      shouldParseArrow(params) {
        if (this.match(14)) {
          return params.every((expr) => this.isAssignable(expr, true));
        }
        return super.shouldParseArrow(params);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      canHaveLeadingDecorator() {
        return super.canHaveLeadingDecorator() || this.isAbstractClass();
      }
      jsxParseOpeningElementAfterName(node) {
        if (this.match(47) || this.match(51)) {
          const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
          if (typeArguments) {
            {
              node.typeParameters = typeArguments;
            }
          }
        }
        return super.jsxParseOpeningElementAfterName(node);
      }
      getGetterSetterExpectedParamCount(method) {
        const baseCount = super.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        const firstParam = params[0];
        const hasContextParam = firstParam && this.isThisParam(firstParam);
        return hasContextParam ? baseCount + 1 : baseCount;
      }
      parseCatchClauseParam() {
        const param = super.parseCatchClauseParam();
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          param.typeAnnotation = type;
          this.resetEndLocation(param);
        }
        return param;
      }
      tsInAmbientContext(cb) {
        const {
          isAmbientContext: oldIsAmbientContext,
          strict: oldStrict
        } = this.state;
        this.state.isAmbientContext = true;
        this.state.strict = false;
        try {
          return cb();
        } finally {
          this.state.isAmbientContext = oldIsAmbientContext;
          this.state.strict = oldStrict;
        }
      }
      parseClass(node, isStatement, optionalId) {
        const oldInAbstractClass = this.state.inAbstractClass;
        this.state.inAbstractClass = !!node.abstract;
        try {
          return super.parseClass(node, isStatement, optionalId);
        } finally {
          this.state.inAbstractClass = oldInAbstractClass;
        }
      }
      tsParseAbstractDeclaration(node, decorators) {
        if (this.match(80)) {
          node.abstract = true;
          return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
        } else if (this.isContextual(129)) {
          if (!this.hasFollowingLineBreak()) {
            node.abstract = true;
            this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifier, node);
            return this.tsParseInterfaceDeclaration(node);
          }
        } else {
          this.unexpected(null, 80);
        }
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
        const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        if (method.abstract || method.type === "TSAbstractMethodDefinition") {
          const hasEstreePlugin = this.hasPlugin("estree");
          const methodFn = hasEstreePlugin ? method.value : method;
          if (methodFn.body) {
            const {
              key
            } = method;
            this.raise(TSErrors.AbstractMethodHasImplementation, method, {
              methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`
            });
          }
        }
        return method;
      }
      tsParseTypeParameterName() {
        const typeName = this.parseIdentifier();
        return typeName.name;
      }
      shouldParseAsAmbientContext() {
        return !!this.getPluginOption("typescript", "dts");
      }
      parse() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.parse();
      }
      getExpression() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.getExpression();
      }
      parseExportSpecifier(node, isString2, isInTypeExport, isMaybeTypeOnly) {
        if (!isString2 && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
          return this.finishNode(node, "ExportSpecifier");
        }
        node.exportKind = "value";
        return super.parseExportSpecifier(node, isString2, isInTypeExport, isMaybeTypeOnly);
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (!importedIsString && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
          return this.finishNode(specifier, "ImportSpecifier");
        }
        specifier.importKind = "value";
        return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);
      }
      parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
        const leftOfAsKey = isImport ? "imported" : "local";
        const rightOfAsKey = isImport ? "local" : "exported";
        let leftOfAs = node[leftOfAsKey];
        let rightOfAs;
        let hasTypeSpecifier = false;
        let canParseAsKeyword = true;
        const loc = leftOfAs.loc.start;
        if (this.isContextual(93)) {
          const firstAs = this.parseIdentifier();
          if (this.isContextual(93)) {
            const secondAs = this.parseIdentifier();
            if (tokenIsKeywordOrIdentifier(this.state.type)) {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
              rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
              canParseAsKeyword = false;
            } else {
              rightOfAs = secondAs;
              canParseAsKeyword = false;
            }
          } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            canParseAsKeyword = false;
            rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
          } else {
            hasTypeSpecifier = true;
            leftOfAs = firstAs;
          }
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          hasTypeSpecifier = true;
          if (isImport) {
            leftOfAs = this.parseIdentifier(true);
            if (!this.isContextual(93)) {
              this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
            }
          } else {
            leftOfAs = this.parseModuleExportName();
          }
        }
        if (hasTypeSpecifier && isInTypeOnlyImportExport) {
          this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);
        }
        node[leftOfAsKey] = leftOfAs;
        node[rightOfAsKey] = rightOfAs;
        const kindKey = isImport ? "importKind" : "exportKind";
        node[kindKey] = hasTypeSpecifier ? "type" : "value";
        if (canParseAsKeyword && this.eatContextual(93)) {
          node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
        }
        if (!node[rightOfAsKey]) {
          node[rightOfAsKey] = this.cloneIdentifier(node[leftOfAsKey]);
        }
        if (isImport) {
          this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
        }
      }
      fillOptionalPropertiesForTSESLint(node) {
        var _node$directive, _node$decorators, _node$optional, _node$typeAnnotation, _node$accessibility, _node$decorators2, _node$override, _node$readonly, _node$static, _node$declare, _node$returnType, _node$typeParameters, _node$optional2, _node$optional3, _node$accessibility2, _node$readonly2, _node$static2, _node$declare2, _node$definite, _node$readonly3, _node$typeAnnotation2, _node$accessibility3, _node$decorators3, _node$override2, _node$optional4, _node$id, _node$abstract, _node$declare3, _node$decorators4, _node$implements, _node$superTypeArgume, _node$typeParameters2, _node$declare4, _node$definite2, _node$const, _node$declare5, _node$computed, _node$qualifier, _node$options, _node$declare6, _node$extends, _node$declare7, _node$global, _node$const2, _node$in, _node$out;
        switch (node.type) {
          case "ExpressionStatement":
            (_node$directive = node.directive) != null ? _node$directive : node.directive = void 0;
            return;
          case "RestElement":
            node.value = void 0;
          case "Identifier":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "ObjectPattern":
            (_node$decorators = node.decorators) != null ? _node$decorators : node.decorators = [];
            (_node$optional = node.optional) != null ? _node$optional : node.optional = false;
            (_node$typeAnnotation = node.typeAnnotation) != null ? _node$typeAnnotation : node.typeAnnotation = void 0;
            return;
          case "TSParameterProperty":
            (_node$accessibility = node.accessibility) != null ? _node$accessibility : node.accessibility = void 0;
            (_node$decorators2 = node.decorators) != null ? _node$decorators2 : node.decorators = [];
            (_node$override = node.override) != null ? _node$override : node.override = false;
            (_node$readonly = node.readonly) != null ? _node$readonly : node.readonly = false;
            (_node$static = node.static) != null ? _node$static : node.static = false;
            return;
          case "TSEmptyBodyFunctionExpression":
            node.body = null;
          case "TSDeclareFunction":
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ClassMethod":
          case "ClassPrivateMethod":
            (_node$declare = node.declare) != null ? _node$declare : node.declare = false;
            (_node$returnType = node.returnType) != null ? _node$returnType : node.returnType = void 0;
            (_node$typeParameters = node.typeParameters) != null ? _node$typeParameters : node.typeParameters = void 0;
            return;
          case "Property":
            (_node$optional2 = node.optional) != null ? _node$optional2 : node.optional = false;
            return;
          case "TSMethodSignature":
          case "TSPropertySignature":
            (_node$optional3 = node.optional) != null ? _node$optional3 : node.optional = false;
          case "TSIndexSignature":
            (_node$accessibility2 = node.accessibility) != null ? _node$accessibility2 : node.accessibility = void 0;
            (_node$readonly2 = node.readonly) != null ? _node$readonly2 : node.readonly = false;
            (_node$static2 = node.static) != null ? _node$static2 : node.static = false;
            return;
          case "TSAbstractPropertyDefinition":
          case "PropertyDefinition":
          case "TSAbstractAccessorProperty":
          case "AccessorProperty":
            (_node$declare2 = node.declare) != null ? _node$declare2 : node.declare = false;
            (_node$definite = node.definite) != null ? _node$definite : node.definite = false;
            (_node$readonly3 = node.readonly) != null ? _node$readonly3 : node.readonly = false;
            (_node$typeAnnotation2 = node.typeAnnotation) != null ? _node$typeAnnotation2 : node.typeAnnotation = void 0;
          case "TSAbstractMethodDefinition":
          case "MethodDefinition":
            (_node$accessibility3 = node.accessibility) != null ? _node$accessibility3 : node.accessibility = void 0;
            (_node$decorators3 = node.decorators) != null ? _node$decorators3 : node.decorators = [];
            (_node$override2 = node.override) != null ? _node$override2 : node.override = false;
            (_node$optional4 = node.optional) != null ? _node$optional4 : node.optional = false;
            return;
          case "ClassExpression":
            (_node$id = node.id) != null ? _node$id : node.id = null;
          case "ClassDeclaration":
            (_node$abstract = node.abstract) != null ? _node$abstract : node.abstract = false;
            (_node$declare3 = node.declare) != null ? _node$declare3 : node.declare = false;
            (_node$decorators4 = node.decorators) != null ? _node$decorators4 : node.decorators = [];
            (_node$implements = node.implements) != null ? _node$implements : node.implements = [];
            (_node$superTypeArgume = node.superTypeArguments) != null ? _node$superTypeArgume : node.superTypeArguments = void 0;
            (_node$typeParameters2 = node.typeParameters) != null ? _node$typeParameters2 : node.typeParameters = void 0;
            return;
          case "TSTypeAliasDeclaration":
          case "VariableDeclaration":
            (_node$declare4 = node.declare) != null ? _node$declare4 : node.declare = false;
            return;
          case "VariableDeclarator":
            (_node$definite2 = node.definite) != null ? _node$definite2 : node.definite = false;
            return;
          case "TSEnumDeclaration":
            (_node$const = node.const) != null ? _node$const : node.const = false;
            (_node$declare5 = node.declare) != null ? _node$declare5 : node.declare = false;
            return;
          case "TSEnumMember":
            (_node$computed = node.computed) != null ? _node$computed : node.computed = false;
            return;
          case "TSImportType":
            (_node$qualifier = node.qualifier) != null ? _node$qualifier : node.qualifier = null;
            (_node$options = node.options) != null ? _node$options : node.options = null;
            return;
          case "TSInterfaceDeclaration":
            (_node$declare6 = node.declare) != null ? _node$declare6 : node.declare = false;
            (_node$extends = node.extends) != null ? _node$extends : node.extends = [];
            return;
          case "TSModuleDeclaration":
            (_node$declare7 = node.declare) != null ? _node$declare7 : node.declare = false;
            (_node$global = node.global) != null ? _node$global : node.global = node.kind === "global";
            return;
          case "TSTypeParameter":
            (_node$const2 = node.const) != null ? _node$const2 : node.const = false;
            (_node$in = node.in) != null ? _node$in : node.in = false;
            (_node$out = node.out) != null ? _node$out : node.out = false;
            return;
        }
      }
    };
    function isPossiblyLiteralEnum(expression) {
      if (expression.type !== "MemberExpression") return false;
      const {
        computed,
        property: property4
      } = expression;
      if (computed && property4.type !== "StringLiteral" && (property4.type !== "TemplateLiteral" || property4.expressions.length > 0)) {
        return false;
      }
      return isUncomputedMemberExpressionChain(expression.object);
    }
    function isValidAmbientConstInitializer(expression, estree2) {
      var _expression$extra;
      const {
        type
      } = expression;
      if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {
        return false;
      }
      if (estree2) {
        if (type === "Literal") {
          const {
            value
          } = expression;
          if (typeof value === "string" || typeof value === "boolean") {
            return true;
          }
        }
      } else {
        if (type === "StringLiteral" || type === "BooleanLiteral") {
          return true;
        }
      }
      if (isNumber(expression, estree2) || isNegativeNumber(expression, estree2)) {
        return true;
      }
      if (type === "TemplateLiteral" && expression.expressions.length === 0) {
        return true;
      }
      if (isPossiblyLiteralEnum(expression)) {
        return true;
      }
      return false;
    }
    function isNumber(expression, estree2) {
      if (estree2) {
        return expression.type === "Literal" && (typeof expression.value === "number" || "bigint" in expression);
      }
      return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
    }
    function isNegativeNumber(expression, estree2) {
      if (expression.type === "UnaryExpression") {
        const {
          operator,
          argument
        } = expression;
        if (operator === "-" && isNumber(argument, estree2)) {
          return true;
        }
      }
      return false;
    }
    function isUncomputedMemberExpressionChain(expression) {
      if (expression.type === "Identifier") return true;
      if (expression.type !== "MemberExpression" || expression.computed) {
        return false;
      }
      return isUncomputedMemberExpressionChain(expression.object);
    }
    var PlaceholderErrors = ParseErrorEnum`placeholders`({
      ClassNameIsRequired: "A class name is required.",
      UnexpectedSpace: "Unexpected space in placeholder."
    });
    var placeholders3 = (superClass) => class PlaceholdersParserMixin extends superClass {
      parsePlaceholder(expectedNode) {
        if (this.match(133)) {
          const node = this.startNode();
          this.next();
          this.assertNoSpace();
          node.name = super.parseIdentifier(true);
          this.assertNoSpace();
          this.expect(133);
          return this.finishPlaceholder(node, expectedNode);
        }
      }
      finishPlaceholder(node, expectedNode) {
        let placeholder = node;
        if (!placeholder.expectedNode || !placeholder.type) {
          placeholder = this.finishNode(placeholder, "Placeholder");
        }
        placeholder.expectedNode = expectedNode;
        return placeholder;
      }
      getTokenFromCode(code3) {
        if (code3 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
          this.finishOp(133, 2);
        } else {
          super.getTokenFromCode(code3);
        }
      }
      parseExprAtom(refExpressionErrors) {
        return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
      }
      parseIdentifier(liberal) {
        return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (word !== void 0) {
          super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
        }
      }
      cloneIdentifier(node) {
        const cloned = super.cloneIdentifier(node);
        if (cloned.type === "Placeholder") {
          cloned.expectedNode = node.expectedNode;
        }
        return cloned;
      }
      cloneStringLiteral(node) {
        if (node.type === "Placeholder") {
          return this.cloneIdentifier(node);
        }
        return super.cloneStringLiteral(node);
      }
      parseBindingAtom() {
        return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
      }
      isValidLVal(type, isParenthesized, binding) {
        return type === "Placeholder" || super.isValidLVal(type, isParenthesized, binding);
      }
      toAssignable(node, isLHS) {
        if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
          node.expectedNode = "Pattern";
        } else {
          super.toAssignable(node, isLHS);
        }
      }
      chStartsBindingIdentifier(ch, pos) {
        if (super.chStartsBindingIdentifier(ch, pos)) {
          return true;
        }
        const next = this.nextTokenStart();
        if (this.input.charCodeAt(next) === 37 && this.input.charCodeAt(next + 1) === 37) {
          return true;
        }
        return false;
      }
      verifyBreakContinue(node, isBreak) {
        if (node.label && node.label.type === "Placeholder") return;
        super.verifyBreakContinue(node, isBreak);
      }
      parseExpressionStatement(node, expr) {
        var _expr$extra;
        if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
          return super.parseExpressionStatement(node, expr);
        }
        if (this.match(14)) {
          const stmt = node;
          stmt.label = this.finishPlaceholder(expr, "Identifier");
          this.next();
          stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
          return this.finishNode(stmt, "LabeledStatement");
        }
        this.semicolon();
        const stmtPlaceholder = node;
        stmtPlaceholder.name = expr.name;
        return this.finishPlaceholder(stmtPlaceholder, "Statement");
      }
      parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
        return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
      }
      parseFunctionId(requireId) {
        return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
      }
      parseClass(node, isStatement, optionalId) {
        const type = isStatement ? "ClassDeclaration" : "ClassExpression";
        this.next();
        const oldStrict = this.state.strict;
        const placeholder = this.parsePlaceholder("Identifier");
        if (placeholder) {
          if (this.match(81) || this.match(133) || this.match(5)) {
            node.id = placeholder;
          } else if (optionalId || !isStatement) {
            node.id = null;
            node.body = this.finishPlaceholder(placeholder, "ClassBody");
            return this.finishNode(node, type);
          } else {
            throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);
          }
        } else {
          this.parseClassId(node, isStatement, optionalId);
        }
        super.parseClassSuper(node);
        node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, type);
      }
      parseExport(node, decorators) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return super.parseExport(node, decorators);
        const node2 = node;
        if (!this.isContextual(98) && !this.match(12)) {
          node2.specifiers = [];
          node2.source = null;
          node2.declaration = this.finishPlaceholder(placeholder, "Declaration");
          return this.finishNode(node2, "ExportNamedDeclaration");
        }
        this.expectPlugin("exportDefaultFrom");
        const specifier = this.startNode();
        specifier.exported = placeholder;
        node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return super.parseExport(node2, decorators);
      }
      isExportDefaultSpecifier() {
        if (this.match(65)) {
          const next = this.nextTokenStart();
          if (this.isUnparsedContextual(next, "from")) {
            if (this.input.startsWith(tokenLabelName(133), this.nextTokenStartSince(next + 4))) {
              return true;
            }
          }
        }
        return super.isExportDefaultSpecifier();
      }
      maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
        var _specifiers;
        if ((_specifiers = node.specifiers) != null && _specifiers.length) {
          return true;
        }
        return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
      }
      checkExport(node) {
        const {
          specifiers
        } = node;
        if (specifiers != null && specifiers.length) {
          node.specifiers = specifiers.filter((node2) => node2.exported.type === "Placeholder");
        }
        super.checkExport(node);
        node.specifiers = specifiers;
      }
      parseImport(node) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return super.parseImport(node);
        node.specifiers = [];
        if (!this.isContextual(98) && !this.match(12)) {
          node.source = this.finishPlaceholder(placeholder, "StringLiteral");
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
        const specifier = this.startNodeAtNode(placeholder);
        specifier.local = placeholder;
        node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
        if (this.eat(12)) {
          const hasStarImport = this.maybeParseStarImportSpecifier(node);
          if (!hasStarImport) this.parseNamedImportSpecifiers(node);
        }
        this.expectContextual(98);
        node.source = this.parseImportSource();
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      }
      parseImportSource() {
        return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
      }
      assertNoSpace() {
        if (this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index)) {
          this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);
        }
      }
    };
    var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
      parseV8Intrinsic() {
        if (this.match(54)) {
          const v8IntrinsicStartLoc = this.state.startLoc;
          const node = this.startNode();
          this.next();
          if (tokenIsIdentifier(this.state.type)) {
            const name50 = this.parseIdentifierName();
            const identifier = this.createIdentifier(node, name50);
            this.castNodeTo(identifier, "V8IntrinsicIdentifier");
            if (this.match(10)) {
              return identifier;
            }
          }
          this.unexpected(v8IntrinsicStartLoc);
        }
      }
      parseExprAtom(refExpressionErrors) {
        return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
      }
    };
    var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
    var TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
    function validatePlugins(pluginsMap) {
      if (pluginsMap.has("decorators")) {
        if (pluginsMap.has("decorators-legacy")) {
          throw new Error("Cannot use the decorators and decorators-legacy plugin together");
        }
        const decoratorsBeforeExport = pluginsMap.get("decorators").decoratorsBeforeExport;
        if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
          throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
        }
        const allowCallParenthesized = pluginsMap.get("decorators").allowCallParenthesized;
        if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
          throw new Error("'allowCallParenthesized' must be a boolean.");
        }
      }
      if (pluginsMap.has("flow") && pluginsMap.has("typescript")) {
        throw new Error("Cannot combine flow and typescript plugins.");
      }
      if (pluginsMap.has("placeholders") && pluginsMap.has("v8intrinsic")) {
        throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
      }
      if (pluginsMap.has("pipelineOperator")) {
        var _pluginsMap$get2;
        const proposal = pluginsMap.get("pipelineOperator").proposal;
        if (!PIPELINE_PROPOSALS.includes(proposal)) {
          const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
          throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
        }
        if (proposal === "hack") {
          if (pluginsMap.has("placeholders")) {
            throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
          }
          if (pluginsMap.has("v8intrinsic")) {
            throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
          }
          const topicToken = pluginsMap.get("pipelineOperator").topicToken;
          if (!TOPIC_TOKENS.includes(topicToken)) {
            const tokenList = TOPIC_TOKENS.map((t) => `"${t}"`).join(", ");
            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
          }
          {
            var _pluginsMap$get;
            if (topicToken === "#" && ((_pluginsMap$get = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get.syntaxType) === "hash") {
              throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
            }
          }
        } else if (proposal === "smart" && ((_pluginsMap$get2 = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get2.syntaxType) === "hash") {
          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
        }
      }
      if (pluginsMap.has("moduleAttributes")) {
        {
          if (pluginsMap.has("deprecatedImportAssert") || pluginsMap.has("importAssertions")) {
            throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
          }
          const moduleAttributesVersionPluginOption = pluginsMap.get("moduleAttributes").version;
          if (moduleAttributesVersionPluginOption !== "may-2020") {
            throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
          }
        }
      }
      if (pluginsMap.has("importAssertions")) {
        if (pluginsMap.has("deprecatedImportAssert")) {
          throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
        }
      }
      if (!pluginsMap.has("deprecatedImportAssert") && pluginsMap.has("importAttributes") && pluginsMap.get("importAttributes").deprecatedAssertSyntax) {
        {
          pluginsMap.set("deprecatedImportAssert", {});
        }
      }
      if (pluginsMap.has("recordAndTuple")) {
        {
          const syntaxType = pluginsMap.get("recordAndTuple").syntaxType;
          if (syntaxType != null) {
            const RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
            if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType)) {
              throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
            }
          }
        }
      }
      if (pluginsMap.has("asyncDoExpressions") && !pluginsMap.has("doExpressions")) {
        const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
        error.missingPlugins = "doExpressions";
        throw error;
      }
      if (pluginsMap.has("optionalChainingAssign") && pluginsMap.get("optionalChainingAssign").version !== "2023-07") {
        throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
      }
    }
    var mixinPlugins = {
      estree,
      jsx,
      flow,
      typescript,
      v8intrinsic,
      placeholders: placeholders3
    };
    var mixinPluginNames = Object.keys(mixinPlugins);
    var ExpressionParser = class extends LValParser {
      checkProto(prop, isRecord, sawProto, refExpressionErrors) {
        if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
          return sawProto;
        }
        const key = prop.key;
        const name50 = key.type === "Identifier" ? key.name : key.value;
        if (name50 === "__proto__") {
          if (isRecord) {
            this.raise(Errors.RecordNoProto, key);
            return true;
          }
          if (sawProto) {
            if (refExpressionErrors) {
              if (refExpressionErrors.doubleProtoLoc === null) {
                refExpressionErrors.doubleProtoLoc = key.loc.start;
              }
            } else {
              this.raise(Errors.DuplicateProto, key);
            }
          }
          return true;
        }
        return sawProto;
      }
      shouldExitDescending(expr, potentialArrowAt) {
        return expr.type === "ArrowFunctionExpression" && this.offsetToSourcePos(expr.start) === potentialArrowAt;
      }
      getExpression() {
        this.enterInitialScopes();
        this.nextToken();
        if (this.match(140)) {
          throw this.raise(Errors.ParseExpressionEmptyInput, this.state.startLoc);
        }
        const expr = this.parseExpression();
        if (!this.match(140)) {
          throw this.raise(Errors.ParseExpressionExpectsEOF, this.state.startLoc, {
            unexpected: this.input.codePointAt(this.state.start)
          });
        }
        this.finalizeRemainingComments();
        expr.comments = this.comments;
        expr.errors = this.state.errors;
        if (this.optionFlags & 256) {
          expr.tokens = this.tokens;
        }
        return expr;
      }
      parseExpression(disallowIn, refExpressionErrors) {
        if (disallowIn) {
          return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
        }
        return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
      }
      parseExpressionBase(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const expr = this.parseMaybeAssign(refExpressionErrors);
        if (this.match(12)) {
          const node = this.startNodeAt(startLoc);
          node.expressions = [expr];
          while (this.eat(12)) {
            node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
          }
          this.toReferencedList(node.expressions);
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      }
      parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
        return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
        return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      setOptionalParametersError(refExpressionErrors) {
        refExpressionErrors.optionalParametersLoc = this.state.startLoc;
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        const startLoc = this.state.startLoc;
        const isYield = this.isContextual(108);
        if (isYield) {
          if (this.prodParam.hasYield) {
            this.next();
            let left2 = this.parseYield(startLoc);
            if (afterLeftParse) {
              left2 = afterLeftParse.call(this, left2, startLoc);
            }
            return left2;
          }
        }
        let ownExpressionErrors;
        if (refExpressionErrors) {
          ownExpressionErrors = false;
        } else {
          refExpressionErrors = new ExpressionErrors();
          ownExpressionErrors = true;
        }
        const {
          type
        } = this.state;
        if (type === 10 || tokenIsIdentifier(type)) {
          this.state.potentialArrowAt = this.state.start;
        }
        let left = this.parseMaybeConditional(refExpressionErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startLoc);
        }
        if (tokenIsAssignment(this.state.type)) {
          const node = this.startNodeAt(startLoc);
          const operator = this.state.value;
          node.operator = operator;
          if (this.match(29)) {
            this.toAssignable(left, true);
            node.left = left;
            const startIndex = startLoc.index;
            if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
              refExpressionErrors.doubleProtoLoc = null;
            }
            if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
              refExpressionErrors.shorthandAssignLoc = null;
            }
            if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
              this.checkDestructuringPrivate(refExpressionErrors);
              refExpressionErrors.privateKeyLoc = null;
            }
          } else {
            node.left = left;
          }
          this.next();
          node.right = this.parseMaybeAssign();
          this.checkLVal(left, this.finishNode(node, "AssignmentExpression"));
          return node;
        } else if (ownExpressionErrors) {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        if (isYield) {
          const {
            type: type2
          } = this.state;
          const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type2) : tokenCanStartExpression(type2) && !this.match(54);
          if (startsExpr2 && !this.isAmbiguousPrefixOrIdentifier()) {
            this.raiseOverwrite(Errors.YieldNotInGeneratorFunction, startLoc);
            return this.parseYield(startLoc);
          }
        }
        return left;
      }
      parseMaybeConditional(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprOps(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseConditional(expr, startLoc, refExpressionErrors);
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (this.eat(17)) {
          const node = this.startNodeAt(startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssignAllowIn();
          this.expect(14);
          node.alternate = this.parseMaybeAssign();
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      }
      parseMaybeUnaryOrPrivate(refExpressionErrors) {
        return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
      }
      parseExprOps(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseExprOp(expr, startLoc, -1);
      }
      parseExprOp(left, leftStartLoc, minPrec) {
        if (this.isPrivateName(left)) {
          const value = this.getPrivateNameSV(left);
          if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
            this.raise(Errors.PrivateInExpectedIn, left, {
              identifierName: value
            });
          }
          this.classScope.usePrivateName(value, left.loc.start);
        }
        const op = this.state.type;
        if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
          let prec = tokenOperatorPrecedence(op);
          if (prec > minPrec) {
            if (op === 39) {
              this.expectPlugin("pipelineOperator");
              if (this.state.inFSharpPipelineDirectBody) {
                return left;
              }
              this.checkPipelineAtInfixOperator(left, leftStartLoc);
            }
            const node = this.startNodeAt(leftStartLoc);
            node.left = left;
            node.operator = this.state.value;
            const logical = op === 41 || op === 42;
            const coalesce = op === 40;
            if (coalesce) {
              prec = tokenOperatorPrecedence(42);
            }
            this.next();
            if (op === 39 && this.hasPlugin(["pipelineOperator", {
              proposal: "minimal"
            }])) {
              if (this.state.type === 96 && this.prodParam.hasAwait) {
                throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
              }
            }
            node.right = this.parseExprOpRightExpr(op, prec);
            const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
            const nextOp = this.state.type;
            if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
              throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);
            }
            return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
          }
        }
        return left;
      }
      parseExprOpRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        switch (op) {
          case 39:
            switch (this.getPluginOption("pipelineOperator", "proposal")) {
              case "hack":
                return this.withTopicBindingContext(() => {
                  return this.parseHackPipeBody();
                });
              case "fsharp":
                return this.withSoloAwaitPermittingContext(() => {
                  return this.parseFSharpPipelineBody(prec);
                });
            }
            if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108)) {
                  throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);
                }
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
              });
            }
          default:
            return this.parseExprOpBaseRightExpr(op, prec);
        }
      }
      parseExprOpBaseRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
      }
      parseHackPipeBody() {
        var _body$extra;
        const {
          startLoc
        } = this.state;
        const body = this.parseMaybeAssign();
        const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
        if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
          this.raise(Errors.PipeUnparenthesizedBody, startLoc, {
            type: body.type
          });
        }
        if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(Errors.PipeTopicUnused, startLoc);
        }
        return body;
      }
      checkExponentialAfterUnary(node) {
        if (this.match(57)) {
          this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);
        }
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        const startLoc = this.state.startLoc;
        const isAwait = this.isContextual(96);
        if (isAwait && this.recordAwaitIfAllowed()) {
          this.next();
          const expr2 = this.parseAwait(startLoc);
          if (!sawUnary) this.checkExponentialAfterUnary(expr2);
          return expr2;
        }
        const update = this.match(34);
        const node = this.startNode();
        if (tokenIsPrefix(this.state.type)) {
          node.operator = this.state.value;
          node.prefix = true;
          if (this.match(72)) {
            this.expectPlugin("throwExpressions");
          }
          const isDelete = this.match(89);
          this.next();
          node.argument = this.parseMaybeUnary(null, true);
          this.checkExpressionErrors(refExpressionErrors, true);
          if (this.state.strict && isDelete) {
            const arg = node.argument;
            if (arg.type === "Identifier") {
              this.raise(Errors.StrictDelete, node);
            } else if (this.hasPropertyAsPrivateName(arg)) {
              this.raise(Errors.DeletePrivateField, node);
            }
          }
          if (!update) {
            if (!sawUnary) {
              this.checkExponentialAfterUnary(node);
            }
            return this.finishNode(node, "UnaryExpression");
          }
        }
        const expr = this.parseUpdate(node, update, refExpressionErrors);
        if (isAwait) {
          const {
            type
          } = this.state;
          const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
          if (startsExpr2 && !this.isAmbiguousPrefixOrIdentifier()) {
            this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);
            return this.parseAwait(startLoc);
          }
        }
        return expr;
      }
      parseUpdate(node, update, refExpressionErrors) {
        if (update) {
          const updateExpressionNode = node;
          this.checkLVal(updateExpressionNode.argument, this.finishNode(updateExpressionNode, "UpdateExpression"));
          return node;
        }
        const startLoc = this.state.startLoc;
        let expr = this.parseExprSubscripts(refExpressionErrors);
        if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;
        while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
          const node2 = this.startNodeAt(startLoc);
          node2.operator = this.state.value;
          node2.prefix = false;
          node2.argument = expr;
          this.next();
          this.checkLVal(expr, expr = this.finishNode(node2, "UpdateExpression"));
        }
        return expr;
      }
      parseExprSubscripts(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprAtom(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseSubscripts(expr, startLoc);
      }
      parseSubscripts(base, startLoc, noCalls) {
        const state = {
          optionalChainMember: false,
          maybeAsyncArrow: this.atPossibleAsyncArrow(base),
          stop: false
        };
        do {
          base = this.parseSubscript(base, startLoc, noCalls, state);
          state.maybeAsyncArrow = false;
        } while (!state.stop);
        return base;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        const {
          type
        } = this.state;
        if (!noCalls && type === 15) {
          return this.parseBind(base, startLoc, noCalls, state);
        } else if (tokenIsTemplate(type)) {
          return this.parseTaggedTemplateExpression(base, startLoc, state);
        }
        let optional = false;
        if (type === 18) {
          if (noCalls) {
            this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);
            if (this.lookaheadCharCode() === 40) {
              return this.stopParseSubscript(base, state);
            }
          }
          state.optionalChainMember = optional = true;
          this.next();
        }
        if (!noCalls && this.match(10)) {
          return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
        } else {
          const computed = this.eat(0);
          if (computed || optional || this.eat(16)) {
            return this.parseMember(base, startLoc, state, computed, optional);
          } else {
            return this.stopParseSubscript(base, state);
          }
        }
      }
      stopParseSubscript(base, state) {
        state.stop = true;
        return base;
      }
      parseMember(base, startLoc, state, computed, optional) {
        const node = this.startNodeAt(startLoc);
        node.object = base;
        node.computed = computed;
        if (computed) {
          node.property = this.parseExpression();
          this.expect(3);
        } else if (this.match(139)) {
          if (base.type === "Super") {
            this.raise(Errors.SuperPrivateField, startLoc);
          }
          this.classScope.usePrivateName(this.state.value, this.state.startLoc);
          node.property = this.parsePrivateName();
        } else {
          node.property = this.parseIdentifier(true);
        }
        if (state.optionalChainMember) {
          node.optional = optional;
          return this.finishNode(node, "OptionalMemberExpression");
        } else {
          return this.finishNode(node, "MemberExpression");
        }
      }
      parseBind(base, startLoc, noCalls, state) {
        const node = this.startNodeAt(startLoc);
        node.object = base;
        this.next();
        node.callee = this.parseNoCallExpr();
        state.stop = true;
        return this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
      }
      parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        let refExpressionErrors = null;
        this.state.maybeInArrowParameters = true;
        this.next();
        const node = this.startNodeAt(startLoc);
        node.callee = base;
        const {
          maybeAsyncArrow,
          optionalChainMember
        } = state;
        if (maybeAsyncArrow) {
          this.expressionScope.enter(newAsyncArrowScope());
          refExpressionErrors = new ExpressionErrors();
        }
        if (optionalChainMember) {
          node.optional = optional;
        }
        if (optional) {
          node.arguments = this.parseCallExpressionArguments(11);
        } else {
          node.arguments = this.parseCallExpressionArguments(11, base.type !== "Super", node, refExpressionErrors);
        }
        let finishedNode = this.finishCallExpression(node, optionalChainMember);
        if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
          state.stop = true;
          this.checkDestructuringPrivate(refExpressionErrors);
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
        } else {
          if (maybeAsyncArrow) {
            this.checkExpressionErrors(refExpressionErrors, true);
            this.expressionScope.exit();
          }
          this.toReferencedArguments(finishedNode);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return finishedNode;
      }
      toReferencedArguments(node, isParenthesizedExpr) {
        this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
      }
      parseTaggedTemplateExpression(base, startLoc, state) {
        const node = this.startNodeAt(startLoc);
        node.tag = base;
        node.quasi = this.parseTemplate(true);
        if (state.optionalChainMember) {
          this.raise(Errors.OptionalChainingNoTemplate, startLoc);
        }
        return this.finishNode(node, "TaggedTemplateExpression");
      }
      atPossibleAsyncArrow(base) {
        return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.offsetToSourcePos(base.start) === this.state.potentialArrowAt;
      }
      finishCallExpression(node, optional) {
        if (node.callee.type === "Import") {
          if (node.arguments.length === 0 || node.arguments.length > 2) {
            this.raise(Errors.ImportCallArity, node);
          } else {
            for (const arg of node.arguments) {
              if (arg.type === "SpreadElement") {
                this.raise(Errors.ImportCallSpreadArgument, arg);
              }
            }
          }
        }
        return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
      }
      parseCallExpressionArguments(close, allowPlaceholder, nodeForExtra, refExpressionErrors) {
        const elts = [];
        let first = true;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              if (nodeForExtra) {
                this.addTrailingCommaExtraToNode(nodeForExtra);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
        }
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return elts;
      }
      shouldParseAsyncArrow() {
        return this.match(19) && !this.canInsertSemicolon();
      }
      parseAsyncArrowFromCallExpression(node, call) {
        var _call$extra;
        this.resetPreviousNodeTrailingComments(call);
        this.expect(19);
        this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
        if (call.innerComments) {
          setInnerComments(node, call.innerComments);
        }
        if (call.callee.trailingComments) {
          setInnerComments(node, call.callee.trailingComments);
        }
        return node;
      }
      parseNoCallExpr() {
        const startLoc = this.state.startLoc;
        return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
      }
      parseExprAtom(refExpressionErrors) {
        let node;
        let decorators = null;
        const {
          type
        } = this.state;
        switch (type) {
          case 79:
            return this.parseSuper();
          case 83:
            node = this.startNode();
            this.next();
            if (this.match(16)) {
              return this.parseImportMetaPropertyOrPhaseCall(node);
            }
            if (this.match(10)) {
              if (this.optionFlags & 512) {
                return this.parseImportCall(node);
              } else {
                return this.finishNode(node, "Import");
              }
            } else {
              this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);
              return this.finishNode(node, "Import");
            }
          case 78:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
          case 90: {
            return this.parseDo(this.startNode(), false);
          }
          case 56:
          case 31: {
            this.readRegexp();
            return this.parseRegExpLiteral(this.state.value);
          }
          case 135:
            return this.parseNumericLiteral(this.state.value);
          case 136:
            return this.parseBigIntLiteral(this.state.value);
          case 134:
            return this.parseStringLiteral(this.state.value);
          case 84:
            return this.parseNullLiteral();
          case 85:
            return this.parseBooleanLiteral(true);
          case 86:
            return this.parseBooleanLiteral(false);
          case 10: {
            const canBeArrow = this.state.potentialArrowAt === this.state.start;
            return this.parseParenAndDistinguishExpression(canBeArrow);
          }
          case 0: {
            return this.parseArrayLike(3, true, false, refExpressionErrors);
          }
          case 5: {
            return this.parseObjectLike(8, false, false, refExpressionErrors);
          }
          case 68:
            return this.parseFunctionOrFunctionSent();
          case 26:
            decorators = this.parseDecorators();
          case 80:
            return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
          case 77:
            return this.parseNewOrNewTarget();
          case 25:
          case 24:
            return this.parseTemplate(false);
          case 15: {
            node = this.startNode();
            this.next();
            node.object = null;
            const callee = node.callee = this.parseNoCallExpr();
            if (callee.type === "MemberExpression") {
              return this.finishNode(node, "BindExpression");
            } else {
              throw this.raise(Errors.UnsupportedBind, callee);
            }
          }
          case 139: {
            this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {
              identifierName: this.state.value
            });
            return this.parsePrivateName();
          }
          case 33: {
            return this.parseTopicReferenceThenEqualsSign(54, "%");
          }
          case 32: {
            return this.parseTopicReferenceThenEqualsSign(44, "^");
          }
          case 37:
          case 38: {
            return this.parseTopicReference("hack");
          }
          case 44:
          case 54:
          case 27: {
            const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
            if (pipeProposal) {
              return this.parseTopicReference(pipeProposal);
            }
            this.unexpected();
            break;
          }
          case 47: {
            const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
            if (isIdentifierStart2(lookaheadCh) || lookaheadCh === 62) {
              this.expectOnePlugin(["jsx", "flow", "typescript"]);
            } else {
              this.unexpected();
            }
            break;
          }
          default:
            {
              if (type === 137) {
                return this.parseDecimalLiteral(this.state.value);
              } else if (type === 2 || type === 1) {
                return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
              } else if (type === 6 || type === 7) {
                return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
              }
            }
            if (tokenIsIdentifier(type)) {
              if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {
                return this.parseModuleExpression();
              }
              const canBeArrow = this.state.potentialArrowAt === this.state.start;
              const containsEsc = this.state.containsEsc;
              const id = this.parseIdentifier();
              if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                const {
                  type: type2
                } = this.state;
                if (type2 === 68) {
                  this.resetPreviousNodeTrailingComments(id);
                  this.next();
                  return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
                } else if (tokenIsIdentifier(type2)) {
                  if (this.lookaheadCharCode() === 61) {
                    return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                  } else {
                    return id;
                  }
                } else if (type2 === 90) {
                  this.resetPreviousNodeTrailingComments(id);
                  return this.parseDo(this.startNodeAtNode(id), true);
                }
              }
              if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
                this.next();
                return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
              }
              return id;
            } else {
              this.unexpected();
            }
        }
      }
      parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
        const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
        if (pipeProposal) {
          this.state.type = topicTokenType;
          this.state.value = topicTokenValue;
          this.state.pos--;
          this.state.end--;
          this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
          return this.parseTopicReference(pipeProposal);
        } else {
          this.unexpected();
        }
      }
      parseTopicReference(pipeProposal) {
        const node = this.startNode();
        const startLoc = this.state.startLoc;
        const tokenType2 = this.state.type;
        this.next();
        return this.finishTopicReference(node, startLoc, pipeProposal, tokenType2);
      }
      finishTopicReference(node, startLoc, pipeProposal, tokenType2) {
        if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType2)) {
          if (pipeProposal === "hack") {
            if (!this.topicReferenceIsAllowedInCurrentContext()) {
              this.raise(Errors.PipeTopicUnbound, startLoc);
            }
            this.registerTopicReference();
            return this.finishNode(node, "TopicReference");
          } else {
            if (!this.topicReferenceIsAllowedInCurrentContext()) {
              this.raise(Errors.PrimaryTopicNotAllowed, startLoc);
            }
            this.registerTopicReference();
            return this.finishNode(node, "PipelinePrimaryTopicReference");
          }
        } else {
          throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {
            token: tokenLabelName(tokenType2)
          });
        }
      }
      testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType2) {
        switch (pipeProposal) {
          case "hack": {
            return this.hasPlugin(["pipelineOperator", {
              topicToken: tokenLabelName(tokenType2)
            }]);
          }
          case "smart":
            return tokenType2 === 27;
          default:
            throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);
        }
      }
      parseAsyncArrowUnaryFunction(node) {
        this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
        const params = [this.parseIdentifier()];
        this.prodParam.exit();
        if (this.hasPrecedingLineBreak()) {
          this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());
        }
        this.expect(19);
        return this.parseArrowExpression(node, params, true);
      }
      parseDo(node, isAsync) {
        this.expectPlugin("doExpressions");
        if (isAsync) {
          this.expectPlugin("asyncDoExpressions");
        }
        node.async = isAsync;
        this.next();
        const oldLabels = this.state.labels;
        this.state.labels = [];
        if (isAsync) {
          this.prodParam.enter(2);
          node.body = this.parseBlock();
          this.prodParam.exit();
        } else {
          node.body = this.parseBlock();
        }
        this.state.labels = oldLabels;
        return this.finishNode(node, "DoExpression");
      }
      parseSuper() {
        const node = this.startNode();
        this.next();
        if (this.match(10) && !this.scope.allowDirectSuper && !(this.optionFlags & 16)) {
          this.raise(Errors.SuperNotAllowed, node);
        } else if (!this.scope.allowSuper && !(this.optionFlags & 16)) {
          this.raise(Errors.UnexpectedSuper, node);
        }
        if (!this.match(10) && !this.match(0) && !this.match(16)) {
          this.raise(Errors.UnsupportedSuper, node);
        }
        return this.finishNode(node, "Super");
      }
      parsePrivateName() {
        const node = this.startNode();
        const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
        const name50 = this.state.value;
        this.next();
        node.id = this.createIdentifier(id, name50);
        return this.finishNode(node, "PrivateName");
      }
      parseFunctionOrFunctionSent() {
        const node = this.startNode();
        this.next();
        if (this.prodParam.hasYield && this.match(16)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
          this.next();
          if (this.match(103)) {
            this.expectPlugin("functionSent");
          } else if (!this.hasPlugin("functionSent")) {
            this.unexpected();
          }
          return this.parseMetaProperty(node, meta, "sent");
        }
        return this.parseFunction(node);
      }
      parseMetaProperty(node, meta, propertyName) {
        node.meta = meta;
        const containsEsc = this.state.containsEsc;
        node.property = this.parseIdentifier(true);
        if (node.property.name !== propertyName || containsEsc) {
          this.raise(Errors.UnsupportedMetaProperty, node.property, {
            target: meta.name,
            onlyValidPropertyName: propertyName
          });
        }
        return this.finishNode(node, "MetaProperty");
      }
      parseImportMetaPropertyOrPhaseCall(node) {
        this.next();
        if (this.isContextual(105) || this.isContextual(97)) {
          const isSource = this.isContextual(105);
          this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation");
          this.next();
          node.phase = isSource ? "source" : "defer";
          return this.parseImportCall(node);
        } else {
          const id = this.createIdentifierAt(this.startNodeAtNode(node), "import", this.state.lastTokStartLoc);
          if (this.isContextual(101)) {
            if (!this.inModule) {
              this.raise(Errors.ImportMetaOutsideModule, id);
            }
            this.sawUnambiguousESM = true;
          }
          return this.parseMetaProperty(node, id, "meta");
        }
      }
      parseLiteralAtNode(value, type, node) {
        this.addExtra(node, "rawValue", value);
        this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
        node.value = value;
        this.next();
        return this.finishNode(node, type);
      }
      parseLiteral(value, type) {
        const node = this.startNode();
        return this.parseLiteralAtNode(value, type, node);
      }
      parseStringLiteral(value) {
        return this.parseLiteral(value, "StringLiteral");
      }
      parseNumericLiteral(value) {
        return this.parseLiteral(value, "NumericLiteral");
      }
      parseBigIntLiteral(value) {
        return this.parseLiteral(value, "BigIntLiteral");
      }
      parseDecimalLiteral(value) {
        return this.parseLiteral(value, "DecimalLiteral");
      }
      parseRegExpLiteral(value) {
        const node = this.startNode();
        this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
        node.pattern = value.pattern;
        node.flags = value.flags;
        this.next();
        return this.finishNode(node, "RegExpLiteral");
      }
      parseBooleanLiteral(value) {
        const node = this.startNode();
        node.value = value;
        this.next();
        return this.finishNode(node, "BooleanLiteral");
      }
      parseNullLiteral() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "NullLiteral");
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        const startLoc = this.state.startLoc;
        let val;
        this.next();
        this.expressionScope.enter(newArrowHeadScope());
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.maybeInArrowParameters = true;
        this.state.inFSharpPipelineDirectBody = false;
        const innerStartLoc = this.state.startLoc;
        const exprList = [];
        const refExpressionErrors = new ExpressionErrors();
        let first = true;
        let spreadStartLoc;
        let optionalCommaStartLoc;
        while (!this.match(11)) {
          if (first) {
            first = false;
          } else {
            this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
            if (this.match(11)) {
              optionalCommaStartLoc = this.state.startLoc;
              break;
            }
          }
          if (this.match(21)) {
            const spreadNodeStartLoc = this.state.startLoc;
            spreadStartLoc = this.state.startLoc;
            exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
            if (!this.checkCommaAfterRest(41)) {
              break;
            }
          } else {
            exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
          }
        }
        const innerEndLoc = this.state.lastTokEndLoc;
        this.expect(11);
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let arrowNode = this.startNodeAt(startLoc);
        if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
          this.checkDestructuringPrivate(refExpressionErrors);
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          this.parseArrowExpression(arrowNode, exprList, false);
          return arrowNode;
        }
        this.expressionScope.exit();
        if (!exprList.length) {
          this.unexpected(this.state.lastTokStartLoc);
        }
        if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);
        if (spreadStartLoc) this.unexpected(spreadStartLoc);
        this.checkExpressionErrors(refExpressionErrors, true);
        this.toReferencedListDeep(exprList, true);
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartLoc);
          val.expressions = exprList;
          this.finishNode(val, "SequenceExpression");
          this.resetEndLocation(val, innerEndLoc);
        } else {
          val = exprList[0];
        }
        return this.wrapParenthesis(startLoc, val);
      }
      wrapParenthesis(startLoc, expression) {
        if (!(this.optionFlags & 1024)) {
          this.addExtra(expression, "parenthesized", true);
          this.addExtra(expression, "parenStart", startLoc.index);
          this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
          return expression;
        }
        const parenExpression = this.startNodeAt(startLoc);
        parenExpression.expression = expression;
        return this.finishNode(parenExpression, "ParenthesizedExpression");
      }
      shouldParseArrow(params) {
        return !this.canInsertSemicolon();
      }
      parseArrow(node) {
        if (this.eat(19)) {
          return node;
        }
      }
      parseParenItem(node, startLoc) {
        return node;
      }
      parseNewOrNewTarget() {
        const node = this.startNode();
        this.next();
        if (this.match(16)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
          this.next();
          const metaProp = this.parseMetaProperty(node, meta, "target");
          if (!this.scope.allowNewTarget) {
            this.raise(Errors.UnexpectedNewTarget, metaProp);
          }
          return metaProp;
        }
        return this.parseNew(node);
      }
      parseNew(node) {
        this.parseNewCallee(node);
        if (this.eat(10)) {
          const args = this.parseExprList(11);
          this.toReferencedList(args);
          node.arguments = args;
        } else {
          node.arguments = [];
        }
        return this.finishNode(node, "NewExpression");
      }
      parseNewCallee(node) {
        const isImport = this.match(83);
        const callee = this.parseNoCallExpr();
        node.callee = callee;
        if (isImport && (callee.type === "Import" || callee.type === "ImportExpression")) {
          this.raise(Errors.ImportCallNotNewExpression, callee);
        }
      }
      parseTemplateElement(isTagged) {
        const {
          start,
          startLoc,
          end,
          value
        } = this.state;
        const elemStart = start + 1;
        const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
        if (value === null) {
          if (!isTagged) {
            this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));
          }
        }
        const isTail = this.match(24);
        const endOffset = isTail ? -1 : -2;
        const elemEnd = end + endOffset;
        elem.value = {
          raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
          cooked: value === null ? null : value.slice(1, endOffset)
        };
        elem.tail = isTail;
        this.next();
        const finishedNode = this.finishNode(elem, "TemplateElement");
        this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
        return finishedNode;
      }
      parseTemplate(isTagged) {
        const node = this.startNode();
        let curElt = this.parseTemplateElement(isTagged);
        const quasis = [curElt];
        const substitutions = [];
        while (!curElt.tail) {
          substitutions.push(this.parseTemplateSubstitution());
          this.readTemplateContinuation();
          quasis.push(curElt = this.parseTemplateElement(isTagged));
        }
        node.expressions = substitutions;
        node.quasis = quasis;
        return this.finishNode(node, "TemplateLiteral");
      }
      parseTemplateSubstitution() {
        return this.parseExpression();
      }
      parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
        if (isRecord) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        let sawProto = false;
        let first = true;
        const node = this.startNode();
        node.properties = [];
        this.next();
        while (!this.match(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              this.addTrailingCommaExtraToNode(node);
              break;
            }
          }
          let prop;
          if (isPattern) {
            prop = this.parseBindingProperty();
          } else {
            prop = this.parsePropertyDefinition(refExpressionErrors);
            sawProto = this.checkProto(prop, isRecord, sawProto, refExpressionErrors);
          }
          if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
            this.raise(Errors.InvalidRecordProperty, prop);
          }
          {
            if (prop.shorthand) {
              this.addExtra(prop, "shorthand", true);
            }
          }
          node.properties.push(prop);
        }
        this.next();
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let type = "ObjectExpression";
        if (isPattern) {
          type = "ObjectPattern";
        } else if (isRecord) {
          type = "RecordExpression";
        }
        return this.finishNode(node, type);
      }
      addTrailingCommaExtraToNode(node) {
        this.addExtra(node, "trailingComma", this.state.lastTokStartLoc.index);
        this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
      }
      maybeAsyncOrAccessorProp(prop) {
        return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
      }
      parsePropertyDefinition(refExpressionErrors) {
        let decorators = [];
        if (this.match(26)) {
          if (this.hasPlugin("decorators")) {
            this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);
          }
          while (this.match(26)) {
            decorators.push(this.parseDecorator());
          }
        }
        const prop = this.startNode();
        let isAsync = false;
        let isAccessor = false;
        let startLoc;
        if (this.match(21)) {
          if (decorators.length) this.unexpected();
          return this.parseSpread();
        }
        if (decorators.length) {
          prop.decorators = decorators;
          decorators = [];
        }
        prop.method = false;
        if (refExpressionErrors) {
          startLoc = this.state.startLoc;
        }
        let isGenerator = this.eat(55);
        this.parsePropertyNamePrefixOperator(prop);
        const containsEsc = this.state.containsEsc;
        this.parsePropertyName(prop, refExpressionErrors);
        if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
          const {
            key
          } = prop;
          const keyName = key.name;
          if (keyName === "async" && !this.hasPrecedingLineBreak()) {
            isAsync = true;
            this.resetPreviousNodeTrailingComments(key);
            isGenerator = this.eat(55);
            this.parsePropertyName(prop);
          }
          if (keyName === "get" || keyName === "set") {
            isAccessor = true;
            this.resetPreviousNodeTrailingComments(key);
            prop.kind = keyName;
            if (this.match(55)) {
              isGenerator = true;
              this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {
                kind: keyName
              });
              this.next();
            }
            this.parsePropertyName(prop);
          }
        }
        return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
      }
      getGetterSetterExpectedParamCount(method) {
        return method.kind === "get" ? 0 : 1;
      }
      getObjectOrClassMethodParams(method) {
        return method.params;
      }
      checkGetterSetterParams(method) {
        var _params;
        const paramCount = this.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length !== paramCount) {
          this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, method);
        }
        if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
          this.raise(Errors.BadSetterRestParameter, method);
        }
      }
      parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        if (isAccessor) {
          const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
          this.checkGetterSetterParams(finishedProp);
          return finishedProp;
        }
        if (isAsync || isGenerator || this.match(10)) {
          if (isPattern) this.unexpected();
          prop.kind = "method";
          prop.method = true;
          return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
        }
      }
      parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        prop.shorthand = false;
        if (this.eat(14)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
          return this.finishObjectProperty(prop);
        }
        if (!prop.computed && prop.key.type === "Identifier") {
          this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));
          } else if (this.match(29)) {
            const shorthandAssignLoc = this.state.startLoc;
            if (refExpressionErrors != null) {
              if (refExpressionErrors.shorthandAssignLoc === null) {
                refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
              }
            } else {
              this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
            }
            prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));
          } else {
            prop.value = this.cloneIdentifier(prop.key);
          }
          prop.shorthand = true;
          return this.finishObjectProperty(prop);
        }
      }
      finishObjectProperty(node) {
        return this.finishNode(node, "ObjectProperty");
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
        if (!node) this.unexpected();
        return node;
      }
      parsePropertyName(prop, refExpressionErrors) {
        if (this.eat(0)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssignAllowIn();
          this.expect(3);
        } else {
          const {
            type,
            value
          } = this.state;
          let key;
          if (tokenIsKeywordOrIdentifier(type)) {
            key = this.parseIdentifier(true);
          } else {
            switch (type) {
              case 135:
                key = this.parseNumericLiteral(value);
                break;
              case 134:
                key = this.parseStringLiteral(value);
                break;
              case 136:
                key = this.parseBigIntLiteral(value);
                break;
              case 139: {
                const privateKeyLoc = this.state.startLoc;
                if (refExpressionErrors != null) {
                  if (refExpressionErrors.privateKeyLoc === null) {
                    refExpressionErrors.privateKeyLoc = privateKeyLoc;
                  }
                } else {
                  this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
                }
                key = this.parsePrivateName();
                break;
              }
              default:
                if (type === 137) {
                  key = this.parseDecimalLiteral(value);
                  break;
                }
                this.unexpected();
            }
          }
          prop.key = key;
          if (type !== 139) {
            prop.computed = false;
          }
        }
      }
      initFunction(node, isAsync) {
        node.id = null;
        node.generator = false;
        node.async = isAsync;
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        this.initFunction(node, isAsync);
        node.generator = isGenerator;
        this.scope.enter(514 | 16 | (inClassScope ? 576 : 0) | (allowDirectSuper ? 32 : 0));
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        this.parseFunctionParams(node, isConstructor);
        const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
        this.prodParam.exit();
        this.scope.exit();
        return finishedNode;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        if (isTuple) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const node = this.startNode();
        this.next();
        node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
      }
      parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
        this.scope.enter(514 | 4);
        let flags = functionFlags(isAsync, false);
        if (!this.match(5) && this.prodParam.hasIn) {
          flags |= 8;
        }
        this.prodParam.enter(flags);
        this.initFunction(node, isAsync);
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        if (params) {
          this.state.maybeInArrowParameters = true;
          this.setArrowFunctionParameters(node, params, trailingCommaLoc);
        }
        this.state.maybeInArrowParameters = false;
        this.parseFunctionBody(node, true);
        this.prodParam.exit();
        this.scope.exit();
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node, "ArrowFunctionExpression");
      }
      setArrowFunctionParameters(node, params, trailingCommaLoc) {
        this.toAssignableList(params, trailingCommaLoc, false);
        node.params = params;
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        this.parseFunctionBody(node, false, isMethod);
        return this.finishNode(node, type);
      }
      parseFunctionBody(node, allowExpression, isMethod = false) {
        const isExpression = allowExpression && !this.match(5);
        this.expressionScope.enter(newExpressionScope());
        if (isExpression) {
          node.body = this.parseMaybeAssign();
          this.checkParams(node, false, allowExpression, false);
        } else {
          const oldStrict = this.state.strict;
          const oldLabels = this.state.labels;
          this.state.labels = [];
          this.prodParam.enter(this.prodParam.currentFlags() | 4);
          node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
            const nonSimple = !this.isSimpleParamList(node.params);
            if (hasStrictModeDirective && nonSimple) {
              this.raise(Errors.IllegalLanguageModeDirective, (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node);
            }
            const strictModeChanged = !oldStrict && this.state.strict;
            this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
            if (this.state.strict && node.id) {
              this.checkIdentifier(node.id, 65, strictModeChanged);
            }
          });
          this.prodParam.exit();
          this.state.labels = oldLabels;
        }
        this.expressionScope.exit();
      }
      isSimpleParameter(node) {
        return node.type === "Identifier";
      }
      isSimpleParamList(params) {
        for (let i = 0, len = params.length; i < len; i++) {
          if (!this.isSimpleParameter(params[i])) return false;
        }
        return true;
      }
      checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();
        const formalParameters = {
          type: "FormalParameters"
        };
        for (const param of node.params) {
          this.checkLVal(param, formalParameters, 5, checkClashes, strictModeChanged);
        }
      }
      parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
        const elts = [];
        let first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              if (nodeForExtra) {
                this.addTrailingCommaExtraToNode(nodeForExtra);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
        }
        return elts;
      }
      parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
        let elt;
        if (this.match(12)) {
          if (!allowEmpty) {
            this.raise(Errors.UnexpectedToken, this.state.curPosition(), {
              unexpected: ","
            });
          }
          elt = null;
        } else if (this.match(21)) {
          const spreadNodeStartLoc = this.state.startLoc;
          elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
        } else if (this.match(17)) {
          this.expectPlugin("partialApplication");
          if (!allowPlaceholder) {
            this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);
          }
          const node = this.startNode();
          this.next();
          elt = this.finishNode(node, "ArgumentPlaceholder");
        } else {
          elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
        }
        return elt;
      }
      parseIdentifier(liberal) {
        const node = this.startNode();
        const name50 = this.parseIdentifierName(liberal);
        return this.createIdentifier(node, name50);
      }
      createIdentifier(node, name50) {
        node.name = name50;
        node.loc.identifierName = name50;
        return this.finishNode(node, "Identifier");
      }
      createIdentifierAt(node, name50, endLoc) {
        node.name = name50;
        node.loc.identifierName = name50;
        return this.finishNodeAt(node, "Identifier", endLoc);
      }
      parseIdentifierName(liberal) {
        let name50;
        const {
          startLoc,
          type
        } = this.state;
        if (tokenIsKeywordOrIdentifier(type)) {
          name50 = this.state.value;
        } else {
          this.unexpected();
        }
        const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
        if (liberal) {
          if (tokenIsKeyword2) {
            this.replaceToken(132);
          }
        } else {
          this.checkReservedWord(name50, startLoc, tokenIsKeyword2, false);
        }
        this.next();
        return name50;
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (word.length > 10) {
          return;
        }
        if (!canBeReservedWord(word)) {
          return;
        }
        if (checkKeywords && isKeyword2(word)) {
          this.raise(Errors.UnexpectedKeyword, startLoc, {
            keyword: word
          });
          return;
        }
        const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
        if (reservedTest(word, this.inModule)) {
          this.raise(Errors.UnexpectedReservedWord, startLoc, {
            reservedWord: word
          });
          return;
        } else if (word === "yield") {
          if (this.prodParam.hasYield) {
            this.raise(Errors.YieldBindingIdentifier, startLoc);
            return;
          }
        } else if (word === "await") {
          if (this.prodParam.hasAwait) {
            this.raise(Errors.AwaitBindingIdentifier, startLoc);
            return;
          }
          if (this.scope.inStaticBlock) {
            this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);
            return;
          }
          this.expressionScope.recordAsyncArrowParametersError(startLoc);
        } else if (word === "arguments") {
          if (this.scope.inClassAndNotInNonArrowFunction) {
            this.raise(Errors.ArgumentsInClass, startLoc);
            return;
          }
        }
      }
      recordAwaitIfAllowed() {
        const isAwaitAllowed = this.prodParam.hasAwait;
        if (isAwaitAllowed && !this.scope.inFunction) {
          this.state.hasTopLevelAwait = true;
        }
        return isAwaitAllowed;
      }
      parseAwait(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);
        if (this.eat(55)) {
          this.raise(Errors.ObsoleteAwaitStar, node);
        }
        if (!this.scope.inFunction && !(this.optionFlags & 1)) {
          if (this.isAmbiguousPrefixOrIdentifier()) {
            this.ambiguousScriptDifferentAst = true;
          } else {
            this.sawUnambiguousESM = true;
          }
        }
        if (!this.state.soloAwait) {
          node.argument = this.parseMaybeUnary(null, true);
        }
        return this.finishNode(node, "AwaitExpression");
      }
      isAmbiguousPrefixOrIdentifier() {
        if (this.hasPrecedingLineBreak()) return true;
        const {
          type
        } = this.state;
        return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 138 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
      }
      parseYield(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);
        let delegating = false;
        let argument = null;
        if (!this.hasPrecedingLineBreak()) {
          delegating = this.eat(55);
          switch (this.state.type) {
            case 13:
            case 140:
            case 8:
            case 11:
            case 3:
            case 9:
            case 14:
            case 12:
              if (!delegating) break;
            default:
              argument = this.parseMaybeAssign();
          }
        }
        node.delegate = delegating;
        node.argument = argument;
        return this.finishNode(node, "YieldExpression");
      }
      parseImportCall(node) {
        this.next();
        node.source = this.parseMaybeAssignAllowIn();
        node.options = null;
        if (this.eat(12)) {
          if (!this.match(11)) {
            node.options = this.parseMaybeAssignAllowIn();
            if (this.eat(12)) {
              this.addTrailingCommaExtraToNode(node.options);
              if (!this.match(11)) {
                do {
                  this.parseMaybeAssignAllowIn();
                } while (this.eat(12) && !this.match(11));
                this.raise(Errors.ImportCallArity, node);
              }
            }
          } else {
            this.addTrailingCommaExtraToNode(node.source);
          }
        }
        this.expect(11);
        return this.finishNode(node, "ImportExpression");
      }
      checkPipelineAtInfixOperator(left, leftStartLoc) {
        if (this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }])) {
          if (left.type === "SequenceExpression") {
            this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);
          }
        }
      }
      parseSmartPipelineBodyInStyle(childExpr, startLoc) {
        if (this.isSimpleReference(childExpr)) {
          const bodyNode = this.startNodeAt(startLoc);
          bodyNode.callee = childExpr;
          return this.finishNode(bodyNode, "PipelineBareFunction");
        } else {
          const bodyNode = this.startNodeAt(startLoc);
          this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
          bodyNode.expression = childExpr;
          return this.finishNode(bodyNode, "PipelineTopicExpression");
        }
      }
      isSimpleReference(expression) {
        switch (expression.type) {
          case "MemberExpression":
            return !expression.computed && this.isSimpleReference(expression.object);
          case "Identifier":
            return true;
          default:
            return false;
        }
      }
      checkSmartPipeTopicBodyEarlyErrors(startLoc) {
        if (this.match(19)) {
          throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);
        }
        if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(Errors.PipelineTopicUnused, startLoc);
        }
      }
      withTopicBindingContext(callback) {
        const outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 1,
          maxTopicIndex: null
        };
        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      }
      withSmartMixTopicForbiddingContext(callback) {
        if (this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }])) {
          const outerContextTopicState = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
          };
          try {
            return callback();
          } finally {
            this.state.topicContext = outerContextTopicState;
          }
        } else {
          return callback();
        }
      }
      withSoloAwaitPermittingContext(callback) {
        const outerContextSoloAwaitState = this.state.soloAwait;
        this.state.soloAwait = true;
        try {
          return callback();
        } finally {
          this.state.soloAwait = outerContextSoloAwaitState;
        }
      }
      allowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToSet = 8 & ~flags;
        if (prodParamToSet) {
          this.prodParam.enter(flags | 8);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      disallowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToClear = 8 & flags;
        if (prodParamToClear) {
          this.prodParam.enter(flags & ~8);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      registerTopicReference() {
        this.state.topicContext.maxTopicIndex = 0;
      }
      topicReferenceIsAllowedInCurrentContext() {
        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
      }
      topicReferenceWasUsedInCurrentContext() {
        return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
      }
      parseFSharpPipelineBody(prec) {
        const startLoc = this.state.startLoc;
        this.state.potentialArrowAt = this.state.start;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = true;
        const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return ret;
      }
      parseModuleExpression() {
        this.expectPlugin("moduleBlocks");
        const node = this.startNode();
        this.next();
        if (!this.match(5)) {
          this.unexpected(null, 5);
        }
        const program = this.startNodeAt(this.state.endLoc);
        this.next();
        const revertScopes = this.initializeScopes(true);
        this.enterInitialScopes();
        try {
          node.body = this.parseProgram(program, 8, "module");
        } finally {
          revertScopes();
        }
        return this.finishNode(node, "ModuleExpression");
      }
      parsePropertyNamePrefixOperator(prop) {
      }
    };
    var loopLabel = {
      kind: 1
    };
    var switchLabel = {
      kind: 2
    };
    var loneSurrogate = /[\uD800-\uDFFF]/u;
    var keywordRelationalOperator = /in(?:stanceof)?/y;
    function babel7CompatTokens(tokens, input, startIndex) {
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        const {
          type
        } = token;
        if (typeof type === "number") {
          {
            if (type === 139) {
              const {
                loc,
                start,
                value,
                end
              } = token;
              const hashEndPos = start + 1;
              const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
              tokens.splice(i, 1, new Token({
                type: getExportedToken(27),
                value: "#",
                start,
                end: hashEndPos,
                startLoc: loc.start,
                endLoc: hashEndLoc
              }), new Token({
                type: getExportedToken(132),
                value,
                start: hashEndPos,
                end,
                startLoc: hashEndLoc,
                endLoc: loc.end
              }));
              i++;
              continue;
            }
            if (tokenIsTemplate(type)) {
              const {
                loc,
                start,
                value,
                end
              } = token;
              const backquoteEnd = start + 1;
              const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
              let startToken;
              if (input.charCodeAt(start - startIndex) === 96) {
                startToken = new Token({
                  type: getExportedToken(22),
                  value: "`",
                  start,
                  end: backquoteEnd,
                  startLoc: loc.start,
                  endLoc: backquoteEndLoc
                });
              } else {
                startToken = new Token({
                  type: getExportedToken(8),
                  value: "}",
                  start,
                  end: backquoteEnd,
                  startLoc: loc.start,
                  endLoc: backquoteEndLoc
                });
              }
              let templateValue, templateElementEnd, templateElementEndLoc, endToken;
              if (type === 24) {
                templateElementEnd = end - 1;
                templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
                templateValue = value === null ? null : value.slice(1, -1);
                endToken = new Token({
                  type: getExportedToken(22),
                  value: "`",
                  start: templateElementEnd,
                  end,
                  startLoc: templateElementEndLoc,
                  endLoc: loc.end
                });
              } else {
                templateElementEnd = end - 2;
                templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
                templateValue = value === null ? null : value.slice(1, -2);
                endToken = new Token({
                  type: getExportedToken(23),
                  value: "${",
                  start: templateElementEnd,
                  end,
                  startLoc: templateElementEndLoc,
                  endLoc: loc.end
                });
              }
              tokens.splice(i, 1, startToken, new Token({
                type: getExportedToken(20),
                value: templateValue,
                start: backquoteEnd,
                end: templateElementEnd,
                startLoc: backquoteEndLoc,
                endLoc: templateElementEndLoc
              }), endToken);
              i += 2;
              continue;
            }
          }
          token.type = getExportedToken(type);
        }
      }
      return tokens;
    }
    var StatementParser = class extends ExpressionParser {
      parseTopLevel(file, program) {
        file.program = this.parseProgram(program);
        file.comments = this.comments;
        if (this.optionFlags & 256) {
          file.tokens = babel7CompatTokens(this.tokens, this.input, this.startIndex);
        }
        return this.finishNode(file, "File");
      }
      parseProgram(program, end = 140, sourceType = this.options.sourceType) {
        program.sourceType = sourceType;
        program.interpreter = this.parseInterpreterDirective();
        this.parseBlockBody(program, true, true, end);
        if (this.inModule) {
          if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0) {
            for (const [localName, at] of Array.from(this.scope.undefinedExports)) {
              this.raise(Errors.ModuleExportUndefined, at, {
                localName
              });
            }
          }
          this.addExtra(program, "topLevelAwait", this.state.hasTopLevelAwait);
        }
        let finishedProgram;
        if (end === 140) {
          finishedProgram = this.finishNode(program, "Program");
        } else {
          finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
        }
        return finishedProgram;
      }
      stmtToDirective(stmt) {
        const directive = this.castNodeTo(stmt, "Directive");
        const directiveLiteral = this.castNodeTo(stmt.expression, "DirectiveLiteral");
        const expressionValue = directiveLiteral.value;
        const raw = this.input.slice(this.offsetToSourcePos(directiveLiteral.start), this.offsetToSourcePos(directiveLiteral.end));
        const val = directiveLiteral.value = raw.slice(1, -1);
        this.addExtra(directiveLiteral, "raw", raw);
        this.addExtra(directiveLiteral, "rawValue", val);
        this.addExtra(directiveLiteral, "expressionValue", expressionValue);
        directive.value = directiveLiteral;
        delete stmt.expression;
        return directive;
      }
      parseInterpreterDirective() {
        if (!this.match(28)) {
          return null;
        }
        const node = this.startNode();
        node.value = this.state.value;
        this.next();
        return this.finishNode(node, "InterpreterDirective");
      }
      isLet() {
        if (!this.isContextual(100)) {
          return false;
        }
        return this.hasFollowingBindingAtom();
      }
      isUsing() {
        if (!this.isContextual(107)) {
          return false;
        }
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        return this.chStartsBindingIdentifier(nextCh, next);
      }
      isForUsing() {
        if (!this.isContextual(107)) {
          return false;
        }
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        if (this.isUnparsedContextual(next, "of")) {
          const nextCharAfterOf = this.lookaheadCharCodeSince(next + 2);
          if (nextCharAfterOf !== 61 && nextCharAfterOf !== 58 && nextCharAfterOf !== 59) {
            return false;
          }
        }
        if (this.chStartsBindingIdentifier(nextCh, next)) {
          this.expectPlugin("explicitResourceManagement");
          return true;
        }
        return false;
      }
      isAwaitUsing() {
        if (!this.isContextual(96)) {
          return false;
        }
        let next = this.nextTokenInLineStart();
        if (this.isUnparsedContextual(next, "using")) {
          next = this.nextTokenInLineStartSince(next + 5);
          const nextCh = this.codePointAtPos(next);
          if (this.chStartsBindingIdentifier(nextCh, next)) {
            this.expectPlugin("explicitResourceManagement");
            return true;
          }
        }
        return false;
      }
      chStartsBindingIdentifier(ch, pos) {
        if (isIdentifierStart2(ch)) {
          keywordRelationalOperator.lastIndex = pos;
          if (keywordRelationalOperator.test(this.input)) {
            const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
            if (!isIdentifierChar(endCh) && endCh !== 92) {
              return false;
            }
          }
          return true;
        } else if (ch === 92) {
          return true;
        } else {
          return false;
        }
      }
      chStartsBindingPattern(ch) {
        return ch === 91 || ch === 123;
      }
      hasFollowingBindingAtom() {
        const next = this.nextTokenStart();
        const nextCh = this.codePointAtPos(next);
        return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
      }
      hasInLineFollowingBindingIdentifierOrBrace() {
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);
      }
      allowsUsing() {
        return (this.scope.inModule || !this.scope.inTopLevel) && !this.scope.inBareCaseStatement;
      }
      parseModuleItem() {
        return this.parseStatementLike(1 | 2 | 4 | 8);
      }
      parseStatementListItem() {
        return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
      }
      parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {
        let flags = 0;
        if (this.options.annexB && !this.state.strict) {
          flags |= 4;
          if (allowLabeledFunction) {
            flags |= 8;
          }
        }
        return this.parseStatementLike(flags);
      }
      parseStatement() {
        return this.parseStatementLike(0);
      }
      parseStatementLike(flags) {
        let decorators = null;
        if (this.match(26)) {
          decorators = this.parseDecorators(true);
        }
        return this.parseStatementContent(flags, decorators);
      }
      parseStatementContent(flags, decorators) {
        const startType = this.state.type;
        const node = this.startNode();
        const allowDeclaration = !!(flags & 2);
        const allowFunctionDeclaration = !!(flags & 4);
        const topLevel = flags & 1;
        switch (startType) {
          case 60:
            return this.parseBreakContinueStatement(node, true);
          case 63:
            return this.parseBreakContinueStatement(node, false);
          case 64:
            return this.parseDebuggerStatement(node);
          case 90:
            return this.parseDoWhileStatement(node);
          case 91:
            return this.parseForStatement(node);
          case 68:
            if (this.lookaheadCharCode() === 46) break;
            if (!allowFunctionDeclaration) {
              this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);
            }
            return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
          case 80:
            if (!allowDeclaration) this.unexpected();
            return this.parseClass(this.maybeTakeDecorators(decorators, node), true);
          case 69:
            return this.parseIfStatement(node);
          case 70:
            return this.parseReturnStatement(node);
          case 71:
            return this.parseSwitchStatement(node);
          case 72:
            return this.parseThrowStatement(node);
          case 73:
            return this.parseTryStatement(node);
          case 96:
            if (this.isAwaitUsing()) {
              if (!this.allowsUsing()) {
                this.raise(Errors.UnexpectedUsingDeclaration, node);
              } else if (!allowDeclaration) {
                this.raise(Errors.UnexpectedLexicalDeclaration, node);
              } else if (!this.recordAwaitIfAllowed()) {
                this.raise(Errors.AwaitUsingNotInAsyncContext, node);
              }
              this.next();
              return this.parseVarStatement(node, "await using");
            }
            break;
          case 107:
            if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) {
              break;
            }
            this.expectPlugin("explicitResourceManagement");
            if (!this.allowsUsing()) {
              this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);
            } else if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
            }
            return this.parseVarStatement(node, "using");
          case 100: {
            if (this.state.containsEsc) {
              break;
            }
            const next = this.nextTokenStart();
            const nextCh = this.codePointAtPos(next);
            if (nextCh !== 91) {
              if (!allowDeclaration && this.hasFollowingLineBreak()) break;
              if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
                break;
              }
            }
          }
          case 75: {
            if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
            }
          }
          case 74: {
            const kind = this.state.value;
            return this.parseVarStatement(node, kind);
          }
          case 92:
            return this.parseWhileStatement(node);
          case 76:
            return this.parseWithStatement(node);
          case 5:
            return this.parseBlock();
          case 13:
            return this.parseEmptyStatement(node);
          case 83: {
            const nextTokenCharCode = this.lookaheadCharCode();
            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
              break;
            }
          }
          case 82: {
            if (!(this.optionFlags & 8) && !topLevel) {
              this.raise(Errors.UnexpectedImportExport, this.state.startLoc);
            }
            this.next();
            let result;
            if (startType === 83) {
              result = this.parseImport(node);
            } else {
              result = this.parseExport(node, decorators);
            }
            this.assertModuleNodeAllowed(result);
            return result;
          }
          default: {
            if (this.isAsyncFunction()) {
              if (!allowDeclaration) {
                this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);
              }
              this.next();
              return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
            }
          }
        }
        const maybeName = this.state.value;
        const expr = this.parseExpression();
        if (tokenIsIdentifier(startType) && expr.type === "Identifier" && this.eat(14)) {
          return this.parseLabeledStatement(node, maybeName, expr, flags);
        } else {
          return this.parseExpressionStatement(node, expr, decorators);
        }
      }
      assertModuleNodeAllowed(node) {
        if (!(this.optionFlags & 8) && !this.inModule) {
          this.raise(Errors.ImportOutsideModule, node);
        }
      }
      decoratorsEnabledBeforeExport() {
        if (this.hasPlugin("decorators-legacy")) return true;
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
      }
      maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
        if (maybeDecorators) {
          var _classNode$decorators;
          if ((_classNode$decorators = classNode.decorators) != null && _classNode$decorators.length) {
            if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
              this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);
            }
            classNode.decorators.unshift(...maybeDecorators);
          } else {
            classNode.decorators = maybeDecorators;
          }
          this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
          if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);
        }
        return classNode;
      }
      canHaveLeadingDecorator() {
        return this.match(80);
      }
      parseDecorators(allowExport) {
        const decorators = [];
        do {
          decorators.push(this.parseDecorator());
        } while (this.match(26));
        if (this.match(82)) {
          if (!allowExport) {
            this.unexpected();
          }
          if (!this.decoratorsEnabledBeforeExport()) {
            this.raise(Errors.DecoratorExportClass, this.state.startLoc);
          }
        } else if (!this.canHaveLeadingDecorator()) {
          throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);
        }
        return decorators;
      }
      parseDecorator() {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);
        const node = this.startNode();
        this.next();
        if (this.hasPlugin("decorators")) {
          const startLoc = this.state.startLoc;
          let expr;
          if (this.match(10)) {
            const startLoc2 = this.state.startLoc;
            this.next();
            expr = this.parseExpression();
            this.expect(11);
            expr = this.wrapParenthesis(startLoc2, expr);
            const paramsStartLoc = this.state.startLoc;
            node.expression = this.parseMaybeDecoratorArguments(expr, startLoc2);
            if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node.expression !== expr) {
              this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);
            }
          } else {
            expr = this.parseIdentifier(false);
            while (this.eat(16)) {
              const node2 = this.startNodeAt(startLoc);
              node2.object = expr;
              if (this.match(139)) {
                this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                node2.property = this.parsePrivateName();
              } else {
                node2.property = this.parseIdentifier(true);
              }
              node2.computed = false;
              expr = this.finishNode(node2, "MemberExpression");
            }
            node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);
          }
        } else {
          node.expression = this.parseExprSubscripts();
        }
        return this.finishNode(node, "Decorator");
      }
      parseMaybeDecoratorArguments(expr, startLoc) {
        if (this.eat(10)) {
          const node = this.startNodeAt(startLoc);
          node.callee = expr;
          node.arguments = this.parseCallExpressionArguments(11);
          this.toReferencedList(node.arguments);
          return this.finishNode(node, "CallExpression");
        }
        return expr;
      }
      parseBreakContinueStatement(node, isBreak) {
        this.next();
        if (this.isLineTerminator()) {
          node.label = null;
        } else {
          node.label = this.parseIdentifier();
          this.semicolon();
        }
        this.verifyBreakContinue(node, isBreak);
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      }
      verifyBreakContinue(node, isBreak) {
        let i;
        for (i = 0; i < this.state.labels.length; ++i) {
          const lab = this.state.labels[i];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === 1)) {
              break;
            }
            if (node.label && isBreak) break;
          }
        }
        if (i === this.state.labels.length) {
          const type = isBreak ? "BreakStatement" : "ContinueStatement";
          this.raise(Errors.IllegalBreakContinue, node, {
            type
          });
        }
      }
      parseDebuggerStatement(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      }
      parseHeaderExpression() {
        this.expect(10);
        const val = this.parseExpression();
        this.expect(11);
        return val;
      }
      parseDoWhileStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.state.labels.pop();
        this.expect(92);
        node.test = this.parseHeaderExpression();
        this.eat(13);
        return this.finishNode(node, "DoWhileStatement");
      }
      parseForStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        let awaitAt = null;
        if (this.isContextual(96) && this.recordAwaitIfAllowed()) {
          awaitAt = this.state.startLoc;
          this.next();
        }
        this.scope.enter(0);
        this.expect(10);
        if (this.match(13)) {
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        const startsWithLet = this.isContextual(100);
        {
          const startsWithAwaitUsing = this.isAwaitUsing();
          const starsWithUsingDeclaration = startsWithAwaitUsing || this.isForUsing();
          const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
          if (this.match(74) || this.match(75) || isLetOrUsing) {
            const initNode = this.startNode();
            let kind;
            if (startsWithAwaitUsing) {
              kind = "await using";
              if (!this.recordAwaitIfAllowed()) {
                this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);
              }
              this.next();
            } else {
              kind = this.state.value;
            }
            this.next();
            this.parseVar(initNode, true, kind);
            const init2 = this.finishNode(initNode, "VariableDeclaration");
            const isForIn = this.match(58);
            if (isForIn && starsWithUsingDeclaration) {
              this.raise(Errors.ForInUsing, init2);
            }
            if ((isForIn || this.isContextual(102)) && init2.declarations.length === 1) {
              return this.parseForIn(node, init2, awaitAt);
            }
            if (awaitAt !== null) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node, init2);
          }
        }
        const startsWithAsync = this.isContextual(95);
        const refExpressionErrors = new ExpressionErrors();
        const init = this.parseExpression(true, refExpressionErrors);
        const isForOf = this.isContextual(102);
        if (isForOf) {
          if (startsWithLet) {
            this.raise(Errors.ForOfLet, init);
          }
          if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
            this.raise(Errors.ForOfAsync, init);
          }
        }
        if (isForOf || this.match(58)) {
          this.checkDestructuringPrivate(refExpressionErrors);
          this.toAssignable(init, true);
          const type = isForOf ? "ForOfStatement" : "ForInStatement";
          this.checkLVal(init, {
            type
          });
          return this.parseForIn(node, init, awaitAt);
        } else {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        if (awaitAt !== null) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      }
      parseFunctionStatement(node, isAsync, isHangingDeclaration) {
        this.next();
        return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
      }
      parseIfStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
        node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
        return this.finishNode(node, "IfStatement");
      }
      parseReturnStatement(node) {
        if (!this.prodParam.hasReturn) {
          this.raise(Errors.IllegalReturn, this.state.startLoc);
        }
        this.next();
        if (this.isLineTerminator()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      }
      parseSwitchStatement(node) {
        this.next();
        node.discriminant = this.parseHeaderExpression();
        const cases = node.cases = [];
        this.expect(5);
        this.state.labels.push(switchLabel);
        this.scope.enter(256);
        let cur;
        for (let sawDefault; !this.match(8); ) {
          if (this.match(61) || this.match(65)) {
            const isCase = this.match(61);
            if (cur) this.finishNode(cur, "SwitchCase");
            cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(14);
          } else {
            if (cur) {
              cur.consequent.push(this.parseStatementListItem());
            } else {
              this.unexpected();
            }
          }
        }
        this.scope.exit();
        if (cur) this.finishNode(cur, "SwitchCase");
        this.next();
        this.state.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      }
      parseThrowStatement(node) {
        this.next();
        if (this.hasPrecedingLineBreak()) {
          this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      }
      parseCatchClauseParam() {
        const param = this.parseBindingAtom();
        this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0);
        this.checkLVal(param, {
          type: "CatchClause"
        }, 9);
        return param;
      }
      parseTryStatement(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.match(62)) {
          const clause = this.startNode();
          this.next();
          if (this.match(10)) {
            this.expect(10);
            clause.param = this.parseCatchClauseParam();
            this.expect(11);
          } else {
            clause.param = null;
            this.scope.enter(0);
          }
          clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
          this.scope.exit();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(67) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(Errors.NoCatchOrFinally, node);
        }
        return this.finishNode(node, "TryStatement");
      }
      parseVarStatement(node, kind, allowMissingInitializer = false) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      }
      parseWhileStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.state.labels.pop();
        return this.finishNode(node, "WhileStatement");
      }
      parseWithStatement(node) {
        if (this.state.strict) {
          this.raise(Errors.StrictWith, this.state.startLoc);
        }
        this.next();
        node.object = this.parseHeaderExpression();
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        return this.finishNode(node, "WithStatement");
      }
      parseEmptyStatement(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      }
      parseLabeledStatement(node, maybeName, expr, flags) {
        for (const label of this.state.labels) {
          if (label.name === maybeName) {
            this.raise(Errors.LabelRedeclaration, expr, {
              labelName: maybeName
            });
          }
        }
        const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;
        for (let i = this.state.labels.length - 1; i >= 0; i--) {
          const label = this.state.labels[i];
          if (label.statementStart === node.start) {
            label.statementStart = this.sourceToOffsetPos(this.state.start);
            label.kind = kind;
          } else {
            break;
          }
        }
        this.state.labels.push({
          name: maybeName,
          kind,
          statementStart: this.sourceToOffsetPos(this.state.start)
        });
        node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
        this.state.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      }
      parseExpressionStatement(node, expr, decorators) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      }
      parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
        const node = this.startNode();
        if (allowDirectives) {
          this.state.strictErrors.clear();
        }
        this.expect(5);
        if (createNewLexicalScope) {
          this.scope.enter(0);
        }
        this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
        if (createNewLexicalScope) {
          this.scope.exit();
        }
        return this.finishNode(node, "BlockStatement");
      }
      isValidDirective(stmt) {
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
      }
      parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        const body = node.body = [];
        const directives = node.directives = [];
        this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
      }
      parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
        const oldStrict = this.state.strict;
        let hasStrictModeDirective = false;
        let parsedNonDirective = false;
        while (!this.match(end)) {
          const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
          if (directives && !parsedNonDirective) {
            if (this.isValidDirective(stmt)) {
              const directive = this.stmtToDirective(stmt);
              directives.push(directive);
              if (!hasStrictModeDirective && directive.value.value === "use strict") {
                hasStrictModeDirective = true;
                this.setStrict(true);
              }
              continue;
            }
            parsedNonDirective = true;
            this.state.strictErrors.clear();
          }
          body.push(stmt);
        }
        afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);
        if (!oldStrict) {
          this.setStrict(false);
        }
        this.next();
      }
      parseFor(node, init) {
        node.init = init;
        this.semicolon(false);
        node.test = this.match(13) ? null : this.parseExpression();
        this.semicolon(false);
        node.update = this.match(11) ? null : this.parseExpression();
        this.expect(11);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, "ForStatement");
      }
      parseForIn(node, init, awaitAt) {
        const isForIn = this.match(58);
        this.next();
        if (isForIn) {
          if (awaitAt !== null) this.unexpected(awaitAt);
        } else {
          node.await = awaitAt !== null;
        }
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(Errors.ForInOfLoopInitializer, init, {
            type: isForIn ? "ForInStatement" : "ForOfStatement"
          });
        }
        if (init.type === "AssignmentPattern") {
          this.raise(Errors.InvalidLhs, init, {
            ancestor: {
              type: "ForStatement"
            }
          });
        }
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
        this.expect(11);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      }
      parseVar(node, isFor, kind, allowMissingInitializer = false) {
        const declarations = node.declarations = [];
        node.kind = kind;
        for (; ; ) {
          const decl = this.startNode();
          this.parseVarId(decl, kind);
          decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
          if (decl.init === null && !allowMissingInitializer) {
            if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102)))) {
              this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                kind: "destructuring"
              });
            } else if ((kind === "const" || kind === "using" || kind === "await using") && !(this.match(58) || this.isContextual(102))) {
              this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                kind
              });
            }
          }
          declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(12)) break;
        }
        return node;
      }
      parseVarId(decl, kind) {
        const id = this.parseBindingAtom();
        if (kind === "using" || kind === "await using") {
          if (id.type === "ArrayPattern" || id.type === "ObjectPattern") {
            this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start);
          }
        }
        this.checkLVal(id, {
          type: "VariableDeclarator"
        }, kind === "var" ? 5 : 8201);
        decl.id = id;
      }
      parseAsyncFunctionExpression(node) {
        return this.parseFunction(node, 8);
      }
      parseFunction(node, flags = 0) {
        const hangingDeclaration = flags & 2;
        const isDeclaration = !!(flags & 1);
        const requireId = isDeclaration && !(flags & 4);
        const isAsync = !!(flags & 8);
        this.initFunction(node, isAsync);
        if (this.match(55)) {
          if (hangingDeclaration) {
            this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);
          }
          this.next();
          node.generator = true;
        }
        if (isDeclaration) {
          node.id = this.parseFunctionId(requireId);
        }
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = false;
        this.scope.enter(514);
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        if (!isDeclaration) {
          node.id = this.parseFunctionId();
        }
        this.parseFunctionParams(node, false);
        this.withSmartMixTopicForbiddingContext(() => {
          this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
        });
        this.prodParam.exit();
        this.scope.exit();
        if (isDeclaration && !hangingDeclaration) {
          this.registerFunctionStatementId(node);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return node;
      }
      parseFunctionId(requireId) {
        return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
      }
      parseFunctionParams(node, isConstructor) {
        this.expect(10);
        this.expressionScope.enter(newParameterDeclarationScope());
        node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));
        this.expressionScope.exit();
      }
      registerFunctionStatementId(node) {
        if (!node.id) return;
        this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);
      }
      parseClass(node, isStatement, optionalId) {
        this.next();
        const oldStrict = this.state.strict;
        this.state.strict = true;
        this.parseClassId(node, isStatement, optionalId);
        this.parseClassSuper(node);
        node.body = this.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      }
      isClassProperty() {
        return this.match(29) || this.match(13) || this.match(8);
      }
      isClassMethod() {
        return this.match(10);
      }
      nameIsConstructor(key) {
        return key.type === "Identifier" && key.name === "constructor" || key.type === "StringLiteral" && key.value === "constructor";
      }
      isNonstaticConstructor(method) {
        return !method.computed && !method.static && this.nameIsConstructor(method.key);
      }
      parseClassBody(hadSuperClass, oldStrict) {
        this.classScope.enter();
        const state = {
          hadConstructor: false,
          hadSuperClass
        };
        let decorators = [];
        const classBody = this.startNode();
        classBody.body = [];
        this.expect(5);
        this.withSmartMixTopicForbiddingContext(() => {
          while (!this.match(8)) {
            if (this.eat(13)) {
              if (decorators.length > 0) {
                throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);
              }
              continue;
            }
            if (this.match(26)) {
              decorators.push(this.parseDecorator());
              continue;
            }
            const member = this.startNode();
            if (decorators.length) {
              member.decorators = decorators;
              this.resetStartLocationFromNode(member, decorators[0]);
              decorators = [];
            }
            this.parseClassMember(classBody, member, state);
            if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
              this.raise(Errors.DecoratorConstructor, member);
            }
          }
        });
        this.state.strict = oldStrict;
        this.next();
        if (decorators.length) {
          throw this.raise(Errors.TrailingDecorator, this.state.startLoc);
        }
        this.classScope.exit();
        return this.finishNode(classBody, "ClassBody");
      }
      parseClassMemberFromModifier(classBody, member) {
        const key = this.parseIdentifier(true);
        if (this.isClassMethod()) {
          const method = member;
          method.kind = "method";
          method.computed = false;
          method.key = key;
          method.static = false;
          this.pushClassMethod(classBody, method, false, false, false, false);
          return true;
        } else if (this.isClassProperty()) {
          const prop = member;
          prop.computed = false;
          prop.key = key;
          prop.static = false;
          classBody.body.push(this.parseClassProperty(prop));
          return true;
        }
        this.resetPreviousNodeTrailingComments(key);
        return false;
      }
      parseClassMember(classBody, member, state) {
        const isStatic = this.isContextual(106);
        if (isStatic) {
          if (this.parseClassMemberFromModifier(classBody, member)) {
            return;
          }
          if (this.eat(5)) {
            this.parseClassStaticBlock(classBody, member);
            return;
          }
        }
        this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const publicMethod = member;
        const privateMethod = member;
        const publicProp = member;
        const privateProp = member;
        const accessorProp = member;
        const method = publicMethod;
        const publicMember = publicMethod;
        member.static = isStatic;
        this.parsePropertyNamePrefixOperator(member);
        if (this.eat(55)) {
          method.kind = "method";
          const isPrivateName = this.match(139);
          this.parseClassElementName(method);
          this.parsePostMemberNameModifiers(method);
          if (isPrivateName) {
            this.pushClassPrivateMethod(classBody, privateMethod, true, false);
            return;
          }
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(Errors.ConstructorIsGenerator, publicMethod.key);
          }
          this.pushClassMethod(classBody, publicMethod, true, false, false, false);
          return;
        }
        const isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type);
        const key = this.parseClassElementName(member);
        const maybeContextualKw = isContextual ? key.name : null;
        const isPrivate = this.isPrivateName(key);
        const maybeQuestionTokenStartLoc = this.state.startLoc;
        this.parsePostMemberNameModifiers(publicMember);
        if (this.isClassMethod()) {
          method.kind = "method";
          if (isPrivate) {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
            return;
          }
          const isConstructor = this.isNonstaticConstructor(publicMethod);
          let allowsDirectSuper = false;
          if (isConstructor) {
            publicMethod.kind = "constructor";
            if (state.hadConstructor && !this.hasPlugin("typescript")) {
              this.raise(Errors.DuplicateConstructor, key);
            }
            if (isConstructor && this.hasPlugin("typescript") && member.override) {
              this.raise(Errors.OverrideOnConstructor, key);
            }
            state.hadConstructor = true;
            allowsDirectSuper = state.hadSuperClass;
          }
          this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
        } else if (this.isClassProperty()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else if (maybeContextualKw === "async" && !this.isLineTerminator()) {
          this.resetPreviousNodeTrailingComments(key);
          const isGenerator = this.eat(55);
          if (publicMember.optional) {
            this.unexpected(maybeQuestionTokenStartLoc);
          }
          method.kind = "method";
          const isPrivate2 = this.match(139);
          this.parseClassElementName(method);
          this.parsePostMemberNameModifiers(publicMember);
          if (isPrivate2) {
            this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsAsync, publicMethod.key);
            }
            this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
          }
        } else if ((maybeContextualKw === "get" || maybeContextualKw === "set") && !(this.match(55) && this.isLineTerminator())) {
          this.resetPreviousNodeTrailingComments(key);
          method.kind = maybeContextualKw;
          const isPrivate2 = this.match(139);
          this.parseClassElementName(publicMethod);
          if (isPrivate2) {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsAccessor, publicMethod.key);
            }
            this.pushClassMethod(classBody, publicMethod, false, false, false, false);
          }
          this.checkGetterSetterParams(publicMethod);
        } else if (maybeContextualKw === "accessor" && !this.isLineTerminator()) {
          this.expectPlugin("decoratorAutoAccessors");
          this.resetPreviousNodeTrailingComments(key);
          const isPrivate2 = this.match(139);
          this.parseClassElementName(publicProp);
          this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
        } else if (this.isLineTerminator()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else {
          this.unexpected();
        }
      }
      parseClassElementName(member) {
        const {
          type,
          value
        } = this.state;
        if ((type === 132 || type === 134) && member.static && value === "prototype") {
          this.raise(Errors.StaticPrototype, this.state.startLoc);
        }
        if (type === 139) {
          if (value === "constructor") {
            this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);
          }
          const key = this.parsePrivateName();
          member.key = key;
          return key;
        }
        this.parsePropertyName(member);
        return member.key;
      }
      parseClassStaticBlock(classBody, member) {
        var _member$decorators;
        this.scope.enter(576 | 128 | 16);
        const oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(0);
        const body = member.body = [];
        this.parseBlockOrModuleBlockBody(body, void 0, false, 8);
        this.prodParam.exit();
        this.scope.exit();
        this.state.labels = oldLabels;
        classBody.body.push(this.finishNode(member, "StaticBlock"));
        if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
          this.raise(Errors.DecoratorStaticBlock, member);
        }
      }
      pushClassProperty(classBody, prop) {
        if (!prop.computed && this.nameIsConstructor(prop.key)) {
          this.raise(Errors.ConstructorClassField, prop.key);
        }
        classBody.body.push(this.parseClassProperty(prop));
      }
      pushClassPrivateProperty(classBody, prop) {
        const node = this.parseClassPrivateProperty(prop);
        classBody.body.push(node);
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
      }
      pushClassAccessorProperty(classBody, prop, isPrivate) {
        if (!isPrivate && !prop.computed && this.nameIsConstructor(prop.key)) {
          this.raise(Errors.ConstructorClassField, prop.key);
        }
        const node = this.parseClassAccessorProperty(prop);
        classBody.body.push(node);
        if (isPrivate) {
          this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
        }
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
        classBody.body.push(node);
        const kind = node.kind === "get" ? node.static ? 6 : 2 : node.kind === "set" ? node.static ? 5 : 1 : 0;
        this.declareClassPrivateMethodInScope(node, kind);
      }
      declareClassPrivateMethodInScope(node, kind) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
      }
      parsePostMemberNameModifiers(methodOrProp) {
      }
      parseClassPrivateProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassPrivateProperty");
      }
      parseClassProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassProperty");
      }
      parseClassAccessorProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassAccessorProperty");
      }
      parseInitializer(node) {
        this.scope.enter(576 | 16);
        this.expressionScope.enter(newExpressionScope());
        this.prodParam.enter(0);
        node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
        this.expressionScope.exit();
        this.prodParam.exit();
        this.scope.exit();
      }
      parseClassId(node, isStatement, optionalId, bindingType = 8331) {
        if (tokenIsIdentifier(this.state.type)) {
          node.id = this.parseIdentifier();
          if (isStatement) {
            this.declareNameFromIdentifier(node.id, bindingType);
          }
        } else {
          if (optionalId || !isStatement) {
            node.id = null;
          } else {
            throw this.raise(Errors.MissingClassName, this.state.startLoc);
          }
        }
      }
      parseClassSuper(node) {
        node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
      }
      parseExport(node, decorators) {
        const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);
        const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
        const parseAfterDefault = !hasDefault || this.eat(12);
        const hasStar = parseAfterDefault && this.eatExportStar(node);
        const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
        const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
        const isFromRequired = hasDefault || hasStar;
        if (hasStar && !hasNamespace) {
          if (hasDefault) this.unexpected();
          if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          this.parseExportFrom(node, true);
          this.sawUnambiguousESM = true;
          return this.finishNode(node, "ExportAllDeclaration");
        }
        const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
        if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
          this.unexpected(null, 5);
        }
        if (hasNamespace && parseAfterNamespace) {
          this.unexpected(null, 98);
        }
        let hasDeclaration;
        if (isFromRequired || hasSpecifiers) {
          hasDeclaration = false;
          if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          this.parseExportFrom(node, isFromRequired);
        } else {
          hasDeclaration = this.maybeParseExportDeclaration(node);
        }
        if (isFromRequired || hasSpecifiers || hasDeclaration) {
          var _node2$declaration;
          const node2 = node;
          this.checkExport(node2, true, false, !!node2.source);
          if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration") {
            this.maybeTakeDecorators(decorators, node2.declaration, node2);
          } else if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          this.sawUnambiguousESM = true;
          return this.finishNode(node2, "ExportNamedDeclaration");
        }
        if (this.eat(65)) {
          const node2 = node;
          const decl = this.parseExportDefaultExpression();
          node2.declaration = decl;
          if (decl.type === "ClassDeclaration") {
            this.maybeTakeDecorators(decorators, decl, node2);
          } else if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          this.checkExport(node2, true, true);
          this.sawUnambiguousESM = true;
          return this.finishNode(node2, "ExportDefaultDeclaration");
        }
        this.unexpected(null, 5);
      }
      eatExportStar(node) {
        return this.eat(55);
      }
      maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
          this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);
          const id = maybeDefaultIdentifier || this.parseIdentifier(true);
          const specifier = this.startNodeAtNode(id);
          specifier.exported = id;
          node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
          return true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(node) {
        if (this.isContextual(93)) {
          var _ref, _ref$specifiers;
          (_ref$specifiers = (_ref = node).specifiers) != null ? _ref$specifiers : _ref.specifiers = [];
          const specifier = this.startNodeAt(this.state.lastTokStartLoc);
          this.next();
          specifier.exported = this.parseModuleExportName();
          node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
          return true;
        }
        return false;
      }
      maybeParseExportNamedSpecifiers(node) {
        if (this.match(5)) {
          const node2 = node;
          if (!node2.specifiers) node2.specifiers = [];
          const isTypeExport = node2.exportKind === "type";
          node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
          node2.source = null;
          if (this.hasPlugin("importAssertions")) {
            node2.assertions = [];
          } else {
            node2.attributes = [];
          }
          node2.declaration = null;
          return true;
        }
        return false;
      }
      maybeParseExportDeclaration(node) {
        if (this.shouldParseExportDeclaration()) {
          node.specifiers = [];
          node.source = null;
          if (this.hasPlugin("importAssertions")) {
            node.assertions = [];
          } else {
            node.attributes = [];
          }
          node.declaration = this.parseExportDeclaration(node);
          return true;
        }
        return false;
      }
      isAsyncFunction() {
        if (!this.isContextual(95)) return false;
        const next = this.nextTokenInLineStart();
        return this.isUnparsedContextual(next, "function");
      }
      parseExportDefaultExpression() {
        const expr = this.startNode();
        if (this.match(68)) {
          this.next();
          return this.parseFunction(expr, 1 | 4);
        } else if (this.isAsyncFunction()) {
          this.next();
          this.next();
          return this.parseFunction(expr, 1 | 4 | 8);
        }
        if (this.match(80)) {
          return this.parseClass(expr, true, true);
        }
        if (this.match(26)) {
          if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
            this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
          }
          return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
        }
        if (this.match(75) || this.match(74) || this.isLet() || this.hasPlugin("explicitResourceManagement") && (this.isUsing() || this.isAwaitUsing())) {
          throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);
        }
        const res = this.parseMaybeAssignAllowIn();
        this.semicolon();
        return res;
      }
      parseExportDeclaration(node) {
        if (this.match(80)) {
          const node2 = this.parseClass(this.startNode(), true, false);
          return node2;
        }
        return this.parseStatementListItem();
      }
      isExportDefaultSpecifier() {
        const {
          type
        } = this.state;
        if (tokenIsIdentifier(type)) {
          if (type === 95 && !this.state.containsEsc || type === 100) {
            return false;
          }
          if ((type === 130 || type === 129) && !this.state.containsEsc) {
            const next2 = this.nextTokenStart();
            const nextChar = this.input.charCodeAt(next2);
            if (nextChar === 123 || this.chStartsBindingIdentifier(nextChar, next2) && !this.input.startsWith("from", next2)) {
              this.expectOnePlugin(["flow", "typescript"]);
              return false;
            }
          }
        } else if (!this.match(65)) {
          return false;
        }
        const next = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next, "from");
        if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
          return true;
        }
        if (this.match(65) && hasFrom) {
          const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
          return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        return false;
      }
      parseExportFrom(node, expect) {
        if (this.eatContextual(98)) {
          node.source = this.parseImportSource();
          this.checkExport(node);
          this.maybeParseImportAttributes(node);
          this.checkJSONModuleImport(node);
        } else if (expect) {
          this.unexpected();
        }
        this.semicolon();
      }
      shouldParseExportDeclaration() {
        const {
          type
        } = this.state;
        if (type === 26) {
          this.expectOnePlugin(["decorators", "decorators-legacy"]);
          if (this.hasPlugin("decorators")) {
            if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
              this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
            }
            return true;
          }
        }
        if (this.hasPlugin("explicitResourceManagement")) {
          if (this.isUsing()) {
            this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
            return true;
          }
          if (this.isAwaitUsing()) {
            this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
            return true;
          }
        }
        return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
      }
      checkExport(node, checkNames, isDefault, isFrom) {
        if (checkNames) {
          var _node$specifiers;
          if (isDefault) {
            this.checkDuplicateExports(node, "default");
            if (this.hasPlugin("exportDefaultFrom")) {
              var _declaration$extra;
              const declaration = node.declaration;
              if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
                this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);
              }
            }
          } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
            for (const specifier of node.specifiers) {
              const {
                exported
              } = specifier;
              const exportName = exported.type === "Identifier" ? exported.name : exported.value;
              this.checkDuplicateExports(specifier, exportName);
              if (!isFrom && specifier.local) {
                const {
                  local
                } = specifier;
                if (local.type !== "Identifier") {
                  this.raise(Errors.ExportBindingIsString, specifier, {
                    localName: local.value,
                    exportName
                  });
                } else {
                  this.checkReservedWord(local.name, local.loc.start, true, false);
                  this.scope.checkLocalExport(local);
                }
              }
            }
          } else if (node.declaration) {
            const decl = node.declaration;
            if (decl.type === "FunctionDeclaration" || decl.type === "ClassDeclaration") {
              const {
                id
              } = decl;
              if (!id) throw new Error("Assertion failure");
              this.checkDuplicateExports(node, id.name);
            } else if (decl.type === "VariableDeclaration") {
              for (const declaration of decl.declarations) {
                this.checkDeclaration(declaration.id);
              }
            }
          }
        }
      }
      checkDeclaration(node) {
        if (node.type === "Identifier") {
          this.checkDuplicateExports(node, node.name);
        } else if (node.type === "ObjectPattern") {
          for (const prop of node.properties) {
            this.checkDeclaration(prop);
          }
        } else if (node.type === "ArrayPattern") {
          for (const elem of node.elements) {
            if (elem) {
              this.checkDeclaration(elem);
            }
          }
        } else if (node.type === "ObjectProperty") {
          this.checkDeclaration(node.value);
        } else if (node.type === "RestElement") {
          this.checkDeclaration(node.argument);
        } else if (node.type === "AssignmentPattern") {
          this.checkDeclaration(node.left);
        }
      }
      checkDuplicateExports(node, exportName) {
        if (this.exportedIdentifiers.has(exportName)) {
          if (exportName === "default") {
            this.raise(Errors.DuplicateDefaultExport, node);
          } else {
            this.raise(Errors.DuplicateExport, node, {
              exportName
            });
          }
        }
        this.exportedIdentifiers.add(exportName);
      }
      parseExportSpecifiers(isInTypeExport) {
        const nodes = [];
        let first = true;
        this.expect(5);
        while (!this.eat(8)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.eat(8)) break;
          }
          const isMaybeTypeOnly = this.isContextual(130);
          const isString2 = this.match(134);
          const node = this.startNode();
          node.local = this.parseModuleExportName();
          nodes.push(this.parseExportSpecifier(node, isString2, isInTypeExport, isMaybeTypeOnly));
        }
        return nodes;
      }
      parseExportSpecifier(node, isString2, isInTypeExport, isMaybeTypeOnly) {
        if (this.eatContextual(93)) {
          node.exported = this.parseModuleExportName();
        } else if (isString2) {
          node.exported = this.cloneStringLiteral(node.local);
        } else if (!node.exported) {
          node.exported = this.cloneIdentifier(node.local);
        }
        return this.finishNode(node, "ExportSpecifier");
      }
      parseModuleExportName() {
        if (this.match(134)) {
          const result = this.parseStringLiteral(this.state.value);
          const surrogate = loneSurrogate.exec(result.value);
          if (surrogate) {
            this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {
              surrogateCharCode: surrogate[0].charCodeAt(0)
            });
          }
          return result;
        }
        return this.parseIdentifier(true);
      }
      isJSONModuleImport(node) {
        if (node.assertions != null) {
          return node.assertions.some(({
            key,
            value
          }) => {
            return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
          });
        }
        return false;
      }
      checkImportReflection(node) {
        const {
          specifiers
        } = node;
        const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
        if (node.phase === "source") {
          if (singleBindingType !== "ImportDefaultSpecifier") {
            this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);
          }
        } else if (node.phase === "defer") {
          if (singleBindingType !== "ImportNamespaceSpecifier") {
            this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);
          }
        } else if (node.module) {
          var _node$assertions;
          if (singleBindingType !== "ImportDefaultSpecifier") {
            this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);
          }
          if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {
            this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);
          }
        }
      }
      checkJSONModuleImport(node) {
        if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
          const {
            specifiers
          } = node;
          if (specifiers != null) {
            const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
              let imported;
              if (specifier.type === "ExportSpecifier") {
                imported = specifier.local;
              } else if (specifier.type === "ImportSpecifier") {
                imported = specifier.imported;
              }
              if (imported !== void 0) {
                return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
              }
            });
            if (nonDefaultNamedSpecifier !== void 0) {
              this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);
            }
          }
        }
      }
      isPotentialImportPhase(isExport) {
        if (isExport) return false;
        return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
      }
      applyImportPhase(node, isExport, phase, loc) {
        if (isExport) {
          return;
        }
        if (phase === "module") {
          this.expectPlugin("importReflection", loc);
          node.module = true;
        } else if (this.hasPlugin("importReflection")) {
          node.module = false;
        }
        if (phase === "source") {
          this.expectPlugin("sourcePhaseImports", loc);
          node.phase = "source";
        } else if (phase === "defer") {
          this.expectPlugin("deferredImportEvaluation", loc);
          node.phase = "defer";
        } else if (this.hasPlugin("sourcePhaseImports")) {
          node.phase = null;
        }
      }
      parseMaybeImportPhase(node, isExport) {
        if (!this.isPotentialImportPhase(isExport)) {
          this.applyImportPhase(node, isExport, null);
          return null;
        }
        const phaseIdentifier = this.startNode();
        const phaseIdentifierName = this.parseIdentifierName(true);
        const {
          type
        } = this.state;
        const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
        if (isImportPhase) {
          this.applyImportPhase(node, isExport, phaseIdentifierName, phaseIdentifier.loc.start);
          return null;
        } else {
          this.applyImportPhase(node, isExport, null);
          return this.createIdentifier(phaseIdentifier, phaseIdentifierName);
        }
      }
      isPrecedingIdImportPhase(phase) {
        const {
          type
        } = this.state;
        return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
      }
      parseImport(node) {
        if (this.match(134)) {
          return this.parseImportSourceAndAttributes(node);
        }
        return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));
      }
      parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
        node.specifiers = [];
        const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);
        const parseNext = !hasDefault || this.eat(12);
        const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
        this.expectContextual(98);
        return this.parseImportSourceAndAttributes(node);
      }
      parseImportSourceAndAttributes(node) {
        var _node$specifiers2;
        (_node$specifiers2 = node.specifiers) != null ? _node$specifiers2 : node.specifiers = [];
        node.source = this.parseImportSource();
        this.maybeParseImportAttributes(node);
        this.checkImportReflection(node);
        this.checkJSONModuleImport(node);
        this.semicolon();
        this.sawUnambiguousESM = true;
        return this.finishNode(node, "ImportDeclaration");
      }
      parseImportSource() {
        if (!this.match(134)) this.unexpected();
        return this.parseExprAtom();
      }
      parseImportSpecifierLocal(node, specifier, type) {
        specifier.local = this.parseIdentifier();
        node.specifiers.push(this.finishImportSpecifier(specifier, type));
      }
      finishImportSpecifier(specifier, type, bindingType = 8201) {
        this.checkLVal(specifier.local, {
          type
        }, bindingType);
        return this.finishNode(specifier, type);
      }
      parseImportAttributes() {
        this.expect(5);
        const attrs = [];
        const attrNames = /* @__PURE__ */ new Set();
        do {
          if (this.match(8)) {
            break;
          }
          const node = this.startNode();
          const keyName = this.state.value;
          if (attrNames.has(keyName)) {
            this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
              key: keyName
            });
          }
          attrNames.add(keyName);
          if (this.match(134)) {
            node.key = this.parseStringLiteral(keyName);
          } else {
            node.key = this.parseIdentifier(true);
          }
          this.expect(14);
          if (!this.match(134)) {
            throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
          }
          node.value = this.parseStringLiteral(this.state.value);
          attrs.push(this.finishNode(node, "ImportAttribute"));
        } while (this.eat(12));
        this.expect(8);
        return attrs;
      }
      parseModuleAttributes() {
        const attrs = [];
        const attributes = /* @__PURE__ */ new Set();
        do {
          const node = this.startNode();
          node.key = this.parseIdentifier(true);
          if (node.key.name !== "type") {
            this.raise(Errors.ModuleAttributeDifferentFromType, node.key);
          }
          if (attributes.has(node.key.name)) {
            this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {
              key: node.key.name
            });
          }
          attributes.add(node.key.name);
          this.expect(14);
          if (!this.match(134)) {
            throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
          }
          node.value = this.parseStringLiteral(this.state.value);
          attrs.push(this.finishNode(node, "ImportAttribute"));
        } while (this.eat(12));
        return attrs;
      }
      maybeParseImportAttributes(node) {
        let attributes;
        {
          var useWith = false;
        }
        if (this.match(76)) {
          if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
            return;
          }
          this.next();
          if (this.hasPlugin("moduleAttributes")) {
            attributes = this.parseModuleAttributes();
            this.addExtra(node, "deprecatedWithLegacySyntax", true);
          } else {
            attributes = this.parseImportAttributes();
          }
          {
            useWith = true;
          }
        } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
          if (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importAssertions")) {
            this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);
          }
          if (!this.hasPlugin("importAssertions")) {
            this.addExtra(node, "deprecatedAssertSyntax", true);
          }
          this.next();
          attributes = this.parseImportAttributes();
        } else {
          attributes = [];
        }
        if (!useWith && this.hasPlugin("importAssertions")) {
          node.assertions = attributes;
        } else {
          node.attributes = attributes;
        }
      }
      maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier) {
          const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
          specifier.local = maybeDefaultIdentifier;
          node.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));
          return true;
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
          return true;
        }
        return false;
      }
      maybeParseStarImportSpecifier(node) {
        if (this.match(55)) {
          const specifier = this.startNode();
          this.next();
          this.expectContextual(93);
          this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
          return true;
        }
        return false;
      }
      parseNamedImportSpecifiers(node) {
        let first = true;
        this.expect(5);
        while (!this.eat(8)) {
          if (first) {
            first = false;
          } else {
            if (this.eat(14)) {
              throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);
            }
            this.expect(12);
            if (this.eat(8)) break;
          }
          const specifier = this.startNode();
          const importedIsString = this.match(134);
          const isMaybeTypeOnly = this.isContextual(130);
          specifier.imported = this.parseModuleExportName();
          const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, void 0);
          node.specifiers.push(importSpecifier);
        }
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (this.eatContextual(93)) {
          specifier.local = this.parseIdentifier();
        } else {
          const {
            imported
          } = specifier;
          if (importedIsString) {
            throw this.raise(Errors.ImportBindingIsString, specifier, {
              importName: imported.value
            });
          }
          this.checkReservedWord(imported.name, specifier.loc.start, true, true);
          if (!specifier.local) {
            specifier.local = this.cloneIdentifier(imported);
          }
        }
        return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
      }
      isThisParam(param) {
        return param.type === "Identifier" && param.name === "this";
      }
    };
    var Parser = class extends StatementParser {
      constructor(options, input, pluginsMap) {
        options = getOptions(options);
        super(options, input);
        this.options = options;
        this.initializeScopes();
        this.plugins = pluginsMap;
        this.filename = options.sourceFilename;
        this.startIndex = options.startIndex;
        let optionFlags = 0;
        if (options.allowAwaitOutsideFunction) {
          optionFlags |= 1;
        }
        if (options.allowReturnOutsideFunction) {
          optionFlags |= 2;
        }
        if (options.allowImportExportEverywhere) {
          optionFlags |= 8;
        }
        if (options.allowSuperOutsideMethod) {
          optionFlags |= 16;
        }
        if (options.allowUndeclaredExports) {
          optionFlags |= 64;
        }
        if (options.allowNewTargetOutsideFunction) {
          optionFlags |= 4;
        }
        if (options.allowYieldOutsideFunction) {
          optionFlags |= 32;
        }
        if (options.ranges) {
          optionFlags |= 128;
        }
        if (options.tokens) {
          optionFlags |= 256;
        }
        if (options.createImportExpressions) {
          optionFlags |= 512;
        }
        if (options.createParenthesizedExpressions) {
          optionFlags |= 1024;
        }
        if (options.errorRecovery) {
          optionFlags |= 2048;
        }
        if (options.attachComment) {
          optionFlags |= 4096;
        }
        if (options.annexB) {
          optionFlags |= 8192;
        }
        this.optionFlags = optionFlags;
      }
      getScopeHandler() {
        return ScopeHandler;
      }
      parse() {
        this.enterInitialScopes();
        const file = this.startNode();
        const program = this.startNode();
        this.nextToken();
        file.errors = null;
        this.parseTopLevel(file, program);
        file.errors = this.state.errors;
        file.comments.length = this.state.commentsLen;
        return file;
      }
    };
    function parse53(input, options) {
      var _options;
      if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
        options = Object.assign({}, options);
        try {
          options.sourceType = "module";
          const parser = getParser(options, input);
          const ast = parser.parse();
          if (parser.sawUnambiguousESM) {
            return ast;
          }
          if (parser.ambiguousScriptDifferentAst) {
            try {
              options.sourceType = "script";
              return getParser(options, input).parse();
            } catch (_unused) {
            }
          } else {
            ast.program.sourceType = "script";
          }
          return ast;
        } catch (moduleError) {
          try {
            options.sourceType = "script";
            return getParser(options, input).parse();
          } catch (_unused2) {
          }
          throw moduleError;
        }
      } else {
        return getParser(options, input).parse();
      }
    }
    function parseExpression(input, options) {
      const parser = getParser(options, input);
      if (parser.options.strictMode) {
        parser.state.strict = true;
      }
      return parser.getExpression();
    }
    function generateExportedTokenTypes(internalTokenTypes) {
      const tokenTypes3 = {};
      for (const typeName of Object.keys(internalTokenTypes)) {
        tokenTypes3[typeName] = getExportedToken(internalTokenTypes[typeName]);
      }
      return tokenTypes3;
    }
    var tokTypes = generateExportedTokenTypes(tt);
    function getParser(options, input) {
      let cls = Parser;
      const pluginsMap = /* @__PURE__ */ new Map();
      if (options != null && options.plugins) {
        for (const plugin of options.plugins) {
          let name50, opts;
          if (typeof plugin === "string") {
            name50 = plugin;
          } else {
            [name50, opts] = plugin;
          }
          if (!pluginsMap.has(name50)) {
            pluginsMap.set(name50, opts || {});
          }
        }
        validatePlugins(pluginsMap);
        cls = getParserClass(pluginsMap);
      }
      return new cls(options, input, pluginsMap);
    }
    var parserClassCache = /* @__PURE__ */ new Map();
    function getParserClass(pluginsMap) {
      const pluginList = [];
      for (const name50 of mixinPluginNames) {
        if (pluginsMap.has(name50)) {
          pluginList.push(name50);
        }
      }
      const key = pluginList.join("|");
      let cls = parserClassCache.get(key);
      if (!cls) {
        cls = Parser;
        for (const plugin of pluginList) {
          cls = mixinPlugins[plugin](cls);
        }
        parserClassCache.set(key, cls);
      }
      return cls;
    }
    exports.parse = parse53;
    exports.parseExpression = parseExpression;
    exports.tokTypes = tokTypes;
  }
});

// node_modules/@babel/traverse/lib/path/lib/virtual-types.js
var require_virtual_types = __commonJS({
  "node_modules/@babel/traverse/lib/path/lib/virtual-types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Var = exports.User = exports.Statement = exports.SpreadProperty = exports.Scope = exports.RestProperty = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = exports.Referenced = exports.Pure = exports.NumericLiteralTypeAnnotation = exports.Generated = exports.ForAwaitStatement = exports.Flow = exports.Expression = exports.ExistentialTypeParam = exports.BlockScoped = exports.BindingIdentifier = void 0;
    var ReferencedIdentifier = exports.ReferencedIdentifier = ["Identifier", "JSXIdentifier"];
    var ReferencedMemberExpression = exports.ReferencedMemberExpression = ["MemberExpression"];
    var BindingIdentifier = exports.BindingIdentifier = ["Identifier"];
    var Statement = exports.Statement = ["Statement"];
    var Expression = exports.Expression = ["Expression"];
    var Scope = exports.Scope = ["Scopable", "Pattern"];
    var Referenced = exports.Referenced = null;
    var BlockScoped = exports.BlockScoped = null;
    var Var = exports.Var = ["VariableDeclaration"];
    var User = exports.User = null;
    var Generated = exports.Generated = null;
    var Pure = exports.Pure = null;
    var Flow = exports.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"];
    var RestProperty = exports.RestProperty = ["RestElement"];
    var SpreadProperty = exports.SpreadProperty = ["RestElement"];
    var ExistentialTypeParam = exports.ExistentialTypeParam = ["ExistsTypeAnnotation"];
    var NumericLiteralTypeAnnotation = exports.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"];
    var ForAwaitStatement = exports.ForAwaitStatement = ["ForOfStatement"];
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h3 = m * 60;
    var d = h3 * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse53(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse53(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n2 = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y;
        case "weeks":
        case "week":
        case "w":
          return n2 * w;
        case "days":
        case "day":
        case "d":
          return n2 * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h3;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h3) {
        return Math.round(ms / h3) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h3) {
        return plural(ms, msAbs, h3, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n2, name50) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms / n2) + " " + name50 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash3 = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash3 = (hash3 << 5) - hash3 + namespace.charCodeAt(i);
          hash3 |= 0;
        }
        return createDebug.colors[Math.abs(hash3) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name50) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name50, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name50, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned3 = false;
      return () => {
        if (!warned3) {
          warned3 = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/@babel/types/lib/utils/shallowEqual.js
var require_shallowEqual = __commonJS({
  "node_modules/@babel/types/lib/utils/shallowEqual.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = shallowEqual;
    function shallowEqual(actual, expected) {
      const keys = Object.keys(expected);
      for (const key of keys) {
        if (actual[key] !== expected[key]) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/@babel/types/lib/utils/deprecationWarning.js
var require_deprecationWarning = __commonJS({
  "node_modules/@babel/types/lib/utils/deprecationWarning.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = deprecationWarning;
    var warnings = /* @__PURE__ */ new Set();
    function deprecationWarning(oldName, newName, prefix = "", cacheKey = oldName) {
      if (warnings.has(cacheKey)) return;
      warnings.add(cacheKey);
      const {
        internal,
        trace
      } = captureShortStackTrace(1, 2);
      if (internal) {
        return;
      }
      console.warn(`${prefix}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`
${trace}`);
    }
    function captureShortStackTrace(skip, length2) {
      const {
        stackTraceLimit,
        prepareStackTrace
      } = Error;
      let stackTrace;
      Error.stackTraceLimit = 1 + skip + length2;
      Error.prepareStackTrace = function(err, stack) {
        stackTrace = stack;
      };
      new Error().stack;
      Error.stackTraceLimit = stackTraceLimit;
      Error.prepareStackTrace = prepareStackTrace;
      if (!stackTrace) return {
        internal: false,
        trace: ""
      };
      const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length2);
      return {
        internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
        trace: shortStackTrace.map((frame) => `    at ${frame}`).join("\n")
      };
    }
  }
});

// node_modules/@babel/types/lib/validators/generated/index.js
var require_generated = __commonJS({
  "node_modules/@babel/types/lib/validators/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isAccessor = isAccessor;
    exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
    exports.isArgumentPlaceholder = isArgumentPlaceholder;
    exports.isArrayExpression = isArrayExpression;
    exports.isArrayPattern = isArrayPattern;
    exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
    exports.isArrowFunctionExpression = isArrowFunctionExpression;
    exports.isAssignmentExpression = isAssignmentExpression;
    exports.isAssignmentPattern = isAssignmentPattern;
    exports.isAwaitExpression = isAwaitExpression;
    exports.isBigIntLiteral = isBigIntLiteral;
    exports.isBinary = isBinary;
    exports.isBinaryExpression = isBinaryExpression;
    exports.isBindExpression = isBindExpression;
    exports.isBlock = isBlock;
    exports.isBlockParent = isBlockParent;
    exports.isBlockStatement = isBlockStatement;
    exports.isBooleanLiteral = isBooleanLiteral;
    exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
    exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
    exports.isBreakStatement = isBreakStatement;
    exports.isCallExpression = isCallExpression;
    exports.isCatchClause = isCatchClause;
    exports.isClass = isClass;
    exports.isClassAccessorProperty = isClassAccessorProperty;
    exports.isClassBody = isClassBody;
    exports.isClassDeclaration = isClassDeclaration;
    exports.isClassExpression = isClassExpression;
    exports.isClassImplements = isClassImplements;
    exports.isClassMethod = isClassMethod;
    exports.isClassPrivateMethod = isClassPrivateMethod;
    exports.isClassPrivateProperty = isClassPrivateProperty;
    exports.isClassProperty = isClassProperty;
    exports.isCompletionStatement = isCompletionStatement;
    exports.isConditional = isConditional;
    exports.isConditionalExpression = isConditionalExpression;
    exports.isContinueStatement = isContinueStatement;
    exports.isDebuggerStatement = isDebuggerStatement;
    exports.isDecimalLiteral = isDecimalLiteral;
    exports.isDeclaration = isDeclaration;
    exports.isDeclareClass = isDeclareClass;
    exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
    exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
    exports.isDeclareFunction = isDeclareFunction;
    exports.isDeclareInterface = isDeclareInterface;
    exports.isDeclareModule = isDeclareModule;
    exports.isDeclareModuleExports = isDeclareModuleExports;
    exports.isDeclareOpaqueType = isDeclareOpaqueType;
    exports.isDeclareTypeAlias = isDeclareTypeAlias;
    exports.isDeclareVariable = isDeclareVariable;
    exports.isDeclaredPredicate = isDeclaredPredicate;
    exports.isDecorator = isDecorator;
    exports.isDirective = isDirective;
    exports.isDirectiveLiteral = isDirectiveLiteral;
    exports.isDoExpression = isDoExpression;
    exports.isDoWhileStatement = isDoWhileStatement;
    exports.isEmptyStatement = isEmptyStatement;
    exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
    exports.isEnumBody = isEnumBody;
    exports.isEnumBooleanBody = isEnumBooleanBody;
    exports.isEnumBooleanMember = isEnumBooleanMember;
    exports.isEnumDeclaration = isEnumDeclaration;
    exports.isEnumDefaultedMember = isEnumDefaultedMember;
    exports.isEnumMember = isEnumMember;
    exports.isEnumNumberBody = isEnumNumberBody;
    exports.isEnumNumberMember = isEnumNumberMember;
    exports.isEnumStringBody = isEnumStringBody;
    exports.isEnumStringMember = isEnumStringMember;
    exports.isEnumSymbolBody = isEnumSymbolBody;
    exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
    exports.isExportAllDeclaration = isExportAllDeclaration;
    exports.isExportDeclaration = isExportDeclaration;
    exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
    exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
    exports.isExportNamedDeclaration = isExportNamedDeclaration;
    exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
    exports.isExportSpecifier = isExportSpecifier;
    exports.isExpression = isExpression;
    exports.isExpressionStatement = isExpressionStatement;
    exports.isExpressionWrapper = isExpressionWrapper;
    exports.isFile = isFile;
    exports.isFlow = isFlow;
    exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
    exports.isFlowDeclaration = isFlowDeclaration;
    exports.isFlowPredicate = isFlowPredicate;
    exports.isFlowType = isFlowType;
    exports.isFor = isFor;
    exports.isForInStatement = isForInStatement;
    exports.isForOfStatement = isForOfStatement;
    exports.isForStatement = isForStatement;
    exports.isForXStatement = isForXStatement;
    exports.isFunction = isFunction;
    exports.isFunctionDeclaration = isFunctionDeclaration;
    exports.isFunctionExpression = isFunctionExpression;
    exports.isFunctionParameter = isFunctionParameter;
    exports.isFunctionParent = isFunctionParent;
    exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
    exports.isFunctionTypeParam = isFunctionTypeParam;
    exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
    exports.isIdentifier = isIdentifier;
    exports.isIfStatement = isIfStatement;
    exports.isImmutable = isImmutable;
    exports.isImport = isImport;
    exports.isImportAttribute = isImportAttribute;
    exports.isImportDeclaration = isImportDeclaration;
    exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
    exports.isImportExpression = isImportExpression;
    exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
    exports.isImportOrExportDeclaration = isImportOrExportDeclaration;
    exports.isImportSpecifier = isImportSpecifier;
    exports.isIndexedAccessType = isIndexedAccessType;
    exports.isInferredPredicate = isInferredPredicate;
    exports.isInterfaceDeclaration = isInterfaceDeclaration;
    exports.isInterfaceExtends = isInterfaceExtends;
    exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
    exports.isInterpreterDirective = isInterpreterDirective;
    exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
    exports.isJSX = isJSX;
    exports.isJSXAttribute = isJSXAttribute;
    exports.isJSXClosingElement = isJSXClosingElement;
    exports.isJSXClosingFragment = isJSXClosingFragment;
    exports.isJSXElement = isJSXElement;
    exports.isJSXEmptyExpression = isJSXEmptyExpression;
    exports.isJSXExpressionContainer = isJSXExpressionContainer;
    exports.isJSXFragment = isJSXFragment;
    exports.isJSXIdentifier = isJSXIdentifier;
    exports.isJSXMemberExpression = isJSXMemberExpression;
    exports.isJSXNamespacedName = isJSXNamespacedName;
    exports.isJSXOpeningElement = isJSXOpeningElement;
    exports.isJSXOpeningFragment = isJSXOpeningFragment;
    exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
    exports.isJSXSpreadChild = isJSXSpreadChild;
    exports.isJSXText = isJSXText;
    exports.isLVal = isLVal;
    exports.isLabeledStatement = isLabeledStatement;
    exports.isLiteral = isLiteral;
    exports.isLogicalExpression = isLogicalExpression;
    exports.isLoop = isLoop;
    exports.isMemberExpression = isMemberExpression;
    exports.isMetaProperty = isMetaProperty;
    exports.isMethod = isMethod;
    exports.isMiscellaneous = isMiscellaneous;
    exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
    exports.isModuleDeclaration = isModuleDeclaration;
    exports.isModuleExpression = isModuleExpression;
    exports.isModuleSpecifier = isModuleSpecifier;
    exports.isNewExpression = isNewExpression;
    exports.isNoop = isNoop;
    exports.isNullLiteral = isNullLiteral;
    exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
    exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
    exports.isNumberLiteral = isNumberLiteral;
    exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
    exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
    exports.isNumericLiteral = isNumericLiteral;
    exports.isObjectExpression = isObjectExpression;
    exports.isObjectMember = isObjectMember;
    exports.isObjectMethod = isObjectMethod;
    exports.isObjectPattern = isObjectPattern;
    exports.isObjectProperty = isObjectProperty;
    exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
    exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
    exports.isObjectTypeIndexer = isObjectTypeIndexer;
    exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
    exports.isObjectTypeProperty = isObjectTypeProperty;
    exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
    exports.isOpaqueType = isOpaqueType;
    exports.isOptionalCallExpression = isOptionalCallExpression;
    exports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
    exports.isOptionalMemberExpression = isOptionalMemberExpression;
    exports.isParenthesizedExpression = isParenthesizedExpression;
    exports.isPattern = isPattern;
    exports.isPatternLike = isPatternLike;
    exports.isPipelineBareFunction = isPipelineBareFunction;
    exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
    exports.isPipelineTopicExpression = isPipelineTopicExpression;
    exports.isPlaceholder = isPlaceholder;
    exports.isPrivate = isPrivate;
    exports.isPrivateName = isPrivateName;
    exports.isProgram = isProgram;
    exports.isProperty = isProperty2;
    exports.isPureish = isPureish;
    exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
    exports.isRecordExpression = isRecordExpression;
    exports.isRegExpLiteral = isRegExpLiteral;
    exports.isRegexLiteral = isRegexLiteral;
    exports.isRestElement = isRestElement;
    exports.isRestProperty = isRestProperty;
    exports.isReturnStatement = isReturnStatement;
    exports.isScopable = isScopable;
    exports.isSequenceExpression = isSequenceExpression;
    exports.isSpreadElement = isSpreadElement;
    exports.isSpreadProperty = isSpreadProperty;
    exports.isStandardized = isStandardized;
    exports.isStatement = isStatement;
    exports.isStaticBlock = isStaticBlock;
    exports.isStringLiteral = isStringLiteral;
    exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
    exports.isStringTypeAnnotation = isStringTypeAnnotation;
    exports.isSuper = isSuper;
    exports.isSwitchCase = isSwitchCase;
    exports.isSwitchStatement = isSwitchStatement;
    exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
    exports.isTSAnyKeyword = isTSAnyKeyword;
    exports.isTSArrayType = isTSArrayType;
    exports.isTSAsExpression = isTSAsExpression;
    exports.isTSBaseType = isTSBaseType;
    exports.isTSBigIntKeyword = isTSBigIntKeyword;
    exports.isTSBooleanKeyword = isTSBooleanKeyword;
    exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
    exports.isTSConditionalType = isTSConditionalType;
    exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
    exports.isTSConstructorType = isTSConstructorType;
    exports.isTSDeclareFunction = isTSDeclareFunction;
    exports.isTSDeclareMethod = isTSDeclareMethod;
    exports.isTSEntityName = isTSEntityName;
    exports.isTSEnumBody = isTSEnumBody;
    exports.isTSEnumDeclaration = isTSEnumDeclaration;
    exports.isTSEnumMember = isTSEnumMember;
    exports.isTSExportAssignment = isTSExportAssignment;
    exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
    exports.isTSExternalModuleReference = isTSExternalModuleReference;
    exports.isTSFunctionType = isTSFunctionType;
    exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
    exports.isTSImportType = isTSImportType;
    exports.isTSIndexSignature = isTSIndexSignature;
    exports.isTSIndexedAccessType = isTSIndexedAccessType;
    exports.isTSInferType = isTSInferType;
    exports.isTSInstantiationExpression = isTSInstantiationExpression;
    exports.isTSInterfaceBody = isTSInterfaceBody;
    exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
    exports.isTSIntersectionType = isTSIntersectionType;
    exports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
    exports.isTSLiteralType = isTSLiteralType;
    exports.isTSMappedType = isTSMappedType;
    exports.isTSMethodSignature = isTSMethodSignature;
    exports.isTSModuleBlock = isTSModuleBlock;
    exports.isTSModuleDeclaration = isTSModuleDeclaration;
    exports.isTSNamedTupleMember = isTSNamedTupleMember;
    exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
    exports.isTSNeverKeyword = isTSNeverKeyword;
    exports.isTSNonNullExpression = isTSNonNullExpression;
    exports.isTSNullKeyword = isTSNullKeyword;
    exports.isTSNumberKeyword = isTSNumberKeyword;
    exports.isTSObjectKeyword = isTSObjectKeyword;
    exports.isTSOptionalType = isTSOptionalType;
    exports.isTSParameterProperty = isTSParameterProperty;
    exports.isTSParenthesizedType = isTSParenthesizedType;
    exports.isTSPropertySignature = isTSPropertySignature;
    exports.isTSQualifiedName = isTSQualifiedName;
    exports.isTSRestType = isTSRestType;
    exports.isTSSatisfiesExpression = isTSSatisfiesExpression;
    exports.isTSStringKeyword = isTSStringKeyword;
    exports.isTSSymbolKeyword = isTSSymbolKeyword;
    exports.isTSTemplateLiteralType = isTSTemplateLiteralType;
    exports.isTSThisType = isTSThisType;
    exports.isTSTupleType = isTSTupleType;
    exports.isTSType = isTSType;
    exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
    exports.isTSTypeAnnotation = isTSTypeAnnotation;
    exports.isTSTypeAssertion = isTSTypeAssertion;
    exports.isTSTypeElement = isTSTypeElement;
    exports.isTSTypeLiteral = isTSTypeLiteral;
    exports.isTSTypeOperator = isTSTypeOperator;
    exports.isTSTypeParameter = isTSTypeParameter;
    exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
    exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
    exports.isTSTypePredicate = isTSTypePredicate;
    exports.isTSTypeQuery = isTSTypeQuery;
    exports.isTSTypeReference = isTSTypeReference;
    exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
    exports.isTSUnionType = isTSUnionType;
    exports.isTSUnknownKeyword = isTSUnknownKeyword;
    exports.isTSVoidKeyword = isTSVoidKeyword;
    exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
    exports.isTemplateElement = isTemplateElement;
    exports.isTemplateLiteral = isTemplateLiteral;
    exports.isTerminatorless = isTerminatorless;
    exports.isThisExpression = isThisExpression;
    exports.isThisTypeAnnotation = isThisTypeAnnotation;
    exports.isThrowStatement = isThrowStatement;
    exports.isTopicReference = isTopicReference;
    exports.isTryStatement = isTryStatement;
    exports.isTupleExpression = isTupleExpression;
    exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
    exports.isTypeAlias = isTypeAlias;
    exports.isTypeAnnotation = isTypeAnnotation;
    exports.isTypeCastExpression = isTypeCastExpression;
    exports.isTypeParameter = isTypeParameter;
    exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
    exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
    exports.isTypeScript = isTypeScript;
    exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
    exports.isUnaryExpression = isUnaryExpression;
    exports.isUnaryLike = isUnaryLike;
    exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
    exports.isUpdateExpression = isUpdateExpression;
    exports.isUserWhitespacable = isUserWhitespacable;
    exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
    exports.isVariableDeclaration = isVariableDeclaration;
    exports.isVariableDeclarator = isVariableDeclarator;
    exports.isVariance = isVariance;
    exports.isVoidPattern = isVoidPattern;
    exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
    exports.isWhile = isWhile;
    exports.isWhileStatement = isWhileStatement;
    exports.isWithStatement = isWithStatement;
    exports.isYieldExpression = isYieldExpression;
    var _shallowEqual = require_shallowEqual();
    var _deprecationWarning = require_deprecationWarning();
    function isArrayExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ArrayExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAssignmentExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "AssignmentExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBinaryExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "BinaryExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInterpreterDirective(node, opts) {
      if (!node) return false;
      if (node.type !== "InterpreterDirective") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDirective(node, opts) {
      if (!node) return false;
      if (node.type !== "Directive") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDirectiveLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "DirectiveLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBlockStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "BlockStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBreakStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "BreakStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isCallExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "CallExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isCatchClause(node, opts) {
      if (!node) return false;
      if (node.type !== "CatchClause") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isConditionalExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ConditionalExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isContinueStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "ContinueStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDebuggerStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "DebuggerStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDoWhileStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "DoWhileStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEmptyStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "EmptyStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExpressionStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "ExpressionStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFile(node, opts) {
      if (!node) return false;
      if (node.type !== "File") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isForInStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "ForInStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isForStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "ForStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "FunctionDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "FunctionExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isIdentifier(node, opts) {
      if (!node) return false;
      if (node.type !== "Identifier") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isIfStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "IfStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLabeledStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "LabeledStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStringLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "StringLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNumericLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "NumericLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNullLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "NullLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBooleanLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "BooleanLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRegExpLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "RegExpLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLogicalExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "LogicalExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMemberExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "MemberExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNewExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "NewExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isProgram(node, opts) {
      if (!node) return false;
      if (node.type !== "Program") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectMethod(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectMethod") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRestElement(node, opts) {
      if (!node) return false;
      if (node.type !== "RestElement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isReturnStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "ReturnStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSequenceExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "SequenceExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isParenthesizedExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ParenthesizedExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSwitchCase(node, opts) {
      if (!node) return false;
      if (node.type !== "SwitchCase") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSwitchStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "SwitchStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isThisExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ThisExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isThrowStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "ThrowStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTryStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "TryStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUnaryExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "UnaryExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUpdateExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "UpdateExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVariableDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "VariableDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVariableDeclarator(node, opts) {
      if (!node) return false;
      if (node.type !== "VariableDeclarator") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isWhileStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "WhileStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isWithStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "WithStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAssignmentPattern(node, opts) {
      if (!node) return false;
      if (node.type !== "AssignmentPattern") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isArrayPattern(node, opts) {
      if (!node) return false;
      if (node.type !== "ArrayPattern") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isArrowFunctionExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ArrowFunctionExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassBody(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassBody") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportAllDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "ExportAllDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportDefaultDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "ExportDefaultDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportNamedDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "ExportNamedDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportSpecifier(node, opts) {
      if (!node) return false;
      if (node.type !== "ExportSpecifier") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isForOfStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "ForOfStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "ImportDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportDefaultSpecifier(node, opts) {
      if (!node) return false;
      if (node.type !== "ImportDefaultSpecifier") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportNamespaceSpecifier(node, opts) {
      if (!node) return false;
      if (node.type !== "ImportNamespaceSpecifier") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportSpecifier(node, opts) {
      if (!node) return false;
      if (node.type !== "ImportSpecifier") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ImportExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMetaProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "MetaProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassMethod(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassMethod") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectPattern(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectPattern") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSpreadElement(node, opts) {
      if (!node) return false;
      if (node.type !== "SpreadElement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSuper(node, opts) {
      if (!node) return false;
      if (node.type !== "Super") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTaggedTemplateExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "TaggedTemplateExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTemplateElement(node, opts) {
      if (!node) return false;
      if (node.type !== "TemplateElement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTemplateLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "TemplateLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isYieldExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "YieldExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAwaitExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "AwaitExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImport(node, opts) {
      if (!node) return false;
      if (node.type !== "Import") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBigIntLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "BigIntLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportNamespaceSpecifier(node, opts) {
      if (!node) return false;
      if (node.type !== "ExportNamespaceSpecifier") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isOptionalMemberExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "OptionalMemberExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isOptionalCallExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "OptionalCallExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassAccessorProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassAccessorProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassPrivateProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassPrivateProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassPrivateMethod(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassPrivateMethod") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPrivateName(node, opts) {
      if (!node) return false;
      if (node.type !== "PrivateName") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStaticBlock(node, opts) {
      if (!node) return false;
      if (node.type !== "StaticBlock") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportAttribute(node, opts) {
      if (!node) return false;
      if (node.type !== "ImportAttribute") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAnyTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "AnyTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isArrayTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "ArrayTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBooleanTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "BooleanTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBooleanLiteralTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "BooleanLiteralTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNullLiteralTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "NullLiteralTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassImplements(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassImplements") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareClass(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareClass") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareFunction(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareFunction") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareInterface(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareInterface") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareModule(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareModule") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareModuleExports(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareModuleExports") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareTypeAlias(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareTypeAlias") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareOpaqueType(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareOpaqueType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareVariable(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareVariable") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareExportDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareExportDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareExportAllDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareExportAllDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclaredPredicate(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclaredPredicate") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExistsTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "ExistsTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "FunctionTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionTypeParam(node, opts) {
      if (!node) return false;
      if (node.type !== "FunctionTypeParam") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isGenericTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "GenericTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInferredPredicate(node, opts) {
      if (!node) return false;
      if (node.type !== "InferredPredicate") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInterfaceExtends(node, opts) {
      if (!node) return false;
      if (node.type !== "InterfaceExtends") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInterfaceDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "InterfaceDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInterfaceTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "InterfaceTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isIntersectionTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "IntersectionTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMixedTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "MixedTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEmptyTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "EmptyTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNullableTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "NullableTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNumberLiteralTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "NumberLiteralTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNumberTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "NumberTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeInternalSlot(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectTypeInternalSlot") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeCallProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectTypeCallProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeIndexer(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectTypeIndexer") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectTypeProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeSpreadProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectTypeSpreadProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isOpaqueType(node, opts) {
      if (!node) return false;
      if (node.type !== "OpaqueType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isQualifiedTypeIdentifier(node, opts) {
      if (!node) return false;
      if (node.type !== "QualifiedTypeIdentifier") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStringLiteralTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "StringLiteralTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStringTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "StringTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSymbolTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "SymbolTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isThisTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "ThisTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTupleTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "TupleTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeofTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "TypeofTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeAlias(node, opts) {
      if (!node) return false;
      if (node.type !== "TypeAlias") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "TypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeCastExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "TypeCastExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeParameter(node, opts) {
      if (!node) return false;
      if (node.type !== "TypeParameter") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeParameterDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TypeParameterDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeParameterInstantiation(node, opts) {
      if (!node) return false;
      if (node.type !== "TypeParameterInstantiation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUnionTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "UnionTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVariance(node, opts) {
      if (!node) return false;
      if (node.type !== "Variance") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVoidTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "VoidTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumBooleanBody(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumBooleanBody") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumNumberBody(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumNumberBody") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumStringBody(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumStringBody") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumSymbolBody(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumSymbolBody") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumBooleanMember(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumBooleanMember") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumNumberMember(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumNumberMember") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumStringMember(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumStringMember") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumDefaultedMember(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumDefaultedMember") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isIndexedAccessType(node, opts) {
      if (!node) return false;
      if (node.type !== "IndexedAccessType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isOptionalIndexedAccessType(node, opts) {
      if (!node) return false;
      if (node.type !== "OptionalIndexedAccessType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXAttribute(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXAttribute") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXClosingElement(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXClosingElement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXElement(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXElement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXEmptyExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXEmptyExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXExpressionContainer(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXExpressionContainer") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXSpreadChild(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXSpreadChild") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXIdentifier(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXIdentifier") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXMemberExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXMemberExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXNamespacedName(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXNamespacedName") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXOpeningElement(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXOpeningElement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXSpreadAttribute(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXSpreadAttribute") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXText(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXText") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXFragment(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXFragment") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXOpeningFragment(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXOpeningFragment") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXClosingFragment(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXClosingFragment") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNoop(node, opts) {
      if (!node) return false;
      if (node.type !== "Noop") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPlaceholder(node, opts) {
      if (!node) return false;
      if (node.type !== "Placeholder") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isV8IntrinsicIdentifier(node, opts) {
      if (!node) return false;
      if (node.type !== "V8IntrinsicIdentifier") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isArgumentPlaceholder(node, opts) {
      if (!node) return false;
      if (node.type !== "ArgumentPlaceholder") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBindExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "BindExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDecorator(node, opts) {
      if (!node) return false;
      if (node.type !== "Decorator") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDoExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "DoExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportDefaultSpecifier(node, opts) {
      if (!node) return false;
      if (node.type !== "ExportDefaultSpecifier") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRecordExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "RecordExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTupleExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "TupleExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDecimalLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "DecimalLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isModuleExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ModuleExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTopicReference(node, opts) {
      if (!node) return false;
      if (node.type !== "TopicReference") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPipelineTopicExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "PipelineTopicExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPipelineBareFunction(node, opts) {
      if (!node) return false;
      if (node.type !== "PipelineBareFunction") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPipelinePrimaryTopicReference(node, opts) {
      if (!node) return false;
      if (node.type !== "PipelinePrimaryTopicReference") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVoidPattern(node, opts) {
      if (!node) return false;
      if (node.type !== "VoidPattern") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSParameterProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "TSParameterProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSDeclareFunction(node, opts) {
      if (!node) return false;
      if (node.type !== "TSDeclareFunction") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSDeclareMethod(node, opts) {
      if (!node) return false;
      if (node.type !== "TSDeclareMethod") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSQualifiedName(node, opts) {
      if (!node) return false;
      if (node.type !== "TSQualifiedName") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSCallSignatureDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSCallSignatureDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSConstructSignatureDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSConstructSignatureDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSPropertySignature(node, opts) {
      if (!node) return false;
      if (node.type !== "TSPropertySignature") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSMethodSignature(node, opts) {
      if (!node) return false;
      if (node.type !== "TSMethodSignature") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSIndexSignature(node, opts) {
      if (!node) return false;
      if (node.type !== "TSIndexSignature") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSAnyKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSAnyKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSBooleanKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSBooleanKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSBigIntKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSBigIntKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSIntrinsicKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSIntrinsicKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNeverKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSNeverKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNullKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSNullKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNumberKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSNumberKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSObjectKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSObjectKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSStringKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSStringKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSSymbolKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSSymbolKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSUndefinedKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSUndefinedKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSUnknownKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSUnknownKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSVoidKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSVoidKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSThisType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSThisType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSFunctionType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSFunctionType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSConstructorType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSConstructorType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeReference(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeReference") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypePredicate(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypePredicate") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeQuery(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeQuery") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSArrayType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSArrayType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTupleType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTupleType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSOptionalType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSOptionalType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSRestType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSRestType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNamedTupleMember(node, opts) {
      if (!node) return false;
      if (node.type !== "TSNamedTupleMember") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSUnionType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSUnionType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSIntersectionType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSIntersectionType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSConditionalType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSConditionalType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSInferType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSInferType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSParenthesizedType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSParenthesizedType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeOperator(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeOperator") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSIndexedAccessType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSIndexedAccessType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSMappedType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSMappedType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTemplateLiteralType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTemplateLiteralType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSLiteralType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSLiteralType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSExpressionWithTypeArguments(node, opts) {
      if (!node) return false;
      if (node.type !== "TSExpressionWithTypeArguments") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSInterfaceDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSInterfaceDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSInterfaceBody(node, opts) {
      if (!node) return false;
      if (node.type !== "TSInterfaceBody") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeAliasDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeAliasDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSInstantiationExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "TSInstantiationExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSAsExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "TSAsExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSSatisfiesExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "TSSatisfiesExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeAssertion(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeAssertion") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSEnumBody(node, opts) {
      if (!node) return false;
      if (node.type !== "TSEnumBody") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSEnumDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSEnumDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSEnumMember(node, opts) {
      if (!node) return false;
      if (node.type !== "TSEnumMember") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSModuleDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSModuleDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSModuleBlock(node, opts) {
      if (!node) return false;
      if (node.type !== "TSModuleBlock") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSImportType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSImportType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSImportEqualsDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSImportEqualsDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSExternalModuleReference(node, opts) {
      if (!node) return false;
      if (node.type !== "TSExternalModuleReference") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNonNullExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "TSNonNullExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSExportAssignment(node, opts) {
      if (!node) return false;
      if (node.type !== "TSExportAssignment") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNamespaceExportDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSNamespaceExportDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeParameterInstantiation(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeParameterInstantiation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeParameterDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeParameterDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeParameter(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeParameter") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStandardized(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "InterpreterDirective":
        case "Directive":
        case "DirectiveLiteral":
        case "BlockStatement":
        case "BreakStatement":
        case "CallExpression":
        case "CatchClause":
        case "ConditionalExpression":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "File":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Identifier":
        case "IfStatement":
        case "LabeledStatement":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "Program":
        case "ObjectExpression":
        case "ObjectMethod":
        case "ObjectProperty":
        case "RestElement":
        case "ReturnStatement":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "SwitchCase":
        case "SwitchStatement":
        case "ThisExpression":
        case "ThrowStatement":
        case "TryStatement":
        case "UnaryExpression":
        case "UpdateExpression":
        case "VariableDeclaration":
        case "VariableDeclarator":
        case "WhileStatement":
        case "WithStatement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ArrowFunctionExpression":
        case "ClassBody":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ExportSpecifier":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ImportExpression":
        case "MetaProperty":
        case "ClassMethod":
        case "ObjectPattern":
        case "SpreadElement":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateElement":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "ExportNamespaceSpecifier":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
        case "StaticBlock":
        case "ImportAttribute":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Identifier":
            case "StringLiteral":
            case "BlockStatement":
            case "ClassBody":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExpression(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "ImportExpression":
        case "MetaProperty":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "TypeCastExpression":
        case "JSXElement":
        case "JSXFragment":
        case "BindExpression":
        case "DoExpression":
        case "RecordExpression":
        case "TupleExpression":
        case "DecimalLiteral":
        case "ModuleExpression":
        case "TopicReference":
        case "PipelineTopicExpression":
        case "PipelineBareFunction":
        case "PipelinePrimaryTopicReference":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Expression":
            case "Identifier":
            case "StringLiteral":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBinary(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "BinaryExpression":
        case "LogicalExpression":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isScopable(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node.expectedNode === "BlockStatement") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBlockParent(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node.expectedNode === "BlockStatement") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBlock(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "BlockStatement":
        case "Program":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node.expectedNode === "BlockStatement") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStatement(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
        case "TSImportEqualsDeclaration":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Statement":
            case "Declaration":
            case "BlockStatement":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTerminatorless(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
        case "YieldExpression":
        case "AwaitExpression":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isCompletionStatement(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isConditional(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ConditionalExpression":
        case "IfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLoop(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isWhile(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "DoWhileStatement":
        case "WhileStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExpressionWrapper(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ExpressionStatement":
        case "ParenthesizedExpression":
        case "TypeCastExpression":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFor(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ForInStatement":
        case "ForStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isForXStatement(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ForInStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunction(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionParent(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPureish(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "ArrowFunctionExpression":
        case "BigIntLiteral":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node.expectedNode === "StringLiteral") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclaration(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "FunctionDeclaration":
        case "VariableDeclaration":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
        case "TSImportEqualsDeclaration":
          break;
        case "Placeholder":
          if (node.expectedNode === "Declaration") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionParameter(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "Identifier":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "VoidPattern":
          break;
        case "Placeholder":
          if (node.expectedNode === "Identifier") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPatternLike(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "Identifier":
        case "MemberExpression":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "VoidPattern":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Pattern":
            case "Identifier":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLVal(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "Identifier":
        case "MemberExpression":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "TSParameterProperty":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Pattern":
            case "Identifier":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSEntityName(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "Identifier":
        case "TSQualifiedName":
          break;
        case "Placeholder":
          if (node.expectedNode === "Identifier") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLiteral(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "TemplateLiteral":
        case "BigIntLiteral":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node.expectedNode === "StringLiteral") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImmutable(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "BigIntLiteral":
        case "JSXAttribute":
        case "JSXClosingElement":
        case "JSXElement":
        case "JSXExpressionContainer":
        case "JSXSpreadChild":
        case "JSXOpeningElement":
        case "JSXText":
        case "JSXFragment":
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node.expectedNode === "StringLiteral") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUserWhitespacable(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ObjectMethod":
        case "ObjectProperty":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMethod(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ObjectMethod":
        case "ClassMethod":
        case "ClassPrivateMethod":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectMember(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ObjectMethod":
        case "ObjectProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isProperty2(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ObjectProperty":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUnaryLike(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "UnaryExpression":
        case "SpreadElement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPattern(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "VoidPattern":
          break;
        case "Placeholder":
          if (node.expectedNode === "Pattern") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClass(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ClassExpression":
        case "ClassDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportOrExportDeclaration(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportDeclaration(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isModuleSpecifier(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ExportSpecifier":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAccessor(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ClassAccessorProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPrivate(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlow(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ClassImplements":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "DeclaredPredicate":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "FunctionTypeParam":
        case "GenericTypeAnnotation":
        case "InferredPredicate":
        case "InterfaceExtends":
        case "InterfaceDeclaration":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
        case "OpaqueType":
        case "QualifiedTypeIdentifier":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "TypeAlias":
        case "TypeAnnotation":
        case "TypeCastExpression":
        case "TypeParameter":
        case "TypeParameterDeclaration":
        case "TypeParameterInstantiation":
        case "UnionTypeAnnotation":
        case "Variance":
        case "VoidTypeAnnotation":
        case "EnumDeclaration":
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlowType(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "GenericTypeAnnotation":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "UnionTypeAnnotation":
        case "VoidTypeAnnotation":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlowBaseAnnotation(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "AnyTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NumberTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "VoidTypeAnnotation":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlowDeclaration(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlowPredicate(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "DeclaredPredicate":
        case "InferredPredicate":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumBody(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumMember(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSX(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "JSXAttribute":
        case "JSXClosingElement":
        case "JSXElement":
        case "JSXEmptyExpression":
        case "JSXExpressionContainer":
        case "JSXSpreadChild":
        case "JSXIdentifier":
        case "JSXMemberExpression":
        case "JSXNamespacedName":
        case "JSXOpeningElement":
        case "JSXSpreadAttribute":
        case "JSXText":
        case "JSXFragment":
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMiscellaneous(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "Noop":
        case "Placeholder":
        case "V8IntrinsicIdentifier":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeScript(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "TSParameterProperty":
        case "TSDeclareFunction":
        case "TSDeclareMethod":
        case "TSQualifiedName":
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSNamedTupleMember":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSTemplateLiteralType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSInterfaceDeclaration":
        case "TSInterfaceBody":
        case "TSTypeAliasDeclaration":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSEnumBody":
        case "TSEnumDeclaration":
        case "TSEnumMember":
        case "TSModuleDeclaration":
        case "TSModuleBlock":
        case "TSImportType":
        case "TSImportEqualsDeclaration":
        case "TSExternalModuleReference":
        case "TSNonNullExpression":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
        case "TSTypeAnnotation":
        case "TSTypeParameterInstantiation":
        case "TSTypeParameterDeclaration":
        case "TSTypeParameter":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeElement(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSType(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSTemplateLiteralType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSImportType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSBaseType(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSTemplateLiteralType":
        case "TSLiteralType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNumberLiteral(node, opts) {
      (0, _deprecationWarning.default)("isNumberLiteral", "isNumericLiteral");
      if (!node) return false;
      if (node.type !== "NumberLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRegexLiteral(node, opts) {
      (0, _deprecationWarning.default)("isRegexLiteral", "isRegExpLiteral");
      if (!node) return false;
      if (node.type !== "RegexLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRestProperty(node, opts) {
      (0, _deprecationWarning.default)("isRestProperty", "isRestElement");
      if (!node) return false;
      if (node.type !== "RestProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSpreadProperty(node, opts) {
      (0, _deprecationWarning.default)("isSpreadProperty", "isSpreadElement");
      if (!node) return false;
      if (node.type !== "SpreadProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isModuleDeclaration(node, opts) {
      (0, _deprecationWarning.default)("isModuleDeclaration", "isImportOrExportDeclaration");
      return isImportOrExportDeclaration(node, opts);
    }
  }
});

// node_modules/@babel/types/lib/validators/matchesPattern.js
var require_matchesPattern = __commonJS({
  "node_modules/@babel/types/lib/validators/matchesPattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = matchesPattern;
    var _index = require_generated();
    function isMemberExpressionLike(node) {
      return (0, _index.isMemberExpression)(node) || (0, _index.isMetaProperty)(node);
    }
    function matchesPattern(member, match, allowPartial) {
      if (!isMemberExpressionLike(member)) return false;
      const parts = Array.isArray(match) ? match : match.split(".");
      const nodes = [];
      let node;
      for (node = member; isMemberExpressionLike(node); node = (_object = node.object) != null ? _object : node.meta) {
        var _object;
        nodes.push(node.property);
      }
      nodes.push(node);
      if (nodes.length < parts.length) return false;
      if (!allowPartial && nodes.length > parts.length) return false;
      for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
        const node2 = nodes[j];
        let value;
        if ((0, _index.isIdentifier)(node2)) {
          value = node2.name;
        } else if ((0, _index.isStringLiteral)(node2)) {
          value = node2.value;
        } else if ((0, _index.isThisExpression)(node2)) {
          value = "this";
        } else if ((0, _index.isSuper)(node2)) {
          value = "super";
        } else if ((0, _index.isPrivateName)(node2)) {
          value = "#" + node2.id.name;
        } else {
          return false;
        }
        if (parts[i] !== value) return false;
      }
      return true;
    }
  }
});

// node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var require_buildMatchMemberExpression = __commonJS({
  "node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = buildMatchMemberExpression;
    var _matchesPattern = require_matchesPattern();
    function buildMatchMemberExpression(match, allowPartial) {
      const parts = match.split(".");
      return (member) => (0, _matchesPattern.default)(member, parts, allowPartial);
    }
  }
});

// node_modules/@babel/types/lib/validators/react/isReactComponent.js
var require_isReactComponent = __commonJS({
  "node_modules/@babel/types/lib/validators/react/isReactComponent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _buildMatchMemberExpression = require_buildMatchMemberExpression();
    var isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
    var _default = exports.default = isReactComponent;
  }
});

// node_modules/@babel/types/lib/validators/react/isCompatTag.js
var require_isCompatTag = __commonJS({
  "node_modules/@babel/types/lib/validators/react/isCompatTag.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isCompatTag;
    function isCompatTag(tagName) {
      return !!tagName && /^[a-z]/.test(tagName);
    }
  }
});

// node_modules/@babel/types/lib/validators/isType.js
var require_isType = __commonJS({
  "node_modules/@babel/types/lib/validators/isType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isType2;
    var _index = require_definitions();
    function isType2(nodeType, targetType) {
      if (nodeType === targetType) return true;
      if (nodeType == null) return false;
      if (_index.ALIAS_KEYS[targetType]) return false;
      const aliases = _index.FLIPPED_ALIAS_KEYS[targetType];
      if (aliases != null && aliases.includes(nodeType)) return true;
      return false;
    }
  }
});

// node_modules/@babel/types/lib/validators/isPlaceholderType.js
var require_isPlaceholderType = __commonJS({
  "node_modules/@babel/types/lib/validators/isPlaceholderType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isPlaceholderType;
    var _index = require_definitions();
    function isPlaceholderType(placeholderType, targetType) {
      if (placeholderType === targetType) return true;
      const aliases = _index.PLACEHOLDERS_ALIAS[placeholderType];
      if (aliases != null && aliases.includes(targetType)) return true;
      return false;
    }
  }
});

// node_modules/@babel/types/lib/validators/is.js
var require_is = __commonJS({
  "node_modules/@babel/types/lib/validators/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = is;
    var _shallowEqual = require_shallowEqual();
    var _isType = require_isType();
    var _isPlaceholderType = require_isPlaceholderType();
    var _index = require_definitions();
    function is(type, node, opts) {
      if (!node) return false;
      const matches = (0, _isType.default)(node.type, type);
      if (!matches) {
        if (!opts && node.type === "Placeholder" && type in _index.FLIPPED_ALIAS_KEYS) {
          return (0, _isPlaceholderType.default)(node.expectedNode, type);
        }
        return false;
      }
      if (opts === void 0) {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isIdentifierChar = isIdentifierChar;
    exports.isIdentifierName = isIdentifierName;
    exports.isIdentifierStart = isIdentifierStart2;
    var nonASCIIidentifierStartChars = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
    var nonASCIIidentifierChars = "------------------------------------------------------------------------------------------------------------------------------------------------------";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 7, 25, 39, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 5, 57, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 24, 43, 261, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 33, 24, 3, 24, 45, 74, 6, 0, 67, 12, 65, 1, 2, 0, 15, 4, 10, 7381, 42, 31, 98, 114, 8702, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 208, 30, 2, 2, 2, 1, 2, 6, 3, 4, 10, 1, 225, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4381, 3, 5773, 3, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 8489];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 78, 5, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 199, 7, 137, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 55, 9, 266, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 233, 0, 3, 0, 8, 1, 6, 0, 475, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code2, set) {
      let pos = 65536;
      for (let i = 0, length2 = set.length; i < length2; i += 2) {
        pos += set[i];
        if (pos > code2) return false;
        pos += set[i + 1];
        if (pos >= code2) return true;
      }
      return false;
    }
    function isIdentifierStart2(code2) {
      if (code2 < 65) return code2 === 36;
      if (code2 <= 90) return true;
      if (code2 < 97) return code2 === 95;
      if (code2 <= 122) return true;
      if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
      }
      return isInAstralSet(code2, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code2) {
      if (code2 < 48) return code2 === 36;
      if (code2 < 58) return true;
      if (code2 < 65) return false;
      if (code2 <= 90) return true;
      if (code2 < 97) return code2 === 95;
      if (code2 <= 122) return true;
      if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
      }
      return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
    }
    function isIdentifierName(name50) {
      let isFirst = true;
      for (let i = 0; i < name50.length; i++) {
        let cp = name50.charCodeAt(i);
        if ((cp & 64512) === 55296 && i + 1 < name50.length) {
          const trail = name50.charCodeAt(++i);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        if (isFirst) {
          isFirst = false;
          if (!isIdentifierStart2(cp)) {
            return false;
          }
        } else if (!isIdentifierChar(cp)) {
          return false;
        }
      }
      return !isFirst;
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isKeyword = isKeyword2;
    exports.isReservedWord = isReservedWord;
    exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    exports.isStrictBindReservedWord = isStrictBindReservedWord;
    exports.isStrictReservedWord = isStrictReservedWord;
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords2 = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword2(word) {
      return keywords2.has(word);
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isIdentifierChar", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports, "isIdentifierName", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports, "isIdentifierStart", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports, "isKeyword", {
      enumerable: true,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports, "isReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = require_identifier();
    var _keyword = require_keyword();
  }
});

// node_modules/@babel/types/lib/validators/isValidIdentifier.js
var require_isValidIdentifier = __commonJS({
  "node_modules/@babel/types/lib/validators/isValidIdentifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isValidIdentifier;
    var _helperValidatorIdentifier = require_lib2();
    function isValidIdentifier(name50, reserved = true) {
      if (typeof name50 !== "string") return false;
      if (reserved) {
        if ((0, _helperValidatorIdentifier.isKeyword)(name50) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name50, true)) {
          return false;
        }
      }
      return (0, _helperValidatorIdentifier.isIdentifierName)(name50);
    }
  }
});

// node_modules/@babel/helper-string-parser/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@babel/helper-string-parser/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.readCodePoint = readCodePoint;
    exports.readInt = readInt;
    exports.readStringContents = readStringContents;
    var _isDigit = function isDigit2(code2) {
      return code2 >= 48 && code2 <= 57;
    };
    var forbiddenNumericSeparatorSiblings = {
      decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
      hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
    };
    var isAllowedNumericSeparatorSibling = {
      bin: (ch) => ch === 48 || ch === 49,
      oct: (ch) => ch >= 48 && ch <= 55,
      dec: (ch) => ch >= 48 && ch <= 57,
      hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
    };
    function readStringContents(type, input, pos, lineStart, curLine, errors) {
      const initialPos = pos;
      const initialLineStart = lineStart;
      const initialCurLine = curLine;
      let out = "";
      let firstInvalidLoc = null;
      let chunkStart = pos;
      const {
        length: length2
      } = input;
      for (; ; ) {
        if (pos >= length2) {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
          out += input.slice(chunkStart, pos);
          break;
        }
        const ch = input.charCodeAt(pos);
        if (isStringEnd(type, ch, input, pos)) {
          out += input.slice(chunkStart, pos);
          break;
        }
        if (ch === 92) {
          out += input.slice(chunkStart, pos);
          const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
          if (res.ch === null && !firstInvalidLoc) {
            firstInvalidLoc = {
              pos,
              lineStart,
              curLine
            };
          } else {
            out += res.ch;
          }
          ({
            pos,
            lineStart,
            curLine
          } = res);
          chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
          ++pos;
          ++curLine;
          lineStart = pos;
        } else if (ch === 10 || ch === 13) {
          if (type === "template") {
            out += input.slice(chunkStart, pos) + "\n";
            ++pos;
            if (ch === 13 && input.charCodeAt(pos) === 10) {
              ++pos;
            }
            ++curLine;
            chunkStart = lineStart = pos;
          } else {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
          }
        } else {
          ++pos;
        }
      }
      return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
        containsInvalid: !!firstInvalidLoc
      };
    }
    function isStringEnd(type, ch, input, pos) {
      if (type === "template") {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
      }
      return ch === (type === "double" ? 34 : 39);
    }
    function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
      const throwOnInvalid = !inTemplate;
      pos++;
      const res = (ch2) => ({
        pos,
        ch: ch2,
        lineStart,
        curLine
      });
      const ch = input.charCodeAt(pos++);
      switch (ch) {
        case 110:
          return res("\n");
        case 114:
          return res("\r");
        case 120: {
          let code2;
          ({
            code: code2,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
          return res(code2 === null ? null : String.fromCharCode(code2));
        }
        case 117: {
          let code2;
          ({
            code: code2,
            pos
          } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
          return res(code2 === null ? null : String.fromCodePoint(code2));
        }
        case 116:
          return res("	");
        case 98:
          return res("\b");
        case 118:
          return res("\v");
        case 102:
          return res("\f");
        case 13:
          if (input.charCodeAt(pos) === 10) {
            ++pos;
          }
        case 10:
          lineStart = pos;
          ++curLine;
        case 8232:
        case 8233:
          return res("");
        case 56:
        case 57:
          if (inTemplate) {
            return res(null);
          } else {
            errors.strictNumericEscape(pos - 1, lineStart, curLine);
          }
        default:
          if (ch >= 48 && ch <= 55) {
            const startPos = pos - 1;
            const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
            let octalStr = match[0];
            let octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            pos += octalStr.length - 1;
            const next = input.charCodeAt(pos);
            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return res(null);
              } else {
                errors.strictNumericEscape(startPos, lineStart, curLine);
              }
            }
            return res(String.fromCharCode(octal));
          }
          return res(String.fromCharCode(ch));
      }
    }
    function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
      const initialPos = pos;
      let n2;
      ({
        n: n2,
        pos
      } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
      if (n2 === null) {
        if (throwOnInvalid) {
          errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        } else {
          pos = initialPos - 1;
        }
      }
      return {
        code: n2,
        pos
      };
    }
    function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
      const start = pos;
      const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
      let invalid = false;
      let total = 0;
      for (let i = 0, e2 = len == null ? Infinity : len; i < e2; ++i) {
        const code2 = input.charCodeAt(pos);
        let val;
        if (code2 === 95 && allowNumSeparator !== "bail") {
          const prev = input.charCodeAt(pos - 1);
          const next = input.charCodeAt(pos + 1);
          if (!allowNumSeparator) {
            if (bailOnError) return {
              n: null,
              pos
            };
            errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
          } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
            if (bailOnError) return {
              n: null,
              pos
            };
            errors.unexpectedNumericSeparator(pos, lineStart, curLine);
          }
          ++pos;
          continue;
        }
        if (code2 >= 97) {
          val = code2 - 97 + 10;
        } else if (code2 >= 65) {
          val = code2 - 65 + 10;
        } else if (_isDigit(code2)) {
          val = code2 - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          if (val <= 9 && bailOnError) {
            return {
              n: null,
              pos
            };
          } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
            val = 0;
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }
        ++pos;
        total = total * radix + val;
      }
      if (pos === start || len != null && pos - start !== len || invalid) {
        return {
          n: null,
          pos
        };
      }
      return {
        n: total,
        pos
      };
    }
    function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
      const ch = input.charCodeAt(pos);
      let code2;
      if (ch === 123) {
        ++pos;
        ({
          code: code2,
          pos
        } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        if (code2 !== null && code2 > 1114111) {
          if (throwOnInvalid) {
            errors.invalidCodePoint(pos, lineStart, curLine);
          } else {
            return {
              code: null,
              pos
            };
          }
        }
      } else {
        ({
          code: code2,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
      }
      return {
        code: code2,
        pos
      };
    }
  }
});

// node_modules/@babel/types/lib/constants/index.js
var require_constants = __commonJS({
  "node_modules/@babel/types/lib/constants/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UPDATE_OPERATORS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.STATEMENT_OR_BLOCK_KEYS = exports.NUMBER_UNARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.LOGICAL_OPERATORS = exports.INHERIT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.EQUALITY_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.COMMENT_KEYS = exports.BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.BINARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = void 0;
    var STATEMENT_OR_BLOCK_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
    var FLATTENABLE_KEYS = exports.FLATTENABLE_KEYS = ["body", "expressions"];
    var FOR_INIT_KEYS = exports.FOR_INIT_KEYS = ["left", "init"];
    var COMMENT_KEYS = exports.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
    var LOGICAL_OPERATORS = exports.LOGICAL_OPERATORS = ["||", "&&", "??"];
    var UPDATE_OPERATORS = exports.UPDATE_OPERATORS = ["++", "--"];
    var BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
    var EQUALITY_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
    var COMPARISON_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
    var BOOLEAN_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
    var NUMBER_BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
    var BINARY_OPERATORS = exports.BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, "|>"];
    var ASSIGNMENT_OPERATORS = exports.ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map((op) => op + "="), ...LOGICAL_OPERATORS.map((op) => op + "=")];
    var BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
    var NUMBER_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
    var STRING_UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = ["typeof"];
    var UNARY_OPERATORS = exports.UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
    var INHERIT_KEYS = exports.INHERIT_KEYS = {
      optional: ["typeAnnotation", "typeParameters", "returnType"],
      force: ["start", "loc", "end"]
    };
    exports.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
    exports.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
  }
});

// node_modules/@babel/types/lib/definitions/utils.js
var require_utils = __commonJS({
  "node_modules/@babel/types/lib/definitions/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.allExpandedTypes = exports.VISITOR_KEYS = exports.NODE_UNION_SHAPES__PRIVATE = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;
    exports.arrayOf = arrayOf;
    exports.arrayOfType = arrayOfType;
    exports.assertEach = assertEach;
    exports.assertNodeOrValueType = assertNodeOrValueType;
    exports.assertNodeType = assertNodeType;
    exports.assertOneOf = assertOneOf;
    exports.assertOptionalChainStart = assertOptionalChainStart;
    exports.assertShape = assertShape;
    exports.assertValueType = assertValueType;
    exports.chain = chain;
    exports.default = defineType;
    exports.defineAliasedType = defineAliasedType;
    exports.validate = validate;
    exports.validateArrayOfType = validateArrayOfType;
    exports.validateOptional = validateOptional;
    exports.validateOptionalType = validateOptionalType;
    exports.validateType = validateType;
    var _is = require_is();
    var _validate = require_validate();
    var VISITOR_KEYS = exports.VISITOR_KEYS = {};
    var ALIAS_KEYS = exports.ALIAS_KEYS = {};
    var FLIPPED_ALIAS_KEYS = exports.FLIPPED_ALIAS_KEYS = {};
    var NODE_FIELDS = exports.NODE_FIELDS = {};
    var BUILDER_KEYS = exports.BUILDER_KEYS = {};
    var DEPRECATED_KEYS = exports.DEPRECATED_KEYS = {};
    var NODE_PARENT_VALIDATIONS = exports.NODE_PARENT_VALIDATIONS = {};
    var NODE_UNION_SHAPES__PRIVATE = exports.NODE_UNION_SHAPES__PRIVATE = {};
    function getType(val) {
      if (Array.isArray(val)) {
        return "array";
      } else if (val === null) {
        return "null";
      } else {
        return typeof val;
      }
    }
    function validate(validate2) {
      return {
        validate: validate2
      };
    }
    function validateType(...typeNames) {
      return validate(assertNodeType(...typeNames));
    }
    function validateOptional(validate2) {
      return {
        validate: validate2,
        optional: true
      };
    }
    function validateOptionalType(...typeNames) {
      return {
        validate: assertNodeType(...typeNames),
        optional: true
      };
    }
    function arrayOf(elementType) {
      return chain(assertValueType("array"), assertEach(elementType));
    }
    function arrayOfType(...typeNames) {
      return arrayOf(assertNodeType(...typeNames));
    }
    function validateArrayOfType(...typeNames) {
      return validate(arrayOfType(...typeNames));
    }
    function assertEach(callback) {
      const childValidator = process.env.BABEL_TYPES_8_BREAKING ? _validate.validateChild : () => {
      };
      function validator(node, key, val) {
        if (!Array.isArray(val)) return;
        let i = 0;
        const subKey = {
          toString() {
            return `${key}[${i}]`;
          }
        };
        for (; i < val.length; i++) {
          const v = val[i];
          callback(node, subKey, v);
          childValidator(node, subKey, v);
        }
      }
      validator.each = callback;
      return validator;
    }
    function assertOneOf(...values) {
      function validate2(node, key, val) {
        if (!values.includes(val)) {
          throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
        }
      }
      validate2.oneOf = values;
      return validate2;
    }
    var allExpandedTypes = exports.allExpandedTypes = [];
    function assertNodeType(...types) {
      const expandedTypes = /* @__PURE__ */ new Set();
      allExpandedTypes.push({
        types,
        set: expandedTypes
      });
      function validate2(node, key, val) {
        const valType = val == null ? void 0 : val.type;
        if (valType != null) {
          if (expandedTypes.has(valType)) {
            (0, _validate.validateChild)(node, key, val);
            return;
          }
          if (valType === "Placeholder") {
            for (const type of types) {
              if ((0, _is.default)(type, val)) {
                (0, _validate.validateChild)(node, key, val);
                return;
              }
            }
          }
        }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(valType)}`);
      }
      validate2.oneOfNodeTypes = types;
      return validate2;
    }
    function assertNodeOrValueType(...types) {
      function validate2(node, key, val) {
        const primitiveType = getType(val);
        for (const type of types) {
          if (primitiveType === type || (0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
          }
        }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
      }
      validate2.oneOfNodeOrValueTypes = types;
      return validate2;
    }
    function assertValueType(type) {
      function validate2(node, key, val) {
        if (getType(val) === type) {
          return;
        }
        throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
      }
      validate2.type = type;
      return validate2;
    }
    function assertShape(shape) {
      const keys = Object.keys(shape);
      function validate2(node, key, val) {
        const errors = [];
        for (const property4 of keys) {
          try {
            (0, _validate.validateField)(node, property4, val[property4], shape[property4]);
          } catch (error) {
            if (error instanceof TypeError) {
              errors.push(error.message);
              continue;
            }
            throw error;
          }
        }
        if (errors.length) {
          throw new TypeError(`Property ${key} of ${node.type} expected to have the following:
${errors.join("\n")}`);
        }
      }
      validate2.shapeOf = shape;
      return validate2;
    }
    function assertOptionalChainStart() {
      function validate2(node) {
        var _current;
        let current = node;
        while (node) {
          const {
            type
          } = current;
          if (type === "OptionalCallExpression") {
            if (current.optional) return;
            current = current.callee;
            continue;
          }
          if (type === "OptionalMemberExpression") {
            if (current.optional) return;
            current = current.object;
            continue;
          }
          break;
        }
        throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
      }
      return validate2;
    }
    function chain(...fns2) {
      function validate2(...args) {
        for (const fn of fns2) {
          fn(...args);
        }
      }
      validate2.chainOf = fns2;
      if (fns2.length >= 2 && "type" in fns2[0] && fns2[0].type === "array" && !("each" in fns2[1])) {
        throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
      }
      return validate2;
    }
    var validTypeOpts = /* @__PURE__ */ new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate", "unionShape"]);
    var validFieldKeys = /* @__PURE__ */ new Set(["default", "optional", "deprecated", "validate"]);
    var store = {};
    function defineAliasedType(...aliases) {
      return (type, opts = {}) => {
        let defined = opts.aliases;
        if (!defined) {
          var _store$opts$inherits$;
          if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
          defined != null ? defined : defined = [];
          opts.aliases = defined;
        }
        const additional = aliases.filter((a) => !defined.includes(a));
        defined.unshift(...additional);
        defineType(type, opts);
      };
    }
    function defineType(type, opts = {}) {
      const inherits = opts.inherits && store[opts.inherits] || {};
      let fields = opts.fields;
      if (!fields) {
        fields = {};
        if (inherits.fields) {
          const keys = Object.getOwnPropertyNames(inherits.fields);
          for (const key of keys) {
            const field = inherits.fields[key];
            const def = field.default;
            if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
              throw new Error("field defaults can only be primitives or empty arrays currently");
            }
            fields[key] = {
              default: Array.isArray(def) ? [] : def,
              optional: field.optional,
              deprecated: field.deprecated,
              validate: field.validate
            };
          }
        }
      }
      const visitor = opts.visitor || inherits.visitor || [];
      const aliases = opts.aliases || inherits.aliases || [];
      const builder = opts.builder || inherits.builder || opts.visitor || [];
      for (const k of Object.keys(opts)) {
        if (!validTypeOpts.has(k)) {
          throw new Error(`Unknown type option "${k}" on ${type}`);
        }
      }
      if (opts.deprecatedAlias) {
        DEPRECATED_KEYS[opts.deprecatedAlias] = type;
      }
      for (const key of visitor.concat(builder)) {
        fields[key] = fields[key] || {};
      }
      for (const key of Object.keys(fields)) {
        const field = fields[key];
        if (field.default !== void 0 && !builder.includes(key)) {
          field.optional = true;
        }
        if (field.default === void 0) {
          field.default = null;
        } else if (!field.validate && field.default != null) {
          field.validate = assertValueType(getType(field.default));
        }
        for (const k of Object.keys(field)) {
          if (!validFieldKeys.has(k)) {
            throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
          }
        }
      }
      VISITOR_KEYS[type] = opts.visitor = visitor;
      BUILDER_KEYS[type] = opts.builder = builder;
      NODE_FIELDS[type] = opts.fields = fields;
      ALIAS_KEYS[type] = opts.aliases = aliases;
      aliases.forEach((alias) => {
        FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
        FLIPPED_ALIAS_KEYS[alias].push(type);
      });
      if (opts.validate) {
        NODE_PARENT_VALIDATIONS[type] = opts.validate;
      }
      if (opts.unionShape) {
        NODE_UNION_SHAPES__PRIVATE[type] = opts.unionShape;
      }
      store[type] = opts;
    }
  }
});

// node_modules/@babel/types/lib/definitions/core.js
var require_core = __commonJS({
  "node_modules/@babel/types/lib/definitions/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.patternLikeCommon = exports.importAttributes = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyUnionShapeCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;
    var _is = require_is();
    var _isValidIdentifier = require_isValidIdentifier();
    var _helperValidatorIdentifier = require_lib2();
    var _helperStringParser = require_lib3();
    var _index = require_constants();
    var _utils = require_utils();
    var classMethodOrPropertyUnionShapeCommon = (allowPrivateName = false) => ({
      unionShape: {
        discriminator: "computed",
        shapes: [{
          name: "computed",
          value: [true],
          properties: {
            key: {
              validate: (0, _utils.assertNodeType)("Expression")
            }
          }
        }, {
          name: "nonComputed",
          value: [false],
          properties: {
            key: {
              validate: allowPrivateName ? (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName") : (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral")
            }
          }
        }]
      }
    });
    exports.classMethodOrPropertyUnionShapeCommon = classMethodOrPropertyUnionShapeCommon;
    var defineType = (0, _utils.defineAliasedType)("Standardized");
    defineType("ArrayExpression", {
      fields: {
        elements: {
          validate: (0, _utils.arrayOf)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement")),
          default: !process.env.BABEL_TYPES_8_BREAKING ? [] : void 0
        }
      },
      visitor: ["elements"],
      aliases: ["Expression"]
    });
    defineType("AssignmentExpression", {
      fields: {
        operator: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("string") : Object.assign(function() {
            const identifier = (0, _utils.assertOneOf)(..._index.ASSIGNMENT_OPERATORS);
            const pattern = (0, _utils.assertOneOf)("=");
            return function(node, key, val) {
              const validator = (0, _is.default)("Pattern", node.left) ? pattern : identifier;
              validator(node, key, val);
            };
          }(), {
            oneOf: _index.ASSIGNMENT_OPERATORS
          })
        },
        left: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal", "OptionalMemberExpression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Expression"]
    });
    defineType("BinaryExpression", {
      builder: ["operator", "left", "right"],
      fields: {
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.BINARY_OPERATORS)
        },
        left: {
          validate: function() {
            const expression = (0, _utils.assertNodeType)("Expression");
            const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
            const validator = Object.assign(function(node, key, val) {
              const validator2 = node.operator === "in" ? inOp : expression;
              validator2(node, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "PrivateName"]
            });
            return validator;
          }()
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"]
    });
    defineType("InterpreterDirective", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("Directive", {
      visitor: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertNodeType)("DirectiveLiteral")
        }
      }
    });
    defineType("DirectiveLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("BlockStatement", {
      builder: ["body", "directives"],
      visitor: ["directives", "body"],
      fields: {
        directives: {
          validate: (0, _utils.arrayOfType)("Directive"),
          default: []
        },
        body: (0, _utils.validateArrayOfType)("Statement")
      },
      aliases: ["Scopable", "BlockParent", "Block", "Statement"]
    });
    defineType("BreakStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    defineType("CallExpression", {
      visitor: ["callee", "typeParameters", "typeArguments", "arguments"],
      builder: ["callee", "arguments"],
      aliases: ["Expression"],
      fields: Object.assign({
        callee: {
          validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
        },
        arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: true
        }
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        optional: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: true
        }
      })
    });
    defineType("CatchClause", {
      visitor: ["param", "body"],
      fields: {
        param: {
          validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      },
      aliases: ["Scopable", "BlockParent"]
    });
    defineType("ConditionalExpression", {
      visitor: ["test", "consequent", "alternate"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        alternate: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression", "Conditional"]
    });
    defineType("ContinueStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    defineType("DebuggerStatement", {
      aliases: ["Statement"]
    });
    defineType("DoWhileStatement", {
      builder: ["test", "body"],
      visitor: ["body", "test"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      },
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
    });
    defineType("EmptyStatement", {
      aliases: ["Statement"]
    });
    defineType("ExpressionStatement", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Statement", "ExpressionWrapper"]
    });
    defineType("File", {
      builder: ["program", "comments", "tokens"],
      visitor: ["program"],
      fields: {
        program: {
          validate: (0, _utils.assertNodeType)("Program")
        },
        comments: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {
          }, {
            each: {
              oneOfNodeTypes: ["CommentBlock", "CommentLine"]
            }
          }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
          optional: true
        },
        tokens: {
          validate: (0, _utils.assertEach)(Object.assign(() => {
          }, {
            type: "any"
          })),
          optional: true
        }
      }
    });
    defineType("ForInStatement", {
      visitor: ["left", "right", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("ForStatement", {
      visitor: ["init", "test", "update", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
      fields: {
        init: {
          validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
          optional: true
        },
        test: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        update: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    var functionCommon = () => ({
      params: (0, _utils.validateArrayOfType)("FunctionParameter"),
      generator: {
        default: false
      },
      async: {
        default: false
      }
    });
    exports.functionCommon = functionCommon;
    var functionTypeAnnotationCommon = () => ({
      returnType: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    });
    exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
    var functionDeclarationCommon = () => Object.assign({}, functionCommon(), {
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      }
    });
    exports.functionDeclarationCommon = functionDeclarationCommon;
    defineType("FunctionDeclaration", {
      builder: ["id", "params", "body", "generator", "async"],
      visitor: ["id", "typeParameters", "params", "predicate", "returnType", "body"],
      fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      }),
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
      validate: !process.env.BABEL_TYPES_8_BREAKING ? void 0 : function() {
        const identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node) {
          if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
            identifier(node, "id", node.id);
          }
        };
      }()
    });
    defineType("FunctionExpression", {
      inherits: "FunctionDeclaration",
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      })
    });
    var patternLikeCommon = () => ({
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      }
    });
    exports.patternLikeCommon = patternLikeCommon;
    defineType("Identifier", {
      builder: ["name"],
      visitor: ["typeAnnotation", "decorators"],
      aliases: ["Expression", "FunctionParameter", "PatternLike", "LVal", "TSEntityName"],
      fields: Object.assign({}, patternLikeCommon(), {
        name: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
            if (!(0, _isValidIdentifier.default)(val, false)) {
              throw new TypeError(`"${val}" is not a valid identifier name`);
            }
          }, {
            type: "string"
          })) : (0, _utils.assertValueType)("string")
        }
      }),
      validate: process.env.BABEL_TYPES_8_BREAKING ? function(parent, key, node) {
        const match = /\.(\w+)$/.exec(key.toString());
        if (!match) return;
        const [, parentKey] = match;
        const nonComp = {
          computed: false
        };
        if (parentKey === "property") {
          if ((0, _is.default)("MemberExpression", parent, nonComp)) return;
          if ((0, _is.default)("OptionalMemberExpression", parent, nonComp)) return;
        } else if (parentKey === "key") {
          if ((0, _is.default)("Property", parent, nonComp)) return;
          if ((0, _is.default)("Method", parent, nonComp)) return;
        } else if (parentKey === "exported") {
          if ((0, _is.default)("ExportSpecifier", parent)) return;
        } else if (parentKey === "imported") {
          if ((0, _is.default)("ImportSpecifier", parent, {
            imported: node
          })) return;
        } else if (parentKey === "meta") {
          if ((0, _is.default)("MetaProperty", parent, {
            meta: node
          })) return;
        }
        if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== "this") {
          throw new TypeError(`"${node.name}" is not a valid identifier`);
        }
      } : void 0
    });
    defineType("IfStatement", {
      visitor: ["test", "consequent", "alternate"],
      aliases: ["Statement", "Conditional"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
          validate: (0, _utils.assertNodeType)("Statement")
        },
        alternate: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("LabeledStatement", {
      visitor: ["label", "body"],
      aliases: ["Statement"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("StringLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("NumericLiteral", {
      builder: ["value"],
      deprecatedAlias: "NumberLiteral",
      fields: {
        value: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("number"), Object.assign(function(node, key, val) {
            if (1 / val < 0 || !Number.isFinite(val)) {
              const error = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${val}) instead.`);
            }
          }, {
            type: "number"
          }))
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("NullLiteral", {
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("BooleanLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("boolean")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("RegExpLiteral", {
      builder: ["pattern", "flags"],
      deprecatedAlias: "RegexLiteral",
      aliases: ["Expression", "Pureish", "Literal"],
      fields: {
        pattern: {
          validate: (0, _utils.assertValueType)("string")
        },
        flags: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
            const invalid = /[^dgimsuvy]/.exec(val);
            if (invalid) {
              throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
            }
          }, {
            type: "string"
          })) : (0, _utils.assertValueType)("string"),
          default: ""
        }
      }
    });
    defineType("LogicalExpression", {
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"],
      fields: {
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.LOGICAL_OPERATORS)
        },
        left: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("MemberExpression", {
      builder: ["object", "property", "computed", ...!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : []],
      visitor: ["object", "property"],
      aliases: ["Expression", "LVal", "PatternLike"],
      unionShape: {
        discriminator: "computed",
        shapes: [{
          name: "computed",
          value: [true],
          properties: {
            property: {
              validate: (0, _utils.assertNodeType)("Expression")
            }
          }
        }, {
          name: "nonComputed",
          value: [false],
          properties: {
            property: {
              validate: (0, _utils.assertNodeType)("Identifier", "PrivateName")
            }
          }
        }]
      },
      fields: Object.assign({
        object: {
          validate: (0, _utils.assertNodeType)("Expression", "Super")
        },
        property: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            };
            validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
            return validator;
          }()
        },
        computed: {
          default: false
        }
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        optional: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      } : {})
    });
    defineType("NewExpression", {
      inherits: "CallExpression"
    });
    defineType("Program", {
      visitor: ["directives", "body"],
      builder: ["body", "directives", "sourceType", "interpreter"],
      fields: {
        sourceType: {
          validate: (0, _utils.assertOneOf)("script", "module"),
          default: "script"
        },
        interpreter: {
          validate: (0, _utils.assertNodeType)("InterpreterDirective"),
          default: null,
          optional: true
        },
        directives: {
          validate: (0, _utils.arrayOfType)("Directive"),
          default: []
        },
        body: (0, _utils.validateArrayOfType)("Statement")
      },
      aliases: ["Scopable", "BlockParent", "Block"]
    });
    defineType("ObjectExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: (0, _utils.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")
      }
    });
    defineType("ObjectMethod", Object.assign({
      builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
      visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"]
    }, classMethodOrPropertyUnionShapeCommon(), {
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        kind: Object.assign({
          validate: (0, _utils.assertOneOf)("method", "get", "set")
        }, !process.env.BABEL_TYPES_8_BREAKING ? {
          default: "method"
        } : {}),
        computed: {
          default: false
        },
        key: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            };
            validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];
            return validator;
          }()
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      }),
      aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
    }));
    defineType("ObjectProperty", {
      builder: ["key", "value", "computed", "shorthand", ...!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : []],
      unionShape: {
        discriminator: "computed",
        shapes: [{
          name: "computed",
          value: [true],
          properties: {
            key: {
              validate: (0, _utils.assertNodeType)("Expression")
            }
          }
        }, {
          name: "nonComputed",
          value: [false],
          properties: {
            key: {
              validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName")
            }
          }
        }]
      },
      fields: {
        computed: {
          default: false
        },
        key: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = Object.assign(function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
            });
            return validator;
          }()
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
        },
        shorthand: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, shorthand) {
            if (!shorthand) return;
            if (node.computed) {
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
            }
            if (!(0, _is.default)("Identifier", node.key)) {
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
            }
          }, {
            type: "boolean"
          })) : (0, _utils.assertValueType)("boolean"),
          default: false
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        }
      },
      visitor: ["decorators", "key", "value"],
      aliases: ["UserWhitespacable", "Property", "ObjectMember"],
      validate: !process.env.BABEL_TYPES_8_BREAKING ? void 0 : function() {
        const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
        const expression = (0, _utils.assertNodeType)("Expression");
        return function(parent, key, node) {
          const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
          validator(node, "value", node.value);
        };
      }()
    });
    defineType("RestElement", {
      visitor: ["argument", "typeAnnotation"],
      builder: ["argument"],
      aliases: ["FunctionParameter", "PatternLike", "LVal"],
      deprecatedAlias: "RestProperty",
      fields: Object.assign({}, patternLikeCommon(), {
        argument: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression", "RestElement", "AssignmentPattern") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        }
      }),
      validate: process.env.BABEL_TYPES_8_BREAKING ? function(parent, key) {
        const match = /(\w+)\[(\d+)\]/.exec(key.toString());
        if (!match) throw new Error("Internal Babel error: malformed key.");
        const [, listKey, index] = match;
        if (parent[listKey].length > +index + 1) {
          throw new TypeError(`RestElement must be last element of ${listKey}`);
        }
      } : void 0
    });
    defineType("ReturnStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        }
      }
    });
    defineType("SequenceExpression", {
      visitor: ["expressions"],
      fields: {
        expressions: (0, _utils.validateArrayOfType)("Expression")
      },
      aliases: ["Expression"]
    });
    defineType("ParenthesizedExpression", {
      visitor: ["expression"],
      aliases: ["Expression", "ExpressionWrapper"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("SwitchCase", {
      visitor: ["test", "consequent"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        consequent: (0, _utils.validateArrayOfType)("Statement")
      }
    });
    defineType("SwitchStatement", {
      visitor: ["discriminant", "cases"],
      aliases: ["Statement", "BlockParent", "Scopable"],
      fields: {
        discriminant: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        cases: (0, _utils.validateArrayOfType)("SwitchCase")
      }
    });
    defineType("ThisExpression", {
      aliases: ["Expression"]
    });
    defineType("ThrowStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("TryStatement", {
      visitor: ["block", "handler", "finalizer"],
      aliases: ["Statement"],
      fields: {
        block: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node) {
            if (!node.handler && !node.finalizer) {
              throw new TypeError("TryStatement expects either a handler or finalizer, or both");
            }
          }, {
            oneOfNodeTypes: ["BlockStatement"]
          })) : (0, _utils.assertNodeType)("BlockStatement")
        },
        handler: {
          optional: true,
          validate: (0, _utils.assertNodeType)("CatchClause")
        },
        finalizer: {
          optional: true,
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      }
    });
    defineType("UnaryExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          default: true
        },
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.UNARY_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["UnaryLike", "Expression"]
    });
    defineType("UpdateExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          default: false
        },
        argument: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
        },
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.UPDATE_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["Expression"]
    });
    defineType("VariableDeclaration", {
      builder: ["kind", "declarations"],
      visitor: ["declarations"],
      aliases: ["Statement", "Declaration"],
      fields: {
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        kind: {
          validate: (0, _utils.assertOneOf)("var", "let", "const", "using", "await using")
        },
        declarations: (0, _utils.validateArrayOfType)("VariableDeclarator")
      },
      validate: process.env.BABEL_TYPES_8_BREAKING ? (() => {
        const withoutInit = (0, _utils.assertNodeType)("Identifier", "Placeholder");
        const constOrLetOrVar = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "Placeholder");
        const usingOrAwaitUsing = (0, _utils.assertNodeType)("Identifier", "VoidPattern", "Placeholder");
        return function(parent, key, node) {
          const {
            kind,
            declarations
          } = node;
          const parentIsForX = (0, _is.default)("ForXStatement", parent, {
            left: node
          });
          if (parentIsForX) {
            if (declarations.length !== 1) {
              throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
            }
          }
          for (const decl of declarations) {
            if (kind === "const" || kind === "let" || kind === "var") {
              if (!parentIsForX && !decl.init) {
                withoutInit(decl, "id", decl.id);
              } else {
                constOrLetOrVar(decl, "id", decl.id);
              }
            } else {
              usingOrAwaitUsing(decl, "id", decl.id);
            }
          }
        };
      })() : void 0
    });
    defineType("VariableDeclarator", {
      visitor: ["id", "init"],
      fields: {
        id: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal", "VoidPattern") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "VoidPattern")
        },
        definite: {
          optional: true,
          validate: (0, _utils.assertValueType)("boolean")
        },
        init: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("WhileStatement", {
      visitor: ["test", "body"],
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("WithStatement", {
      visitor: ["object", "body"],
      aliases: ["Statement"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("AssignmentPattern", {
      visitor: ["left", "right", "decorators"],
      builder: ["left", "right"],
      aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        left: {
          validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        }
      })
    });
    defineType("ArrayPattern", {
      visitor: ["elements", "typeAnnotation"],
      builder: ["elements"],
      aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        elements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike")))
        }
      })
    });
    defineType("ArrowFunctionExpression", {
      builder: ["params", "body", "async"],
      visitor: ["typeParameters", "params", "predicate", "returnType", "body"],
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        expression: {
          validate: (0, _utils.assertValueType)("boolean")
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      })
    });
    defineType("ClassBody", {
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")
      }
    });
    defineType("ClassExpression", {
      builder: ["id", "superClass", "body", "decorators"],
      visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body"],
      aliases: ["Scopable", "Class", "Expression"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        },
        ["superTypeParameters"]: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        },
        implements: {
          validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        },
        mixins: {
          validate: (0, _utils.assertNodeType)("InterfaceExtends"),
          optional: true
        }
      }
    });
    defineType("ClassDeclaration", {
      inherits: "ClassExpression",
      aliases: ["Scopable", "Class", "Statement", "Declaration"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        },
        ["superTypeParameters"]: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        },
        implements: {
          validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        },
        mixins: {
          validate: (0, _utils.assertNodeType)("InterfaceExtends"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        abstract: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      },
      validate: !process.env.BABEL_TYPES_8_BREAKING ? void 0 : function() {
        const identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node) {
          if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
            identifier(node, "id", node.id);
          }
        };
      }()
    });
    var importAttributes = exports.importAttributes = {
      attributes: {
        optional: true,
        validate: (0, _utils.arrayOfType)("ImportAttribute")
      }
    };
    importAttributes.assertions = {
      deprecated: true,
      optional: true,
      validate: (0, _utils.arrayOfType)("ImportAttribute")
    };
    defineType("ExportAllDeclaration", {
      builder: ["source"],
      visitor: ["source", "attributes", "assertions"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: Object.assign({
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      }, importAttributes)
    });
    defineType("ExportDefaultDeclaration", {
      visitor: ["declaration"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: {
        declaration: (0, _utils.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"),
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
      }
    });
    defineType("ExportNamedDeclaration", {
      builder: ["declaration", "specifiers", "source"],
      visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: Object.assign({
        declaration: {
          optional: true,
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node, key, val) {
            if (val && node.specifiers.length) {
              throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
            }
            if (val && node.source) {
              throw new TypeError("Cannot export a declaration from a source");
            }
          }, {
            oneOfNodeTypes: ["Declaration"]
          })) : (0, _utils.assertNodeType)("Declaration")
        }
      }, importAttributes, {
        specifiers: {
          default: [],
          validate: (0, _utils.arrayOf)(function() {
            const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
            const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
            if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;
            return Object.assign(function(node, key, val) {
              const validator = node.source ? sourced : sourceless;
              validator(node, key, val);
            }, {
              oneOfNodeTypes: ["ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"]
            });
          }())
        },
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral"),
          optional: true
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      })
    });
    defineType("ExportSpecifier", {
      visitor: ["local", "exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        exportKind: {
          validate: (0, _utils.assertOneOf)("type", "value"),
          optional: true
        }
      }
    });
    defineType("ForOfStatement", {
      visitor: ["left", "right", "body"],
      builder: ["left", "right", "body", "await"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: function() {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
            }
            const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
            const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
            return Object.assign(function(node, key, val) {
              if ((0, _is.default)("VariableDeclaration", val)) {
                declaration(node, key, val);
              } else {
                lval(node, key, val);
              }
            }, {
              oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression"]
            });
          }()
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        },
        await: {
          default: false
        }
      }
    });
    defineType("ImportDeclaration", {
      builder: ["specifiers", "source"],
      visitor: ["specifiers", "source", "attributes", "assertions"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
      fields: Object.assign({}, importAttributes, {
        module: {
          optional: true,
          validate: (0, _utils.assertValueType)("boolean")
        },
        phase: {
          default: null,
          validate: (0, _utils.assertOneOf)("source", "defer")
        },
        specifiers: (0, _utils.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
          optional: true
        }
      })
    });
    defineType("ImportDefaultSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("ImportNamespaceSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("ImportSpecifier", {
      visitor: ["imported", "local"],
      builder: ["local", "imported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        imported: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
          optional: true
        }
      }
    });
    defineType("ImportExpression", {
      visitor: ["source", "options"],
      aliases: ["Expression"],
      fields: {
        phase: {
          default: null,
          validate: (0, _utils.assertOneOf)("source", "defer")
        },
        source: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        options: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        }
      }
    });
    defineType("MetaProperty", {
      visitor: ["meta", "property"],
      aliases: ["Expression"],
      fields: {
        meta: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node, key, val) {
            let property4;
            switch (val.name) {
              case "function":
                property4 = "sent";
                break;
              case "new":
                property4 = "target";
                break;
              case "import":
                property4 = "meta";
                break;
            }
            if (!(0, _is.default)("Identifier", node.property, {
              name: property4
            })) {
              throw new TypeError("Unrecognised MetaProperty");
            }
          }, {
            oneOfNodeTypes: ["Identifier"]
          })) : (0, _utils.assertNodeType)("Identifier")
        },
        property: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    var classMethodOrPropertyCommon = () => ({
      abstract: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: true
      },
      static: {
        default: false
      },
      override: {
        default: false
      },
      computed: {
        default: false
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      key: {
        validate: (0, _utils.chain)(function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
          const computed = (0, _utils.assertNodeType)("Expression");
          return function(node, key, val) {
            const validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
        }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
      }
    });
    exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
    var classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
      params: (0, _utils.validateArrayOfType)("FunctionParameter", "TSParameterProperty"),
      kind: {
        validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
        default: "method"
      },
      access: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      }
    });
    exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
    defineType("ClassMethod", Object.assign({
      aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
      builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
      visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"]
    }, classMethodOrPropertyUnionShapeCommon(), {
      fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      })
    }));
    defineType("ObjectPattern", {
      visitor: ["decorators", "properties", "typeAnnotation"],
      builder: ["properties"],
      aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        properties: (0, _utils.validateArrayOfType)("RestElement", "ObjectProperty")
      })
    });
    defineType("SpreadElement", {
      visitor: ["argument"],
      aliases: ["UnaryLike"],
      deprecatedAlias: "SpreadProperty",
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("Super", {
      aliases: ["Expression"]
    });
    defineType("TaggedTemplateExpression", {
      visitor: ["tag", "typeParameters", "quasi"],
      builder: ["tag", "quasi"],
      aliases: ["Expression"],
      fields: {
        tag: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        quasi: {
          validate: (0, _utils.assertNodeType)("TemplateLiteral")
        },
        ["typeParameters"]: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType("TemplateElement", {
      builder: ["value", "tail"],
      fields: {
        value: {
          validate: (0, _utils.chain)((0, _utils.assertShape)({
            raw: {
              validate: (0, _utils.assertValueType)("string")
            },
            cooked: {
              validate: (0, _utils.assertValueType)("string"),
              optional: true
            }
          }), function templateElementCookedValidator(node) {
            const raw = node.value.raw;
            let unterminatedCalled = false;
            const error = () => {
              throw new Error("Internal @babel/types error.");
            };
            const {
              str,
              firstInvalidLoc
            } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
              unterminated() {
                unterminatedCalled = true;
              },
              strictNumericEscape: error,
              invalidEscapeSequence: error,
              numericSeparatorInEscapeSequence: error,
              unexpectedNumericSeparator: error,
              invalidDigit: error,
              invalidCodePoint: error
            });
            if (!unterminatedCalled) throw new Error("Invalid raw");
            node.value.cooked = firstInvalidLoc ? null : str;
          })
        },
        tail: {
          default: false
        }
      }
    });
    defineType("TemplateLiteral", {
      visitor: ["quasis", "expressions"],
      aliases: ["Expression", "Literal"],
      fields: {
        quasis: (0, _utils.validateArrayOfType)("TemplateElement"),
        expressions: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node, key, val) {
            if (node.quasis.length !== val.length + 1) {
              throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.
Expected ${val.length + 1} quasis but got ${node.quasis.length}`);
            }
          })
        }
      }
    });
    defineType("YieldExpression", {
      builder: ["argument", "delegate"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        delegate: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
            if (val && !node.argument) {
              throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
            }
          }, {
            type: "boolean"
          })) : (0, _utils.assertValueType)("boolean"),
          default: false
        },
        argument: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("AwaitExpression", {
      builder: ["argument"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("Import", {
      aliases: ["Expression"]
    });
    defineType("BigIntLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("ExportNamespaceSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("OptionalMemberExpression", {
      builder: ["object", "property", "computed", "optional"],
      visitor: ["object", "property"],
      aliases: ["Expression"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        property: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = Object.assign(function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "Identifier"]
            });
            return validator;
          }()
        },
        computed: {
          default: false
        },
        optional: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
        }
      }
    });
    defineType("OptionalCallExpression", {
      visitor: ["callee", "typeParameters", "typeArguments", "arguments"],
      builder: ["callee", "arguments", "optional"],
      aliases: ["Expression"],
      fields: Object.assign({
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
        optional: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
        },
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: true
        }
      }, {
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: true
        }
      })
    });
    defineType("ClassProperty", Object.assign({
      visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
      builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
      aliases: ["Property"]
    }, classMethodOrPropertyUnionShapeCommon(), {
      fields: Object.assign({}, classMethodOrPropertyCommon(), {
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      })
    }));
    defineType("ClassAccessorProperty", Object.assign({
      visitor: ["decorators", "key", "typeAnnotation", "value"],
      builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
      aliases: ["Property", "Accessor"]
    }, classMethodOrPropertyUnionShapeCommon(true), {
      fields: Object.assign({}, classMethodOrPropertyCommon(), {
        key: {
          validate: (0, _utils.chain)(function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            return function(node, key, val) {
              const validator = node.computed ? computed : normal;
              validator(node, key, val);
            };
          }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      })
    }));
    defineType("ClassPrivateProperty", {
      visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
      builder: ["key", "value", "decorators", "static"],
      aliases: ["Property", "Private"],
      fields: {
        key: {
          validate: (0, _utils.assertNodeType)("PrivateName")
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        },
        static: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        optional: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      }
    });
    defineType("ClassPrivateMethod", {
      builder: ["kind", "key", "params", "body", "static"],
      visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
      aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        kind: {
          validate: (0, _utils.assertOneOf)("get", "set", "method"),
          default: "method"
        },
        key: {
          validate: (0, _utils.assertNodeType)("PrivateName")
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      })
    });
    defineType("PrivateName", {
      visitor: ["id"],
      aliases: ["Private"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("StaticBlock", {
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("Statement")
      },
      aliases: ["Scopable", "BlockParent", "FunctionParent"]
    });
    defineType("ImportAttribute", {
      visitor: ["key", "value"],
      fields: {
        key: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        value: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        }
      }
    });
  }
});

// node_modules/@babel/types/lib/definitions/flow.js
var require_flow = __commonJS({
  "node_modules/@babel/types/lib/definitions/flow.js"() {
    "use strict";
    var _core = require_core();
    var _utils = require_utils();
    var defineType = (0, _utils.defineAliasedType)("Flow");
    var defineInterfaceishType = (name50) => {
      const isDeclareClass = name50 === "DeclareClass";
      defineType(name50, {
        builder: ["id", "typeParameters", "extends", "body"],
        visitor: ["id", "typeParameters", "extends", ...isDeclareClass ? ["mixins", "implements"] : [], "body"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: Object.assign({
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends"))
        }, isDeclareClass ? {
          mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
          implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements"))
        } : {}, {
          body: (0, _utils.validateType)("ObjectTypeAnnotation")
        })
      });
    };
    defineType("AnyTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ArrayTypeAnnotation", {
      visitor: ["elementType"],
      aliases: ["FlowType"],
      fields: {
        elementType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("BooleanTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("BooleanLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("NullLiteralTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ClassImplements", {
      visitor: ["id", "typeParameters"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("DeclareClass");
    defineType("DeclareFunction", {
      builder: ["id"],
      visitor: ["id", "predicate"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
      }
    });
    defineInterfaceishType("DeclareInterface");
    defineType("DeclareModule", {
      builder: ["id", "body", "kind"],
      visitor: ["id", "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier", "StringLiteral"),
        body: (0, _utils.validateType)("BlockStatement"),
        kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
      }
    });
    defineType("DeclareModuleExports", {
      visitor: ["typeAnnotation"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
      }
    });
    defineType("DeclareTypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("DeclareOpaqueType", {
      visitor: ["id", "typeParameters", "supertype"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateOptionalType)("FlowType")
      }
    });
    defineType("DeclareVariable", {
      visitor: ["id"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("DeclareExportDeclaration", {
      visitor: ["declaration", "specifiers", "source", "attributes"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        declaration: (0, _utils.validateOptionalType)("Flow"),
        specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")),
        source: (0, _utils.validateOptionalType)("StringLiteral"),
        default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }, _core.importAttributes)
    });
    defineType("DeclareExportAllDeclaration", {
      visitor: ["source", "attributes"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        source: (0, _utils.validateType)("StringLiteral"),
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      }, _core.importAttributes)
    });
    defineType("DeclaredPredicate", {
      visitor: ["value"],
      aliases: ["FlowPredicate"],
      fields: {
        value: (0, _utils.validateType)("Flow")
      }
    });
    defineType("ExistsTypeAnnotation", {
      aliases: ["FlowType"]
    });
    defineType("FunctionTypeAnnotation", {
      builder: ["typeParameters", "params", "rest", "returnType"],
      visitor: ["typeParameters", "this", "params", "rest", "returnType"],
      aliases: ["FlowType"],
      fields: {
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        params: (0, _utils.validateArrayOfType)("FunctionTypeParam"),
        rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        returnType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("FunctionTypeParam", {
      visitor: ["name", "typeAnnotation"],
      fields: {
        name: (0, _utils.validateOptionalType)("Identifier"),
        typeAnnotation: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("GenericTypeAnnotation", {
      visitor: ["id", "typeParameters"],
      aliases: ["FlowType"],
      fields: {
        id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineType("InferredPredicate", {
      aliases: ["FlowPredicate"]
    });
    defineType("InterfaceExtends", {
      visitor: ["id", "typeParameters"],
      fields: {
        id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("InterfaceDeclaration");
    defineType("InterfaceTypeAnnotation", {
      visitor: ["extends", "body"],
      aliases: ["FlowType"],
      fields: {
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
        body: (0, _utils.validateType)("ObjectTypeAnnotation")
      }
    });
    defineType("IntersectionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("MixedTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("EmptyTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("NullableTypeAnnotation", {
      visitor: ["typeAnnotation"],
      aliases: ["FlowType"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("NumberLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
      }
    });
    defineType("NumberTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ObjectTypeAnnotation", {
      visitor: ["properties", "indexers", "callProperties", "internalSlots"],
      aliases: ["FlowType"],
      builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
      fields: {
        properties: (0, _utils.validate)((0, _utils.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")),
        indexers: {
          validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
          optional: true,
          default: []
        },
        callProperties: {
          validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
          optional: true,
          default: []
        },
        internalSlots: {
          validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
          optional: true,
          default: []
        },
        exact: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        },
        inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeInternalSlot", {
      visitor: ["id", "value"],
      builder: ["id", "value", "optional", "static", "method"],
      aliases: ["UserWhitespacable"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        value: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeCallProperty", {
      visitor: ["value"],
      aliases: ["UserWhitespacable"],
      fields: {
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeIndexer", {
      visitor: ["variance", "id", "key", "value"],
      builder: ["id", "key", "value", "variance"],
      aliases: ["UserWhitespacable"],
      fields: {
        id: (0, _utils.validateOptionalType)("Identifier"),
        key: (0, _utils.validateType)("FlowType"),
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance")
      }
    });
    defineType("ObjectTypeProperty", {
      visitor: ["key", "value", "variance"],
      aliases: ["UserWhitespacable"],
      fields: {
        key: (0, _utils.validateType)("Identifier", "StringLiteral"),
        value: (0, _utils.validateType)("FlowType"),
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance"),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeSpreadProperty", {
      visitor: ["argument"],
      aliases: ["UserWhitespacable"],
      fields: {
        argument: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("OpaqueType", {
      visitor: ["id", "typeParameters", "supertype", "impltype"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("QualifiedTypeIdentifier", {
      visitor: ["qualification", "id"],
      builder: ["id", "qualification"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        qualification: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier")
      }
    });
    defineType("StringLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
      }
    });
    defineType("StringTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("SymbolTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ThisTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("TupleTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("TypeofTypeAnnotation", {
      visitor: ["argument"],
      aliases: ["FlowType"],
      fields: {
        argument: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeAnnotation", {
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeCastExpression", {
      visitor: ["expression", "typeAnnotation"],
      aliases: ["ExpressionWrapper", "Expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
      }
    });
    defineType("TypeParameter", {
      visitor: ["bound", "default", "variance"],
      fields: {
        name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
        default: (0, _utils.validateOptionalType)("FlowType"),
        variance: (0, _utils.validateOptionalType)("Variance")
      }
    });
    defineType("TypeParameterDeclaration", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
      }
    });
    defineType("TypeParameterInstantiation", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("UnionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("Variance", {
      builder: ["kind"],
      fields: {
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
      }
    });
    defineType("VoidTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("EnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "body"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        body: (0, _utils.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody")
      }
    });
    defineType("EnumBooleanBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumNumberBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumStringBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumSymbolBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumBooleanMember", {
      aliases: ["EnumMember"],
      builder: ["id"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("BooleanLiteral")
      }
    });
    defineType("EnumNumberMember", {
      aliases: ["EnumMember"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("NumericLiteral")
      }
    });
    defineType("EnumStringMember", {
      aliases: ["EnumMember"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("StringLiteral")
      }
    });
    defineType("EnumDefaultedMember", {
      aliases: ["EnumMember"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("IndexedAccessType", {
      visitor: ["objectType", "indexType"],
      aliases: ["FlowType"],
      fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("OptionalIndexedAccessType", {
      visitor: ["objectType", "indexType"],
      aliases: ["FlowType"],
      fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
  }
});

// node_modules/@babel/types/lib/definitions/jsx.js
var require_jsx = __commonJS({
  "node_modules/@babel/types/lib/definitions/jsx.js"() {
    "use strict";
    var _utils = require_utils();
    var defineType = (0, _utils.defineAliasedType)("JSX");
    defineType("JSXAttribute", {
      visitor: ["name", "value"],
      aliases: ["Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
        },
        value: {
          optional: true,
          validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
        }
      }
    });
    defineType("JSXClosingElement", {
      visitor: ["name"],
      aliases: ["Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        }
      }
    });
    defineType("JSXElement", {
      builder: ["openingElement", "closingElement", "children", "selfClosing"],
      visitor: ["openingElement", "children", "closingElement"],
      aliases: ["Immutable", "Expression"],
      fields: Object.assign({
        openingElement: {
          validate: (0, _utils.assertNodeType)("JSXOpeningElement")
        },
        closingElement: {
          optional: true,
          validate: (0, _utils.assertNodeType)("JSXClosingElement")
        },
        children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
      }, {
        selfClosing: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      })
    });
    defineType("JSXEmptyExpression", {});
    defineType("JSXExpressionContainer", {
      visitor: ["expression"],
      aliases: ["Immutable"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
        }
      }
    });
    defineType("JSXSpreadChild", {
      visitor: ["expression"],
      aliases: ["Immutable"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("JSXIdentifier", {
      builder: ["name"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("JSXMemberExpression", {
      visitor: ["object", "property"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
        },
        property: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
      }
    });
    defineType("JSXNamespacedName", {
      visitor: ["namespace", "name"],
      fields: {
        namespace: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        },
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
      }
    });
    defineType("JSXOpeningElement", {
      builder: ["name", "attributes", "selfClosing"],
      visitor: ["name", "typeParameters", "typeArguments", "attributes"],
      aliases: ["Immutable"],
      fields: Object.assign({
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        },
        selfClosing: {
          default: false
        },
        attributes: (0, _utils.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"),
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: true
        }
      }, {
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: true
        }
      })
    });
    defineType("JSXSpreadAttribute", {
      visitor: ["argument"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("JSXText", {
      aliases: ["Immutable"],
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("JSXFragment", {
      builder: ["openingFragment", "closingFragment", "children"],
      visitor: ["openingFragment", "children", "closingFragment"],
      aliases: ["Immutable", "Expression"],
      fields: {
        openingFragment: {
          validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
        },
        closingFragment: {
          validate: (0, _utils.assertNodeType)("JSXClosingFragment")
        },
        children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
      }
    });
    defineType("JSXOpeningFragment", {
      aliases: ["Immutable"]
    });
    defineType("JSXClosingFragment", {
      aliases: ["Immutable"]
    });
  }
});

// node_modules/@babel/types/lib/definitions/placeholders.js
var require_placeholders = __commonJS({
  "node_modules/@babel/types/lib/definitions/placeholders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;
    var _utils = require_utils();
    var PLACEHOLDERS = exports.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
    var PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS_ALIAS = {
      Declaration: ["Statement"],
      Pattern: ["PatternLike", "LVal"]
    };
    for (const type of PLACEHOLDERS) {
      const alias = _utils.ALIAS_KEYS[type];
      if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;
    }
    var PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_FLIPPED_ALIAS = {};
    Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
      PLACEHOLDERS_ALIAS[type].forEach((alias) => {
        if (!hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
          PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
        }
        PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
      });
    });
  }
});

// node_modules/@babel/types/lib/definitions/misc.js
var require_misc = __commonJS({
  "node_modules/@babel/types/lib/definitions/misc.js"() {
    "use strict";
    var _utils = require_utils();
    var _placeholders = require_placeholders();
    var _core = require_core();
    var defineType = (0, _utils.defineAliasedType)("Miscellaneous");
    defineType("Noop", {
      visitor: []
    });
    defineType("Placeholder", {
      visitor: [],
      builder: ["expectedNode", "name"],
      fields: Object.assign({
        name: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        expectedNode: {
          validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
        }
      }, (0, _core.patternLikeCommon)())
    });
    defineType("V8IntrinsicIdentifier", {
      builder: ["name"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
  }
});

// node_modules/@babel/types/lib/definitions/experimental.js
var require_experimental = __commonJS({
  "node_modules/@babel/types/lib/definitions/experimental.js"() {
    "use strict";
    var _utils = require_utils();
    (0, _utils.default)("ArgumentPlaceholder", {});
    (0, _utils.default)("BindExpression", {
      visitor: ["object", "callee"],
      aliases: ["Expression"],
      fields: !process.env.BABEL_TYPES_8_BREAKING ? {
        object: {
          validate: Object.assign(() => {
          }, {
            oneOfNodeTypes: ["Expression"]
          })
        },
        callee: {
          validate: Object.assign(() => {
          }, {
            oneOfNodeTypes: ["Expression"]
          })
        }
      } : {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("Decorator", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("DoExpression", {
      visitor: ["body"],
      builder: ["body", "async"],
      aliases: ["Expression"],
      fields: {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        async: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        }
      }
    });
    (0, _utils.default)("ExportDefaultSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    (0, _utils.default)("RecordExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: (0, _utils.validateArrayOfType)("ObjectProperty", "SpreadElement")
      }
    });
    (0, _utils.default)("TupleExpression", {
      fields: {
        elements: {
          validate: (0, _utils.arrayOfType)("Expression", "SpreadElement"),
          default: []
        }
      },
      visitor: ["elements"],
      aliases: ["Expression"]
    });
    (0, _utils.default)("DecimalLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    (0, _utils.default)("ModuleExpression", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, _utils.assertNodeType)("Program")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("TopicReference", {
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelineTopicExpression", {
      builder: ["expression"],
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelineBareFunction", {
      builder: ["callee"],
      visitor: ["callee"],
      fields: {
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelinePrimaryTopicReference", {
      aliases: ["Expression"]
    });
    (0, _utils.default)("VoidPattern", {
      aliases: ["Pattern", "PatternLike", "FunctionParameter"]
    });
  }
});

// node_modules/@babel/types/lib/definitions/typescript.js
var require_typescript = __commonJS({
  "node_modules/@babel/types/lib/definitions/typescript.js"() {
    "use strict";
    var _utils = require_utils();
    var _core = require_core();
    var _is = require_is();
    var defineType = (0, _utils.defineAliasedType)("TypeScript");
    var bool = (0, _utils.assertValueType)("boolean");
    var tSFunctionTypeAnnotationCommon = () => ({
      returnType: {
        validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    });
    defineType("TSParameterProperty", {
      aliases: ["LVal"],
      visitor: ["parameter"],
      fields: {
        accessibility: {
          validate: (0, _utils.assertOneOf)("public", "private", "protected"),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        parameter: {
          validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
        },
        override: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        }
      }
    });
    defineType("TSDeclareFunction", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "params", "returnType"],
      fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
    });
    defineType("TSDeclareMethod", Object.assign({
      visitor: ["decorators", "key", "typeParameters", "params", "returnType"]
    }, (0, _core.classMethodOrPropertyUnionShapeCommon)(), {
      fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
    }));
    defineType("TSQualifiedName", {
      aliases: ["TSEntityName"],
      visitor: ["left", "right"],
      fields: {
        left: (0, _utils.validateType)("TSEntityName"),
        right: (0, _utils.validateType)("Identifier")
      }
    });
    var signatureDeclarationCommon = () => ({
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      ["parameters"]: (0, _utils.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement"),
      ["typeAnnotation"]: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    });
    var callConstructSignatureDeclaration = {
      aliases: ["TSTypeElement"],
      visitor: ["typeParameters", "parameters", "typeAnnotation"],
      fields: signatureDeclarationCommon()
    };
    defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
    defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
    var namedTypeElementCommon = () => ({
      key: (0, _utils.validateType)("Expression"),
      computed: {
        default: false
      },
      optional: (0, _utils.validateOptional)(bool)
    });
    defineType("TSPropertySignature", {
      aliases: ["TSTypeElement"],
      visitor: ["key", "typeAnnotation"],
      fields: Object.assign({}, namedTypeElementCommon(), {
        readonly: (0, _utils.validateOptional)(bool),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        kind: {
          optional: true,
          validate: (0, _utils.assertOneOf)("get", "set")
        }
      })
    });
    defineType("TSMethodSignature", {
      aliases: ["TSTypeElement"],
      visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
      fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
        kind: {
          validate: (0, _utils.assertOneOf)("method", "get", "set")
        }
      })
    });
    defineType("TSIndexSignature", {
      aliases: ["TSTypeElement"],
      visitor: ["parameters", "typeAnnotation"],
      fields: {
        readonly: (0, _utils.validateOptional)(bool),
        static: (0, _utils.validateOptional)(bool),
        parameters: (0, _utils.validateArrayOfType)("Identifier"),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
      }
    });
    var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
    for (const type of tsKeywordTypes) {
      defineType(type, {
        aliases: ["TSType", "TSBaseType"],
        visitor: [],
        fields: {}
      });
    }
    defineType("TSThisType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
    var fnOrCtrBase = {
      aliases: ["TSType"],
      visitor: ["typeParameters", "parameters", "typeAnnotation"]
    };
    defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
      fields: signatureDeclarationCommon()
    }));
    defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
      fields: Object.assign({}, signatureDeclarationCommon(), {
        abstract: (0, _utils.validateOptional)(bool)
      })
    }));
    defineType("TSTypeReference", {
      aliases: ["TSType"],
      visitor: ["typeName", "typeParameters"],
      fields: {
        typeName: (0, _utils.validateType)("TSEntityName"),
        ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSTypePredicate", {
      aliases: ["TSType"],
      visitor: ["parameterName", "typeAnnotation"],
      builder: ["parameterName", "typeAnnotation", "asserts"],
      fields: {
        parameterName: (0, _utils.validateType)("Identifier", "TSThisType"),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        asserts: (0, _utils.validateOptional)(bool)
      }
    });
    defineType("TSTypeQuery", {
      aliases: ["TSType"],
      visitor: ["exprName", "typeParameters"],
      fields: {
        exprName: (0, _utils.validateType)("TSEntityName", "TSImportType"),
        ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSTypeLiteral", {
      aliases: ["TSType"],
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("TSTypeElement")
      }
    });
    defineType("TSArrayType", {
      aliases: ["TSType"],
      visitor: ["elementType"],
      fields: {
        elementType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSTupleType", {
      aliases: ["TSType"],
      visitor: ["elementTypes"],
      fields: {
        elementTypes: (0, _utils.validateArrayOfType)("TSType", "TSNamedTupleMember")
      }
    });
    defineType("TSOptionalType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSRestType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSNamedTupleMember", {
      visitor: ["label", "elementType"],
      builder: ["label", "elementType", "optional"],
      fields: {
        label: (0, _utils.validateType)("Identifier"),
        optional: {
          validate: bool,
          default: false
        },
        elementType: (0, _utils.validateType)("TSType")
      }
    });
    var unionOrIntersection = {
      aliases: ["TSType"],
      visitor: ["types"],
      fields: {
        types: (0, _utils.validateArrayOfType)("TSType")
      }
    };
    defineType("TSUnionType", unionOrIntersection);
    defineType("TSIntersectionType", unionOrIntersection);
    defineType("TSConditionalType", {
      aliases: ["TSType"],
      visitor: ["checkType", "extendsType", "trueType", "falseType"],
      fields: {
        checkType: (0, _utils.validateType)("TSType"),
        extendsType: (0, _utils.validateType)("TSType"),
        trueType: (0, _utils.validateType)("TSType"),
        falseType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSInferType", {
      aliases: ["TSType"],
      visitor: ["typeParameter"],
      fields: {
        typeParameter: (0, _utils.validateType)("TSTypeParameter")
      }
    });
    defineType("TSParenthesizedType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSTypeOperator", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      builder: ["typeAnnotation", "operator"],
      fields: {
        operator: {
          validate: (0, _utils.assertValueType)("string"),
          default: "keyof"
        },
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSIndexedAccessType", {
      aliases: ["TSType"],
      visitor: ["objectType", "indexType"],
      fields: {
        objectType: (0, _utils.validateType)("TSType"),
        indexType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSMappedType", {
      aliases: ["TSType"],
      visitor: ["typeParameter", "nameType", "typeAnnotation"],
      builder: ["typeParameter", "typeAnnotation", "nameType"],
      fields: Object.assign({}, {
        typeParameter: (0, _utils.validateType)("TSTypeParameter")
      }, {
        readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
        optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
        typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
        nameType: (0, _utils.validateOptionalType)("TSType")
      })
    });
    defineType("TSTemplateLiteralType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: ["quasis", "types"],
      fields: {
        quasis: (0, _utils.validateArrayOfType)("TemplateElement"),
        types: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")), function(node, key, val) {
            if (node.quasis.length !== val.length + 1) {
              throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of types.
Expected ${val.length + 1} quasis but got ${node.quasis.length}`);
            }
          })
        }
      }
    });
    defineType("TSLiteralType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: ["literal"],
      fields: {
        literal: {
          validate: function() {
            const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
            const unaryOperator = (0, _utils.assertOneOf)("-");
            const literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
            const validator = function validator2(parent, key, node) {
              if ((0, _is.default)("UnaryExpression", node)) {
                unaryOperator(node, "operator", node.operator);
                unaryExpression(node, "argument", node.argument);
              } else {
                literal(parent, key, node);
              }
            };
            validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"];
            return validator;
          }()
        }
      }
    });
    defineType("TSExpressionWithTypeArguments", {
      aliases: ["TSType"],
      visitor: ["expression", "typeParameters"],
      fields: {
        expression: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSInterfaceDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "extends", "body"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
        body: (0, _utils.validateType)("TSInterfaceBody")
      }
    });
    defineType("TSInterfaceBody", {
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("TSTypeElement")
      }
    });
    defineType("TSTypeAliasDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "typeAnnotation"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSInstantiationExpression", {
      aliases: ["Expression"],
      visitor: ["expression", "typeParameters"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    var TSTypeExpression = {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["expression", "typeAnnotation"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    };
    defineType("TSAsExpression", TSTypeExpression);
    defineType("TSSatisfiesExpression", TSTypeExpression);
    defineType("TSTypeAssertion", {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["typeAnnotation", "expression"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType"),
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSEnumBody", {
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("TSEnumMember")
      }
    });
    defineType("TSEnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "members"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        const: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        members: (0, _utils.validateArrayOfType)("TSEnumMember"),
        initializer: (0, _utils.validateOptionalType)("Expression"),
        body: (0, _utils.validateOptionalType)("TSEnumBody")
      }
    });
    defineType("TSEnumMember", {
      visitor: ["id", "initializer"],
      fields: {
        id: (0, _utils.validateType)("Identifier", "StringLiteral"),
        initializer: (0, _utils.validateOptionalType)("Expression")
      }
    });
    defineType("TSModuleDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "body"],
      fields: Object.assign({
        kind: {
          validate: (0, _utils.assertOneOf)("global", "module", "namespace")
        },
        declare: (0, _utils.validateOptional)(bool)
      }, {
        global: (0, _utils.validateOptional)(bool)
      }, {
        id: (0, _utils.validateType)("Identifier", "StringLiteral"),
        body: (0, _utils.validateType)("TSModuleBlock", "TSModuleDeclaration")
      })
    });
    defineType("TSModuleBlock", {
      aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("Statement")
      }
    });
    defineType("TSImportType", {
      aliases: ["TSType"],
      builder: ["argument", "qualifier", "typeParameters"],
      visitor: ["argument", "options", "qualifier", "typeParameters"],
      fields: Object.assign({}, {
        argument: (0, _utils.validateType)("StringLiteral")
      }, {
        qualifier: (0, _utils.validateOptionalType)("TSEntityName")
      }, {
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }, {
        options: {
          validate: (0, _utils.assertNodeType)("ObjectExpression"),
          optional: true
        }
      })
    });
    defineType("TSImportEqualsDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "moduleReference"],
      fields: Object.assign({}, {
        isExport: (0, _utils.validate)(bool)
      }, {
        id: (0, _utils.validateType)("Identifier"),
        moduleReference: (0, _utils.validateType)("TSEntityName", "TSExternalModuleReference"),
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "value"),
          optional: true
        }
      })
    });
    defineType("TSExternalModuleReference", {
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("StringLiteral")
      }
    });
    defineType("TSNonNullExpression", {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSExportAssignment", {
      aliases: ["Statement"],
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSNamespaceExportDeclaration", {
      aliases: ["Statement"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("TSTypeAnnotation", {
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TSType")
        }
      }
    });
    defineType("TSTypeParameterInstantiation", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validateArrayOfType)("TSType")
      }
    });
    defineType("TSTypeParameterDeclaration", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validateArrayOfType)("TSTypeParameter")
      }
    });
    defineType("TSTypeParameter", {
      builder: ["constraint", "default", "name"],
      visitor: ["constraint", "default"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        },
        in: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        out: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        const: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        constraint: {
          validate: (0, _utils.assertNodeType)("TSType"),
          optional: true
        },
        default: {
          validate: (0, _utils.assertNodeType)("TSType"),
          optional: true
        }
      }
    });
  }
});

// node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var require_deprecated_aliases = __commonJS({
  "node_modules/@babel/types/lib/definitions/deprecated-aliases.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DEPRECATED_ALIASES = void 0;
    var DEPRECATED_ALIASES = exports.DEPRECATED_ALIASES = {
      ModuleDeclaration: "ImportOrExportDeclaration"
    };
  }
});

// node_modules/@babel/types/lib/definitions/index.js
var require_definitions = __commonJS({
  "node_modules/@babel/types/lib/definitions/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports, "BUILDER_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.BUILDER_KEYS;
      }
    });
    Object.defineProperty(exports, "DEPRECATED_ALIASES", {
      enumerable: true,
      get: function() {
        return _deprecatedAliases.DEPRECATED_ALIASES;
      }
    });
    Object.defineProperty(exports, "DEPRECATED_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.DEPRECATED_KEYS;
      }
    });
    Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.FLIPPED_ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports, "NODE_FIELDS", {
      enumerable: true,
      get: function() {
        return _utils.NODE_FIELDS;
      }
    });
    Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
      enumerable: true,
      get: function() {
        return _utils.NODE_PARENT_VALIDATIONS;
      }
    });
    Object.defineProperty(exports, "NODE_UNION_SHAPES__PRIVATE", {
      enumerable: true,
      get: function() {
        return _utils.NODE_UNION_SHAPES__PRIVATE;
      }
    });
    Object.defineProperty(exports, "PLACEHOLDERS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS;
      }
    });
    Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS_ALIAS;
      }
    });
    Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
      }
    });
    exports.TYPES = void 0;
    Object.defineProperty(exports, "VISITOR_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.VISITOR_KEYS;
      }
    });
    require_core();
    require_flow();
    require_jsx();
    require_misc();
    require_experimental();
    require_typescript();
    var _utils = require_utils();
    var _placeholders = require_placeholders();
    var _deprecatedAliases = require_deprecated_aliases();
    Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach((deprecatedAlias) => {
      _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];
    });
    for (const {
      types,
      set
    } of _utils.allExpandedTypes) {
      for (const type of types) {
        const aliases = _utils.FLIPPED_ALIAS_KEYS[type];
        if (aliases) {
          aliases.forEach(set.add, set);
        } else {
          set.add(type);
        }
      }
    }
    var TYPES = exports.TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
  }
});

// node_modules/@babel/types/lib/validators/validate.js
var require_validate = __commonJS({
  "node_modules/@babel/types/lib/validators/validate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = validate;
    exports.validateChild = validateChild;
    exports.validateField = validateField;
    exports.validateInternal = validateInternal;
    var _index = require_definitions();
    function validate(node, key, val) {
      if (!node) return;
      const fields = _index.NODE_FIELDS[node.type];
      if (!fields) return;
      const field = fields[key];
      validateField(node, key, val, field);
      validateChild(node, key, val);
    }
    function validateInternal(field, node, key, val, maybeNode) {
      if (!(field != null && field.validate)) return;
      if (field.optional && val == null) return;
      field.validate(node, key, val);
      if (maybeNode) {
        var _NODE_PARENT_VALIDATI;
        const type = val.type;
        if (type == null) return;
        (_NODE_PARENT_VALIDATI = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI.call(_index.NODE_PARENT_VALIDATIONS, node, key, val);
      }
    }
    function validateField(node, key, val, field) {
      if (!(field != null && field.validate)) return;
      if (field.optional && val == null) return;
      field.validate(node, key, val);
    }
    function validateChild(node, key, val) {
      var _NODE_PARENT_VALIDATI2;
      const type = val == null ? void 0 : val.type;
      if (type == null) return;
      (_NODE_PARENT_VALIDATI2 = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI2.call(_index.NODE_PARENT_VALIDATIONS, node, key, val);
    }
  }
});

// node_modules/@babel/types/lib/builders/generated/lowercase.js
var require_lowercase = __commonJS({
  "node_modules/@babel/types/lib/builders/generated/lowercase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.anyTypeAnnotation = anyTypeAnnotation;
    exports.argumentPlaceholder = argumentPlaceholder;
    exports.arrayExpression = arrayExpression;
    exports.arrayPattern = arrayPattern;
    exports.arrayTypeAnnotation = arrayTypeAnnotation;
    exports.arrowFunctionExpression = arrowFunctionExpression;
    exports.assignmentExpression = assignmentExpression;
    exports.assignmentPattern = assignmentPattern;
    exports.awaitExpression = awaitExpression;
    exports.bigIntLiteral = bigIntLiteral;
    exports.binaryExpression = binaryExpression;
    exports.bindExpression = bindExpression;
    exports.blockStatement = blockStatement;
    exports.booleanLiteral = booleanLiteral;
    exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
    exports.booleanTypeAnnotation = booleanTypeAnnotation;
    exports.breakStatement = breakStatement;
    exports.callExpression = callExpression;
    exports.catchClause = catchClause;
    exports.classAccessorProperty = classAccessorProperty;
    exports.classBody = classBody;
    exports.classDeclaration = classDeclaration;
    exports.classExpression = classExpression;
    exports.classImplements = classImplements;
    exports.classMethod = classMethod;
    exports.classPrivateMethod = classPrivateMethod;
    exports.classPrivateProperty = classPrivateProperty;
    exports.classProperty = classProperty;
    exports.conditionalExpression = conditionalExpression;
    exports.continueStatement = continueStatement;
    exports.debuggerStatement = debuggerStatement;
    exports.decimalLiteral = decimalLiteral;
    exports.declareClass = declareClass;
    exports.declareExportAllDeclaration = declareExportAllDeclaration;
    exports.declareExportDeclaration = declareExportDeclaration;
    exports.declareFunction = declareFunction;
    exports.declareInterface = declareInterface;
    exports.declareModule = declareModule;
    exports.declareModuleExports = declareModuleExports;
    exports.declareOpaqueType = declareOpaqueType;
    exports.declareTypeAlias = declareTypeAlias;
    exports.declareVariable = declareVariable;
    exports.declaredPredicate = declaredPredicate;
    exports.decorator = decorator;
    exports.directive = directive;
    exports.directiveLiteral = directiveLiteral;
    exports.doExpression = doExpression;
    exports.doWhileStatement = doWhileStatement;
    exports.emptyStatement = emptyStatement;
    exports.emptyTypeAnnotation = emptyTypeAnnotation;
    exports.enumBooleanBody = enumBooleanBody;
    exports.enumBooleanMember = enumBooleanMember;
    exports.enumDeclaration = enumDeclaration;
    exports.enumDefaultedMember = enumDefaultedMember;
    exports.enumNumberBody = enumNumberBody;
    exports.enumNumberMember = enumNumberMember;
    exports.enumStringBody = enumStringBody;
    exports.enumStringMember = enumStringMember;
    exports.enumSymbolBody = enumSymbolBody;
    exports.existsTypeAnnotation = existsTypeAnnotation;
    exports.exportAllDeclaration = exportAllDeclaration;
    exports.exportDefaultDeclaration = exportDefaultDeclaration;
    exports.exportDefaultSpecifier = exportDefaultSpecifier;
    exports.exportNamedDeclaration = exportNamedDeclaration;
    exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
    exports.exportSpecifier = exportSpecifier;
    exports.expressionStatement = expressionStatement;
    exports.file = file;
    exports.forInStatement = forInStatement;
    exports.forOfStatement = forOfStatement;
    exports.forStatement = forStatement;
    exports.functionDeclaration = functionDeclaration;
    exports.functionExpression = functionExpression;
    exports.functionTypeAnnotation = functionTypeAnnotation;
    exports.functionTypeParam = functionTypeParam;
    exports.genericTypeAnnotation = genericTypeAnnotation;
    exports.identifier = identifier;
    exports.ifStatement = ifStatement;
    exports.import = _import;
    exports.importAttribute = importAttribute;
    exports.importDeclaration = importDeclaration;
    exports.importDefaultSpecifier = importDefaultSpecifier;
    exports.importExpression = importExpression;
    exports.importNamespaceSpecifier = importNamespaceSpecifier;
    exports.importSpecifier = importSpecifier;
    exports.indexedAccessType = indexedAccessType;
    exports.inferredPredicate = inferredPredicate;
    exports.interfaceDeclaration = interfaceDeclaration;
    exports.interfaceExtends = interfaceExtends;
    exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
    exports.interpreterDirective = interpreterDirective;
    exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
    exports.jSXAttribute = exports.jsxAttribute = jsxAttribute;
    exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
    exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
    exports.jSXElement = exports.jsxElement = jsxElement;
    exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
    exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
    exports.jSXFragment = exports.jsxFragment = jsxFragment;
    exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
    exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
    exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
    exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
    exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
    exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
    exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
    exports.jSXText = exports.jsxText = jsxText;
    exports.labeledStatement = labeledStatement;
    exports.logicalExpression = logicalExpression;
    exports.memberExpression = memberExpression;
    exports.metaProperty = metaProperty;
    exports.mixedTypeAnnotation = mixedTypeAnnotation;
    exports.moduleExpression = moduleExpression;
    exports.newExpression = newExpression;
    exports.noop = noop5;
    exports.nullLiteral = nullLiteral;
    exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
    exports.nullableTypeAnnotation = nullableTypeAnnotation;
    exports.numberLiteral = NumberLiteral;
    exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
    exports.numberTypeAnnotation = numberTypeAnnotation;
    exports.numericLiteral = numericLiteral;
    exports.objectExpression = objectExpression;
    exports.objectMethod = objectMethod;
    exports.objectPattern = objectPattern;
    exports.objectProperty = objectProperty;
    exports.objectTypeAnnotation = objectTypeAnnotation;
    exports.objectTypeCallProperty = objectTypeCallProperty;
    exports.objectTypeIndexer = objectTypeIndexer;
    exports.objectTypeInternalSlot = objectTypeInternalSlot;
    exports.objectTypeProperty = objectTypeProperty;
    exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
    exports.opaqueType = opaqueType;
    exports.optionalCallExpression = optionalCallExpression;
    exports.optionalIndexedAccessType = optionalIndexedAccessType;
    exports.optionalMemberExpression = optionalMemberExpression;
    exports.parenthesizedExpression = parenthesizedExpression;
    exports.pipelineBareFunction = pipelineBareFunction;
    exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
    exports.pipelineTopicExpression = pipelineTopicExpression;
    exports.placeholder = placeholder;
    exports.privateName = privateName;
    exports.program = program;
    exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
    exports.recordExpression = recordExpression;
    exports.regExpLiteral = regExpLiteral;
    exports.regexLiteral = RegexLiteral;
    exports.restElement = restElement;
    exports.restProperty = RestProperty;
    exports.returnStatement = returnStatement;
    exports.sequenceExpression = sequenceExpression;
    exports.spreadElement = spreadElement;
    exports.spreadProperty = SpreadProperty;
    exports.staticBlock = staticBlock;
    exports.stringLiteral = stringLiteral;
    exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
    exports.stringTypeAnnotation = stringTypeAnnotation;
    exports.super = _super;
    exports.switchCase = switchCase;
    exports.switchStatement = switchStatement;
    exports.symbolTypeAnnotation = symbolTypeAnnotation;
    exports.taggedTemplateExpression = taggedTemplateExpression;
    exports.templateElement = templateElement;
    exports.templateLiteral = templateLiteral;
    exports.thisExpression = thisExpression;
    exports.thisTypeAnnotation = thisTypeAnnotation;
    exports.throwStatement = throwStatement;
    exports.topicReference = topicReference;
    exports.tryStatement = tryStatement;
    exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
    exports.tSArrayType = exports.tsArrayType = tsArrayType;
    exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
    exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
    exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
    exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
    exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
    exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
    exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
    exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
    exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
    exports.tSEnumBody = exports.tsEnumBody = tsEnumBody;
    exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
    exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
    exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
    exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
    exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
    exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
    exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
    exports.tSImportType = exports.tsImportType = tsImportType;
    exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
    exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
    exports.tSInferType = exports.tsInferType = tsInferType;
    exports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;
    exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
    exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
    exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
    exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
    exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
    exports.tSMappedType = exports.tsMappedType = tsMappedType;
    exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
    exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
    exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
    exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
    exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
    exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
    exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
    exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
    exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
    exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
    exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
    exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
    exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
    exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
    exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
    exports.tSRestType = exports.tsRestType = tsRestType;
    exports.tSSatisfiesExpression = exports.tsSatisfiesExpression = tsSatisfiesExpression;
    exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
    exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
    exports.tSTemplateLiteralType = exports.tsTemplateLiteralType = tsTemplateLiteralType;
    exports.tSThisType = exports.tsThisType = tsThisType;
    exports.tSTupleType = exports.tsTupleType = tsTupleType;
    exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
    exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
    exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
    exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
    exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
    exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
    exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
    exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
    exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
    exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
    exports.tSTypeReference = exports.tsTypeReference = tsTypeReference;
    exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
    exports.tSUnionType = exports.tsUnionType = tsUnionType;
    exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
    exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
    exports.tupleExpression = tupleExpression;
    exports.tupleTypeAnnotation = tupleTypeAnnotation;
    exports.typeAlias = typeAlias;
    exports.typeAnnotation = typeAnnotation;
    exports.typeCastExpression = typeCastExpression;
    exports.typeParameter = typeParameter;
    exports.typeParameterDeclaration = typeParameterDeclaration;
    exports.typeParameterInstantiation = typeParameterInstantiation;
    exports.typeofTypeAnnotation = typeofTypeAnnotation;
    exports.unaryExpression = unaryExpression;
    exports.unionTypeAnnotation = unionTypeAnnotation;
    exports.updateExpression = updateExpression;
    exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
    exports.variableDeclaration = variableDeclaration;
    exports.variableDeclarator = variableDeclarator;
    exports.variance = variance;
    exports.voidPattern = voidPattern;
    exports.voidTypeAnnotation = voidTypeAnnotation;
    exports.whileStatement = whileStatement;
    exports.withStatement = withStatement;
    exports.yieldExpression = yieldExpression;
    var _validate = require_validate();
    var _deprecationWarning = require_deprecationWarning();
    var utils = require_utils();
    var {
      validateInternal: validate
    } = _validate;
    var {
      NODE_FIELDS
    } = utils;
    function bigIntLiteral(value) {
      if (typeof value === "bigint") {
        value = value.toString();
      }
      const node = {
        type: "BigIntLiteral",
        value
      };
      const defs = NODE_FIELDS.BigIntLiteral;
      validate(defs.value, node, "value", value);
      return node;
    }
    function arrayExpression(elements = []) {
      const node = {
        type: "ArrayExpression",
        elements
      };
      const defs = NODE_FIELDS.ArrayExpression;
      validate(defs.elements, node, "elements", elements, 1);
      return node;
    }
    function assignmentExpression(operator, left, right) {
      const node = {
        type: "AssignmentExpression",
        operator,
        left,
        right
      };
      const defs = NODE_FIELDS.AssignmentExpression;
      validate(defs.operator, node, "operator", operator);
      validate(defs.left, node, "left", left, 1);
      validate(defs.right, node, "right", right, 1);
      return node;
    }
    function binaryExpression(operator, left, right) {
      const node = {
        type: "BinaryExpression",
        operator,
        left,
        right
      };
      const defs = NODE_FIELDS.BinaryExpression;
      validate(defs.operator, node, "operator", operator);
      validate(defs.left, node, "left", left, 1);
      validate(defs.right, node, "right", right, 1);
      return node;
    }
    function interpreterDirective(value) {
      const node = {
        type: "InterpreterDirective",
        value
      };
      const defs = NODE_FIELDS.InterpreterDirective;
      validate(defs.value, node, "value", value);
      return node;
    }
    function directive(value) {
      const node = {
        type: "Directive",
        value
      };
      const defs = NODE_FIELDS.Directive;
      validate(defs.value, node, "value", value, 1);
      return node;
    }
    function directiveLiteral(value) {
      const node = {
        type: "DirectiveLiteral",
        value
      };
      const defs = NODE_FIELDS.DirectiveLiteral;
      validate(defs.value, node, "value", value);
      return node;
    }
    function blockStatement(body, directives = []) {
      const node = {
        type: "BlockStatement",
        body,
        directives
      };
      const defs = NODE_FIELDS.BlockStatement;
      validate(defs.body, node, "body", body, 1);
      validate(defs.directives, node, "directives", directives, 1);
      return node;
    }
    function breakStatement(label = null) {
      const node = {
        type: "BreakStatement",
        label
      };
      const defs = NODE_FIELDS.BreakStatement;
      validate(defs.label, node, "label", label, 1);
      return node;
    }
    function callExpression(callee, _arguments) {
      const node = {
        type: "CallExpression",
        callee,
        arguments: _arguments
      };
      const defs = NODE_FIELDS.CallExpression;
      validate(defs.callee, node, "callee", callee, 1);
      validate(defs.arguments, node, "arguments", _arguments, 1);
      return node;
    }
    function catchClause(param = null, body) {
      const node = {
        type: "CatchClause",
        param,
        body
      };
      const defs = NODE_FIELDS.CatchClause;
      validate(defs.param, node, "param", param, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function conditionalExpression(test, consequent, alternate) {
      const node = {
        type: "ConditionalExpression",
        test,
        consequent,
        alternate
      };
      const defs = NODE_FIELDS.ConditionalExpression;
      validate(defs.test, node, "test", test, 1);
      validate(defs.consequent, node, "consequent", consequent, 1);
      validate(defs.alternate, node, "alternate", alternate, 1);
      return node;
    }
    function continueStatement(label = null) {
      const node = {
        type: "ContinueStatement",
        label
      };
      const defs = NODE_FIELDS.ContinueStatement;
      validate(defs.label, node, "label", label, 1);
      return node;
    }
    function debuggerStatement() {
      return {
        type: "DebuggerStatement"
      };
    }
    function doWhileStatement(test, body) {
      const node = {
        type: "DoWhileStatement",
        test,
        body
      };
      const defs = NODE_FIELDS.DoWhileStatement;
      validate(defs.test, node, "test", test, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function emptyStatement() {
      return {
        type: "EmptyStatement"
      };
    }
    function expressionStatement(expression) {
      const node = {
        type: "ExpressionStatement",
        expression
      };
      const defs = NODE_FIELDS.ExpressionStatement;
      validate(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function file(program2, comments = null, tokens = null) {
      const node = {
        type: "File",
        program: program2,
        comments,
        tokens
      };
      const defs = NODE_FIELDS.File;
      validate(defs.program, node, "program", program2, 1);
      validate(defs.comments, node, "comments", comments, 1);
      validate(defs.tokens, node, "tokens", tokens);
      return node;
    }
    function forInStatement(left, right, body) {
      const node = {
        type: "ForInStatement",
        left,
        right,
        body
      };
      const defs = NODE_FIELDS.ForInStatement;
      validate(defs.left, node, "left", left, 1);
      validate(defs.right, node, "right", right, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function forStatement(init = null, test = null, update = null, body) {
      const node = {
        type: "ForStatement",
        init,
        test,
        update,
        body
      };
      const defs = NODE_FIELDS.ForStatement;
      validate(defs.init, node, "init", init, 1);
      validate(defs.test, node, "test", test, 1);
      validate(defs.update, node, "update", update, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function functionDeclaration(id = null, params, body, generator = false, async = false) {
      const node = {
        type: "FunctionDeclaration",
        id,
        params,
        body,
        generator,
        async
      };
      const defs = NODE_FIELDS.FunctionDeclaration;
      validate(defs.id, node, "id", id, 1);
      validate(defs.params, node, "params", params, 1);
      validate(defs.body, node, "body", body, 1);
      validate(defs.generator, node, "generator", generator);
      validate(defs.async, node, "async", async);
      return node;
    }
    function functionExpression(id = null, params, body, generator = false, async = false) {
      const node = {
        type: "FunctionExpression",
        id,
        params,
        body,
        generator,
        async
      };
      const defs = NODE_FIELDS.FunctionExpression;
      validate(defs.id, node, "id", id, 1);
      validate(defs.params, node, "params", params, 1);
      validate(defs.body, node, "body", body, 1);
      validate(defs.generator, node, "generator", generator);
      validate(defs.async, node, "async", async);
      return node;
    }
    function identifier(name50) {
      const node = {
        type: "Identifier",
        name: name50
      };
      const defs = NODE_FIELDS.Identifier;
      validate(defs.name, node, "name", name50);
      return node;
    }
    function ifStatement(test, consequent, alternate = null) {
      const node = {
        type: "IfStatement",
        test,
        consequent,
        alternate
      };
      const defs = NODE_FIELDS.IfStatement;
      validate(defs.test, node, "test", test, 1);
      validate(defs.consequent, node, "consequent", consequent, 1);
      validate(defs.alternate, node, "alternate", alternate, 1);
      return node;
    }
    function labeledStatement(label, body) {
      const node = {
        type: "LabeledStatement",
        label,
        body
      };
      const defs = NODE_FIELDS.LabeledStatement;
      validate(defs.label, node, "label", label, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function stringLiteral(value) {
      const node = {
        type: "StringLiteral",
        value
      };
      const defs = NODE_FIELDS.StringLiteral;
      validate(defs.value, node, "value", value);
      return node;
    }
    function numericLiteral(value) {
      const node = {
        type: "NumericLiteral",
        value
      };
      const defs = NODE_FIELDS.NumericLiteral;
      validate(defs.value, node, "value", value);
      return node;
    }
    function nullLiteral() {
      return {
        type: "NullLiteral"
      };
    }
    function booleanLiteral(value) {
      const node = {
        type: "BooleanLiteral",
        value
      };
      const defs = NODE_FIELDS.BooleanLiteral;
      validate(defs.value, node, "value", value);
      return node;
    }
    function regExpLiteral(pattern, flags = "") {
      const node = {
        type: "RegExpLiteral",
        pattern,
        flags
      };
      const defs = NODE_FIELDS.RegExpLiteral;
      validate(defs.pattern, node, "pattern", pattern);
      validate(defs.flags, node, "flags", flags);
      return node;
    }
    function logicalExpression(operator, left, right) {
      const node = {
        type: "LogicalExpression",
        operator,
        left,
        right
      };
      const defs = NODE_FIELDS.LogicalExpression;
      validate(defs.operator, node, "operator", operator);
      validate(defs.left, node, "left", left, 1);
      validate(defs.right, node, "right", right, 1);
      return node;
    }
    function memberExpression(object, property4, computed = false, optional = null) {
      const node = {
        type: "MemberExpression",
        object,
        property: property4,
        computed,
        optional
      };
      const defs = NODE_FIELDS.MemberExpression;
      validate(defs.object, node, "object", object, 1);
      validate(defs.property, node, "property", property4, 1);
      validate(defs.computed, node, "computed", computed);
      validate(defs.optional, node, "optional", optional);
      return node;
    }
    function newExpression(callee, _arguments) {
      const node = {
        type: "NewExpression",
        callee,
        arguments: _arguments
      };
      const defs = NODE_FIELDS.NewExpression;
      validate(defs.callee, node, "callee", callee, 1);
      validate(defs.arguments, node, "arguments", _arguments, 1);
      return node;
    }
    function program(body, directives = [], sourceType = "script", interpreter = null) {
      const node = {
        type: "Program",
        body,
        directives,
        sourceType,
        interpreter
      };
      const defs = NODE_FIELDS.Program;
      validate(defs.body, node, "body", body, 1);
      validate(defs.directives, node, "directives", directives, 1);
      validate(defs.sourceType, node, "sourceType", sourceType);
      validate(defs.interpreter, node, "interpreter", interpreter, 1);
      return node;
    }
    function objectExpression(properties5) {
      const node = {
        type: "ObjectExpression",
        properties: properties5
      };
      const defs = NODE_FIELDS.ObjectExpression;
      validate(defs.properties, node, "properties", properties5, 1);
      return node;
    }
    function objectMethod(kind = "method", key, params, body, computed = false, generator = false, async = false) {
      const node = {
        type: "ObjectMethod",
        kind,
        key,
        params,
        body,
        computed,
        generator,
        async
      };
      const defs = NODE_FIELDS.ObjectMethod;
      validate(defs.kind, node, "kind", kind);
      validate(defs.key, node, "key", key, 1);
      validate(defs.params, node, "params", params, 1);
      validate(defs.body, node, "body", body, 1);
      validate(defs.computed, node, "computed", computed);
      validate(defs.generator, node, "generator", generator);
      validate(defs.async, node, "async", async);
      return node;
    }
    function objectProperty(key, value, computed = false, shorthand = false, decorators = null) {
      const node = {
        type: "ObjectProperty",
        key,
        value,
        computed,
        shorthand,
        decorators
      };
      const defs = NODE_FIELDS.ObjectProperty;
      validate(defs.key, node, "key", key, 1);
      validate(defs.value, node, "value", value, 1);
      validate(defs.computed, node, "computed", computed);
      validate(defs.shorthand, node, "shorthand", shorthand);
      validate(defs.decorators, node, "decorators", decorators, 1);
      return node;
    }
    function restElement(argument) {
      const node = {
        type: "RestElement",
        argument
      };
      const defs = NODE_FIELDS.RestElement;
      validate(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function returnStatement(argument = null) {
      const node = {
        type: "ReturnStatement",
        argument
      };
      const defs = NODE_FIELDS.ReturnStatement;
      validate(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function sequenceExpression(expressions) {
      const node = {
        type: "SequenceExpression",
        expressions
      };
      const defs = NODE_FIELDS.SequenceExpression;
      validate(defs.expressions, node, "expressions", expressions, 1);
      return node;
    }
    function parenthesizedExpression(expression) {
      const node = {
        type: "ParenthesizedExpression",
        expression
      };
      const defs = NODE_FIELDS.ParenthesizedExpression;
      validate(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function switchCase(test = null, consequent) {
      const node = {
        type: "SwitchCase",
        test,
        consequent
      };
      const defs = NODE_FIELDS.SwitchCase;
      validate(defs.test, node, "test", test, 1);
      validate(defs.consequent, node, "consequent", consequent, 1);
      return node;
    }
    function switchStatement(discriminant, cases) {
      const node = {
        type: "SwitchStatement",
        discriminant,
        cases
      };
      const defs = NODE_FIELDS.SwitchStatement;
      validate(defs.discriminant, node, "discriminant", discriminant, 1);
      validate(defs.cases, node, "cases", cases, 1);
      return node;
    }
    function thisExpression() {
      return {
        type: "ThisExpression"
      };
    }
    function throwStatement(argument) {
      const node = {
        type: "ThrowStatement",
        argument
      };
      const defs = NODE_FIELDS.ThrowStatement;
      validate(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function tryStatement(block, handler3 = null, finalizer = null) {
      const node = {
        type: "TryStatement",
        block,
        handler: handler3,
        finalizer
      };
      const defs = NODE_FIELDS.TryStatement;
      validate(defs.block, node, "block", block, 1);
      validate(defs.handler, node, "handler", handler3, 1);
      validate(defs.finalizer, node, "finalizer", finalizer, 1);
      return node;
    }
    function unaryExpression(operator, argument, prefix = true) {
      const node = {
        type: "UnaryExpression",
        operator,
        argument,
        prefix
      };
      const defs = NODE_FIELDS.UnaryExpression;
      validate(defs.operator, node, "operator", operator);
      validate(defs.argument, node, "argument", argument, 1);
      validate(defs.prefix, node, "prefix", prefix);
      return node;
    }
    function updateExpression(operator, argument, prefix = false) {
      const node = {
        type: "UpdateExpression",
        operator,
        argument,
        prefix
      };
      const defs = NODE_FIELDS.UpdateExpression;
      validate(defs.operator, node, "operator", operator);
      validate(defs.argument, node, "argument", argument, 1);
      validate(defs.prefix, node, "prefix", prefix);
      return node;
    }
    function variableDeclaration(kind, declarations) {
      const node = {
        type: "VariableDeclaration",
        kind,
        declarations
      };
      const defs = NODE_FIELDS.VariableDeclaration;
      validate(defs.kind, node, "kind", kind);
      validate(defs.declarations, node, "declarations", declarations, 1);
      return node;
    }
    function variableDeclarator(id, init = null) {
      const node = {
        type: "VariableDeclarator",
        id,
        init
      };
      const defs = NODE_FIELDS.VariableDeclarator;
      validate(defs.id, node, "id", id, 1);
      validate(defs.init, node, "init", init, 1);
      return node;
    }
    function whileStatement(test, body) {
      const node = {
        type: "WhileStatement",
        test,
        body
      };
      const defs = NODE_FIELDS.WhileStatement;
      validate(defs.test, node, "test", test, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function withStatement(object, body) {
      const node = {
        type: "WithStatement",
        object,
        body
      };
      const defs = NODE_FIELDS.WithStatement;
      validate(defs.object, node, "object", object, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function assignmentPattern(left, right) {
      const node = {
        type: "AssignmentPattern",
        left,
        right
      };
      const defs = NODE_FIELDS.AssignmentPattern;
      validate(defs.left, node, "left", left, 1);
      validate(defs.right, node, "right", right, 1);
      return node;
    }
    function arrayPattern(elements) {
      const node = {
        type: "ArrayPattern",
        elements
      };
      const defs = NODE_FIELDS.ArrayPattern;
      validate(defs.elements, node, "elements", elements, 1);
      return node;
    }
    function arrowFunctionExpression(params, body, async = false) {
      const node = {
        type: "ArrowFunctionExpression",
        params,
        body,
        async,
        expression: null
      };
      const defs = NODE_FIELDS.ArrowFunctionExpression;
      validate(defs.params, node, "params", params, 1);
      validate(defs.body, node, "body", body, 1);
      validate(defs.async, node, "async", async);
      return node;
    }
    function classBody(body) {
      const node = {
        type: "ClassBody",
        body
      };
      const defs = NODE_FIELDS.ClassBody;
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function classExpression(id = null, superClass = null, body, decorators = null) {
      const node = {
        type: "ClassExpression",
        id,
        superClass,
        body,
        decorators
      };
      const defs = NODE_FIELDS.ClassExpression;
      validate(defs.id, node, "id", id, 1);
      validate(defs.superClass, node, "superClass", superClass, 1);
      validate(defs.body, node, "body", body, 1);
      validate(defs.decorators, node, "decorators", decorators, 1);
      return node;
    }
    function classDeclaration(id = null, superClass = null, body, decorators = null) {
      const node = {
        type: "ClassDeclaration",
        id,
        superClass,
        body,
        decorators
      };
      const defs = NODE_FIELDS.ClassDeclaration;
      validate(defs.id, node, "id", id, 1);
      validate(defs.superClass, node, "superClass", superClass, 1);
      validate(defs.body, node, "body", body, 1);
      validate(defs.decorators, node, "decorators", decorators, 1);
      return node;
    }
    function exportAllDeclaration(source) {
      const node = {
        type: "ExportAllDeclaration",
        source
      };
      const defs = NODE_FIELDS.ExportAllDeclaration;
      validate(defs.source, node, "source", source, 1);
      return node;
    }
    function exportDefaultDeclaration(declaration) {
      const node = {
        type: "ExportDefaultDeclaration",
        declaration
      };
      const defs = NODE_FIELDS.ExportDefaultDeclaration;
      validate(defs.declaration, node, "declaration", declaration, 1);
      return node;
    }
    function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
      const node = {
        type: "ExportNamedDeclaration",
        declaration,
        specifiers,
        source
      };
      const defs = NODE_FIELDS.ExportNamedDeclaration;
      validate(defs.declaration, node, "declaration", declaration, 1);
      validate(defs.specifiers, node, "specifiers", specifiers, 1);
      validate(defs.source, node, "source", source, 1);
      return node;
    }
    function exportSpecifier(local, exported) {
      const node = {
        type: "ExportSpecifier",
        local,
        exported
      };
      const defs = NODE_FIELDS.ExportSpecifier;
      validate(defs.local, node, "local", local, 1);
      validate(defs.exported, node, "exported", exported, 1);
      return node;
    }
    function forOfStatement(left, right, body, _await = false) {
      const node = {
        type: "ForOfStatement",
        left,
        right,
        body,
        await: _await
      };
      const defs = NODE_FIELDS.ForOfStatement;
      validate(defs.left, node, "left", left, 1);
      validate(defs.right, node, "right", right, 1);
      validate(defs.body, node, "body", body, 1);
      validate(defs.await, node, "await", _await);
      return node;
    }
    function importDeclaration(specifiers, source) {
      const node = {
        type: "ImportDeclaration",
        specifiers,
        source
      };
      const defs = NODE_FIELDS.ImportDeclaration;
      validate(defs.specifiers, node, "specifiers", specifiers, 1);
      validate(defs.source, node, "source", source, 1);
      return node;
    }
    function importDefaultSpecifier(local) {
      const node = {
        type: "ImportDefaultSpecifier",
        local
      };
      const defs = NODE_FIELDS.ImportDefaultSpecifier;
      validate(defs.local, node, "local", local, 1);
      return node;
    }
    function importNamespaceSpecifier(local) {
      const node = {
        type: "ImportNamespaceSpecifier",
        local
      };
      const defs = NODE_FIELDS.ImportNamespaceSpecifier;
      validate(defs.local, node, "local", local, 1);
      return node;
    }
    function importSpecifier(local, imported) {
      const node = {
        type: "ImportSpecifier",
        local,
        imported
      };
      const defs = NODE_FIELDS.ImportSpecifier;
      validate(defs.local, node, "local", local, 1);
      validate(defs.imported, node, "imported", imported, 1);
      return node;
    }
    function importExpression(source, options = null) {
      const node = {
        type: "ImportExpression",
        source,
        options
      };
      const defs = NODE_FIELDS.ImportExpression;
      validate(defs.source, node, "source", source, 1);
      validate(defs.options, node, "options", options, 1);
      return node;
    }
    function metaProperty(meta, property4) {
      const node = {
        type: "MetaProperty",
        meta,
        property: property4
      };
      const defs = NODE_FIELDS.MetaProperty;
      validate(defs.meta, node, "meta", meta, 1);
      validate(defs.property, node, "property", property4, 1);
      return node;
    }
    function classMethod(kind = "method", key, params, body, computed = false, _static = false, generator = false, async = false) {
      const node = {
        type: "ClassMethod",
        kind,
        key,
        params,
        body,
        computed,
        static: _static,
        generator,
        async
      };
      const defs = NODE_FIELDS.ClassMethod;
      validate(defs.kind, node, "kind", kind);
      validate(defs.key, node, "key", key, 1);
      validate(defs.params, node, "params", params, 1);
      validate(defs.body, node, "body", body, 1);
      validate(defs.computed, node, "computed", computed);
      validate(defs.static, node, "static", _static);
      validate(defs.generator, node, "generator", generator);
      validate(defs.async, node, "async", async);
      return node;
    }
    function objectPattern(properties5) {
      const node = {
        type: "ObjectPattern",
        properties: properties5
      };
      const defs = NODE_FIELDS.ObjectPattern;
      validate(defs.properties, node, "properties", properties5, 1);
      return node;
    }
    function spreadElement(argument) {
      const node = {
        type: "SpreadElement",
        argument
      };
      const defs = NODE_FIELDS.SpreadElement;
      validate(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function _super() {
      return {
        type: "Super"
      };
    }
    function taggedTemplateExpression(tag, quasi) {
      const node = {
        type: "TaggedTemplateExpression",
        tag,
        quasi
      };
      const defs = NODE_FIELDS.TaggedTemplateExpression;
      validate(defs.tag, node, "tag", tag, 1);
      validate(defs.quasi, node, "quasi", quasi, 1);
      return node;
    }
    function templateElement(value, tail = false) {
      const node = {
        type: "TemplateElement",
        value,
        tail
      };
      const defs = NODE_FIELDS.TemplateElement;
      validate(defs.value, node, "value", value);
      validate(defs.tail, node, "tail", tail);
      return node;
    }
    function templateLiteral(quasis, expressions) {
      const node = {
        type: "TemplateLiteral",
        quasis,
        expressions
      };
      const defs = NODE_FIELDS.TemplateLiteral;
      validate(defs.quasis, node, "quasis", quasis, 1);
      validate(defs.expressions, node, "expressions", expressions, 1);
      return node;
    }
    function yieldExpression(argument = null, delegate = false) {
      const node = {
        type: "YieldExpression",
        argument,
        delegate
      };
      const defs = NODE_FIELDS.YieldExpression;
      validate(defs.argument, node, "argument", argument, 1);
      validate(defs.delegate, node, "delegate", delegate);
      return node;
    }
    function awaitExpression(argument) {
      const node = {
        type: "AwaitExpression",
        argument
      };
      const defs = NODE_FIELDS.AwaitExpression;
      validate(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function _import() {
      return {
        type: "Import"
      };
    }
    function exportNamespaceSpecifier(exported) {
      const node = {
        type: "ExportNamespaceSpecifier",
        exported
      };
      const defs = NODE_FIELDS.ExportNamespaceSpecifier;
      validate(defs.exported, node, "exported", exported, 1);
      return node;
    }
    function optionalMemberExpression(object, property4, computed = false, optional) {
      const node = {
        type: "OptionalMemberExpression",
        object,
        property: property4,
        computed,
        optional
      };
      const defs = NODE_FIELDS.OptionalMemberExpression;
      validate(defs.object, node, "object", object, 1);
      validate(defs.property, node, "property", property4, 1);
      validate(defs.computed, node, "computed", computed);
      validate(defs.optional, node, "optional", optional);
      return node;
    }
    function optionalCallExpression(callee, _arguments, optional) {
      const node = {
        type: "OptionalCallExpression",
        callee,
        arguments: _arguments,
        optional
      };
      const defs = NODE_FIELDS.OptionalCallExpression;
      validate(defs.callee, node, "callee", callee, 1);
      validate(defs.arguments, node, "arguments", _arguments, 1);
      validate(defs.optional, node, "optional", optional);
      return node;
    }
    function classProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
      const node = {
        type: "ClassProperty",
        key,
        value,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static
      };
      const defs = NODE_FIELDS.ClassProperty;
      validate(defs.key, node, "key", key, 1);
      validate(defs.value, node, "value", value, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      validate(defs.decorators, node, "decorators", decorators, 1);
      validate(defs.computed, node, "computed", computed);
      validate(defs.static, node, "static", _static);
      return node;
    }
    function classAccessorProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
      const node = {
        type: "ClassAccessorProperty",
        key,
        value,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static
      };
      const defs = NODE_FIELDS.ClassAccessorProperty;
      validate(defs.key, node, "key", key, 1);
      validate(defs.value, node, "value", value, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      validate(defs.decorators, node, "decorators", decorators, 1);
      validate(defs.computed, node, "computed", computed);
      validate(defs.static, node, "static", _static);
      return node;
    }
    function classPrivateProperty(key, value = null, decorators = null, _static = false) {
      const node = {
        type: "ClassPrivateProperty",
        key,
        value,
        decorators,
        static: _static
      };
      const defs = NODE_FIELDS.ClassPrivateProperty;
      validate(defs.key, node, "key", key, 1);
      validate(defs.value, node, "value", value, 1);
      validate(defs.decorators, node, "decorators", decorators, 1);
      validate(defs.static, node, "static", _static);
      return node;
    }
    function classPrivateMethod(kind = "method", key, params, body, _static = false) {
      const node = {
        type: "ClassPrivateMethod",
        kind,
        key,
        params,
        body,
        static: _static
      };
      const defs = NODE_FIELDS.ClassPrivateMethod;
      validate(defs.kind, node, "kind", kind);
      validate(defs.key, node, "key", key, 1);
      validate(defs.params, node, "params", params, 1);
      validate(defs.body, node, "body", body, 1);
      validate(defs.static, node, "static", _static);
      return node;
    }
    function privateName(id) {
      const node = {
        type: "PrivateName",
        id
      };
      const defs = NODE_FIELDS.PrivateName;
      validate(defs.id, node, "id", id, 1);
      return node;
    }
    function staticBlock(body) {
      const node = {
        type: "StaticBlock",
        body
      };
      const defs = NODE_FIELDS.StaticBlock;
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function importAttribute(key, value) {
      const node = {
        type: "ImportAttribute",
        key,
        value
      };
      const defs = NODE_FIELDS.ImportAttribute;
      validate(defs.key, node, "key", key, 1);
      validate(defs.value, node, "value", value, 1);
      return node;
    }
    function anyTypeAnnotation() {
      return {
        type: "AnyTypeAnnotation"
      };
    }
    function arrayTypeAnnotation(elementType) {
      const node = {
        type: "ArrayTypeAnnotation",
        elementType
      };
      const defs = NODE_FIELDS.ArrayTypeAnnotation;
      validate(defs.elementType, node, "elementType", elementType, 1);
      return node;
    }
    function booleanTypeAnnotation() {
      return {
        type: "BooleanTypeAnnotation"
      };
    }
    function booleanLiteralTypeAnnotation(value) {
      const node = {
        type: "BooleanLiteralTypeAnnotation",
        value
      };
      const defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;
      validate(defs.value, node, "value", value);
      return node;
    }
    function nullLiteralTypeAnnotation() {
      return {
        type: "NullLiteralTypeAnnotation"
      };
    }
    function classImplements(id, typeParameters = null) {
      const node = {
        type: "ClassImplements",
        id,
        typeParameters
      };
      const defs = NODE_FIELDS.ClassImplements;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      return node;
    }
    function declareClass(id, typeParameters = null, _extends = null, body) {
      const node = {
        type: "DeclareClass",
        id,
        typeParameters,
        extends: _extends,
        body
      };
      const defs = NODE_FIELDS.DeclareClass;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.extends, node, "extends", _extends, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function declareFunction(id) {
      const node = {
        type: "DeclareFunction",
        id
      };
      const defs = NODE_FIELDS.DeclareFunction;
      validate(defs.id, node, "id", id, 1);
      return node;
    }
    function declareInterface(id, typeParameters = null, _extends = null, body) {
      const node = {
        type: "DeclareInterface",
        id,
        typeParameters,
        extends: _extends,
        body
      };
      const defs = NODE_FIELDS.DeclareInterface;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.extends, node, "extends", _extends, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function declareModule(id, body, kind = null) {
      const node = {
        type: "DeclareModule",
        id,
        body,
        kind
      };
      const defs = NODE_FIELDS.DeclareModule;
      validate(defs.id, node, "id", id, 1);
      validate(defs.body, node, "body", body, 1);
      validate(defs.kind, node, "kind", kind);
      return node;
    }
    function declareModuleExports(typeAnnotation2) {
      const node = {
        type: "DeclareModuleExports",
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.DeclareModuleExports;
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function declareTypeAlias(id, typeParameters = null, right) {
      const node = {
        type: "DeclareTypeAlias",
        id,
        typeParameters,
        right
      };
      const defs = NODE_FIELDS.DeclareTypeAlias;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.right, node, "right", right, 1);
      return node;
    }
    function declareOpaqueType(id, typeParameters = null, supertype = null) {
      const node = {
        type: "DeclareOpaqueType",
        id,
        typeParameters,
        supertype
      };
      const defs = NODE_FIELDS.DeclareOpaqueType;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.supertype, node, "supertype", supertype, 1);
      return node;
    }
    function declareVariable(id) {
      const node = {
        type: "DeclareVariable",
        id
      };
      const defs = NODE_FIELDS.DeclareVariable;
      validate(defs.id, node, "id", id, 1);
      return node;
    }
    function declareExportDeclaration(declaration = null, specifiers = null, source = null, attributes = null) {
      const node = {
        type: "DeclareExportDeclaration",
        declaration,
        specifiers,
        source,
        attributes
      };
      const defs = NODE_FIELDS.DeclareExportDeclaration;
      validate(defs.declaration, node, "declaration", declaration, 1);
      validate(defs.specifiers, node, "specifiers", specifiers, 1);
      validate(defs.source, node, "source", source, 1);
      validate(defs.attributes, node, "attributes", attributes, 1);
      return node;
    }
    function declareExportAllDeclaration(source, attributes = null) {
      const node = {
        type: "DeclareExportAllDeclaration",
        source,
        attributes
      };
      const defs = NODE_FIELDS.DeclareExportAllDeclaration;
      validate(defs.source, node, "source", source, 1);
      validate(defs.attributes, node, "attributes", attributes, 1);
      return node;
    }
    function declaredPredicate(value) {
      const node = {
        type: "DeclaredPredicate",
        value
      };
      const defs = NODE_FIELDS.DeclaredPredicate;
      validate(defs.value, node, "value", value, 1);
      return node;
    }
    function existsTypeAnnotation() {
      return {
        type: "ExistsTypeAnnotation"
      };
    }
    function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
      const node = {
        type: "FunctionTypeAnnotation",
        typeParameters,
        params,
        rest,
        returnType
      };
      const defs = NODE_FIELDS.FunctionTypeAnnotation;
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.params, node, "params", params, 1);
      validate(defs.rest, node, "rest", rest, 1);
      validate(defs.returnType, node, "returnType", returnType, 1);
      return node;
    }
    function functionTypeParam(name50 = null, typeAnnotation2) {
      const node = {
        type: "FunctionTypeParam",
        name: name50,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.FunctionTypeParam;
      validate(defs.name, node, "name", name50, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function genericTypeAnnotation(id, typeParameters = null) {
      const node = {
        type: "GenericTypeAnnotation",
        id,
        typeParameters
      };
      const defs = NODE_FIELDS.GenericTypeAnnotation;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      return node;
    }
    function inferredPredicate() {
      return {
        type: "InferredPredicate"
      };
    }
    function interfaceExtends(id, typeParameters = null) {
      const node = {
        type: "InterfaceExtends",
        id,
        typeParameters
      };
      const defs = NODE_FIELDS.InterfaceExtends;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      return node;
    }
    function interfaceDeclaration(id, typeParameters = null, _extends = null, body) {
      const node = {
        type: "InterfaceDeclaration",
        id,
        typeParameters,
        extends: _extends,
        body
      };
      const defs = NODE_FIELDS.InterfaceDeclaration;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.extends, node, "extends", _extends, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function interfaceTypeAnnotation(_extends = null, body) {
      const node = {
        type: "InterfaceTypeAnnotation",
        extends: _extends,
        body
      };
      const defs = NODE_FIELDS.InterfaceTypeAnnotation;
      validate(defs.extends, node, "extends", _extends, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function intersectionTypeAnnotation(types) {
      const node = {
        type: "IntersectionTypeAnnotation",
        types
      };
      const defs = NODE_FIELDS.IntersectionTypeAnnotation;
      validate(defs.types, node, "types", types, 1);
      return node;
    }
    function mixedTypeAnnotation() {
      return {
        type: "MixedTypeAnnotation"
      };
    }
    function emptyTypeAnnotation() {
      return {
        type: "EmptyTypeAnnotation"
      };
    }
    function nullableTypeAnnotation(typeAnnotation2) {
      const node = {
        type: "NullableTypeAnnotation",
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.NullableTypeAnnotation;
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function numberLiteralTypeAnnotation(value) {
      const node = {
        type: "NumberLiteralTypeAnnotation",
        value
      };
      const defs = NODE_FIELDS.NumberLiteralTypeAnnotation;
      validate(defs.value, node, "value", value);
      return node;
    }
    function numberTypeAnnotation() {
      return {
        type: "NumberTypeAnnotation"
      };
    }
    function objectTypeAnnotation(properties5, indexers = [], callProperties = [], internalSlots = [], exact = false) {
      const node = {
        type: "ObjectTypeAnnotation",
        properties: properties5,
        indexers,
        callProperties,
        internalSlots,
        exact
      };
      const defs = NODE_FIELDS.ObjectTypeAnnotation;
      validate(defs.properties, node, "properties", properties5, 1);
      validate(defs.indexers, node, "indexers", indexers, 1);
      validate(defs.callProperties, node, "callProperties", callProperties, 1);
      validate(defs.internalSlots, node, "internalSlots", internalSlots, 1);
      validate(defs.exact, node, "exact", exact);
      return node;
    }
    function objectTypeInternalSlot(id, value, optional, _static, method) {
      const node = {
        type: "ObjectTypeInternalSlot",
        id,
        value,
        optional,
        static: _static,
        method
      };
      const defs = NODE_FIELDS.ObjectTypeInternalSlot;
      validate(defs.id, node, "id", id, 1);
      validate(defs.value, node, "value", value, 1);
      validate(defs.optional, node, "optional", optional);
      validate(defs.static, node, "static", _static);
      validate(defs.method, node, "method", method);
      return node;
    }
    function objectTypeCallProperty(value) {
      const node = {
        type: "ObjectTypeCallProperty",
        value,
        static: null
      };
      const defs = NODE_FIELDS.ObjectTypeCallProperty;
      validate(defs.value, node, "value", value, 1);
      return node;
    }
    function objectTypeIndexer(id = null, key, value, variance2 = null) {
      const node = {
        type: "ObjectTypeIndexer",
        id,
        key,
        value,
        variance: variance2,
        static: null
      };
      const defs = NODE_FIELDS.ObjectTypeIndexer;
      validate(defs.id, node, "id", id, 1);
      validate(defs.key, node, "key", key, 1);
      validate(defs.value, node, "value", value, 1);
      validate(defs.variance, node, "variance", variance2, 1);
      return node;
    }
    function objectTypeProperty(key, value, variance2 = null) {
      const node = {
        type: "ObjectTypeProperty",
        key,
        value,
        variance: variance2,
        kind: null,
        method: null,
        optional: null,
        proto: null,
        static: null
      };
      const defs = NODE_FIELDS.ObjectTypeProperty;
      validate(defs.key, node, "key", key, 1);
      validate(defs.value, node, "value", value, 1);
      validate(defs.variance, node, "variance", variance2, 1);
      return node;
    }
    function objectTypeSpreadProperty(argument) {
      const node = {
        type: "ObjectTypeSpreadProperty",
        argument
      };
      const defs = NODE_FIELDS.ObjectTypeSpreadProperty;
      validate(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function opaqueType(id, typeParameters = null, supertype = null, impltype) {
      const node = {
        type: "OpaqueType",
        id,
        typeParameters,
        supertype,
        impltype
      };
      const defs = NODE_FIELDS.OpaqueType;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.supertype, node, "supertype", supertype, 1);
      validate(defs.impltype, node, "impltype", impltype, 1);
      return node;
    }
    function qualifiedTypeIdentifier(id, qualification) {
      const node = {
        type: "QualifiedTypeIdentifier",
        id,
        qualification
      };
      const defs = NODE_FIELDS.QualifiedTypeIdentifier;
      validate(defs.id, node, "id", id, 1);
      validate(defs.qualification, node, "qualification", qualification, 1);
      return node;
    }
    function stringLiteralTypeAnnotation(value) {
      const node = {
        type: "StringLiteralTypeAnnotation",
        value
      };
      const defs = NODE_FIELDS.StringLiteralTypeAnnotation;
      validate(defs.value, node, "value", value);
      return node;
    }
    function stringTypeAnnotation() {
      return {
        type: "StringTypeAnnotation"
      };
    }
    function symbolTypeAnnotation() {
      return {
        type: "SymbolTypeAnnotation"
      };
    }
    function thisTypeAnnotation() {
      return {
        type: "ThisTypeAnnotation"
      };
    }
    function tupleTypeAnnotation(types) {
      const node = {
        type: "TupleTypeAnnotation",
        types
      };
      const defs = NODE_FIELDS.TupleTypeAnnotation;
      validate(defs.types, node, "types", types, 1);
      return node;
    }
    function typeofTypeAnnotation(argument) {
      const node = {
        type: "TypeofTypeAnnotation",
        argument
      };
      const defs = NODE_FIELDS.TypeofTypeAnnotation;
      validate(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function typeAlias(id, typeParameters = null, right) {
      const node = {
        type: "TypeAlias",
        id,
        typeParameters,
        right
      };
      const defs = NODE_FIELDS.TypeAlias;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.right, node, "right", right, 1);
      return node;
    }
    function typeAnnotation(typeAnnotation2) {
      const node = {
        type: "TypeAnnotation",
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TypeAnnotation;
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function typeCastExpression(expression, typeAnnotation2) {
      const node = {
        type: "TypeCastExpression",
        expression,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TypeCastExpression;
      validate(defs.expression, node, "expression", expression, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function typeParameter(bound = null, _default = null, variance2 = null) {
      const node = {
        type: "TypeParameter",
        bound,
        default: _default,
        variance: variance2,
        name: null
      };
      const defs = NODE_FIELDS.TypeParameter;
      validate(defs.bound, node, "bound", bound, 1);
      validate(defs.default, node, "default", _default, 1);
      validate(defs.variance, node, "variance", variance2, 1);
      return node;
    }
    function typeParameterDeclaration(params) {
      const node = {
        type: "TypeParameterDeclaration",
        params
      };
      const defs = NODE_FIELDS.TypeParameterDeclaration;
      validate(defs.params, node, "params", params, 1);
      return node;
    }
    function typeParameterInstantiation(params) {
      const node = {
        type: "TypeParameterInstantiation",
        params
      };
      const defs = NODE_FIELDS.TypeParameterInstantiation;
      validate(defs.params, node, "params", params, 1);
      return node;
    }
    function unionTypeAnnotation(types) {
      const node = {
        type: "UnionTypeAnnotation",
        types
      };
      const defs = NODE_FIELDS.UnionTypeAnnotation;
      validate(defs.types, node, "types", types, 1);
      return node;
    }
    function variance(kind) {
      const node = {
        type: "Variance",
        kind
      };
      const defs = NODE_FIELDS.Variance;
      validate(defs.kind, node, "kind", kind);
      return node;
    }
    function voidTypeAnnotation() {
      return {
        type: "VoidTypeAnnotation"
      };
    }
    function enumDeclaration(id, body) {
      const node = {
        type: "EnumDeclaration",
        id,
        body
      };
      const defs = NODE_FIELDS.EnumDeclaration;
      validate(defs.id, node, "id", id, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function enumBooleanBody(members) {
      const node = {
        type: "EnumBooleanBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      };
      const defs = NODE_FIELDS.EnumBooleanBody;
      validate(defs.members, node, "members", members, 1);
      return node;
    }
    function enumNumberBody(members) {
      const node = {
        type: "EnumNumberBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      };
      const defs = NODE_FIELDS.EnumNumberBody;
      validate(defs.members, node, "members", members, 1);
      return node;
    }
    function enumStringBody(members) {
      const node = {
        type: "EnumStringBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      };
      const defs = NODE_FIELDS.EnumStringBody;
      validate(defs.members, node, "members", members, 1);
      return node;
    }
    function enumSymbolBody(members) {
      const node = {
        type: "EnumSymbolBody",
        members,
        hasUnknownMembers: null
      };
      const defs = NODE_FIELDS.EnumSymbolBody;
      validate(defs.members, node, "members", members, 1);
      return node;
    }
    function enumBooleanMember(id) {
      const node = {
        type: "EnumBooleanMember",
        id,
        init: null
      };
      const defs = NODE_FIELDS.EnumBooleanMember;
      validate(defs.id, node, "id", id, 1);
      return node;
    }
    function enumNumberMember(id, init) {
      const node = {
        type: "EnumNumberMember",
        id,
        init
      };
      const defs = NODE_FIELDS.EnumNumberMember;
      validate(defs.id, node, "id", id, 1);
      validate(defs.init, node, "init", init, 1);
      return node;
    }
    function enumStringMember(id, init) {
      const node = {
        type: "EnumStringMember",
        id,
        init
      };
      const defs = NODE_FIELDS.EnumStringMember;
      validate(defs.id, node, "id", id, 1);
      validate(defs.init, node, "init", init, 1);
      return node;
    }
    function enumDefaultedMember(id) {
      const node = {
        type: "EnumDefaultedMember",
        id
      };
      const defs = NODE_FIELDS.EnumDefaultedMember;
      validate(defs.id, node, "id", id, 1);
      return node;
    }
    function indexedAccessType(objectType, indexType) {
      const node = {
        type: "IndexedAccessType",
        objectType,
        indexType
      };
      const defs = NODE_FIELDS.IndexedAccessType;
      validate(defs.objectType, node, "objectType", objectType, 1);
      validate(defs.indexType, node, "indexType", indexType, 1);
      return node;
    }
    function optionalIndexedAccessType(objectType, indexType) {
      const node = {
        type: "OptionalIndexedAccessType",
        objectType,
        indexType,
        optional: null
      };
      const defs = NODE_FIELDS.OptionalIndexedAccessType;
      validate(defs.objectType, node, "objectType", objectType, 1);
      validate(defs.indexType, node, "indexType", indexType, 1);
      return node;
    }
    function jsxAttribute(name50, value = null) {
      const node = {
        type: "JSXAttribute",
        name: name50,
        value
      };
      const defs = NODE_FIELDS.JSXAttribute;
      validate(defs.name, node, "name", name50, 1);
      validate(defs.value, node, "value", value, 1);
      return node;
    }
    function jsxClosingElement(name50) {
      const node = {
        type: "JSXClosingElement",
        name: name50
      };
      const defs = NODE_FIELDS.JSXClosingElement;
      validate(defs.name, node, "name", name50, 1);
      return node;
    }
    function jsxElement(openingElement, closingElement = null, children, selfClosing = null) {
      const node = {
        type: "JSXElement",
        openingElement,
        closingElement,
        children,
        selfClosing
      };
      const defs = NODE_FIELDS.JSXElement;
      validate(defs.openingElement, node, "openingElement", openingElement, 1);
      validate(defs.closingElement, node, "closingElement", closingElement, 1);
      validate(defs.children, node, "children", children, 1);
      validate(defs.selfClosing, node, "selfClosing", selfClosing);
      return node;
    }
    function jsxEmptyExpression() {
      return {
        type: "JSXEmptyExpression"
      };
    }
    function jsxExpressionContainer(expression) {
      const node = {
        type: "JSXExpressionContainer",
        expression
      };
      const defs = NODE_FIELDS.JSXExpressionContainer;
      validate(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function jsxSpreadChild(expression) {
      const node = {
        type: "JSXSpreadChild",
        expression
      };
      const defs = NODE_FIELDS.JSXSpreadChild;
      validate(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function jsxIdentifier(name50) {
      const node = {
        type: "JSXIdentifier",
        name: name50
      };
      const defs = NODE_FIELDS.JSXIdentifier;
      validate(defs.name, node, "name", name50);
      return node;
    }
    function jsxMemberExpression(object, property4) {
      const node = {
        type: "JSXMemberExpression",
        object,
        property: property4
      };
      const defs = NODE_FIELDS.JSXMemberExpression;
      validate(defs.object, node, "object", object, 1);
      validate(defs.property, node, "property", property4, 1);
      return node;
    }
    function jsxNamespacedName(namespace, name50) {
      const node = {
        type: "JSXNamespacedName",
        namespace,
        name: name50
      };
      const defs = NODE_FIELDS.JSXNamespacedName;
      validate(defs.namespace, node, "namespace", namespace, 1);
      validate(defs.name, node, "name", name50, 1);
      return node;
    }
    function jsxOpeningElement(name50, attributes, selfClosing = false) {
      const node = {
        type: "JSXOpeningElement",
        name: name50,
        attributes,
        selfClosing
      };
      const defs = NODE_FIELDS.JSXOpeningElement;
      validate(defs.name, node, "name", name50, 1);
      validate(defs.attributes, node, "attributes", attributes, 1);
      validate(defs.selfClosing, node, "selfClosing", selfClosing);
      return node;
    }
    function jsxSpreadAttribute(argument) {
      const node = {
        type: "JSXSpreadAttribute",
        argument
      };
      const defs = NODE_FIELDS.JSXSpreadAttribute;
      validate(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function jsxText(value) {
      const node = {
        type: "JSXText",
        value
      };
      const defs = NODE_FIELDS.JSXText;
      validate(defs.value, node, "value", value);
      return node;
    }
    function jsxFragment(openingFragment, closingFragment, children) {
      const node = {
        type: "JSXFragment",
        openingFragment,
        closingFragment,
        children
      };
      const defs = NODE_FIELDS.JSXFragment;
      validate(defs.openingFragment, node, "openingFragment", openingFragment, 1);
      validate(defs.closingFragment, node, "closingFragment", closingFragment, 1);
      validate(defs.children, node, "children", children, 1);
      return node;
    }
    function jsxOpeningFragment() {
      return {
        type: "JSXOpeningFragment"
      };
    }
    function jsxClosingFragment() {
      return {
        type: "JSXClosingFragment"
      };
    }
    function noop5() {
      return {
        type: "Noop"
      };
    }
    function placeholder(expectedNode, name50) {
      const node = {
        type: "Placeholder",
        expectedNode,
        name: name50
      };
      const defs = NODE_FIELDS.Placeholder;
      validate(defs.expectedNode, node, "expectedNode", expectedNode);
      validate(defs.name, node, "name", name50, 1);
      return node;
    }
    function v8IntrinsicIdentifier(name50) {
      const node = {
        type: "V8IntrinsicIdentifier",
        name: name50
      };
      const defs = NODE_FIELDS.V8IntrinsicIdentifier;
      validate(defs.name, node, "name", name50);
      return node;
    }
    function argumentPlaceholder() {
      return {
        type: "ArgumentPlaceholder"
      };
    }
    function bindExpression(object, callee) {
      const node = {
        type: "BindExpression",
        object,
        callee
      };
      const defs = NODE_FIELDS.BindExpression;
      validate(defs.object, node, "object", object, 1);
      validate(defs.callee, node, "callee", callee, 1);
      return node;
    }
    function decorator(expression) {
      const node = {
        type: "Decorator",
        expression
      };
      const defs = NODE_FIELDS.Decorator;
      validate(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function doExpression(body, async = false) {
      const node = {
        type: "DoExpression",
        body,
        async
      };
      const defs = NODE_FIELDS.DoExpression;
      validate(defs.body, node, "body", body, 1);
      validate(defs.async, node, "async", async);
      return node;
    }
    function exportDefaultSpecifier(exported) {
      const node = {
        type: "ExportDefaultSpecifier",
        exported
      };
      const defs = NODE_FIELDS.ExportDefaultSpecifier;
      validate(defs.exported, node, "exported", exported, 1);
      return node;
    }
    function recordExpression(properties5) {
      const node = {
        type: "RecordExpression",
        properties: properties5
      };
      const defs = NODE_FIELDS.RecordExpression;
      validate(defs.properties, node, "properties", properties5, 1);
      return node;
    }
    function tupleExpression(elements = []) {
      const node = {
        type: "TupleExpression",
        elements
      };
      const defs = NODE_FIELDS.TupleExpression;
      validate(defs.elements, node, "elements", elements, 1);
      return node;
    }
    function decimalLiteral(value) {
      const node = {
        type: "DecimalLiteral",
        value
      };
      const defs = NODE_FIELDS.DecimalLiteral;
      validate(defs.value, node, "value", value);
      return node;
    }
    function moduleExpression(body) {
      const node = {
        type: "ModuleExpression",
        body
      };
      const defs = NODE_FIELDS.ModuleExpression;
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function topicReference() {
      return {
        type: "TopicReference"
      };
    }
    function pipelineTopicExpression(expression) {
      const node = {
        type: "PipelineTopicExpression",
        expression
      };
      const defs = NODE_FIELDS.PipelineTopicExpression;
      validate(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function pipelineBareFunction(callee) {
      const node = {
        type: "PipelineBareFunction",
        callee
      };
      const defs = NODE_FIELDS.PipelineBareFunction;
      validate(defs.callee, node, "callee", callee, 1);
      return node;
    }
    function pipelinePrimaryTopicReference() {
      return {
        type: "PipelinePrimaryTopicReference"
      };
    }
    function voidPattern() {
      return {
        type: "VoidPattern"
      };
    }
    function tsParameterProperty(parameter) {
      const node = {
        type: "TSParameterProperty",
        parameter
      };
      const defs = NODE_FIELDS.TSParameterProperty;
      validate(defs.parameter, node, "parameter", parameter, 1);
      return node;
    }
    function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
      const node = {
        type: "TSDeclareFunction",
        id,
        typeParameters,
        params,
        returnType
      };
      const defs = NODE_FIELDS.TSDeclareFunction;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.params, node, "params", params, 1);
      validate(defs.returnType, node, "returnType", returnType, 1);
      return node;
    }
    function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
      const node = {
        type: "TSDeclareMethod",
        decorators,
        key,
        typeParameters,
        params,
        returnType
      };
      const defs = NODE_FIELDS.TSDeclareMethod;
      validate(defs.decorators, node, "decorators", decorators, 1);
      validate(defs.key, node, "key", key, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.params, node, "params", params, 1);
      validate(defs.returnType, node, "returnType", returnType, 1);
      return node;
    }
    function tsQualifiedName(left, right) {
      const node = {
        type: "TSQualifiedName",
        left,
        right
      };
      const defs = NODE_FIELDS.TSQualifiedName;
      validate(defs.left, node, "left", left, 1);
      validate(defs.right, node, "right", right, 1);
      return node;
    }
    function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
      const node = {
        type: "TSCallSignatureDeclaration",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSCallSignatureDeclaration;
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.parameters, node, "parameters", parameters, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
      const node = {
        type: "TSConstructSignatureDeclaration",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSConstructSignatureDeclaration;
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.parameters, node, "parameters", parameters, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsPropertySignature(key, typeAnnotation2 = null) {
      const node = {
        type: "TSPropertySignature",
        key,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSPropertySignature;
      validate(defs.key, node, "key", key, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation2 = null) {
      const node = {
        type: "TSMethodSignature",
        key,
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2,
        kind: null
      };
      const defs = NODE_FIELDS.TSMethodSignature;
      validate(defs.key, node, "key", key, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.parameters, node, "parameters", parameters, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsIndexSignature(parameters, typeAnnotation2 = null) {
      const node = {
        type: "TSIndexSignature",
        parameters,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSIndexSignature;
      validate(defs.parameters, node, "parameters", parameters, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsAnyKeyword() {
      return {
        type: "TSAnyKeyword"
      };
    }
    function tsBooleanKeyword() {
      return {
        type: "TSBooleanKeyword"
      };
    }
    function tsBigIntKeyword() {
      return {
        type: "TSBigIntKeyword"
      };
    }
    function tsIntrinsicKeyword() {
      return {
        type: "TSIntrinsicKeyword"
      };
    }
    function tsNeverKeyword() {
      return {
        type: "TSNeverKeyword"
      };
    }
    function tsNullKeyword() {
      return {
        type: "TSNullKeyword"
      };
    }
    function tsNumberKeyword() {
      return {
        type: "TSNumberKeyword"
      };
    }
    function tsObjectKeyword() {
      return {
        type: "TSObjectKeyword"
      };
    }
    function tsStringKeyword() {
      return {
        type: "TSStringKeyword"
      };
    }
    function tsSymbolKeyword() {
      return {
        type: "TSSymbolKeyword"
      };
    }
    function tsUndefinedKeyword() {
      return {
        type: "TSUndefinedKeyword"
      };
    }
    function tsUnknownKeyword() {
      return {
        type: "TSUnknownKeyword"
      };
    }
    function tsVoidKeyword() {
      return {
        type: "TSVoidKeyword"
      };
    }
    function tsThisType() {
      return {
        type: "TSThisType"
      };
    }
    function tsFunctionType(typeParameters = null, parameters, typeAnnotation2 = null) {
      const node = {
        type: "TSFunctionType",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSFunctionType;
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.parameters, node, "parameters", parameters, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsConstructorType(typeParameters = null, parameters, typeAnnotation2 = null) {
      const node = {
        type: "TSConstructorType",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSConstructorType;
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.parameters, node, "parameters", parameters, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsTypeReference(typeName, typeParameters = null) {
      const node = {
        type: "TSTypeReference",
        typeName,
        typeParameters
      };
      const defs = NODE_FIELDS.TSTypeReference;
      validate(defs.typeName, node, "typeName", typeName, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      return node;
    }
    function tsTypePredicate(parameterName, typeAnnotation2 = null, asserts = null) {
      const node = {
        type: "TSTypePredicate",
        parameterName,
        typeAnnotation: typeAnnotation2,
        asserts
      };
      const defs = NODE_FIELDS.TSTypePredicate;
      validate(defs.parameterName, node, "parameterName", parameterName, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      validate(defs.asserts, node, "asserts", asserts);
      return node;
    }
    function tsTypeQuery(exprName, typeParameters = null) {
      const node = {
        type: "TSTypeQuery",
        exprName,
        typeParameters
      };
      const defs = NODE_FIELDS.TSTypeQuery;
      validate(defs.exprName, node, "exprName", exprName, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      return node;
    }
    function tsTypeLiteral(members) {
      const node = {
        type: "TSTypeLiteral",
        members
      };
      const defs = NODE_FIELDS.TSTypeLiteral;
      validate(defs.members, node, "members", members, 1);
      return node;
    }
    function tsArrayType(elementType) {
      const node = {
        type: "TSArrayType",
        elementType
      };
      const defs = NODE_FIELDS.TSArrayType;
      validate(defs.elementType, node, "elementType", elementType, 1);
      return node;
    }
    function tsTupleType(elementTypes) {
      const node = {
        type: "TSTupleType",
        elementTypes
      };
      const defs = NODE_FIELDS.TSTupleType;
      validate(defs.elementTypes, node, "elementTypes", elementTypes, 1);
      return node;
    }
    function tsOptionalType(typeAnnotation2) {
      const node = {
        type: "TSOptionalType",
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSOptionalType;
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsRestType(typeAnnotation2) {
      const node = {
        type: "TSRestType",
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSRestType;
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsNamedTupleMember(label, elementType, optional = false) {
      const node = {
        type: "TSNamedTupleMember",
        label,
        elementType,
        optional
      };
      const defs = NODE_FIELDS.TSNamedTupleMember;
      validate(defs.label, node, "label", label, 1);
      validate(defs.elementType, node, "elementType", elementType, 1);
      validate(defs.optional, node, "optional", optional);
      return node;
    }
    function tsUnionType(types) {
      const node = {
        type: "TSUnionType",
        types
      };
      const defs = NODE_FIELDS.TSUnionType;
      validate(defs.types, node, "types", types, 1);
      return node;
    }
    function tsIntersectionType(types) {
      const node = {
        type: "TSIntersectionType",
        types
      };
      const defs = NODE_FIELDS.TSIntersectionType;
      validate(defs.types, node, "types", types, 1);
      return node;
    }
    function tsConditionalType(checkType, extendsType, trueType, falseType) {
      const node = {
        type: "TSConditionalType",
        checkType,
        extendsType,
        trueType,
        falseType
      };
      const defs = NODE_FIELDS.TSConditionalType;
      validate(defs.checkType, node, "checkType", checkType, 1);
      validate(defs.extendsType, node, "extendsType", extendsType, 1);
      validate(defs.trueType, node, "trueType", trueType, 1);
      validate(defs.falseType, node, "falseType", falseType, 1);
      return node;
    }
    function tsInferType(typeParameter2) {
      const node = {
        type: "TSInferType",
        typeParameter: typeParameter2
      };
      const defs = NODE_FIELDS.TSInferType;
      validate(defs.typeParameter, node, "typeParameter", typeParameter2, 1);
      return node;
    }
    function tsParenthesizedType(typeAnnotation2) {
      const node = {
        type: "TSParenthesizedType",
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSParenthesizedType;
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsTypeOperator(typeAnnotation2, operator = "keyof") {
      const node = {
        type: "TSTypeOperator",
        typeAnnotation: typeAnnotation2,
        operator
      };
      const defs = NODE_FIELDS.TSTypeOperator;
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      validate(defs.operator, node, "operator", operator);
      return node;
    }
    function tsIndexedAccessType(objectType, indexType) {
      const node = {
        type: "TSIndexedAccessType",
        objectType,
        indexType
      };
      const defs = NODE_FIELDS.TSIndexedAccessType;
      validate(defs.objectType, node, "objectType", objectType, 1);
      validate(defs.indexType, node, "indexType", indexType, 1);
      return node;
    }
    function tsMappedType(typeParameter2, typeAnnotation2 = null, nameType = null) {
      const node = {
        type: "TSMappedType",
        typeParameter: typeParameter2,
        typeAnnotation: typeAnnotation2,
        nameType
      };
      const defs = NODE_FIELDS.TSMappedType;
      validate(defs.typeParameter, node, "typeParameter", typeParameter2, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      validate(defs.nameType, node, "nameType", nameType, 1);
      return node;
    }
    function tsTemplateLiteralType(quasis, types) {
      const node = {
        type: "TSTemplateLiteralType",
        quasis,
        types
      };
      const defs = NODE_FIELDS.TSTemplateLiteralType;
      validate(defs.quasis, node, "quasis", quasis, 1);
      validate(defs.types, node, "types", types, 1);
      return node;
    }
    function tsLiteralType(literal) {
      const node = {
        type: "TSLiteralType",
        literal
      };
      const defs = NODE_FIELDS.TSLiteralType;
      validate(defs.literal, node, "literal", literal, 1);
      return node;
    }
    function tsExpressionWithTypeArguments(expression, typeParameters = null) {
      const node = {
        type: "TSExpressionWithTypeArguments",
        expression,
        typeParameters
      };
      const defs = NODE_FIELDS.TSExpressionWithTypeArguments;
      validate(defs.expression, node, "expression", expression, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      return node;
    }
    function tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {
      const node = {
        type: "TSInterfaceDeclaration",
        id,
        typeParameters,
        extends: _extends,
        body
      };
      const defs = NODE_FIELDS.TSInterfaceDeclaration;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.extends, node, "extends", _extends, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function tsInterfaceBody(body) {
      const node = {
        type: "TSInterfaceBody",
        body
      };
      const defs = NODE_FIELDS.TSInterfaceBody;
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation2) {
      const node = {
        type: "TSTypeAliasDeclaration",
        id,
        typeParameters,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSTypeAliasDeclaration;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsInstantiationExpression(expression, typeParameters = null) {
      const node = {
        type: "TSInstantiationExpression",
        expression,
        typeParameters
      };
      const defs = NODE_FIELDS.TSInstantiationExpression;
      validate(defs.expression, node, "expression", expression, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      return node;
    }
    function tsAsExpression(expression, typeAnnotation2) {
      const node = {
        type: "TSAsExpression",
        expression,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSAsExpression;
      validate(defs.expression, node, "expression", expression, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsSatisfiesExpression(expression, typeAnnotation2) {
      const node = {
        type: "TSSatisfiesExpression",
        expression,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSSatisfiesExpression;
      validate(defs.expression, node, "expression", expression, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsTypeAssertion(typeAnnotation2, expression) {
      const node = {
        type: "TSTypeAssertion",
        typeAnnotation: typeAnnotation2,
        expression
      };
      const defs = NODE_FIELDS.TSTypeAssertion;
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      validate(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function tsEnumBody(members) {
      const node = {
        type: "TSEnumBody",
        members
      };
      const defs = NODE_FIELDS.TSEnumBody;
      validate(defs.members, node, "members", members, 1);
      return node;
    }
    function tsEnumDeclaration(id, members) {
      const node = {
        type: "TSEnumDeclaration",
        id,
        members
      };
      const defs = NODE_FIELDS.TSEnumDeclaration;
      validate(defs.id, node, "id", id, 1);
      validate(defs.members, node, "members", members, 1);
      return node;
    }
    function tsEnumMember(id, initializer = null) {
      const node = {
        type: "TSEnumMember",
        id,
        initializer
      };
      const defs = NODE_FIELDS.TSEnumMember;
      validate(defs.id, node, "id", id, 1);
      validate(defs.initializer, node, "initializer", initializer, 1);
      return node;
    }
    function tsModuleDeclaration(id, body) {
      const node = {
        type: "TSModuleDeclaration",
        id,
        body,
        kind: null
      };
      const defs = NODE_FIELDS.TSModuleDeclaration;
      validate(defs.id, node, "id", id, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function tsModuleBlock(body) {
      const node = {
        type: "TSModuleBlock",
        body
      };
      const defs = NODE_FIELDS.TSModuleBlock;
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function tsImportType(argument, qualifier = null, typeParameters = null) {
      const node = {
        type: "TSImportType",
        argument,
        qualifier,
        typeParameters
      };
      const defs = NODE_FIELDS.TSImportType;
      validate(defs.argument, node, "argument", argument, 1);
      validate(defs.qualifier, node, "qualifier", qualifier, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      return node;
    }
    function tsImportEqualsDeclaration(id, moduleReference) {
      const node = {
        type: "TSImportEqualsDeclaration",
        id,
        moduleReference,
        isExport: null
      };
      const defs = NODE_FIELDS.TSImportEqualsDeclaration;
      validate(defs.id, node, "id", id, 1);
      validate(defs.moduleReference, node, "moduleReference", moduleReference, 1);
      return node;
    }
    function tsExternalModuleReference(expression) {
      const node = {
        type: "TSExternalModuleReference",
        expression
      };
      const defs = NODE_FIELDS.TSExternalModuleReference;
      validate(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function tsNonNullExpression(expression) {
      const node = {
        type: "TSNonNullExpression",
        expression
      };
      const defs = NODE_FIELDS.TSNonNullExpression;
      validate(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function tsExportAssignment(expression) {
      const node = {
        type: "TSExportAssignment",
        expression
      };
      const defs = NODE_FIELDS.TSExportAssignment;
      validate(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function tsNamespaceExportDeclaration(id) {
      const node = {
        type: "TSNamespaceExportDeclaration",
        id
      };
      const defs = NODE_FIELDS.TSNamespaceExportDeclaration;
      validate(defs.id, node, "id", id, 1);
      return node;
    }
    function tsTypeAnnotation(typeAnnotation2) {
      const node = {
        type: "TSTypeAnnotation",
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSTypeAnnotation;
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsTypeParameterInstantiation(params) {
      const node = {
        type: "TSTypeParameterInstantiation",
        params
      };
      const defs = NODE_FIELDS.TSTypeParameterInstantiation;
      validate(defs.params, node, "params", params, 1);
      return node;
    }
    function tsTypeParameterDeclaration(params) {
      const node = {
        type: "TSTypeParameterDeclaration",
        params
      };
      const defs = NODE_FIELDS.TSTypeParameterDeclaration;
      validate(defs.params, node, "params", params, 1);
      return node;
    }
    function tsTypeParameter(constraint = null, _default = null, name50) {
      const node = {
        type: "TSTypeParameter",
        constraint,
        default: _default,
        name: name50
      };
      const defs = NODE_FIELDS.TSTypeParameter;
      validate(defs.constraint, node, "constraint", constraint, 1);
      validate(defs.default, node, "default", _default, 1);
      validate(defs.name, node, "name", name50);
      return node;
    }
    function NumberLiteral(value) {
      (0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type ");
      return numericLiteral(value);
    }
    function RegexLiteral(pattern, flags = "") {
      (0, _deprecationWarning.default)("RegexLiteral", "RegExpLiteral", "The node type ");
      return regExpLiteral(pattern, flags);
    }
    function RestProperty(argument) {
      (0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type ");
      return restElement(argument);
    }
    function SpreadProperty(argument) {
      (0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type ");
      return spreadElement(argument);
    }
  }
});

// node_modules/@babel/types/lib/builders/generated/uppercase.js
var require_uppercase = __commonJS({
  "node_modules/@babel/types/lib/builders/generated/uppercase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JSXIdentifier = exports.JSXFragment = exports.JSXExpressionContainer = exports.JSXEmptyExpression = exports.JSXElement = exports.JSXClosingFragment = exports.JSXClosingElement = exports.JSXAttribute = exports.IntersectionTypeAnnotation = exports.InterpreterDirective = exports.InterfaceTypeAnnotation = exports.InterfaceExtends = exports.InterfaceDeclaration = exports.InferredPredicate = exports.IndexedAccessType = exports.ImportSpecifier = exports.ImportNamespaceSpecifier = exports.ImportExpression = exports.ImportDefaultSpecifier = exports.ImportDeclaration = exports.ImportAttribute = exports.Import = exports.IfStatement = exports.Identifier = exports.GenericTypeAnnotation = exports.FunctionTypeParam = exports.FunctionTypeAnnotation = exports.FunctionExpression = exports.FunctionDeclaration = exports.ForStatement = exports.ForOfStatement = exports.ForInStatement = exports.File = exports.ExpressionStatement = exports.ExportSpecifier = exports.ExportNamespaceSpecifier = exports.ExportNamedDeclaration = exports.ExportDefaultSpecifier = exports.ExportDefaultDeclaration = exports.ExportAllDeclaration = exports.ExistsTypeAnnotation = exports.EnumSymbolBody = exports.EnumStringMember = exports.EnumStringBody = exports.EnumNumberMember = exports.EnumNumberBody = exports.EnumDefaultedMember = exports.EnumDeclaration = exports.EnumBooleanMember = exports.EnumBooleanBody = exports.EmptyTypeAnnotation = exports.EmptyStatement = exports.DoWhileStatement = exports.DoExpression = exports.DirectiveLiteral = exports.Directive = exports.Decorator = exports.DeclaredPredicate = exports.DeclareVariable = exports.DeclareTypeAlias = exports.DeclareOpaqueType = exports.DeclareModuleExports = exports.DeclareModule = exports.DeclareInterface = exports.DeclareFunction = exports.DeclareExportDeclaration = exports.DeclareExportAllDeclaration = exports.DeclareClass = exports.DecimalLiteral = exports.DebuggerStatement = exports.ContinueStatement = exports.ConditionalExpression = exports.ClassProperty = exports.ClassPrivateProperty = exports.ClassPrivateMethod = exports.ClassMethod = exports.ClassImplements = exports.ClassExpression = exports.ClassDeclaration = exports.ClassBody = exports.ClassAccessorProperty = exports.CatchClause = exports.CallExpression = exports.BreakStatement = exports.BooleanTypeAnnotation = exports.BooleanLiteralTypeAnnotation = exports.BooleanLiteral = exports.BlockStatement = exports.BindExpression = exports.BinaryExpression = exports.BigIntLiteral = exports.AwaitExpression = exports.AssignmentPattern = exports.AssignmentExpression = exports.ArrowFunctionExpression = exports.ArrayTypeAnnotation = exports.ArrayPattern = exports.ArrayExpression = exports.ArgumentPlaceholder = exports.AnyTypeAnnotation = void 0;
    exports.TSNumberKeyword = exports.TSNullKeyword = exports.TSNonNullExpression = exports.TSNeverKeyword = exports.TSNamespaceExportDeclaration = exports.TSNamedTupleMember = exports.TSModuleDeclaration = exports.TSModuleBlock = exports.TSMethodSignature = exports.TSMappedType = exports.TSLiteralType = exports.TSIntrinsicKeyword = exports.TSIntersectionType = exports.TSInterfaceDeclaration = exports.TSInterfaceBody = exports.TSInstantiationExpression = exports.TSInferType = exports.TSIndexedAccessType = exports.TSIndexSignature = exports.TSImportType = exports.TSImportEqualsDeclaration = exports.TSFunctionType = exports.TSExternalModuleReference = exports.TSExpressionWithTypeArguments = exports.TSExportAssignment = exports.TSEnumMember = exports.TSEnumDeclaration = exports.TSEnumBody = exports.TSDeclareMethod = exports.TSDeclareFunction = exports.TSConstructorType = exports.TSConstructSignatureDeclaration = exports.TSConditionalType = exports.TSCallSignatureDeclaration = exports.TSBooleanKeyword = exports.TSBigIntKeyword = exports.TSAsExpression = exports.TSArrayType = exports.TSAnyKeyword = exports.SymbolTypeAnnotation = exports.SwitchStatement = exports.SwitchCase = exports.Super = exports.StringTypeAnnotation = exports.StringLiteralTypeAnnotation = exports.StringLiteral = exports.StaticBlock = exports.SpreadProperty = exports.SpreadElement = exports.SequenceExpression = exports.ReturnStatement = exports.RestProperty = exports.RestElement = exports.RegexLiteral = exports.RegExpLiteral = exports.RecordExpression = exports.QualifiedTypeIdentifier = exports.Program = exports.PrivateName = exports.Placeholder = exports.PipelineTopicExpression = exports.PipelinePrimaryTopicReference = exports.PipelineBareFunction = exports.ParenthesizedExpression = exports.OptionalMemberExpression = exports.OptionalIndexedAccessType = exports.OptionalCallExpression = exports.OpaqueType = exports.ObjectTypeSpreadProperty = exports.ObjectTypeProperty = exports.ObjectTypeInternalSlot = exports.ObjectTypeIndexer = exports.ObjectTypeCallProperty = exports.ObjectTypeAnnotation = exports.ObjectProperty = exports.ObjectPattern = exports.ObjectMethod = exports.ObjectExpression = exports.NumericLiteral = exports.NumberTypeAnnotation = exports.NumberLiteralTypeAnnotation = exports.NumberLiteral = exports.NullableTypeAnnotation = exports.NullLiteralTypeAnnotation = exports.NullLiteral = exports.Noop = exports.NewExpression = exports.ModuleExpression = exports.MixedTypeAnnotation = exports.MetaProperty = exports.MemberExpression = exports.LogicalExpression = exports.LabeledStatement = exports.JSXText = exports.JSXSpreadChild = exports.JSXSpreadAttribute = exports.JSXOpeningFragment = exports.JSXOpeningElement = exports.JSXNamespacedName = exports.JSXMemberExpression = void 0;
    exports.YieldExpression = exports.WithStatement = exports.WhileStatement = exports.VoidTypeAnnotation = exports.VoidPattern = exports.Variance = exports.VariableDeclarator = exports.VariableDeclaration = exports.V8IntrinsicIdentifier = exports.UpdateExpression = exports.UnionTypeAnnotation = exports.UnaryExpression = exports.TypeofTypeAnnotation = exports.TypeParameterInstantiation = exports.TypeParameterDeclaration = exports.TypeParameter = exports.TypeCastExpression = exports.TypeAnnotation = exports.TypeAlias = exports.TupleTypeAnnotation = exports.TupleExpression = exports.TryStatement = exports.TopicReference = exports.ThrowStatement = exports.ThisTypeAnnotation = exports.ThisExpression = exports.TemplateLiteral = exports.TemplateElement = exports.TaggedTemplateExpression = exports.TSVoidKeyword = exports.TSUnknownKeyword = exports.TSUnionType = exports.TSUndefinedKeyword = exports.TSTypeReference = exports.TSTypeQuery = exports.TSTypePredicate = exports.TSTypeParameterInstantiation = exports.TSTypeParameterDeclaration = exports.TSTypeParameter = exports.TSTypeOperator = exports.TSTypeLiteral = exports.TSTypeAssertion = exports.TSTypeAnnotation = exports.TSTypeAliasDeclaration = exports.TSTupleType = exports.TSThisType = exports.TSTemplateLiteralType = exports.TSSymbolKeyword = exports.TSStringKeyword = exports.TSSatisfiesExpression = exports.TSRestType = exports.TSQualifiedName = exports.TSPropertySignature = exports.TSParenthesizedType = exports.TSParameterProperty = exports.TSOptionalType = exports.TSObjectKeyword = void 0;
    var b = require_lowercase();
    var _deprecationWarning = require_deprecationWarning();
    function alias(lowercase) {
      return b[lowercase];
    }
    var ArrayExpression = exports.ArrayExpression = alias("arrayExpression");
    var AssignmentExpression = exports.AssignmentExpression = alias("assignmentExpression");
    var BinaryExpression = exports.BinaryExpression = alias("binaryExpression");
    var InterpreterDirective = exports.InterpreterDirective = alias("interpreterDirective");
    var Directive = exports.Directive = alias("directive");
    var DirectiveLiteral = exports.DirectiveLiteral = alias("directiveLiteral");
    var BlockStatement = exports.BlockStatement = alias("blockStatement");
    var BreakStatement = exports.BreakStatement = alias("breakStatement");
    var CallExpression = exports.CallExpression = alias("callExpression");
    var CatchClause = exports.CatchClause = alias("catchClause");
    var ConditionalExpression = exports.ConditionalExpression = alias("conditionalExpression");
    var ContinueStatement = exports.ContinueStatement = alias("continueStatement");
    var DebuggerStatement = exports.DebuggerStatement = alias("debuggerStatement");
    var DoWhileStatement = exports.DoWhileStatement = alias("doWhileStatement");
    var EmptyStatement = exports.EmptyStatement = alias("emptyStatement");
    var ExpressionStatement = exports.ExpressionStatement = alias("expressionStatement");
    var File = exports.File = alias("file");
    var ForInStatement = exports.ForInStatement = alias("forInStatement");
    var ForStatement = exports.ForStatement = alias("forStatement");
    var FunctionDeclaration = exports.FunctionDeclaration = alias("functionDeclaration");
    var FunctionExpression = exports.FunctionExpression = alias("functionExpression");
    var Identifier = exports.Identifier = alias("identifier");
    var IfStatement = exports.IfStatement = alias("ifStatement");
    var LabeledStatement = exports.LabeledStatement = alias("labeledStatement");
    var StringLiteral = exports.StringLiteral = alias("stringLiteral");
    var NumericLiteral = exports.NumericLiteral = alias("numericLiteral");
    var NullLiteral = exports.NullLiteral = alias("nullLiteral");
    var BooleanLiteral = exports.BooleanLiteral = alias("booleanLiteral");
    var RegExpLiteral = exports.RegExpLiteral = alias("regExpLiteral");
    var LogicalExpression = exports.LogicalExpression = alias("logicalExpression");
    var MemberExpression = exports.MemberExpression = alias("memberExpression");
    var NewExpression = exports.NewExpression = alias("newExpression");
    var Program = exports.Program = alias("program");
    var ObjectExpression = exports.ObjectExpression = alias("objectExpression");
    var ObjectMethod = exports.ObjectMethod = alias("objectMethod");
    var ObjectProperty = exports.ObjectProperty = alias("objectProperty");
    var RestElement = exports.RestElement = alias("restElement");
    var ReturnStatement = exports.ReturnStatement = alias("returnStatement");
    var SequenceExpression = exports.SequenceExpression = alias("sequenceExpression");
    var ParenthesizedExpression = exports.ParenthesizedExpression = alias("parenthesizedExpression");
    var SwitchCase = exports.SwitchCase = alias("switchCase");
    var SwitchStatement = exports.SwitchStatement = alias("switchStatement");
    var ThisExpression = exports.ThisExpression = alias("thisExpression");
    var ThrowStatement = exports.ThrowStatement = alias("throwStatement");
    var TryStatement = exports.TryStatement = alias("tryStatement");
    var UnaryExpression = exports.UnaryExpression = alias("unaryExpression");
    var UpdateExpression = exports.UpdateExpression = alias("updateExpression");
    var VariableDeclaration = exports.VariableDeclaration = alias("variableDeclaration");
    var VariableDeclarator = exports.VariableDeclarator = alias("variableDeclarator");
    var WhileStatement = exports.WhileStatement = alias("whileStatement");
    var WithStatement = exports.WithStatement = alias("withStatement");
    var AssignmentPattern = exports.AssignmentPattern = alias("assignmentPattern");
    var ArrayPattern = exports.ArrayPattern = alias("arrayPattern");
    var ArrowFunctionExpression = exports.ArrowFunctionExpression = alias("arrowFunctionExpression");
    var ClassBody = exports.ClassBody = alias("classBody");
    var ClassExpression = exports.ClassExpression = alias("classExpression");
    var ClassDeclaration = exports.ClassDeclaration = alias("classDeclaration");
    var ExportAllDeclaration = exports.ExportAllDeclaration = alias("exportAllDeclaration");
    var ExportDefaultDeclaration = exports.ExportDefaultDeclaration = alias("exportDefaultDeclaration");
    var ExportNamedDeclaration = exports.ExportNamedDeclaration = alias("exportNamedDeclaration");
    var ExportSpecifier = exports.ExportSpecifier = alias("exportSpecifier");
    var ForOfStatement = exports.ForOfStatement = alias("forOfStatement");
    var ImportDeclaration = exports.ImportDeclaration = alias("importDeclaration");
    var ImportDefaultSpecifier = exports.ImportDefaultSpecifier = alias("importDefaultSpecifier");
    var ImportNamespaceSpecifier = exports.ImportNamespaceSpecifier = alias("importNamespaceSpecifier");
    var ImportSpecifier = exports.ImportSpecifier = alias("importSpecifier");
    var ImportExpression = exports.ImportExpression = alias("importExpression");
    var MetaProperty = exports.MetaProperty = alias("metaProperty");
    var ClassMethod = exports.ClassMethod = alias("classMethod");
    var ObjectPattern = exports.ObjectPattern = alias("objectPattern");
    var SpreadElement = exports.SpreadElement = alias("spreadElement");
    var Super = exports.Super = alias("super");
    var TaggedTemplateExpression = exports.TaggedTemplateExpression = alias("taggedTemplateExpression");
    var TemplateElement = exports.TemplateElement = alias("templateElement");
    var TemplateLiteral = exports.TemplateLiteral = alias("templateLiteral");
    var YieldExpression = exports.YieldExpression = alias("yieldExpression");
    var AwaitExpression = exports.AwaitExpression = alias("awaitExpression");
    var Import = exports.Import = alias("import");
    var BigIntLiteral = exports.BigIntLiteral = alias("bigIntLiteral");
    var ExportNamespaceSpecifier = exports.ExportNamespaceSpecifier = alias("exportNamespaceSpecifier");
    var OptionalMemberExpression = exports.OptionalMemberExpression = alias("optionalMemberExpression");
    var OptionalCallExpression = exports.OptionalCallExpression = alias("optionalCallExpression");
    var ClassProperty = exports.ClassProperty = alias("classProperty");
    var ClassAccessorProperty = exports.ClassAccessorProperty = alias("classAccessorProperty");
    var ClassPrivateProperty = exports.ClassPrivateProperty = alias("classPrivateProperty");
    var ClassPrivateMethod = exports.ClassPrivateMethod = alias("classPrivateMethod");
    var PrivateName = exports.PrivateName = alias("privateName");
    var StaticBlock = exports.StaticBlock = alias("staticBlock");
    var ImportAttribute = exports.ImportAttribute = alias("importAttribute");
    var AnyTypeAnnotation = exports.AnyTypeAnnotation = alias("anyTypeAnnotation");
    var ArrayTypeAnnotation = exports.ArrayTypeAnnotation = alias("arrayTypeAnnotation");
    var BooleanTypeAnnotation = exports.BooleanTypeAnnotation = alias("booleanTypeAnnotation");
    var BooleanLiteralTypeAnnotation = exports.BooleanLiteralTypeAnnotation = alias("booleanLiteralTypeAnnotation");
    var NullLiteralTypeAnnotation = exports.NullLiteralTypeAnnotation = alias("nullLiteralTypeAnnotation");
    var ClassImplements = exports.ClassImplements = alias("classImplements");
    var DeclareClass = exports.DeclareClass = alias("declareClass");
    var DeclareFunction = exports.DeclareFunction = alias("declareFunction");
    var DeclareInterface = exports.DeclareInterface = alias("declareInterface");
    var DeclareModule = exports.DeclareModule = alias("declareModule");
    var DeclareModuleExports = exports.DeclareModuleExports = alias("declareModuleExports");
    var DeclareTypeAlias = exports.DeclareTypeAlias = alias("declareTypeAlias");
    var DeclareOpaqueType = exports.DeclareOpaqueType = alias("declareOpaqueType");
    var DeclareVariable = exports.DeclareVariable = alias("declareVariable");
    var DeclareExportDeclaration = exports.DeclareExportDeclaration = alias("declareExportDeclaration");
    var DeclareExportAllDeclaration = exports.DeclareExportAllDeclaration = alias("declareExportAllDeclaration");
    var DeclaredPredicate = exports.DeclaredPredicate = alias("declaredPredicate");
    var ExistsTypeAnnotation = exports.ExistsTypeAnnotation = alias("existsTypeAnnotation");
    var FunctionTypeAnnotation = exports.FunctionTypeAnnotation = alias("functionTypeAnnotation");
    var FunctionTypeParam = exports.FunctionTypeParam = alias("functionTypeParam");
    var GenericTypeAnnotation = exports.GenericTypeAnnotation = alias("genericTypeAnnotation");
    var InferredPredicate = exports.InferredPredicate = alias("inferredPredicate");
    var InterfaceExtends = exports.InterfaceExtends = alias("interfaceExtends");
    var InterfaceDeclaration = exports.InterfaceDeclaration = alias("interfaceDeclaration");
    var InterfaceTypeAnnotation = exports.InterfaceTypeAnnotation = alias("interfaceTypeAnnotation");
    var IntersectionTypeAnnotation = exports.IntersectionTypeAnnotation = alias("intersectionTypeAnnotation");
    var MixedTypeAnnotation = exports.MixedTypeAnnotation = alias("mixedTypeAnnotation");
    var EmptyTypeAnnotation = exports.EmptyTypeAnnotation = alias("emptyTypeAnnotation");
    var NullableTypeAnnotation = exports.NullableTypeAnnotation = alias("nullableTypeAnnotation");
    var NumberLiteralTypeAnnotation = exports.NumberLiteralTypeAnnotation = alias("numberLiteralTypeAnnotation");
    var NumberTypeAnnotation = exports.NumberTypeAnnotation = alias("numberTypeAnnotation");
    var ObjectTypeAnnotation = exports.ObjectTypeAnnotation = alias("objectTypeAnnotation");
    var ObjectTypeInternalSlot = exports.ObjectTypeInternalSlot = alias("objectTypeInternalSlot");
    var ObjectTypeCallProperty = exports.ObjectTypeCallProperty = alias("objectTypeCallProperty");
    var ObjectTypeIndexer = exports.ObjectTypeIndexer = alias("objectTypeIndexer");
    var ObjectTypeProperty = exports.ObjectTypeProperty = alias("objectTypeProperty");
    var ObjectTypeSpreadProperty = exports.ObjectTypeSpreadProperty = alias("objectTypeSpreadProperty");
    var OpaqueType = exports.OpaqueType = alias("opaqueType");
    var QualifiedTypeIdentifier = exports.QualifiedTypeIdentifier = alias("qualifiedTypeIdentifier");
    var StringLiteralTypeAnnotation = exports.StringLiteralTypeAnnotation = alias("stringLiteralTypeAnnotation");
    var StringTypeAnnotation = exports.StringTypeAnnotation = alias("stringTypeAnnotation");
    var SymbolTypeAnnotation = exports.SymbolTypeAnnotation = alias("symbolTypeAnnotation");
    var ThisTypeAnnotation = exports.ThisTypeAnnotation = alias("thisTypeAnnotation");
    var TupleTypeAnnotation = exports.TupleTypeAnnotation = alias("tupleTypeAnnotation");
    var TypeofTypeAnnotation = exports.TypeofTypeAnnotation = alias("typeofTypeAnnotation");
    var TypeAlias = exports.TypeAlias = alias("typeAlias");
    var TypeAnnotation = exports.TypeAnnotation = alias("typeAnnotation");
    var TypeCastExpression = exports.TypeCastExpression = alias("typeCastExpression");
    var TypeParameter = exports.TypeParameter = alias("typeParameter");
    var TypeParameterDeclaration = exports.TypeParameterDeclaration = alias("typeParameterDeclaration");
    var TypeParameterInstantiation = exports.TypeParameterInstantiation = alias("typeParameterInstantiation");
    var UnionTypeAnnotation = exports.UnionTypeAnnotation = alias("unionTypeAnnotation");
    var Variance = exports.Variance = alias("variance");
    var VoidTypeAnnotation = exports.VoidTypeAnnotation = alias("voidTypeAnnotation");
    var EnumDeclaration = exports.EnumDeclaration = alias("enumDeclaration");
    var EnumBooleanBody = exports.EnumBooleanBody = alias("enumBooleanBody");
    var EnumNumberBody = exports.EnumNumberBody = alias("enumNumberBody");
    var EnumStringBody = exports.EnumStringBody = alias("enumStringBody");
    var EnumSymbolBody = exports.EnumSymbolBody = alias("enumSymbolBody");
    var EnumBooleanMember = exports.EnumBooleanMember = alias("enumBooleanMember");
    var EnumNumberMember = exports.EnumNumberMember = alias("enumNumberMember");
    var EnumStringMember = exports.EnumStringMember = alias("enumStringMember");
    var EnumDefaultedMember = exports.EnumDefaultedMember = alias("enumDefaultedMember");
    var IndexedAccessType = exports.IndexedAccessType = alias("indexedAccessType");
    var OptionalIndexedAccessType = exports.OptionalIndexedAccessType = alias("optionalIndexedAccessType");
    var JSXAttribute = exports.JSXAttribute = alias("jsxAttribute");
    var JSXClosingElement = exports.JSXClosingElement = alias("jsxClosingElement");
    var JSXElement = exports.JSXElement = alias("jsxElement");
    var JSXEmptyExpression = exports.JSXEmptyExpression = alias("jsxEmptyExpression");
    var JSXExpressionContainer = exports.JSXExpressionContainer = alias("jsxExpressionContainer");
    var JSXSpreadChild = exports.JSXSpreadChild = alias("jsxSpreadChild");
    var JSXIdentifier = exports.JSXIdentifier = alias("jsxIdentifier");
    var JSXMemberExpression = exports.JSXMemberExpression = alias("jsxMemberExpression");
    var JSXNamespacedName = exports.JSXNamespacedName = alias("jsxNamespacedName");
    var JSXOpeningElement = exports.JSXOpeningElement = alias("jsxOpeningElement");
    var JSXSpreadAttribute = exports.JSXSpreadAttribute = alias("jsxSpreadAttribute");
    var JSXText = exports.JSXText = alias("jsxText");
    var JSXFragment = exports.JSXFragment = alias("jsxFragment");
    var JSXOpeningFragment = exports.JSXOpeningFragment = alias("jsxOpeningFragment");
    var JSXClosingFragment = exports.JSXClosingFragment = alias("jsxClosingFragment");
    var Noop = exports.Noop = alias("noop");
    var Placeholder = exports.Placeholder = alias("placeholder");
    var V8IntrinsicIdentifier = exports.V8IntrinsicIdentifier = alias("v8IntrinsicIdentifier");
    var ArgumentPlaceholder = exports.ArgumentPlaceholder = alias("argumentPlaceholder");
    var BindExpression = exports.BindExpression = alias("bindExpression");
    var Decorator = exports.Decorator = alias("decorator");
    var DoExpression = exports.DoExpression = alias("doExpression");
    var ExportDefaultSpecifier = exports.ExportDefaultSpecifier = alias("exportDefaultSpecifier");
    var RecordExpression = exports.RecordExpression = alias("recordExpression");
    var TupleExpression = exports.TupleExpression = alias("tupleExpression");
    var DecimalLiteral = exports.DecimalLiteral = alias("decimalLiteral");
    var ModuleExpression = exports.ModuleExpression = alias("moduleExpression");
    var TopicReference = exports.TopicReference = alias("topicReference");
    var PipelineTopicExpression = exports.PipelineTopicExpression = alias("pipelineTopicExpression");
    var PipelineBareFunction = exports.PipelineBareFunction = alias("pipelineBareFunction");
    var PipelinePrimaryTopicReference = exports.PipelinePrimaryTopicReference = alias("pipelinePrimaryTopicReference");
    var VoidPattern = exports.VoidPattern = alias("voidPattern");
    var TSParameterProperty = exports.TSParameterProperty = alias("tsParameterProperty");
    var TSDeclareFunction = exports.TSDeclareFunction = alias("tsDeclareFunction");
    var TSDeclareMethod = exports.TSDeclareMethod = alias("tsDeclareMethod");
    var TSQualifiedName = exports.TSQualifiedName = alias("tsQualifiedName");
    var TSCallSignatureDeclaration = exports.TSCallSignatureDeclaration = alias("tsCallSignatureDeclaration");
    var TSConstructSignatureDeclaration = exports.TSConstructSignatureDeclaration = alias("tsConstructSignatureDeclaration");
    var TSPropertySignature = exports.TSPropertySignature = alias("tsPropertySignature");
    var TSMethodSignature = exports.TSMethodSignature = alias("tsMethodSignature");
    var TSIndexSignature = exports.TSIndexSignature = alias("tsIndexSignature");
    var TSAnyKeyword = exports.TSAnyKeyword = alias("tsAnyKeyword");
    var TSBooleanKeyword = exports.TSBooleanKeyword = alias("tsBooleanKeyword");
    var TSBigIntKeyword = exports.TSBigIntKeyword = alias("tsBigIntKeyword");
    var TSIntrinsicKeyword = exports.TSIntrinsicKeyword = alias("tsIntrinsicKeyword");
    var TSNeverKeyword = exports.TSNeverKeyword = alias("tsNeverKeyword");
    var TSNullKeyword = exports.TSNullKeyword = alias("tsNullKeyword");
    var TSNumberKeyword = exports.TSNumberKeyword = alias("tsNumberKeyword");
    var TSObjectKeyword = exports.TSObjectKeyword = alias("tsObjectKeyword");
    var TSStringKeyword = exports.TSStringKeyword = alias("tsStringKeyword");
    var TSSymbolKeyword = exports.TSSymbolKeyword = alias("tsSymbolKeyword");
    var TSUndefinedKeyword = exports.TSUndefinedKeyword = alias("tsUndefinedKeyword");
    var TSUnknownKeyword = exports.TSUnknownKeyword = alias("tsUnknownKeyword");
    var TSVoidKeyword = exports.TSVoidKeyword = alias("tsVoidKeyword");
    var TSThisType = exports.TSThisType = alias("tsThisType");
    var TSFunctionType = exports.TSFunctionType = alias("tsFunctionType");
    var TSConstructorType = exports.TSConstructorType = alias("tsConstructorType");
    var TSTypeReference = exports.TSTypeReference = alias("tsTypeReference");
    var TSTypePredicate = exports.TSTypePredicate = alias("tsTypePredicate");
    var TSTypeQuery = exports.TSTypeQuery = alias("tsTypeQuery");
    var TSTypeLiteral = exports.TSTypeLiteral = alias("tsTypeLiteral");
    var TSArrayType = exports.TSArrayType = alias("tsArrayType");
    var TSTupleType = exports.TSTupleType = alias("tsTupleType");
    var TSOptionalType = exports.TSOptionalType = alias("tsOptionalType");
    var TSRestType = exports.TSRestType = alias("tsRestType");
    var TSNamedTupleMember = exports.TSNamedTupleMember = alias("tsNamedTupleMember");
    var TSUnionType = exports.TSUnionType = alias("tsUnionType");
    var TSIntersectionType = exports.TSIntersectionType = alias("tsIntersectionType");
    var TSConditionalType = exports.TSConditionalType = alias("tsConditionalType");
    var TSInferType = exports.TSInferType = alias("tsInferType");
    var TSParenthesizedType = exports.TSParenthesizedType = alias("tsParenthesizedType");
    var TSTypeOperator = exports.TSTypeOperator = alias("tsTypeOperator");
    var TSIndexedAccessType = exports.TSIndexedAccessType = alias("tsIndexedAccessType");
    var TSMappedType = exports.TSMappedType = alias("tsMappedType");
    var TSTemplateLiteralType = exports.TSTemplateLiteralType = alias("tsTemplateLiteralType");
    var TSLiteralType = exports.TSLiteralType = alias("tsLiteralType");
    var TSExpressionWithTypeArguments = exports.TSExpressionWithTypeArguments = alias("tsExpressionWithTypeArguments");
    var TSInterfaceDeclaration = exports.TSInterfaceDeclaration = alias("tsInterfaceDeclaration");
    var TSInterfaceBody = exports.TSInterfaceBody = alias("tsInterfaceBody");
    var TSTypeAliasDeclaration = exports.TSTypeAliasDeclaration = alias("tsTypeAliasDeclaration");
    var TSInstantiationExpression = exports.TSInstantiationExpression = alias("tsInstantiationExpression");
    var TSAsExpression = exports.TSAsExpression = alias("tsAsExpression");
    var TSSatisfiesExpression = exports.TSSatisfiesExpression = alias("tsSatisfiesExpression");
    var TSTypeAssertion = exports.TSTypeAssertion = alias("tsTypeAssertion");
    var TSEnumBody = exports.TSEnumBody = alias("tsEnumBody");
    var TSEnumDeclaration = exports.TSEnumDeclaration = alias("tsEnumDeclaration");
    var TSEnumMember = exports.TSEnumMember = alias("tsEnumMember");
    var TSModuleDeclaration = exports.TSModuleDeclaration = alias("tsModuleDeclaration");
    var TSModuleBlock = exports.TSModuleBlock = alias("tsModuleBlock");
    var TSImportType = exports.TSImportType = alias("tsImportType");
    var TSImportEqualsDeclaration = exports.TSImportEqualsDeclaration = alias("tsImportEqualsDeclaration");
    var TSExternalModuleReference = exports.TSExternalModuleReference = alias("tsExternalModuleReference");
    var TSNonNullExpression = exports.TSNonNullExpression = alias("tsNonNullExpression");
    var TSExportAssignment = exports.TSExportAssignment = alias("tsExportAssignment");
    var TSNamespaceExportDeclaration = exports.TSNamespaceExportDeclaration = alias("tsNamespaceExportDeclaration");
    var TSTypeAnnotation = exports.TSTypeAnnotation = alias("tsTypeAnnotation");
    var TSTypeParameterInstantiation = exports.TSTypeParameterInstantiation = alias("tsTypeParameterInstantiation");
    var TSTypeParameterDeclaration = exports.TSTypeParameterDeclaration = alias("tsTypeParameterDeclaration");
    var TSTypeParameter = exports.TSTypeParameter = alias("tsTypeParameter");
    var NumberLiteral = exports.NumberLiteral = b.numberLiteral;
    var RegexLiteral = exports.RegexLiteral = b.regexLiteral;
    var RestProperty = exports.RestProperty = b.restProperty;
    var SpreadProperty = exports.SpreadProperty = b.spreadProperty;
  }
});

// node_modules/@babel/types/lib/builders/generated/index.js
var require_generated2 = __commonJS({
  "node_modules/@babel/types/lib/builders/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _lowercase = require_lowercase();
    Object.keys(_lowercase).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _lowercase[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _lowercase[key];
        }
      });
    });
    var _uppercase = require_uppercase();
    Object.keys(_uppercase).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _uppercase[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _uppercase[key];
        }
      });
    });
  }
});

// node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var require_cleanJSXElementLiteralChild = __commonJS({
  "node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cleanJSXElementLiteralChild;
    var _index = require_generated2();
    var _index2 = require_lib4();
    function cleanJSXElementLiteralChild(child, args) {
      const lines = child.value.split(/\r\n|\n|\r/);
      let lastNonEmptyLine = 0;
      for (let i = 0; i < lines.length; i++) {
        if (/[^ \t]/.exec(lines[i])) {
          lastNonEmptyLine = i;
        }
      }
      let str = "";
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const isFirstLine = i === 0;
        const isLastLine = i === lines.length - 1;
        const isLastNonEmptyLine = i === lastNonEmptyLine;
        let trimmedLine = line.replace(/\t/g, " ");
        if (!isFirstLine) {
          trimmedLine = trimmedLine.replace(/^ +/, "");
        }
        if (!isLastLine) {
          trimmedLine = trimmedLine.replace(/ +$/, "");
        }
        if (trimmedLine) {
          if (!isLastNonEmptyLine) {
            trimmedLine += " ";
          }
          str += trimmedLine;
        }
      }
      if (str) args.push((0, _index2.inherits)((0, _index.stringLiteral)(str), child));
    }
  }
});

// node_modules/@babel/types/lib/builders/react/buildChildren.js
var require_buildChildren = __commonJS({
  "node_modules/@babel/types/lib/builders/react/buildChildren.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = buildChildren;
    var _index = require_generated();
    var _cleanJSXElementLiteralChild = require_cleanJSXElementLiteralChild();
    function buildChildren(node) {
      const elements = [];
      for (let i = 0; i < node.children.length; i++) {
        let child = node.children[i];
        if ((0, _index.isJSXText)(child)) {
          (0, _cleanJSXElementLiteralChild.default)(child, elements);
          continue;
        }
        if ((0, _index.isJSXExpressionContainer)(child)) child = child.expression;
        if ((0, _index.isJSXEmptyExpression)(child)) continue;
        elements.push(child);
      }
      return elements;
    }
  }
});

// node_modules/@babel/types/lib/validators/isNode.js
var require_isNode = __commonJS({
  "node_modules/@babel/types/lib/validators/isNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isNode;
    var _index = require_definitions();
    function isNode(node) {
      return !!(node && _index.VISITOR_KEYS[node.type]);
    }
  }
});

// node_modules/@babel/types/lib/asserts/assertNode.js
var require_assertNode = __commonJS({
  "node_modules/@babel/types/lib/asserts/assertNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = assertNode;
    var _isNode = require_isNode();
    function assertNode(node) {
      if (!(0, _isNode.default)(node)) {
        var _node$type;
        const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
        throw new TypeError(`Not a valid node of type "${type}"`);
      }
    }
  }
});

// node_modules/@babel/types/lib/asserts/generated/index.js
var require_generated3 = __commonJS({
  "node_modules/@babel/types/lib/asserts/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.assertAccessor = assertAccessor;
    exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
    exports.assertArgumentPlaceholder = assertArgumentPlaceholder;
    exports.assertArrayExpression = assertArrayExpression;
    exports.assertArrayPattern = assertArrayPattern;
    exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
    exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
    exports.assertAssignmentExpression = assertAssignmentExpression;
    exports.assertAssignmentPattern = assertAssignmentPattern;
    exports.assertAwaitExpression = assertAwaitExpression;
    exports.assertBigIntLiteral = assertBigIntLiteral;
    exports.assertBinary = assertBinary;
    exports.assertBinaryExpression = assertBinaryExpression;
    exports.assertBindExpression = assertBindExpression;
    exports.assertBlock = assertBlock;
    exports.assertBlockParent = assertBlockParent;
    exports.assertBlockStatement = assertBlockStatement;
    exports.assertBooleanLiteral = assertBooleanLiteral;
    exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
    exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
    exports.assertBreakStatement = assertBreakStatement;
    exports.assertCallExpression = assertCallExpression;
    exports.assertCatchClause = assertCatchClause;
    exports.assertClass = assertClass;
    exports.assertClassAccessorProperty = assertClassAccessorProperty;
    exports.assertClassBody = assertClassBody;
    exports.assertClassDeclaration = assertClassDeclaration;
    exports.assertClassExpression = assertClassExpression;
    exports.assertClassImplements = assertClassImplements;
    exports.assertClassMethod = assertClassMethod;
    exports.assertClassPrivateMethod = assertClassPrivateMethod;
    exports.assertClassPrivateProperty = assertClassPrivateProperty;
    exports.assertClassProperty = assertClassProperty;
    exports.assertCompletionStatement = assertCompletionStatement;
    exports.assertConditional = assertConditional;
    exports.assertConditionalExpression = assertConditionalExpression;
    exports.assertContinueStatement = assertContinueStatement;
    exports.assertDebuggerStatement = assertDebuggerStatement;
    exports.assertDecimalLiteral = assertDecimalLiteral;
    exports.assertDeclaration = assertDeclaration;
    exports.assertDeclareClass = assertDeclareClass;
    exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
    exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
    exports.assertDeclareFunction = assertDeclareFunction;
    exports.assertDeclareInterface = assertDeclareInterface;
    exports.assertDeclareModule = assertDeclareModule;
    exports.assertDeclareModuleExports = assertDeclareModuleExports;
    exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
    exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
    exports.assertDeclareVariable = assertDeclareVariable;
    exports.assertDeclaredPredicate = assertDeclaredPredicate;
    exports.assertDecorator = assertDecorator;
    exports.assertDirective = assertDirective;
    exports.assertDirectiveLiteral = assertDirectiveLiteral;
    exports.assertDoExpression = assertDoExpression;
    exports.assertDoWhileStatement = assertDoWhileStatement;
    exports.assertEmptyStatement = assertEmptyStatement;
    exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
    exports.assertEnumBody = assertEnumBody;
    exports.assertEnumBooleanBody = assertEnumBooleanBody;
    exports.assertEnumBooleanMember = assertEnumBooleanMember;
    exports.assertEnumDeclaration = assertEnumDeclaration;
    exports.assertEnumDefaultedMember = assertEnumDefaultedMember;
    exports.assertEnumMember = assertEnumMember;
    exports.assertEnumNumberBody = assertEnumNumberBody;
    exports.assertEnumNumberMember = assertEnumNumberMember;
    exports.assertEnumStringBody = assertEnumStringBody;
    exports.assertEnumStringMember = assertEnumStringMember;
    exports.assertEnumSymbolBody = assertEnumSymbolBody;
    exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
    exports.assertExportAllDeclaration = assertExportAllDeclaration;
    exports.assertExportDeclaration = assertExportDeclaration;
    exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
    exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
    exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
    exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
    exports.assertExportSpecifier = assertExportSpecifier;
    exports.assertExpression = assertExpression;
    exports.assertExpressionStatement = assertExpressionStatement;
    exports.assertExpressionWrapper = assertExpressionWrapper;
    exports.assertFile = assertFile;
    exports.assertFlow = assertFlow;
    exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
    exports.assertFlowDeclaration = assertFlowDeclaration;
    exports.assertFlowPredicate = assertFlowPredicate;
    exports.assertFlowType = assertFlowType;
    exports.assertFor = assertFor;
    exports.assertForInStatement = assertForInStatement;
    exports.assertForOfStatement = assertForOfStatement;
    exports.assertForStatement = assertForStatement;
    exports.assertForXStatement = assertForXStatement;
    exports.assertFunction = assertFunction;
    exports.assertFunctionDeclaration = assertFunctionDeclaration;
    exports.assertFunctionExpression = assertFunctionExpression;
    exports.assertFunctionParameter = assertFunctionParameter;
    exports.assertFunctionParent = assertFunctionParent;
    exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
    exports.assertFunctionTypeParam = assertFunctionTypeParam;
    exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
    exports.assertIdentifier = assertIdentifier;
    exports.assertIfStatement = assertIfStatement;
    exports.assertImmutable = assertImmutable;
    exports.assertImport = assertImport;
    exports.assertImportAttribute = assertImportAttribute;
    exports.assertImportDeclaration = assertImportDeclaration;
    exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
    exports.assertImportExpression = assertImportExpression;
    exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
    exports.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
    exports.assertImportSpecifier = assertImportSpecifier;
    exports.assertIndexedAccessType = assertIndexedAccessType;
    exports.assertInferredPredicate = assertInferredPredicate;
    exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
    exports.assertInterfaceExtends = assertInterfaceExtends;
    exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
    exports.assertInterpreterDirective = assertInterpreterDirective;
    exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
    exports.assertJSX = assertJSX;
    exports.assertJSXAttribute = assertJSXAttribute;
    exports.assertJSXClosingElement = assertJSXClosingElement;
    exports.assertJSXClosingFragment = assertJSXClosingFragment;
    exports.assertJSXElement = assertJSXElement;
    exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
    exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
    exports.assertJSXFragment = assertJSXFragment;
    exports.assertJSXIdentifier = assertJSXIdentifier;
    exports.assertJSXMemberExpression = assertJSXMemberExpression;
    exports.assertJSXNamespacedName = assertJSXNamespacedName;
    exports.assertJSXOpeningElement = assertJSXOpeningElement;
    exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
    exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
    exports.assertJSXSpreadChild = assertJSXSpreadChild;
    exports.assertJSXText = assertJSXText;
    exports.assertLVal = assertLVal;
    exports.assertLabeledStatement = assertLabeledStatement;
    exports.assertLiteral = assertLiteral;
    exports.assertLogicalExpression = assertLogicalExpression;
    exports.assertLoop = assertLoop;
    exports.assertMemberExpression = assertMemberExpression;
    exports.assertMetaProperty = assertMetaProperty;
    exports.assertMethod = assertMethod;
    exports.assertMiscellaneous = assertMiscellaneous;
    exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
    exports.assertModuleDeclaration = assertModuleDeclaration;
    exports.assertModuleExpression = assertModuleExpression;
    exports.assertModuleSpecifier = assertModuleSpecifier;
    exports.assertNewExpression = assertNewExpression;
    exports.assertNoop = assertNoop;
    exports.assertNullLiteral = assertNullLiteral;
    exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
    exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
    exports.assertNumberLiteral = assertNumberLiteral;
    exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
    exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
    exports.assertNumericLiteral = assertNumericLiteral;
    exports.assertObjectExpression = assertObjectExpression;
    exports.assertObjectMember = assertObjectMember;
    exports.assertObjectMethod = assertObjectMethod;
    exports.assertObjectPattern = assertObjectPattern;
    exports.assertObjectProperty = assertObjectProperty;
    exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
    exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
    exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
    exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
    exports.assertObjectTypeProperty = assertObjectTypeProperty;
    exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
    exports.assertOpaqueType = assertOpaqueType;
    exports.assertOptionalCallExpression = assertOptionalCallExpression;
    exports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
    exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
    exports.assertParenthesizedExpression = assertParenthesizedExpression;
    exports.assertPattern = assertPattern;
    exports.assertPatternLike = assertPatternLike;
    exports.assertPipelineBareFunction = assertPipelineBareFunction;
    exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
    exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
    exports.assertPlaceholder = assertPlaceholder;
    exports.assertPrivate = assertPrivate;
    exports.assertPrivateName = assertPrivateName;
    exports.assertProgram = assertProgram;
    exports.assertProperty = assertProperty;
    exports.assertPureish = assertPureish;
    exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
    exports.assertRecordExpression = assertRecordExpression;
    exports.assertRegExpLiteral = assertRegExpLiteral;
    exports.assertRegexLiteral = assertRegexLiteral;
    exports.assertRestElement = assertRestElement;
    exports.assertRestProperty = assertRestProperty;
    exports.assertReturnStatement = assertReturnStatement;
    exports.assertScopable = assertScopable;
    exports.assertSequenceExpression = assertSequenceExpression;
    exports.assertSpreadElement = assertSpreadElement;
    exports.assertSpreadProperty = assertSpreadProperty;
    exports.assertStandardized = assertStandardized;
    exports.assertStatement = assertStatement;
    exports.assertStaticBlock = assertStaticBlock;
    exports.assertStringLiteral = assertStringLiteral;
    exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
    exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
    exports.assertSuper = assertSuper;
    exports.assertSwitchCase = assertSwitchCase;
    exports.assertSwitchStatement = assertSwitchStatement;
    exports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
    exports.assertTSAnyKeyword = assertTSAnyKeyword;
    exports.assertTSArrayType = assertTSArrayType;
    exports.assertTSAsExpression = assertTSAsExpression;
    exports.assertTSBaseType = assertTSBaseType;
    exports.assertTSBigIntKeyword = assertTSBigIntKeyword;
    exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
    exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
    exports.assertTSConditionalType = assertTSConditionalType;
    exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
    exports.assertTSConstructorType = assertTSConstructorType;
    exports.assertTSDeclareFunction = assertTSDeclareFunction;
    exports.assertTSDeclareMethod = assertTSDeclareMethod;
    exports.assertTSEntityName = assertTSEntityName;
    exports.assertTSEnumBody = assertTSEnumBody;
    exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
    exports.assertTSEnumMember = assertTSEnumMember;
    exports.assertTSExportAssignment = assertTSExportAssignment;
    exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
    exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
    exports.assertTSFunctionType = assertTSFunctionType;
    exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
    exports.assertTSImportType = assertTSImportType;
    exports.assertTSIndexSignature = assertTSIndexSignature;
    exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
    exports.assertTSInferType = assertTSInferType;
    exports.assertTSInstantiationExpression = assertTSInstantiationExpression;
    exports.assertTSInterfaceBody = assertTSInterfaceBody;
    exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
    exports.assertTSIntersectionType = assertTSIntersectionType;
    exports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
    exports.assertTSLiteralType = assertTSLiteralType;
    exports.assertTSMappedType = assertTSMappedType;
    exports.assertTSMethodSignature = assertTSMethodSignature;
    exports.assertTSModuleBlock = assertTSModuleBlock;
    exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
    exports.assertTSNamedTupleMember = assertTSNamedTupleMember;
    exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
    exports.assertTSNeverKeyword = assertTSNeverKeyword;
    exports.assertTSNonNullExpression = assertTSNonNullExpression;
    exports.assertTSNullKeyword = assertTSNullKeyword;
    exports.assertTSNumberKeyword = assertTSNumberKeyword;
    exports.assertTSObjectKeyword = assertTSObjectKeyword;
    exports.assertTSOptionalType = assertTSOptionalType;
    exports.assertTSParameterProperty = assertTSParameterProperty;
    exports.assertTSParenthesizedType = assertTSParenthesizedType;
    exports.assertTSPropertySignature = assertTSPropertySignature;
    exports.assertTSQualifiedName = assertTSQualifiedName;
    exports.assertTSRestType = assertTSRestType;
    exports.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
    exports.assertTSStringKeyword = assertTSStringKeyword;
    exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
    exports.assertTSTemplateLiteralType = assertTSTemplateLiteralType;
    exports.assertTSThisType = assertTSThisType;
    exports.assertTSTupleType = assertTSTupleType;
    exports.assertTSType = assertTSType;
    exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
    exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
    exports.assertTSTypeAssertion = assertTSTypeAssertion;
    exports.assertTSTypeElement = assertTSTypeElement;
    exports.assertTSTypeLiteral = assertTSTypeLiteral;
    exports.assertTSTypeOperator = assertTSTypeOperator;
    exports.assertTSTypeParameter = assertTSTypeParameter;
    exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
    exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
    exports.assertTSTypePredicate = assertTSTypePredicate;
    exports.assertTSTypeQuery = assertTSTypeQuery;
    exports.assertTSTypeReference = assertTSTypeReference;
    exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
    exports.assertTSUnionType = assertTSUnionType;
    exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
    exports.assertTSVoidKeyword = assertTSVoidKeyword;
    exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
    exports.assertTemplateElement = assertTemplateElement;
    exports.assertTemplateLiteral = assertTemplateLiteral;
    exports.assertTerminatorless = assertTerminatorless;
    exports.assertThisExpression = assertThisExpression;
    exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
    exports.assertThrowStatement = assertThrowStatement;
    exports.assertTopicReference = assertTopicReference;
    exports.assertTryStatement = assertTryStatement;
    exports.assertTupleExpression = assertTupleExpression;
    exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
    exports.assertTypeAlias = assertTypeAlias;
    exports.assertTypeAnnotation = assertTypeAnnotation;
    exports.assertTypeCastExpression = assertTypeCastExpression;
    exports.assertTypeParameter = assertTypeParameter;
    exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
    exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
    exports.assertTypeScript = assertTypeScript;
    exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
    exports.assertUnaryExpression = assertUnaryExpression;
    exports.assertUnaryLike = assertUnaryLike;
    exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
    exports.assertUpdateExpression = assertUpdateExpression;
    exports.assertUserWhitespacable = assertUserWhitespacable;
    exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
    exports.assertVariableDeclaration = assertVariableDeclaration;
    exports.assertVariableDeclarator = assertVariableDeclarator;
    exports.assertVariance = assertVariance;
    exports.assertVoidPattern = assertVoidPattern;
    exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
    exports.assertWhile = assertWhile;
    exports.assertWhileStatement = assertWhileStatement;
    exports.assertWithStatement = assertWithStatement;
    exports.assertYieldExpression = assertYieldExpression;
    var _is = require_is();
    var _deprecationWarning = require_deprecationWarning();
    function assert(type, node, opts) {
      if (!(0, _is.default)(type, node, opts)) {
        throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node.type}".`);
      }
    }
    function assertArrayExpression(node, opts) {
      assert("ArrayExpression", node, opts);
    }
    function assertAssignmentExpression(node, opts) {
      assert("AssignmentExpression", node, opts);
    }
    function assertBinaryExpression(node, opts) {
      assert("BinaryExpression", node, opts);
    }
    function assertInterpreterDirective(node, opts) {
      assert("InterpreterDirective", node, opts);
    }
    function assertDirective(node, opts) {
      assert("Directive", node, opts);
    }
    function assertDirectiveLiteral(node, opts) {
      assert("DirectiveLiteral", node, opts);
    }
    function assertBlockStatement(node, opts) {
      assert("BlockStatement", node, opts);
    }
    function assertBreakStatement(node, opts) {
      assert("BreakStatement", node, opts);
    }
    function assertCallExpression(node, opts) {
      assert("CallExpression", node, opts);
    }
    function assertCatchClause(node, opts) {
      assert("CatchClause", node, opts);
    }
    function assertConditionalExpression(node, opts) {
      assert("ConditionalExpression", node, opts);
    }
    function assertContinueStatement(node, opts) {
      assert("ContinueStatement", node, opts);
    }
    function assertDebuggerStatement(node, opts) {
      assert("DebuggerStatement", node, opts);
    }
    function assertDoWhileStatement(node, opts) {
      assert("DoWhileStatement", node, opts);
    }
    function assertEmptyStatement(node, opts) {
      assert("EmptyStatement", node, opts);
    }
    function assertExpressionStatement(node, opts) {
      assert("ExpressionStatement", node, opts);
    }
    function assertFile(node, opts) {
      assert("File", node, opts);
    }
    function assertForInStatement(node, opts) {
      assert("ForInStatement", node, opts);
    }
    function assertForStatement(node, opts) {
      assert("ForStatement", node, opts);
    }
    function assertFunctionDeclaration(node, opts) {
      assert("FunctionDeclaration", node, opts);
    }
    function assertFunctionExpression(node, opts) {
      assert("FunctionExpression", node, opts);
    }
    function assertIdentifier(node, opts) {
      assert("Identifier", node, opts);
    }
    function assertIfStatement(node, opts) {
      assert("IfStatement", node, opts);
    }
    function assertLabeledStatement(node, opts) {
      assert("LabeledStatement", node, opts);
    }
    function assertStringLiteral(node, opts) {
      assert("StringLiteral", node, opts);
    }
    function assertNumericLiteral(node, opts) {
      assert("NumericLiteral", node, opts);
    }
    function assertNullLiteral(node, opts) {
      assert("NullLiteral", node, opts);
    }
    function assertBooleanLiteral(node, opts) {
      assert("BooleanLiteral", node, opts);
    }
    function assertRegExpLiteral(node, opts) {
      assert("RegExpLiteral", node, opts);
    }
    function assertLogicalExpression(node, opts) {
      assert("LogicalExpression", node, opts);
    }
    function assertMemberExpression(node, opts) {
      assert("MemberExpression", node, opts);
    }
    function assertNewExpression(node, opts) {
      assert("NewExpression", node, opts);
    }
    function assertProgram(node, opts) {
      assert("Program", node, opts);
    }
    function assertObjectExpression(node, opts) {
      assert("ObjectExpression", node, opts);
    }
    function assertObjectMethod(node, opts) {
      assert("ObjectMethod", node, opts);
    }
    function assertObjectProperty(node, opts) {
      assert("ObjectProperty", node, opts);
    }
    function assertRestElement(node, opts) {
      assert("RestElement", node, opts);
    }
    function assertReturnStatement(node, opts) {
      assert("ReturnStatement", node, opts);
    }
    function assertSequenceExpression(node, opts) {
      assert("SequenceExpression", node, opts);
    }
    function assertParenthesizedExpression(node, opts) {
      assert("ParenthesizedExpression", node, opts);
    }
    function assertSwitchCase(node, opts) {
      assert("SwitchCase", node, opts);
    }
    function assertSwitchStatement(node, opts) {
      assert("SwitchStatement", node, opts);
    }
    function assertThisExpression(node, opts) {
      assert("ThisExpression", node, opts);
    }
    function assertThrowStatement(node, opts) {
      assert("ThrowStatement", node, opts);
    }
    function assertTryStatement(node, opts) {
      assert("TryStatement", node, opts);
    }
    function assertUnaryExpression(node, opts) {
      assert("UnaryExpression", node, opts);
    }
    function assertUpdateExpression(node, opts) {
      assert("UpdateExpression", node, opts);
    }
    function assertVariableDeclaration(node, opts) {
      assert("VariableDeclaration", node, opts);
    }
    function assertVariableDeclarator(node, opts) {
      assert("VariableDeclarator", node, opts);
    }
    function assertWhileStatement(node, opts) {
      assert("WhileStatement", node, opts);
    }
    function assertWithStatement(node, opts) {
      assert("WithStatement", node, opts);
    }
    function assertAssignmentPattern(node, opts) {
      assert("AssignmentPattern", node, opts);
    }
    function assertArrayPattern(node, opts) {
      assert("ArrayPattern", node, opts);
    }
    function assertArrowFunctionExpression(node, opts) {
      assert("ArrowFunctionExpression", node, opts);
    }
    function assertClassBody(node, opts) {
      assert("ClassBody", node, opts);
    }
    function assertClassExpression(node, opts) {
      assert("ClassExpression", node, opts);
    }
    function assertClassDeclaration(node, opts) {
      assert("ClassDeclaration", node, opts);
    }
    function assertExportAllDeclaration(node, opts) {
      assert("ExportAllDeclaration", node, opts);
    }
    function assertExportDefaultDeclaration(node, opts) {
      assert("ExportDefaultDeclaration", node, opts);
    }
    function assertExportNamedDeclaration(node, opts) {
      assert("ExportNamedDeclaration", node, opts);
    }
    function assertExportSpecifier(node, opts) {
      assert("ExportSpecifier", node, opts);
    }
    function assertForOfStatement(node, opts) {
      assert("ForOfStatement", node, opts);
    }
    function assertImportDeclaration(node, opts) {
      assert("ImportDeclaration", node, opts);
    }
    function assertImportDefaultSpecifier(node, opts) {
      assert("ImportDefaultSpecifier", node, opts);
    }
    function assertImportNamespaceSpecifier(node, opts) {
      assert("ImportNamespaceSpecifier", node, opts);
    }
    function assertImportSpecifier(node, opts) {
      assert("ImportSpecifier", node, opts);
    }
    function assertImportExpression(node, opts) {
      assert("ImportExpression", node, opts);
    }
    function assertMetaProperty(node, opts) {
      assert("MetaProperty", node, opts);
    }
    function assertClassMethod(node, opts) {
      assert("ClassMethod", node, opts);
    }
    function assertObjectPattern(node, opts) {
      assert("ObjectPattern", node, opts);
    }
    function assertSpreadElement(node, opts) {
      assert("SpreadElement", node, opts);
    }
    function assertSuper(node, opts) {
      assert("Super", node, opts);
    }
    function assertTaggedTemplateExpression(node, opts) {
      assert("TaggedTemplateExpression", node, opts);
    }
    function assertTemplateElement(node, opts) {
      assert("TemplateElement", node, opts);
    }
    function assertTemplateLiteral(node, opts) {
      assert("TemplateLiteral", node, opts);
    }
    function assertYieldExpression(node, opts) {
      assert("YieldExpression", node, opts);
    }
    function assertAwaitExpression(node, opts) {
      assert("AwaitExpression", node, opts);
    }
    function assertImport(node, opts) {
      assert("Import", node, opts);
    }
    function assertBigIntLiteral(node, opts) {
      assert("BigIntLiteral", node, opts);
    }
    function assertExportNamespaceSpecifier(node, opts) {
      assert("ExportNamespaceSpecifier", node, opts);
    }
    function assertOptionalMemberExpression(node, opts) {
      assert("OptionalMemberExpression", node, opts);
    }
    function assertOptionalCallExpression(node, opts) {
      assert("OptionalCallExpression", node, opts);
    }
    function assertClassProperty(node, opts) {
      assert("ClassProperty", node, opts);
    }
    function assertClassAccessorProperty(node, opts) {
      assert("ClassAccessorProperty", node, opts);
    }
    function assertClassPrivateProperty(node, opts) {
      assert("ClassPrivateProperty", node, opts);
    }
    function assertClassPrivateMethod(node, opts) {
      assert("ClassPrivateMethod", node, opts);
    }
    function assertPrivateName(node, opts) {
      assert("PrivateName", node, opts);
    }
    function assertStaticBlock(node, opts) {
      assert("StaticBlock", node, opts);
    }
    function assertImportAttribute(node, opts) {
      assert("ImportAttribute", node, opts);
    }
    function assertAnyTypeAnnotation(node, opts) {
      assert("AnyTypeAnnotation", node, opts);
    }
    function assertArrayTypeAnnotation(node, opts) {
      assert("ArrayTypeAnnotation", node, opts);
    }
    function assertBooleanTypeAnnotation(node, opts) {
      assert("BooleanTypeAnnotation", node, opts);
    }
    function assertBooleanLiteralTypeAnnotation(node, opts) {
      assert("BooleanLiteralTypeAnnotation", node, opts);
    }
    function assertNullLiteralTypeAnnotation(node, opts) {
      assert("NullLiteralTypeAnnotation", node, opts);
    }
    function assertClassImplements(node, opts) {
      assert("ClassImplements", node, opts);
    }
    function assertDeclareClass(node, opts) {
      assert("DeclareClass", node, opts);
    }
    function assertDeclareFunction(node, opts) {
      assert("DeclareFunction", node, opts);
    }
    function assertDeclareInterface(node, opts) {
      assert("DeclareInterface", node, opts);
    }
    function assertDeclareModule(node, opts) {
      assert("DeclareModule", node, opts);
    }
    function assertDeclareModuleExports(node, opts) {
      assert("DeclareModuleExports", node, opts);
    }
    function assertDeclareTypeAlias(node, opts) {
      assert("DeclareTypeAlias", node, opts);
    }
    function assertDeclareOpaqueType(node, opts) {
      assert("DeclareOpaqueType", node, opts);
    }
    function assertDeclareVariable(node, opts) {
      assert("DeclareVariable", node, opts);
    }
    function assertDeclareExportDeclaration(node, opts) {
      assert("DeclareExportDeclaration", node, opts);
    }
    function assertDeclareExportAllDeclaration(node, opts) {
      assert("DeclareExportAllDeclaration", node, opts);
    }
    function assertDeclaredPredicate(node, opts) {
      assert("DeclaredPredicate", node, opts);
    }
    function assertExistsTypeAnnotation(node, opts) {
      assert("ExistsTypeAnnotation", node, opts);
    }
    function assertFunctionTypeAnnotation(node, opts) {
      assert("FunctionTypeAnnotation", node, opts);
    }
    function assertFunctionTypeParam(node, opts) {
      assert("FunctionTypeParam", node, opts);
    }
    function assertGenericTypeAnnotation(node, opts) {
      assert("GenericTypeAnnotation", node, opts);
    }
    function assertInferredPredicate(node, opts) {
      assert("InferredPredicate", node, opts);
    }
    function assertInterfaceExtends(node, opts) {
      assert("InterfaceExtends", node, opts);
    }
    function assertInterfaceDeclaration(node, opts) {
      assert("InterfaceDeclaration", node, opts);
    }
    function assertInterfaceTypeAnnotation(node, opts) {
      assert("InterfaceTypeAnnotation", node, opts);
    }
    function assertIntersectionTypeAnnotation(node, opts) {
      assert("IntersectionTypeAnnotation", node, opts);
    }
    function assertMixedTypeAnnotation(node, opts) {
      assert("MixedTypeAnnotation", node, opts);
    }
    function assertEmptyTypeAnnotation(node, opts) {
      assert("EmptyTypeAnnotation", node, opts);
    }
    function assertNullableTypeAnnotation(node, opts) {
      assert("NullableTypeAnnotation", node, opts);
    }
    function assertNumberLiteralTypeAnnotation(node, opts) {
      assert("NumberLiteralTypeAnnotation", node, opts);
    }
    function assertNumberTypeAnnotation(node, opts) {
      assert("NumberTypeAnnotation", node, opts);
    }
    function assertObjectTypeAnnotation(node, opts) {
      assert("ObjectTypeAnnotation", node, opts);
    }
    function assertObjectTypeInternalSlot(node, opts) {
      assert("ObjectTypeInternalSlot", node, opts);
    }
    function assertObjectTypeCallProperty(node, opts) {
      assert("ObjectTypeCallProperty", node, opts);
    }
    function assertObjectTypeIndexer(node, opts) {
      assert("ObjectTypeIndexer", node, opts);
    }
    function assertObjectTypeProperty(node, opts) {
      assert("ObjectTypeProperty", node, opts);
    }
    function assertObjectTypeSpreadProperty(node, opts) {
      assert("ObjectTypeSpreadProperty", node, opts);
    }
    function assertOpaqueType(node, opts) {
      assert("OpaqueType", node, opts);
    }
    function assertQualifiedTypeIdentifier(node, opts) {
      assert("QualifiedTypeIdentifier", node, opts);
    }
    function assertStringLiteralTypeAnnotation(node, opts) {
      assert("StringLiteralTypeAnnotation", node, opts);
    }
    function assertStringTypeAnnotation(node, opts) {
      assert("StringTypeAnnotation", node, opts);
    }
    function assertSymbolTypeAnnotation(node, opts) {
      assert("SymbolTypeAnnotation", node, opts);
    }
    function assertThisTypeAnnotation(node, opts) {
      assert("ThisTypeAnnotation", node, opts);
    }
    function assertTupleTypeAnnotation(node, opts) {
      assert("TupleTypeAnnotation", node, opts);
    }
    function assertTypeofTypeAnnotation(node, opts) {
      assert("TypeofTypeAnnotation", node, opts);
    }
    function assertTypeAlias(node, opts) {
      assert("TypeAlias", node, opts);
    }
    function assertTypeAnnotation(node, opts) {
      assert("TypeAnnotation", node, opts);
    }
    function assertTypeCastExpression(node, opts) {
      assert("TypeCastExpression", node, opts);
    }
    function assertTypeParameter(node, opts) {
      assert("TypeParameter", node, opts);
    }
    function assertTypeParameterDeclaration(node, opts) {
      assert("TypeParameterDeclaration", node, opts);
    }
    function assertTypeParameterInstantiation(node, opts) {
      assert("TypeParameterInstantiation", node, opts);
    }
    function assertUnionTypeAnnotation(node, opts) {
      assert("UnionTypeAnnotation", node, opts);
    }
    function assertVariance(node, opts) {
      assert("Variance", node, opts);
    }
    function assertVoidTypeAnnotation(node, opts) {
      assert("VoidTypeAnnotation", node, opts);
    }
    function assertEnumDeclaration(node, opts) {
      assert("EnumDeclaration", node, opts);
    }
    function assertEnumBooleanBody(node, opts) {
      assert("EnumBooleanBody", node, opts);
    }
    function assertEnumNumberBody(node, opts) {
      assert("EnumNumberBody", node, opts);
    }
    function assertEnumStringBody(node, opts) {
      assert("EnumStringBody", node, opts);
    }
    function assertEnumSymbolBody(node, opts) {
      assert("EnumSymbolBody", node, opts);
    }
    function assertEnumBooleanMember(node, opts) {
      assert("EnumBooleanMember", node, opts);
    }
    function assertEnumNumberMember(node, opts) {
      assert("EnumNumberMember", node, opts);
    }
    function assertEnumStringMember(node, opts) {
      assert("EnumStringMember", node, opts);
    }
    function assertEnumDefaultedMember(node, opts) {
      assert("EnumDefaultedMember", node, opts);
    }
    function assertIndexedAccessType(node, opts) {
      assert("IndexedAccessType", node, opts);
    }
    function assertOptionalIndexedAccessType(node, opts) {
      assert("OptionalIndexedAccessType", node, opts);
    }
    function assertJSXAttribute(node, opts) {
      assert("JSXAttribute", node, opts);
    }
    function assertJSXClosingElement(node, opts) {
      assert("JSXClosingElement", node, opts);
    }
    function assertJSXElement(node, opts) {
      assert("JSXElement", node, opts);
    }
    function assertJSXEmptyExpression(node, opts) {
      assert("JSXEmptyExpression", node, opts);
    }
    function assertJSXExpressionContainer(node, opts) {
      assert("JSXExpressionContainer", node, opts);
    }
    function assertJSXSpreadChild(node, opts) {
      assert("JSXSpreadChild", node, opts);
    }
    function assertJSXIdentifier(node, opts) {
      assert("JSXIdentifier", node, opts);
    }
    function assertJSXMemberExpression(node, opts) {
      assert("JSXMemberExpression", node, opts);
    }
    function assertJSXNamespacedName(node, opts) {
      assert("JSXNamespacedName", node, opts);
    }
    function assertJSXOpeningElement(node, opts) {
      assert("JSXOpeningElement", node, opts);
    }
    function assertJSXSpreadAttribute(node, opts) {
      assert("JSXSpreadAttribute", node, opts);
    }
    function assertJSXText(node, opts) {
      assert("JSXText", node, opts);
    }
    function assertJSXFragment(node, opts) {
      assert("JSXFragment", node, opts);
    }
    function assertJSXOpeningFragment(node, opts) {
      assert("JSXOpeningFragment", node, opts);
    }
    function assertJSXClosingFragment(node, opts) {
      assert("JSXClosingFragment", node, opts);
    }
    function assertNoop(node, opts) {
      assert("Noop", node, opts);
    }
    function assertPlaceholder(node, opts) {
      assert("Placeholder", node, opts);
    }
    function assertV8IntrinsicIdentifier(node, opts) {
      assert("V8IntrinsicIdentifier", node, opts);
    }
    function assertArgumentPlaceholder(node, opts) {
      assert("ArgumentPlaceholder", node, opts);
    }
    function assertBindExpression(node, opts) {
      assert("BindExpression", node, opts);
    }
    function assertDecorator(node, opts) {
      assert("Decorator", node, opts);
    }
    function assertDoExpression(node, opts) {
      assert("DoExpression", node, opts);
    }
    function assertExportDefaultSpecifier(node, opts) {
      assert("ExportDefaultSpecifier", node, opts);
    }
    function assertRecordExpression(node, opts) {
      assert("RecordExpression", node, opts);
    }
    function assertTupleExpression(node, opts) {
      assert("TupleExpression", node, opts);
    }
    function assertDecimalLiteral(node, opts) {
      assert("DecimalLiteral", node, opts);
    }
    function assertModuleExpression(node, opts) {
      assert("ModuleExpression", node, opts);
    }
    function assertTopicReference(node, opts) {
      assert("TopicReference", node, opts);
    }
    function assertPipelineTopicExpression(node, opts) {
      assert("PipelineTopicExpression", node, opts);
    }
    function assertPipelineBareFunction(node, opts) {
      assert("PipelineBareFunction", node, opts);
    }
    function assertPipelinePrimaryTopicReference(node, opts) {
      assert("PipelinePrimaryTopicReference", node, opts);
    }
    function assertVoidPattern(node, opts) {
      assert("VoidPattern", node, opts);
    }
    function assertTSParameterProperty(node, opts) {
      assert("TSParameterProperty", node, opts);
    }
    function assertTSDeclareFunction(node, opts) {
      assert("TSDeclareFunction", node, opts);
    }
    function assertTSDeclareMethod(node, opts) {
      assert("TSDeclareMethod", node, opts);
    }
    function assertTSQualifiedName(node, opts) {
      assert("TSQualifiedName", node, opts);
    }
    function assertTSCallSignatureDeclaration(node, opts) {
      assert("TSCallSignatureDeclaration", node, opts);
    }
    function assertTSConstructSignatureDeclaration(node, opts) {
      assert("TSConstructSignatureDeclaration", node, opts);
    }
    function assertTSPropertySignature(node, opts) {
      assert("TSPropertySignature", node, opts);
    }
    function assertTSMethodSignature(node, opts) {
      assert("TSMethodSignature", node, opts);
    }
    function assertTSIndexSignature(node, opts) {
      assert("TSIndexSignature", node, opts);
    }
    function assertTSAnyKeyword(node, opts) {
      assert("TSAnyKeyword", node, opts);
    }
    function assertTSBooleanKeyword(node, opts) {
      assert("TSBooleanKeyword", node, opts);
    }
    function assertTSBigIntKeyword(node, opts) {
      assert("TSBigIntKeyword", node, opts);
    }
    function assertTSIntrinsicKeyword(node, opts) {
      assert("TSIntrinsicKeyword", node, opts);
    }
    function assertTSNeverKeyword(node, opts) {
      assert("TSNeverKeyword", node, opts);
    }
    function assertTSNullKeyword(node, opts) {
      assert("TSNullKeyword", node, opts);
    }
    function assertTSNumberKeyword(node, opts) {
      assert("TSNumberKeyword", node, opts);
    }
    function assertTSObjectKeyword(node, opts) {
      assert("TSObjectKeyword", node, opts);
    }
    function assertTSStringKeyword(node, opts) {
      assert("TSStringKeyword", node, opts);
    }
    function assertTSSymbolKeyword(node, opts) {
      assert("TSSymbolKeyword", node, opts);
    }
    function assertTSUndefinedKeyword(node, opts) {
      assert("TSUndefinedKeyword", node, opts);
    }
    function assertTSUnknownKeyword(node, opts) {
      assert("TSUnknownKeyword", node, opts);
    }
    function assertTSVoidKeyword(node, opts) {
      assert("TSVoidKeyword", node, opts);
    }
    function assertTSThisType(node, opts) {
      assert("TSThisType", node, opts);
    }
    function assertTSFunctionType(node, opts) {
      assert("TSFunctionType", node, opts);
    }
    function assertTSConstructorType(node, opts) {
      assert("TSConstructorType", node, opts);
    }
    function assertTSTypeReference(node, opts) {
      assert("TSTypeReference", node, opts);
    }
    function assertTSTypePredicate(node, opts) {
      assert("TSTypePredicate", node, opts);
    }
    function assertTSTypeQuery(node, opts) {
      assert("TSTypeQuery", node, opts);
    }
    function assertTSTypeLiteral(node, opts) {
      assert("TSTypeLiteral", node, opts);
    }
    function assertTSArrayType(node, opts) {
      assert("TSArrayType", node, opts);
    }
    function assertTSTupleType(node, opts) {
      assert("TSTupleType", node, opts);
    }
    function assertTSOptionalType(node, opts) {
      assert("TSOptionalType", node, opts);
    }
    function assertTSRestType(node, opts) {
      assert("TSRestType", node, opts);
    }
    function assertTSNamedTupleMember(node, opts) {
      assert("TSNamedTupleMember", node, opts);
    }
    function assertTSUnionType(node, opts) {
      assert("TSUnionType", node, opts);
    }
    function assertTSIntersectionType(node, opts) {
      assert("TSIntersectionType", node, opts);
    }
    function assertTSConditionalType(node, opts) {
      assert("TSConditionalType", node, opts);
    }
    function assertTSInferType(node, opts) {
      assert("TSInferType", node, opts);
    }
    function assertTSParenthesizedType(node, opts) {
      assert("TSParenthesizedType", node, opts);
    }
    function assertTSTypeOperator(node, opts) {
      assert("TSTypeOperator", node, opts);
    }
    function assertTSIndexedAccessType(node, opts) {
      assert("TSIndexedAccessType", node, opts);
    }
    function assertTSMappedType(node, opts) {
      assert("TSMappedType", node, opts);
    }
    function assertTSTemplateLiteralType(node, opts) {
      assert("TSTemplateLiteralType", node, opts);
    }
    function assertTSLiteralType(node, opts) {
      assert("TSLiteralType", node, opts);
    }
    function assertTSExpressionWithTypeArguments(node, opts) {
      assert("TSExpressionWithTypeArguments", node, opts);
    }
    function assertTSInterfaceDeclaration(node, opts) {
      assert("TSInterfaceDeclaration", node, opts);
    }
    function assertTSInterfaceBody(node, opts) {
      assert("TSInterfaceBody", node, opts);
    }
    function assertTSTypeAliasDeclaration(node, opts) {
      assert("TSTypeAliasDeclaration", node, opts);
    }
    function assertTSInstantiationExpression(node, opts) {
      assert("TSInstantiationExpression", node, opts);
    }
    function assertTSAsExpression(node, opts) {
      assert("TSAsExpression", node, opts);
    }
    function assertTSSatisfiesExpression(node, opts) {
      assert("TSSatisfiesExpression", node, opts);
    }
    function assertTSTypeAssertion(node, opts) {
      assert("TSTypeAssertion", node, opts);
    }
    function assertTSEnumBody(node, opts) {
      assert("TSEnumBody", node, opts);
    }
    function assertTSEnumDeclaration(node, opts) {
      assert("TSEnumDeclaration", node, opts);
    }
    function assertTSEnumMember(node, opts) {
      assert("TSEnumMember", node, opts);
    }
    function assertTSModuleDeclaration(node, opts) {
      assert("TSModuleDeclaration", node, opts);
    }
    function assertTSModuleBlock(node, opts) {
      assert("TSModuleBlock", node, opts);
    }
    function assertTSImportType(node, opts) {
      assert("TSImportType", node, opts);
    }
    function assertTSImportEqualsDeclaration(node, opts) {
      assert("TSImportEqualsDeclaration", node, opts);
    }
    function assertTSExternalModuleReference(node, opts) {
      assert("TSExternalModuleReference", node, opts);
    }
    function assertTSNonNullExpression(node, opts) {
      assert("TSNonNullExpression", node, opts);
    }
    function assertTSExportAssignment(node, opts) {
      assert("TSExportAssignment", node, opts);
    }
    function assertTSNamespaceExportDeclaration(node, opts) {
      assert("TSNamespaceExportDeclaration", node, opts);
    }
    function assertTSTypeAnnotation(node, opts) {
      assert("TSTypeAnnotation", node, opts);
    }
    function assertTSTypeParameterInstantiation(node, opts) {
      assert("TSTypeParameterInstantiation", node, opts);
    }
    function assertTSTypeParameterDeclaration(node, opts) {
      assert("TSTypeParameterDeclaration", node, opts);
    }
    function assertTSTypeParameter(node, opts) {
      assert("TSTypeParameter", node, opts);
    }
    function assertStandardized(node, opts) {
      assert("Standardized", node, opts);
    }
    function assertExpression(node, opts) {
      assert("Expression", node, opts);
    }
    function assertBinary(node, opts) {
      assert("Binary", node, opts);
    }
    function assertScopable(node, opts) {
      assert("Scopable", node, opts);
    }
    function assertBlockParent(node, opts) {
      assert("BlockParent", node, opts);
    }
    function assertBlock(node, opts) {
      assert("Block", node, opts);
    }
    function assertStatement(node, opts) {
      assert("Statement", node, opts);
    }
    function assertTerminatorless(node, opts) {
      assert("Terminatorless", node, opts);
    }
    function assertCompletionStatement(node, opts) {
      assert("CompletionStatement", node, opts);
    }
    function assertConditional(node, opts) {
      assert("Conditional", node, opts);
    }
    function assertLoop(node, opts) {
      assert("Loop", node, opts);
    }
    function assertWhile(node, opts) {
      assert("While", node, opts);
    }
    function assertExpressionWrapper(node, opts) {
      assert("ExpressionWrapper", node, opts);
    }
    function assertFor(node, opts) {
      assert("For", node, opts);
    }
    function assertForXStatement(node, opts) {
      assert("ForXStatement", node, opts);
    }
    function assertFunction(node, opts) {
      assert("Function", node, opts);
    }
    function assertFunctionParent(node, opts) {
      assert("FunctionParent", node, opts);
    }
    function assertPureish(node, opts) {
      assert("Pureish", node, opts);
    }
    function assertDeclaration(node, opts) {
      assert("Declaration", node, opts);
    }
    function assertFunctionParameter(node, opts) {
      assert("FunctionParameter", node, opts);
    }
    function assertPatternLike(node, opts) {
      assert("PatternLike", node, opts);
    }
    function assertLVal(node, opts) {
      assert("LVal", node, opts);
    }
    function assertTSEntityName(node, opts) {
      assert("TSEntityName", node, opts);
    }
    function assertLiteral(node, opts) {
      assert("Literal", node, opts);
    }
    function assertImmutable(node, opts) {
      assert("Immutable", node, opts);
    }
    function assertUserWhitespacable(node, opts) {
      assert("UserWhitespacable", node, opts);
    }
    function assertMethod(node, opts) {
      assert("Method", node, opts);
    }
    function assertObjectMember(node, opts) {
      assert("ObjectMember", node, opts);
    }
    function assertProperty(node, opts) {
      assert("Property", node, opts);
    }
    function assertUnaryLike(node, opts) {
      assert("UnaryLike", node, opts);
    }
    function assertPattern(node, opts) {
      assert("Pattern", node, opts);
    }
    function assertClass(node, opts) {
      assert("Class", node, opts);
    }
    function assertImportOrExportDeclaration(node, opts) {
      assert("ImportOrExportDeclaration", node, opts);
    }
    function assertExportDeclaration(node, opts) {
      assert("ExportDeclaration", node, opts);
    }
    function assertModuleSpecifier(node, opts) {
      assert("ModuleSpecifier", node, opts);
    }
    function assertAccessor(node, opts) {
      assert("Accessor", node, opts);
    }
    function assertPrivate(node, opts) {
      assert("Private", node, opts);
    }
    function assertFlow(node, opts) {
      assert("Flow", node, opts);
    }
    function assertFlowType(node, opts) {
      assert("FlowType", node, opts);
    }
    function assertFlowBaseAnnotation(node, opts) {
      assert("FlowBaseAnnotation", node, opts);
    }
    function assertFlowDeclaration(node, opts) {
      assert("FlowDeclaration", node, opts);
    }
    function assertFlowPredicate(node, opts) {
      assert("FlowPredicate", node, opts);
    }
    function assertEnumBody(node, opts) {
      assert("EnumBody", node, opts);
    }
    function assertEnumMember(node, opts) {
      assert("EnumMember", node, opts);
    }
    function assertJSX(node, opts) {
      assert("JSX", node, opts);
    }
    function assertMiscellaneous(node, opts) {
      assert("Miscellaneous", node, opts);
    }
    function assertTypeScript(node, opts) {
      assert("TypeScript", node, opts);
    }
    function assertTSTypeElement(node, opts) {
      assert("TSTypeElement", node, opts);
    }
    function assertTSType(node, opts) {
      assert("TSType", node, opts);
    }
    function assertTSBaseType(node, opts) {
      assert("TSBaseType", node, opts);
    }
    function assertNumberLiteral(node, opts) {
      (0, _deprecationWarning.default)("assertNumberLiteral", "assertNumericLiteral");
      assert("NumberLiteral", node, opts);
    }
    function assertRegexLiteral(node, opts) {
      (0, _deprecationWarning.default)("assertRegexLiteral", "assertRegExpLiteral");
      assert("RegexLiteral", node, opts);
    }
    function assertRestProperty(node, opts) {
      (0, _deprecationWarning.default)("assertRestProperty", "assertRestElement");
      assert("RestProperty", node, opts);
    }
    function assertSpreadProperty(node, opts) {
      (0, _deprecationWarning.default)("assertSpreadProperty", "assertSpreadElement");
      assert("SpreadProperty", node, opts);
    }
    function assertModuleDeclaration(node, opts) {
      (0, _deprecationWarning.default)("assertModuleDeclaration", "assertImportOrExportDeclaration");
      assert("ModuleDeclaration", node, opts);
    }
  }
});

// node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var require_createTypeAnnotationBasedOnTypeof = __commonJS({
  "node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = require_generated2();
    var _default = exports.default = createTypeAnnotationBasedOnTypeof;
    function createTypeAnnotationBasedOnTypeof(type) {
      switch (type) {
        case "string":
          return (0, _index.stringTypeAnnotation)();
        case "number":
          return (0, _index.numberTypeAnnotation)();
        case "undefined":
          return (0, _index.voidTypeAnnotation)();
        case "boolean":
          return (0, _index.booleanTypeAnnotation)();
        case "function":
          return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Function"));
        case "object":
          return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Object"));
        case "symbol":
          return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Symbol"));
        case "bigint":
          return (0, _index.anyTypeAnnotation)();
      }
      throw new Error("Invalid typeof value: " + type);
    }
  }
});

// node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var require_removeTypeDuplicates = __commonJS({
  "node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removeTypeDuplicates;
    var _index = require_generated();
    function getQualifiedName(node) {
      return (0, _index.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
    }
    function removeTypeDuplicates(nodesIn) {
      const nodes = Array.from(nodesIn);
      const generics = /* @__PURE__ */ new Map();
      const bases = /* @__PURE__ */ new Map();
      const typeGroups = /* @__PURE__ */ new Set();
      const types = [];
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (!node) continue;
        if (types.includes(node)) {
          continue;
        }
        if ((0, _index.isAnyTypeAnnotation)(node)) {
          return [node];
        }
        if ((0, _index.isFlowBaseAnnotation)(node)) {
          bases.set(node.type, node);
          continue;
        }
        if ((0, _index.isUnionTypeAnnotation)(node)) {
          if (!typeGroups.has(node.types)) {
            nodes.push(...node.types);
            typeGroups.add(node.types);
          }
          continue;
        }
        if ((0, _index.isGenericTypeAnnotation)(node)) {
          const name50 = getQualifiedName(node.id);
          if (generics.has(name50)) {
            let existing = generics.get(name50);
            if (existing.typeParameters) {
              if (node.typeParameters) {
                existing.typeParameters.params.push(...node.typeParameters.params);
                existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
              }
            } else {
              existing = node.typeParameters;
            }
          } else {
            generics.set(name50, node);
          }
          continue;
        }
        types.push(node);
      }
      for (const [, baseType] of bases) {
        types.push(baseType);
      }
      for (const [, genericName] of generics) {
        types.push(genericName);
      }
      return types;
    }
  }
});

// node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var require_createFlowUnionType = __commonJS({
  "node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = createFlowUnionType;
    var _index = require_generated2();
    var _removeTypeDuplicates = require_removeTypeDuplicates();
    function createFlowUnionType(types) {
      const flattened = (0, _removeTypeDuplicates.default)(types);
      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return (0, _index.unionTypeAnnotation)(flattened);
      }
    }
  }
});

// node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var require_removeTypeDuplicates2 = __commonJS({
  "node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removeTypeDuplicates;
    var _index = require_generated();
    function getQualifiedName(node) {
      return (0, _index.isIdentifier)(node) ? node.name : (0, _index.isThisExpression)(node) ? "this" : `${node.right.name}.${getQualifiedName(node.left)}`;
    }
    function removeTypeDuplicates(nodesIn) {
      const nodes = Array.from(nodesIn);
      const generics = /* @__PURE__ */ new Map();
      const bases = /* @__PURE__ */ new Map();
      const typeGroups = /* @__PURE__ */ new Set();
      const types = [];
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (!node) continue;
        if (types.includes(node)) {
          continue;
        }
        if ((0, _index.isTSAnyKeyword)(node)) {
          return [node];
        }
        if ((0, _index.isTSBaseType)(node)) {
          bases.set(node.type, node);
          continue;
        }
        if ((0, _index.isTSUnionType)(node)) {
          if (!typeGroups.has(node.types)) {
            nodes.push(...node.types);
            typeGroups.add(node.types);
          }
          continue;
        }
        const typeArgumentsKey = "typeParameters";
        if ((0, _index.isTSTypeReference)(node) && node[typeArgumentsKey]) {
          const typeArguments = node[typeArgumentsKey];
          const name50 = getQualifiedName(node.typeName);
          if (generics.has(name50)) {
            let existing = generics.get(name50);
            const existingTypeArguments = existing[typeArgumentsKey];
            if (existingTypeArguments) {
              existingTypeArguments.params.push(...typeArguments.params);
              existingTypeArguments.params = removeTypeDuplicates(existingTypeArguments.params);
            } else {
              existing = typeArguments;
            }
          } else {
            generics.set(name50, node);
          }
          continue;
        }
        types.push(node);
      }
      for (const [, baseType] of bases) {
        types.push(baseType);
      }
      for (const [, genericName] of generics) {
        types.push(genericName);
      }
      return types;
    }
  }
});

// node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var require_createTSUnionType = __commonJS({
  "node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = createTSUnionType;
    var _index = require_generated2();
    var _removeTypeDuplicates = require_removeTypeDuplicates2();
    var _index2 = require_generated();
    function createTSUnionType(typeAnnotations) {
      const types = typeAnnotations.map((type) => {
        return (0, _index2.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;
      });
      const flattened = (0, _removeTypeDuplicates.default)(types);
      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return (0, _index.tsUnionType)(flattened);
      }
    }
  }
});

// node_modules/@babel/types/lib/builders/productions.js
var require_productions = __commonJS({
  "node_modules/@babel/types/lib/builders/productions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.buildUndefinedNode = buildUndefinedNode;
    var _index = require_generated2();
    function buildUndefinedNode() {
      return (0, _index.unaryExpression)("void", (0, _index.numericLiteral)(0), true);
    }
  }
});

// node_modules/@babel/types/lib/clone/cloneNode.js
var require_cloneNode = __commonJS({
  "node_modules/@babel/types/lib/clone/cloneNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneNode;
    var _index = require_definitions();
    var _index2 = require_generated();
    var {
      hasOwn
    } = {
      hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
    };
    function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
      if (obj && typeof obj.type === "string") {
        return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
      }
      return obj;
    }
    function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
      if (Array.isArray(obj)) {
        return obj.map((node) => cloneIfNode(node, deep, withoutLoc, commentsCache));
      }
      return cloneIfNode(obj, deep, withoutLoc, commentsCache);
    }
    function cloneNode(node, deep = true, withoutLoc = false) {
      return cloneNodeInternal(node, deep, withoutLoc, /* @__PURE__ */ new Map());
    }
    function cloneNodeInternal(node, deep = true, withoutLoc = false, commentsCache) {
      if (!node) return node;
      const {
        type
      } = node;
      const newNode = {
        type: node.type
      };
      if ((0, _index2.isIdentifier)(node)) {
        newNode.name = node.name;
        if (hasOwn(node, "optional") && typeof node.optional === "boolean") {
          newNode.optional = node.optional;
        }
        if (hasOwn(node, "typeAnnotation")) {
          newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;
        }
        if (hasOwn(node, "decorators")) {
          newNode.decorators = deep ? cloneIfNodeOrArray(node.decorators, true, withoutLoc, commentsCache) : node.decorators;
        }
      } else if (!hasOwn(_index.NODE_FIELDS, type)) {
        throw new Error(`Unknown node type: "${type}"`);
      } else {
        for (const field of Object.keys(_index.NODE_FIELDS[type])) {
          if (hasOwn(node, field)) {
            if (deep) {
              newNode[field] = (0, _index2.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);
            } else {
              newNode[field] = node[field];
            }
          }
        }
      }
      if (hasOwn(node, "loc")) {
        if (withoutLoc) {
          newNode.loc = null;
        } else {
          newNode.loc = node.loc;
        }
      }
      if (hasOwn(node, "leadingComments")) {
        newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);
      }
      if (hasOwn(node, "innerComments")) {
        newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);
      }
      if (hasOwn(node, "trailingComments")) {
        newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);
      }
      if (hasOwn(node, "extra")) {
        newNode.extra = Object.assign({}, node.extra);
      }
      return newNode;
    }
    function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
      if (!comments || !deep) {
        return comments;
      }
      return comments.map((comment) => {
        const cache = commentsCache.get(comment);
        if (cache) return cache;
        const {
          type,
          value,
          loc
        } = comment;
        const ret = {
          type,
          value,
          loc
        };
        if (withoutLoc) {
          ret.loc = null;
        }
        commentsCache.set(comment, ret);
        return ret;
      });
    }
  }
});

// node_modules/@babel/types/lib/clone/clone.js
var require_clone = __commonJS({
  "node_modules/@babel/types/lib/clone/clone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = clone3;
    var _cloneNode = require_cloneNode();
    function clone3(node) {
      return (0, _cloneNode.default)(node, false);
    }
  }
});

// node_modules/@babel/types/lib/clone/cloneDeep.js
var require_cloneDeep = __commonJS({
  "node_modules/@babel/types/lib/clone/cloneDeep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneDeep;
    var _cloneNode = require_cloneNode();
    function cloneDeep(node) {
      return (0, _cloneNode.default)(node);
    }
  }
});

// node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var require_cloneDeepWithoutLoc = __commonJS({
  "node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneDeepWithoutLoc;
    var _cloneNode = require_cloneNode();
    function cloneDeepWithoutLoc(node) {
      return (0, _cloneNode.default)(node, true, true);
    }
  }
});

// node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var require_cloneWithoutLoc = __commonJS({
  "node_modules/@babel/types/lib/clone/cloneWithoutLoc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneWithoutLoc;
    var _cloneNode = require_cloneNode();
    function cloneWithoutLoc(node) {
      return (0, _cloneNode.default)(node, false, true);
    }
  }
});

// node_modules/@babel/types/lib/comments/addComments.js
var require_addComments = __commonJS({
  "node_modules/@babel/types/lib/comments/addComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = addComments;
    function addComments(node, type, comments) {
      if (!comments || !node) return node;
      const key = `${type}Comments`;
      if (node[key]) {
        if (type === "leading") {
          node[key] = comments.concat(node[key]);
        } else {
          node[key].push(...comments);
        }
      } else {
        node[key] = comments;
      }
      return node;
    }
  }
});

// node_modules/@babel/types/lib/comments/addComment.js
var require_addComment = __commonJS({
  "node_modules/@babel/types/lib/comments/addComment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = addComment;
    var _addComments = require_addComments();
    function addComment(node, type, content, line) {
      return (0, _addComments.default)(node, type, [{
        type: line ? "CommentLine" : "CommentBlock",
        value: content
      }]);
    }
  }
});

// node_modules/@babel/types/lib/utils/inherit.js
var require_inherit = __commonJS({
  "node_modules/@babel/types/lib/utils/inherit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inherit;
    function inherit(key, child, parent) {
      if (child && parent) {
        child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
      }
    }
  }
});

// node_modules/@babel/types/lib/comments/inheritInnerComments.js
var require_inheritInnerComments = __commonJS({
  "node_modules/@babel/types/lib/comments/inheritInnerComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inheritInnerComments;
    var _inherit = require_inherit();
    function inheritInnerComments(child, parent) {
      (0, _inherit.default)("innerComments", child, parent);
    }
  }
});

// node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var require_inheritLeadingComments = __commonJS({
  "node_modules/@babel/types/lib/comments/inheritLeadingComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inheritLeadingComments;
    var _inherit = require_inherit();
    function inheritLeadingComments(child, parent) {
      (0, _inherit.default)("leadingComments", child, parent);
    }
  }
});

// node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var require_inheritTrailingComments = __commonJS({
  "node_modules/@babel/types/lib/comments/inheritTrailingComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inheritTrailingComments;
    var _inherit = require_inherit();
    function inheritTrailingComments(child, parent) {
      (0, _inherit.default)("trailingComments", child, parent);
    }
  }
});

// node_modules/@babel/types/lib/comments/inheritsComments.js
var require_inheritsComments = __commonJS({
  "node_modules/@babel/types/lib/comments/inheritsComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inheritsComments;
    var _inheritTrailingComments = require_inheritTrailingComments();
    var _inheritLeadingComments = require_inheritLeadingComments();
    var _inheritInnerComments = require_inheritInnerComments();
    function inheritsComments(child, parent) {
      (0, _inheritTrailingComments.default)(child, parent);
      (0, _inheritLeadingComments.default)(child, parent);
      (0, _inheritInnerComments.default)(child, parent);
      return child;
    }
  }
});

// node_modules/@babel/types/lib/comments/removeComments.js
var require_removeComments = __commonJS({
  "node_modules/@babel/types/lib/comments/removeComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removeComments2;
    var _index = require_constants();
    function removeComments2(node) {
      _index.COMMENT_KEYS.forEach((key) => {
        node[key] = null;
      });
      return node;
    }
  }
});

// node_modules/@babel/types/lib/constants/generated/index.js
var require_generated4 = __commonJS({
  "node_modules/@babel/types/lib/constants/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.WHILE_TYPES = exports.USERWHITESPACABLE_TYPES = exports.UNARYLIKE_TYPES = exports.TYPESCRIPT_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.TSENTITYNAME_TYPES = exports.TSBASETYPE_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.STANDARDIZED_TYPES = exports.SCOPABLE_TYPES = exports.PUREISH_TYPES = exports.PROPERTY_TYPES = exports.PRIVATE_TYPES = exports.PATTERN_TYPES = exports.PATTERNLIKE_TYPES = exports.OBJECTMEMBER_TYPES = exports.MODULESPECIFIER_TYPES = exports.MODULEDECLARATION_TYPES = exports.MISCELLANEOUS_TYPES = exports.METHOD_TYPES = exports.LVAL_TYPES = exports.LOOP_TYPES = exports.LITERAL_TYPES = exports.JSX_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = exports.IMMUTABLE_TYPES = exports.FUNCTION_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FUNCTIONPARAMETER_TYPES = exports.FOR_TYPES = exports.FORXSTATEMENT_TYPES = exports.FLOW_TYPES = exports.FLOWTYPE_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.EXPRESSION_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.DECLARATION_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.CLASS_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.BINARY_TYPES = exports.ACCESSOR_TYPES = void 0;
    var _index = require_definitions();
    var STANDARDIZED_TYPES = exports.STANDARDIZED_TYPES = _index.FLIPPED_ALIAS_KEYS["Standardized"];
    var EXPRESSION_TYPES = exports.EXPRESSION_TYPES = _index.FLIPPED_ALIAS_KEYS["Expression"];
    var BINARY_TYPES = exports.BINARY_TYPES = _index.FLIPPED_ALIAS_KEYS["Binary"];
    var SCOPABLE_TYPES = exports.SCOPABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Scopable"];
    var BLOCKPARENT_TYPES = exports.BLOCKPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["BlockParent"];
    var BLOCK_TYPES = exports.BLOCK_TYPES = _index.FLIPPED_ALIAS_KEYS["Block"];
    var STATEMENT_TYPES = exports.STATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["Statement"];
    var TERMINATORLESS_TYPES = exports.TERMINATORLESS_TYPES = _index.FLIPPED_ALIAS_KEYS["Terminatorless"];
    var COMPLETIONSTATEMENT_TYPES = exports.COMPLETIONSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["CompletionStatement"];
    var CONDITIONAL_TYPES = exports.CONDITIONAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Conditional"];
    var LOOP_TYPES = exports.LOOP_TYPES = _index.FLIPPED_ALIAS_KEYS["Loop"];
    var WHILE_TYPES = exports.WHILE_TYPES = _index.FLIPPED_ALIAS_KEYS["While"];
    var EXPRESSIONWRAPPER_TYPES = exports.EXPRESSIONWRAPPER_TYPES = _index.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
    var FOR_TYPES = exports.FOR_TYPES = _index.FLIPPED_ALIAS_KEYS["For"];
    var FORXSTATEMENT_TYPES = exports.FORXSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["ForXStatement"];
    var FUNCTION_TYPES = exports.FUNCTION_TYPES = _index.FLIPPED_ALIAS_KEYS["Function"];
    var FUNCTIONPARENT_TYPES = exports.FUNCTIONPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["FunctionParent"];
    var PUREISH_TYPES = exports.PUREISH_TYPES = _index.FLIPPED_ALIAS_KEYS["Pureish"];
    var DECLARATION_TYPES = exports.DECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["Declaration"];
    var FUNCTIONPARAMETER_TYPES = exports.FUNCTIONPARAMETER_TYPES = _index.FLIPPED_ALIAS_KEYS["FunctionParameter"];
    var PATTERNLIKE_TYPES = exports.PATTERNLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["PatternLike"];
    var LVAL_TYPES = exports.LVAL_TYPES = _index.FLIPPED_ALIAS_KEYS["LVal"];
    var TSENTITYNAME_TYPES = exports.TSENTITYNAME_TYPES = _index.FLIPPED_ALIAS_KEYS["TSEntityName"];
    var LITERAL_TYPES = exports.LITERAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Literal"];
    var IMMUTABLE_TYPES = exports.IMMUTABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Immutable"];
    var USERWHITESPACABLE_TYPES = exports.USERWHITESPACABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
    var METHOD_TYPES = exports.METHOD_TYPES = _index.FLIPPED_ALIAS_KEYS["Method"];
    var OBJECTMEMBER_TYPES = exports.OBJECTMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["ObjectMember"];
    var PROPERTY_TYPES = exports.PROPERTY_TYPES = _index.FLIPPED_ALIAS_KEYS["Property"];
    var UNARYLIKE_TYPES = exports.UNARYLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["UnaryLike"];
    var PATTERN_TYPES = exports.PATTERN_TYPES = _index.FLIPPED_ALIAS_KEYS["Pattern"];
    var CLASS_TYPES = exports.CLASS_TYPES = _index.FLIPPED_ALIAS_KEYS["Class"];
    var IMPORTOREXPORTDECLARATION_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ImportOrExportDeclaration"];
    var EXPORTDECLARATION_TYPES = exports.EXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
    var MODULESPECIFIER_TYPES = exports.MODULESPECIFIER_TYPES = _index.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
    var ACCESSOR_TYPES = exports.ACCESSOR_TYPES = _index.FLIPPED_ALIAS_KEYS["Accessor"];
    var PRIVATE_TYPES = exports.PRIVATE_TYPES = _index.FLIPPED_ALIAS_KEYS["Private"];
    var FLOW_TYPES = exports.FLOW_TYPES = _index.FLIPPED_ALIAS_KEYS["Flow"];
    var FLOWTYPE_TYPES = exports.FLOWTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowType"];
    var FLOWBASEANNOTATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
    var FLOWDECLARATION_TYPES = exports.FLOWDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
    var FLOWPREDICATE_TYPES = exports.FLOWPREDICATE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowPredicate"];
    var ENUMBODY_TYPES = exports.ENUMBODY_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumBody"];
    var ENUMMEMBER_TYPES = exports.ENUMMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumMember"];
    var JSX_TYPES = exports.JSX_TYPES = _index.FLIPPED_ALIAS_KEYS["JSX"];
    var MISCELLANEOUS_TYPES = exports.MISCELLANEOUS_TYPES = _index.FLIPPED_ALIAS_KEYS["Miscellaneous"];
    var TYPESCRIPT_TYPES = exports.TYPESCRIPT_TYPES = _index.FLIPPED_ALIAS_KEYS["TypeScript"];
    var TSTYPEELEMENT_TYPES = exports.TSTYPEELEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["TSTypeElement"];
    var TSTYPE_TYPES = exports.TSTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSType"];
    var TSBASETYPE_TYPES = exports.TSBASETYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSBaseType"];
    var MODULEDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
  }
});

// node_modules/@babel/types/lib/converters/toBlock.js
var require_toBlock = __commonJS({
  "node_modules/@babel/types/lib/converters/toBlock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toBlock;
    var _index = require_generated();
    var _index2 = require_generated2();
    function toBlock(node, parent) {
      if ((0, _index.isBlockStatement)(node)) {
        return node;
      }
      let blockNodes = [];
      if ((0, _index.isEmptyStatement)(node)) {
        blockNodes = [];
      } else {
        if (!(0, _index.isStatement)(node)) {
          if ((0, _index.isFunction)(parent)) {
            node = (0, _index2.returnStatement)(node);
          } else {
            node = (0, _index2.expressionStatement)(node);
          }
        }
        blockNodes = [node];
      }
      return (0, _index2.blockStatement)(blockNodes);
    }
  }
});

// node_modules/@babel/types/lib/converters/ensureBlock.js
var require_ensureBlock = __commonJS({
  "node_modules/@babel/types/lib/converters/ensureBlock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = ensureBlock;
    var _toBlock = require_toBlock();
    function ensureBlock(node, key = "body") {
      const result = (0, _toBlock.default)(node[key], node);
      node[key] = result;
      return result;
    }
  }
});

// node_modules/@babel/types/lib/converters/toIdentifier.js
var require_toIdentifier = __commonJS({
  "node_modules/@babel/types/lib/converters/toIdentifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toIdentifier;
    var _isValidIdentifier = require_isValidIdentifier();
    var _helperValidatorIdentifier = require_lib2();
    function toIdentifier(input) {
      input = input + "";
      let name50 = "";
      for (const c of input) {
        name50 += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
      }
      name50 = name50.replace(/^[-0-9]+/, "");
      name50 = name50.replace(/[-\s]+(.)?/g, function(match, c) {
        return c ? c.toUpperCase() : "";
      });
      if (!(0, _isValidIdentifier.default)(name50)) {
        name50 = `_${name50}`;
      }
      return name50 || "_";
    }
  }
});

// node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var require_toBindingIdentifierName = __commonJS({
  "node_modules/@babel/types/lib/converters/toBindingIdentifierName.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toBindingIdentifierName;
    var _toIdentifier = require_toIdentifier();
    function toBindingIdentifierName(name50) {
      name50 = (0, _toIdentifier.default)(name50);
      if (name50 === "eval" || name50 === "arguments") name50 = "_" + name50;
      return name50;
    }
  }
});

// node_modules/@babel/types/lib/converters/toComputedKey.js
var require_toComputedKey = __commonJS({
  "node_modules/@babel/types/lib/converters/toComputedKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toComputedKey;
    var _index = require_generated();
    var _index2 = require_generated2();
    function toComputedKey(node, key = node.key || node.property) {
      if (!node.computed && (0, _index.isIdentifier)(key)) key = (0, _index2.stringLiteral)(key.name);
      return key;
    }
  }
});

// node_modules/@babel/types/lib/converters/toExpression.js
var require_toExpression = __commonJS({
  "node_modules/@babel/types/lib/converters/toExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = require_generated();
    var _default = exports.default = toExpression;
    function toExpression(node) {
      if ((0, _index.isExpressionStatement)(node)) {
        node = node.expression;
      }
      if ((0, _index.isExpression)(node)) {
        return node;
      }
      if ((0, _index.isClass)(node)) {
        node.type = "ClassExpression";
        node.abstract = false;
      } else if ((0, _index.isFunction)(node)) {
        node.type = "FunctionExpression";
      }
      if (!(0, _index.isExpression)(node)) {
        throw new Error(`cannot turn ${node.type} to an expression`);
      }
      return node;
    }
  }
});

// node_modules/@babel/types/lib/traverse/traverseFast.js
var require_traverseFast = __commonJS({
  "node_modules/@babel/types/lib/traverse/traverseFast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = traverseFast;
    var _index = require_definitions();
    var _skip = Symbol();
    var _stop = Symbol();
    function traverseFast(node, enter, opts) {
      if (!node) return false;
      const keys = _index.VISITOR_KEYS[node.type];
      if (!keys) return false;
      opts = opts || {};
      const ret = enter(node, opts);
      if (ret !== void 0) {
        switch (ret) {
          case _skip:
            return false;
          case _stop:
            return true;
        }
      }
      for (const key of keys) {
        const subNode = node[key];
        if (!subNode) continue;
        if (Array.isArray(subNode)) {
          for (const node2 of subNode) {
            if (traverseFast(node2, enter, opts)) return true;
          }
        } else {
          if (traverseFast(subNode, enter, opts)) return true;
        }
      }
      return false;
    }
    traverseFast.skip = _skip;
    traverseFast.stop = _stop;
  }
});

// node_modules/@babel/types/lib/modifications/removeProperties.js
var require_removeProperties = __commonJS({
  "node_modules/@babel/types/lib/modifications/removeProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removeProperties;
    var _index = require_constants();
    var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
    var CLEAR_KEYS_PLUS_COMMENTS = [..._index.COMMENT_KEYS, "comments", ...CLEAR_KEYS];
    function removeProperties(node, opts = {}) {
      const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
      for (const key of map) {
        if (node[key] != null) node[key] = void 0;
      }
      for (const key of Object.keys(node)) {
        if (key.startsWith("_") && node[key] != null) node[key] = void 0;
      }
      const symbols2 = Object.getOwnPropertySymbols(node);
      for (const sym of symbols2) {
        node[sym] = null;
      }
    }
  }
});

// node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var require_removePropertiesDeep = __commonJS({
  "node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removePropertiesDeep;
    var _traverseFast = require_traverseFast();
    var _removeProperties = require_removeProperties();
    function removePropertiesDeep(tree, opts) {
      (0, _traverseFast.default)(tree, _removeProperties.default, opts);
      return tree;
    }
  }
});

// node_modules/@babel/types/lib/converters/toKeyAlias.js
var require_toKeyAlias = __commonJS({
  "node_modules/@babel/types/lib/converters/toKeyAlias.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toKeyAlias;
    var _index = require_generated();
    var _cloneNode = require_cloneNode();
    var _removePropertiesDeep = require_removePropertiesDeep();
    function toKeyAlias(node, key = node.key) {
      let alias;
      if (node.kind === "method") {
        return toKeyAlias.increment() + "";
      } else if ((0, _index.isIdentifier)(key)) {
        alias = key.name;
      } else if ((0, _index.isStringLiteral)(key)) {
        alias = JSON.stringify(key.value);
      } else {
        alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
      }
      if (node.computed) {
        alias = `[${alias}]`;
      }
      if (node.static) {
        alias = `static:${alias}`;
      }
      return alias;
    }
    toKeyAlias.uid = 0;
    toKeyAlias.increment = function() {
      if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
        return toKeyAlias.uid = 0;
      } else {
        return toKeyAlias.uid++;
      }
    };
  }
});

// node_modules/@babel/types/lib/converters/toStatement.js
var require_toStatement = __commonJS({
  "node_modules/@babel/types/lib/converters/toStatement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = require_generated();
    var _index2 = require_generated2();
    var _default = exports.default = toStatement;
    function toStatement(node, ignore) {
      if ((0, _index.isStatement)(node)) {
        return node;
      }
      let mustHaveId = false;
      let newType;
      if ((0, _index.isClass)(node)) {
        mustHaveId = true;
        newType = "ClassDeclaration";
      } else if ((0, _index.isFunction)(node)) {
        mustHaveId = true;
        newType = "FunctionDeclaration";
      } else if ((0, _index.isAssignmentExpression)(node)) {
        return (0, _index2.expressionStatement)(node);
      }
      if (mustHaveId && !node.id) {
        newType = false;
      }
      if (!newType) {
        if (ignore) {
          return false;
        } else {
          throw new Error(`cannot turn ${node.type} to a statement`);
        }
      }
      node.type = newType;
      return node;
    }
  }
});

// node_modules/@babel/types/lib/converters/valueToNode.js
var require_valueToNode = __commonJS({
  "node_modules/@babel/types/lib/converters/valueToNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _isValidIdentifier = require_isValidIdentifier();
    var _index = require_generated2();
    var _default = exports.default = valueToNode;
    var objectToString = Function.call.bind(Object.prototype.toString);
    function isRegExp(value) {
      return objectToString(value) === "[object RegExp]";
    }
    function isPlainObject(value) {
      if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const proto = Object.getPrototypeOf(value);
      return proto === null || Object.getPrototypeOf(proto) === null;
    }
    function valueToNode(value) {
      if (value === void 0) {
        return (0, _index.identifier)("undefined");
      }
      if (value === true || value === false) {
        return (0, _index.booleanLiteral)(value);
      }
      if (value === null) {
        return (0, _index.nullLiteral)();
      }
      if (typeof value === "string") {
        return (0, _index.stringLiteral)(value);
      }
      if (typeof value === "number") {
        let result;
        if (Number.isFinite(value)) {
          result = (0, _index.numericLiteral)(Math.abs(value));
        } else {
          let numerator;
          if (Number.isNaN(value)) {
            numerator = (0, _index.numericLiteral)(0);
          } else {
            numerator = (0, _index.numericLiteral)(1);
          }
          result = (0, _index.binaryExpression)("/", numerator, (0, _index.numericLiteral)(0));
        }
        if (value < 0 || Object.is(value, -0)) {
          result = (0, _index.unaryExpression)("-", result);
        }
        return result;
      }
      if (typeof value === "bigint") {
        if (value < 0) {
          return (0, _index.unaryExpression)("-", (0, _index.bigIntLiteral)(-value));
        } else {
          return (0, _index.bigIntLiteral)(value);
        }
      }
      if (isRegExp(value)) {
        const pattern = value.source;
        const flags = /\/([a-z]*)$/.exec(value.toString())[1];
        return (0, _index.regExpLiteral)(pattern, flags);
      }
      if (Array.isArray(value)) {
        return (0, _index.arrayExpression)(value.map(valueToNode));
      }
      if (isPlainObject(value)) {
        const props = [];
        for (const key of Object.keys(value)) {
          let nodeKey, computed = false;
          if ((0, _isValidIdentifier.default)(key)) {
            if (key === "__proto__") {
              computed = true;
              nodeKey = (0, _index.stringLiteral)(key);
            } else {
              nodeKey = (0, _index.identifier)(key);
            }
          } else {
            nodeKey = (0, _index.stringLiteral)(key);
          }
          props.push((0, _index.objectProperty)(nodeKey, valueToNode(value[key]), computed));
        }
        return (0, _index.objectExpression)(props);
      }
      throw new Error("don't know how to turn this value into a node");
    }
  }
});

// node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var require_appendToMemberExpression = __commonJS({
  "node_modules/@babel/types/lib/modifications/appendToMemberExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = appendToMemberExpression;
    var _index = require_generated2();
    function appendToMemberExpression(member, append, computed = false) {
      member.object = (0, _index.memberExpression)(member.object, member.property, member.computed);
      member.property = append;
      member.computed = !!computed;
      return member;
    }
  }
});

// node_modules/@babel/types/lib/modifications/inherits.js
var require_inherits = __commonJS({
  "node_modules/@babel/types/lib/modifications/inherits.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inherits;
    var _index = require_constants();
    var _inheritsComments = require_inheritsComments();
    function inherits(child, parent) {
      if (!child || !parent) return child;
      for (const key of _index.INHERIT_KEYS.optional) {
        if (child[key] == null) {
          child[key] = parent[key];
        }
      }
      for (const key of Object.keys(parent)) {
        if (key.startsWith("_") && key !== "__clone") {
          child[key] = parent[key];
        }
      }
      for (const key of _index.INHERIT_KEYS.force) {
        child[key] = parent[key];
      }
      (0, _inheritsComments.default)(child, parent);
      return child;
    }
  }
});

// node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var require_prependToMemberExpression = __commonJS({
  "node_modules/@babel/types/lib/modifications/prependToMemberExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = prependToMemberExpression;
    var _index = require_generated2();
    var _index2 = require_lib4();
    function prependToMemberExpression(member, prepend) {
      if ((0, _index2.isSuper)(member.object)) {
        throw new Error("Cannot prepend node to super property access (`super.foo`).");
      }
      member.object = (0, _index.memberExpression)(prepend, member.object);
      return member;
    }
  }
});

// node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js
var require_getAssignmentIdentifiers = __commonJS({
  "node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getAssignmentIdentifiers;
    function getAssignmentIdentifiers(node) {
      const search = [].concat(node);
      const ids = /* @__PURE__ */ Object.create(null);
      while (search.length) {
        const id = search.pop();
        if (!id) continue;
        switch (id.type) {
          case "ArrayPattern":
            search.push(...id.elements);
            break;
          case "AssignmentExpression":
          case "AssignmentPattern":
          case "ForInStatement":
          case "ForOfStatement":
            search.push(id.left);
            break;
          case "ObjectPattern":
            search.push(...id.properties);
            break;
          case "ObjectProperty":
            search.push(id.value);
            break;
          case "RestElement":
          case "UpdateExpression":
            search.push(id.argument);
            break;
          case "UnaryExpression":
            if (id.operator === "delete") {
              search.push(id.argument);
            }
            break;
          case "Identifier":
            ids[id.name] = id;
            break;
          default:
            break;
        }
      }
      return ids;
    }
  }
});

// node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var require_getBindingIdentifiers = __commonJS({
  "node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getBindingIdentifiers;
    var _index = require_generated();
    function getBindingIdentifiers(node, duplicates, outerOnly, newBindingsOnly) {
      const search = [].concat(node);
      const ids = /* @__PURE__ */ Object.create(null);
      while (search.length) {
        const id = search.shift();
        if (!id) continue;
        if (newBindingsOnly && ((0, _index.isAssignmentExpression)(id) || (0, _index.isUnaryExpression)(id) || (0, _index.isUpdateExpression)(id))) {
          continue;
        }
        if ((0, _index.isIdentifier)(id)) {
          if (duplicates) {
            const _ids = ids[id.name] = ids[id.name] || [];
            _ids.push(id);
          } else {
            ids[id.name] = id;
          }
          continue;
        }
        if ((0, _index.isExportDeclaration)(id) && !(0, _index.isExportAllDeclaration)(id)) {
          if ((0, _index.isDeclaration)(id.declaration)) {
            search.push(id.declaration);
          }
          continue;
        }
        if (outerOnly) {
          if ((0, _index.isFunctionDeclaration)(id)) {
            search.push(id.id);
            continue;
          }
          if ((0, _index.isFunctionExpression)(id)) {
            continue;
          }
        }
        const keys2 = getBindingIdentifiers.keys[id.type];
        if (keys2) {
          for (let i = 0; i < keys2.length; i++) {
            const key = keys2[i];
            const nodes = id[key];
            if (nodes) {
              if (Array.isArray(nodes)) {
                search.push(...nodes);
              } else {
                search.push(nodes);
              }
            }
          }
        }
      }
      return ids;
    }
    var keys = {
      DeclareClass: ["id"],
      DeclareFunction: ["id"],
      DeclareModule: ["id"],
      DeclareVariable: ["id"],
      DeclareInterface: ["id"],
      DeclareTypeAlias: ["id"],
      DeclareOpaqueType: ["id"],
      InterfaceDeclaration: ["id"],
      TypeAlias: ["id"],
      OpaqueType: ["id"],
      CatchClause: ["param"],
      LabeledStatement: ["label"],
      UnaryExpression: ["argument"],
      AssignmentExpression: ["left"],
      ImportSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportDefaultSpecifier: ["local"],
      ImportDeclaration: ["specifiers"],
      TSImportEqualsDeclaration: ["id"],
      ExportSpecifier: ["exported"],
      ExportNamespaceSpecifier: ["exported"],
      ExportDefaultSpecifier: ["exported"],
      FunctionDeclaration: ["id", "params"],
      FunctionExpression: ["id", "params"],
      ArrowFunctionExpression: ["params"],
      ObjectMethod: ["params"],
      ClassMethod: ["params"],
      ClassPrivateMethod: ["params"],
      ForInStatement: ["left"],
      ForOfStatement: ["left"],
      ClassDeclaration: ["id"],
      ClassExpression: ["id"],
      RestElement: ["argument"],
      UpdateExpression: ["argument"],
      ObjectProperty: ["value"],
      AssignmentPattern: ["left"],
      ArrayPattern: ["elements"],
      ObjectPattern: ["properties"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id"]
    };
    getBindingIdentifiers.keys = keys;
  }
});

// node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var require_getOuterBindingIdentifiers = __commonJS({
  "node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _default = exports.default = getOuterBindingIdentifiers;
    function getOuterBindingIdentifiers(node, duplicates) {
      return (0, _getBindingIdentifiers.default)(node, duplicates, true);
    }
  }
});

// node_modules/@babel/types/lib/retrievers/getFunctionName.js
var require_getFunctionName = __commonJS({
  "node_modules/@babel/types/lib/retrievers/getFunctionName.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getFunctionName;
    var _index = require_generated();
    function getNameFromLiteralId(id) {
      if ((0, _index.isNullLiteral)(id)) {
        return "null";
      }
      if ((0, _index.isRegExpLiteral)(id)) {
        return `/${id.pattern}/${id.flags}`;
      }
      if ((0, _index.isTemplateLiteral)(id)) {
        return id.quasis.map((quasi) => quasi.value.raw).join("");
      }
      if (id.value !== void 0) {
        return String(id.value);
      }
      return null;
    }
    function getObjectMemberKey(node) {
      if (!node.computed || (0, _index.isLiteral)(node.key)) {
        return node.key;
      }
    }
    function getFunctionName(node, parent) {
      if ("id" in node && node.id) {
        return {
          name: node.id.name,
          originalNode: node.id
        };
      }
      let prefix = "";
      let id;
      if ((0, _index.isObjectProperty)(parent, {
        value: node
      })) {
        id = getObjectMemberKey(parent);
      } else if ((0, _index.isObjectMethod)(node) || (0, _index.isClassMethod)(node)) {
        id = getObjectMemberKey(node);
        if (node.kind === "get") prefix = "get ";
        else if (node.kind === "set") prefix = "set ";
      } else if ((0, _index.isVariableDeclarator)(parent, {
        init: node
      })) {
        id = parent.id;
      } else if ((0, _index.isAssignmentExpression)(parent, {
        operator: "=",
        right: node
      })) {
        id = parent.left;
      }
      if (!id) return null;
      const name50 = (0, _index.isLiteral)(id) ? getNameFromLiteralId(id) : (0, _index.isIdentifier)(id) ? id.name : (0, _index.isPrivateName)(id) ? id.id.name : null;
      if (name50 == null) return null;
      return {
        name: prefix + name50,
        originalNode: id
      };
    }
  }
});

// node_modules/@babel/types/lib/traverse/traverse.js
var require_traverse = __commonJS({
  "node_modules/@babel/types/lib/traverse/traverse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = traverse2;
    var _index = require_definitions();
    function traverse2(node, handlers, state) {
      if (typeof handlers === "function") {
        handlers = {
          enter: handlers
        };
      }
      const {
        enter,
        exit
      } = handlers;
      traverseSimpleImpl(node, enter, exit, state, []);
    }
    function traverseSimpleImpl(node, enter, exit, state, ancestors) {
      const keys = _index.VISITOR_KEYS[node.type];
      if (!keys) return;
      if (enter) enter(node, ancestors, state);
      for (const key of keys) {
        const subNode = node[key];
        if (Array.isArray(subNode)) {
          for (let i = 0; i < subNode.length; i++) {
            const child = subNode[i];
            if (!child) continue;
            ancestors.push({
              node,
              key,
              index: i
            });
            traverseSimpleImpl(child, enter, exit, state, ancestors);
            ancestors.pop();
          }
        } else if (subNode) {
          ancestors.push({
            node,
            key
          });
          traverseSimpleImpl(subNode, enter, exit, state, ancestors);
          ancestors.pop();
        }
      }
      if (exit) exit(node, ancestors, state);
    }
  }
});

// node_modules/@babel/types/lib/validators/isBinding.js
var require_isBinding = __commonJS({
  "node_modules/@babel/types/lib/validators/isBinding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBinding;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    function isBinding(node, parent, grandparent) {
      if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
        return false;
      }
      const keys = _getBindingIdentifiers.default.keys[parent.type];
      if (keys) {
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const val = parent[key];
          if (Array.isArray(val)) {
            if (val.includes(node)) return true;
          } else {
            if (val === node) return true;
          }
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/types/lib/validators/isLet.js
var require_isLet = __commonJS({
  "node_modules/@babel/types/lib/validators/isLet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isLet;
    var _index = require_generated();
    var BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
    function isLet(node) {
      return (0, _index.isVariableDeclaration)(node) && (node.kind !== "var" || node[BLOCK_SCOPED_SYMBOL]);
    }
  }
});

// node_modules/@babel/types/lib/validators/isBlockScoped.js
var require_isBlockScoped = __commonJS({
  "node_modules/@babel/types/lib/validators/isBlockScoped.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBlockScoped;
    var _index = require_generated();
    var _isLet = require_isLet();
    function isBlockScoped(node) {
      return (0, _index.isFunctionDeclaration)(node) || (0, _index.isClassDeclaration)(node) || (0, _isLet.default)(node);
    }
  }
});

// node_modules/@babel/types/lib/validators/isImmutable.js
var require_isImmutable = __commonJS({
  "node_modules/@babel/types/lib/validators/isImmutable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isImmutable;
    var _isType = require_isType();
    var _index = require_generated();
    function isImmutable(node) {
      if ((0, _isType.default)(node.type, "Immutable")) return true;
      if ((0, _index.isIdentifier)(node)) {
        if (node.name === "undefined") {
          return true;
        } else {
          return false;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var require_isNodesEquivalent = __commonJS({
  "node_modules/@babel/types/lib/validators/isNodesEquivalent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isNodesEquivalent;
    var _index = require_definitions();
    function isNodesEquivalent(a, b) {
      if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
        return a === b;
      }
      if (a.type !== b.type) {
        return false;
      }
      const fields = Object.keys(_index.NODE_FIELDS[a.type] || a.type);
      const visitorKeys = _index.VISITOR_KEYS[a.type];
      for (const field of fields) {
        const val_a = a[field];
        const val_b = b[field];
        if (typeof val_a !== typeof val_b) {
          return false;
        }
        if (val_a == null && val_b == null) {
          continue;
        } else if (val_a == null || val_b == null) {
          return false;
        }
        if (Array.isArray(val_a)) {
          if (!Array.isArray(val_b)) {
            return false;
          }
          if (val_a.length !== val_b.length) {
            return false;
          }
          for (let i = 0; i < val_a.length; i++) {
            if (!isNodesEquivalent(val_a[i], val_b[i])) {
              return false;
            }
          }
          continue;
        }
        if (typeof val_a === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
          for (const key of Object.keys(val_a)) {
            if (val_a[key] !== val_b[key]) {
              return false;
            }
          }
          continue;
        }
        if (!isNodesEquivalent(val_a, val_b)) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/@babel/types/lib/validators/isReferenced.js
var require_isReferenced = __commonJS({
  "node_modules/@babel/types/lib/validators/isReferenced.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isReferenced;
    function isReferenced(node, parent, grandparent) {
      switch (parent.type) {
        case "MemberExpression":
        case "OptionalMemberExpression":
          if (parent.property === node) {
            return !!parent.computed;
          }
          return parent.object === node;
        case "JSXMemberExpression":
          return parent.object === node;
        case "VariableDeclarator":
          return parent.init === node;
        case "ArrowFunctionExpression":
          return parent.body === node;
        case "PrivateName":
          return false;
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ObjectMethod":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return false;
        case "ObjectProperty":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return (grandparent == null ? void 0 : grandparent.type) !== "ObjectPattern";
        case "ClassProperty":
        case "ClassAccessorProperty":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return true;
        case "ClassPrivateProperty":
          return parent.key !== node;
        case "ClassDeclaration":
        case "ClassExpression":
          return parent.superClass === node;
        case "AssignmentExpression":
          return parent.right === node;
        case "AssignmentPattern":
          return parent.right === node;
        case "LabeledStatement":
          return false;
        case "CatchClause":
          return false;
        case "RestElement":
          return false;
        case "BreakStatement":
        case "ContinueStatement":
          return false;
        case "FunctionDeclaration":
        case "FunctionExpression":
          return false;
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          return false;
        case "ExportSpecifier":
          if (grandparent != null && grandparent.source) {
            return false;
          }
          return parent.local === node;
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
          return false;
        case "ImportAttribute":
          return false;
        case "JSXAttribute":
          return false;
        case "ObjectPattern":
        case "ArrayPattern":
          return false;
        case "MetaProperty":
          return false;
        case "ObjectTypeProperty":
          return parent.key !== node;
        case "TSEnumMember":
          return parent.id !== node;
        case "TSPropertySignature":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return true;
      }
      return true;
    }
  }
});

// node_modules/@babel/types/lib/validators/isScope.js
var require_isScope = __commonJS({
  "node_modules/@babel/types/lib/validators/isScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isScope;
    var _index = require_generated();
    function isScope(node, parent) {
      if ((0, _index.isBlockStatement)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
        return false;
      }
      if ((0, _index.isPattern)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
        return true;
      }
      return (0, _index.isScopable)(node);
    }
  }
});

// node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var require_isSpecifierDefault = __commonJS({
  "node_modules/@babel/types/lib/validators/isSpecifierDefault.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isSpecifierDefault;
    var _index = require_generated();
    function isSpecifierDefault(specifier) {
      return (0, _index.isImportDefaultSpecifier)(specifier) || (0, _index.isIdentifier)(specifier.imported || specifier.exported, {
        name: "default"
      });
    }
  }
});

// node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var require_isValidES3Identifier = __commonJS({
  "node_modules/@babel/types/lib/validators/isValidES3Identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isValidES3Identifier;
    var _isValidIdentifier = require_isValidIdentifier();
    var RESERVED_WORDS_ES3_ONLY = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
    function isValidES3Identifier(name50) {
      return (0, _isValidIdentifier.default)(name50) && !RESERVED_WORDS_ES3_ONLY.has(name50);
    }
  }
});

// node_modules/@babel/types/lib/validators/isVar.js
var require_isVar = __commonJS({
  "node_modules/@babel/types/lib/validators/isVar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isVar;
    var _index = require_generated();
    var BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
    function isVar(node) {
      return (0, _index.isVariableDeclaration)(node, {
        kind: "var"
      }) && !node[BLOCK_SCOPED_SYMBOL];
    }
  }
});

// node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var require_gatherSequenceExpressions = __commonJS({
  "node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = gatherSequenceExpressions;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _index = require_generated();
    var _index2 = require_generated2();
    var _productions = require_productions();
    var _cloneNode = require_cloneNode();
    function gatherSequenceExpressions(nodes, declars) {
      const exprs = [];
      let ensureLastUndefined = true;
      for (const node of nodes) {
        if (!(0, _index.isEmptyStatement)(node)) {
          ensureLastUndefined = false;
        }
        if ((0, _index.isExpression)(node)) {
          exprs.push(node);
        } else if ((0, _index.isExpressionStatement)(node)) {
          exprs.push(node.expression);
        } else if ((0, _index.isVariableDeclaration)(node)) {
          if (node.kind !== "var") return;
          for (const declar of node.declarations) {
            const bindings = (0, _getBindingIdentifiers.default)(declar);
            for (const key of Object.keys(bindings)) {
              declars.push({
                kind: node.kind,
                id: (0, _cloneNode.default)(bindings[key])
              });
            }
            if (declar.init) {
              exprs.push((0, _index2.assignmentExpression)("=", declar.id, declar.init));
            }
          }
          ensureLastUndefined = true;
        } else if ((0, _index.isIfStatement)(node)) {
          const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], declars) : (0, _productions.buildUndefinedNode)();
          const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], declars) : (0, _productions.buildUndefinedNode)();
          if (!consequent || !alternate) return;
          exprs.push((0, _index2.conditionalExpression)(node.test, consequent, alternate));
        } else if ((0, _index.isBlockStatement)(node)) {
          const body = gatherSequenceExpressions(node.body, declars);
          if (!body) return;
          exprs.push(body);
        } else if ((0, _index.isEmptyStatement)(node)) {
          if (nodes.indexOf(node) === 0) {
            ensureLastUndefined = true;
          }
        } else {
          return;
        }
      }
      if (ensureLastUndefined) {
        exprs.push((0, _productions.buildUndefinedNode)());
      }
      if (exprs.length === 1) {
        return exprs[0];
      } else {
        return (0, _index2.sequenceExpression)(exprs);
      }
    }
  }
});

// node_modules/@babel/types/lib/converters/toSequenceExpression.js
var require_toSequenceExpression = __commonJS({
  "node_modules/@babel/types/lib/converters/toSequenceExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toSequenceExpression;
    var _gatherSequenceExpressions = require_gatherSequenceExpressions();
    function toSequenceExpression(nodes, scope) {
      if (!(nodes != null && nodes.length)) return;
      const declars = [];
      const result = (0, _gatherSequenceExpressions.default)(nodes, declars);
      if (!result) return;
      for (const declar of declars) {
        scope.push(declar);
      }
      return result;
    }
  }
});

// node_modules/@babel/types/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@babel/types/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      react: true,
      assertNode: true,
      createTypeAnnotationBasedOnTypeof: true,
      createUnionTypeAnnotation: true,
      createFlowUnionType: true,
      createTSUnionType: true,
      cloneNode: true,
      clone: true,
      cloneDeep: true,
      cloneDeepWithoutLoc: true,
      cloneWithoutLoc: true,
      addComment: true,
      addComments: true,
      inheritInnerComments: true,
      inheritLeadingComments: true,
      inheritsComments: true,
      inheritTrailingComments: true,
      removeComments: true,
      ensureBlock: true,
      toBindingIdentifierName: true,
      toBlock: true,
      toComputedKey: true,
      toExpression: true,
      toIdentifier: true,
      toKeyAlias: true,
      toStatement: true,
      valueToNode: true,
      appendToMemberExpression: true,
      inherits: true,
      prependToMemberExpression: true,
      removeProperties: true,
      removePropertiesDeep: true,
      removeTypeDuplicates: true,
      getAssignmentIdentifiers: true,
      getBindingIdentifiers: true,
      getOuterBindingIdentifiers: true,
      getFunctionName: true,
      traverse: true,
      traverseFast: true,
      shallowEqual: true,
      is: true,
      isBinding: true,
      isBlockScoped: true,
      isImmutable: true,
      isLet: true,
      isNode: true,
      isNodesEquivalent: true,
      isPlaceholderType: true,
      isReferenced: true,
      isScope: true,
      isSpecifierDefault: true,
      isType: true,
      isValidES3Identifier: true,
      isValidIdentifier: true,
      isVar: true,
      matchesPattern: true,
      validate: true,
      buildMatchMemberExpression: true,
      __internal__deprecationWarning: true
    };
    Object.defineProperty(exports, "__internal__deprecationWarning", {
      enumerable: true,
      get: function() {
        return _deprecationWarning.default;
      }
    });
    Object.defineProperty(exports, "addComment", {
      enumerable: true,
      get: function() {
        return _addComment.default;
      }
    });
    Object.defineProperty(exports, "addComments", {
      enumerable: true,
      get: function() {
        return _addComments.default;
      }
    });
    Object.defineProperty(exports, "appendToMemberExpression", {
      enumerable: true,
      get: function() {
        return _appendToMemberExpression.default;
      }
    });
    Object.defineProperty(exports, "assertNode", {
      enumerable: true,
      get: function() {
        return _assertNode.default;
      }
    });
    Object.defineProperty(exports, "buildMatchMemberExpression", {
      enumerable: true,
      get: function() {
        return _buildMatchMemberExpression.default;
      }
    });
    Object.defineProperty(exports, "clone", {
      enumerable: true,
      get: function() {
        return _clone.default;
      }
    });
    Object.defineProperty(exports, "cloneDeep", {
      enumerable: true,
      get: function() {
        return _cloneDeep.default;
      }
    });
    Object.defineProperty(exports, "cloneDeepWithoutLoc", {
      enumerable: true,
      get: function() {
        return _cloneDeepWithoutLoc.default;
      }
    });
    Object.defineProperty(exports, "cloneNode", {
      enumerable: true,
      get: function() {
        return _cloneNode.default;
      }
    });
    Object.defineProperty(exports, "cloneWithoutLoc", {
      enumerable: true,
      get: function() {
        return _cloneWithoutLoc.default;
      }
    });
    Object.defineProperty(exports, "createFlowUnionType", {
      enumerable: true,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports, "createTSUnionType", {
      enumerable: true,
      get: function() {
        return _createTSUnionType.default;
      }
    });
    Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
      enumerable: true,
      get: function() {
        return _createTypeAnnotationBasedOnTypeof.default;
      }
    });
    Object.defineProperty(exports, "createUnionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports, "ensureBlock", {
      enumerable: true,
      get: function() {
        return _ensureBlock.default;
      }
    });
    Object.defineProperty(exports, "getAssignmentIdentifiers", {
      enumerable: true,
      get: function() {
        return _getAssignmentIdentifiers.default;
      }
    });
    Object.defineProperty(exports, "getBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return _getBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports, "getFunctionName", {
      enumerable: true,
      get: function() {
        return _getFunctionName.default;
      }
    });
    Object.defineProperty(exports, "getOuterBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return _getOuterBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports, "inheritInnerComments", {
      enumerable: true,
      get: function() {
        return _inheritInnerComments.default;
      }
    });
    Object.defineProperty(exports, "inheritLeadingComments", {
      enumerable: true,
      get: function() {
        return _inheritLeadingComments.default;
      }
    });
    Object.defineProperty(exports, "inheritTrailingComments", {
      enumerable: true,
      get: function() {
        return _inheritTrailingComments.default;
      }
    });
    Object.defineProperty(exports, "inherits", {
      enumerable: true,
      get: function() {
        return _inherits.default;
      }
    });
    Object.defineProperty(exports, "inheritsComments", {
      enumerable: true,
      get: function() {
        return _inheritsComments.default;
      }
    });
    Object.defineProperty(exports, "is", {
      enumerable: true,
      get: function() {
        return _is.default;
      }
    });
    Object.defineProperty(exports, "isBinding", {
      enumerable: true,
      get: function() {
        return _isBinding.default;
      }
    });
    Object.defineProperty(exports, "isBlockScoped", {
      enumerable: true,
      get: function() {
        return _isBlockScoped.default;
      }
    });
    Object.defineProperty(exports, "isImmutable", {
      enumerable: true,
      get: function() {
        return _isImmutable.default;
      }
    });
    Object.defineProperty(exports, "isLet", {
      enumerable: true,
      get: function() {
        return _isLet.default;
      }
    });
    Object.defineProperty(exports, "isNode", {
      enumerable: true,
      get: function() {
        return _isNode.default;
      }
    });
    Object.defineProperty(exports, "isNodesEquivalent", {
      enumerable: true,
      get: function() {
        return _isNodesEquivalent.default;
      }
    });
    Object.defineProperty(exports, "isPlaceholderType", {
      enumerable: true,
      get: function() {
        return _isPlaceholderType.default;
      }
    });
    Object.defineProperty(exports, "isReferenced", {
      enumerable: true,
      get: function() {
        return _isReferenced.default;
      }
    });
    Object.defineProperty(exports, "isScope", {
      enumerable: true,
      get: function() {
        return _isScope.default;
      }
    });
    Object.defineProperty(exports, "isSpecifierDefault", {
      enumerable: true,
      get: function() {
        return _isSpecifierDefault.default;
      }
    });
    Object.defineProperty(exports, "isType", {
      enumerable: true,
      get: function() {
        return _isType.default;
      }
    });
    Object.defineProperty(exports, "isValidES3Identifier", {
      enumerable: true,
      get: function() {
        return _isValidES3Identifier.default;
      }
    });
    Object.defineProperty(exports, "isValidIdentifier", {
      enumerable: true,
      get: function() {
        return _isValidIdentifier.default;
      }
    });
    Object.defineProperty(exports, "isVar", {
      enumerable: true,
      get: function() {
        return _isVar.default;
      }
    });
    Object.defineProperty(exports, "matchesPattern", {
      enumerable: true,
      get: function() {
        return _matchesPattern.default;
      }
    });
    Object.defineProperty(exports, "prependToMemberExpression", {
      enumerable: true,
      get: function() {
        return _prependToMemberExpression.default;
      }
    });
    exports.react = void 0;
    Object.defineProperty(exports, "removeComments", {
      enumerable: true,
      get: function() {
        return _removeComments.default;
      }
    });
    Object.defineProperty(exports, "removeProperties", {
      enumerable: true,
      get: function() {
        return _removeProperties.default;
      }
    });
    Object.defineProperty(exports, "removePropertiesDeep", {
      enumerable: true,
      get: function() {
        return _removePropertiesDeep.default;
      }
    });
    Object.defineProperty(exports, "removeTypeDuplicates", {
      enumerable: true,
      get: function() {
        return _removeTypeDuplicates.default;
      }
    });
    Object.defineProperty(exports, "shallowEqual", {
      enumerable: true,
      get: function() {
        return _shallowEqual.default;
      }
    });
    Object.defineProperty(exports, "toBindingIdentifierName", {
      enumerable: true,
      get: function() {
        return _toBindingIdentifierName.default;
      }
    });
    Object.defineProperty(exports, "toBlock", {
      enumerable: true,
      get: function() {
        return _toBlock.default;
      }
    });
    Object.defineProperty(exports, "toComputedKey", {
      enumerable: true,
      get: function() {
        return _toComputedKey.default;
      }
    });
    Object.defineProperty(exports, "toExpression", {
      enumerable: true,
      get: function() {
        return _toExpression.default;
      }
    });
    Object.defineProperty(exports, "toIdentifier", {
      enumerable: true,
      get: function() {
        return _toIdentifier.default;
      }
    });
    Object.defineProperty(exports, "toKeyAlias", {
      enumerable: true,
      get: function() {
        return _toKeyAlias.default;
      }
    });
    Object.defineProperty(exports, "toStatement", {
      enumerable: true,
      get: function() {
        return _toStatement.default;
      }
    });
    Object.defineProperty(exports, "traverse", {
      enumerable: true,
      get: function() {
        return _traverse2.default;
      }
    });
    Object.defineProperty(exports, "traverseFast", {
      enumerable: true,
      get: function() {
        return _traverseFast.default;
      }
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports, "valueToNode", {
      enumerable: true,
      get: function() {
        return _valueToNode.default;
      }
    });
    var _isReactComponent = require_isReactComponent();
    var _isCompatTag = require_isCompatTag();
    var _buildChildren = require_buildChildren();
    var _assertNode = require_assertNode();
    var _index = require_generated3();
    Object.keys(_index).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _index[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _index[key];
        }
      });
    });
    var _createTypeAnnotationBasedOnTypeof = require_createTypeAnnotationBasedOnTypeof();
    var _createFlowUnionType = require_createFlowUnionType();
    var _createTSUnionType = require_createTSUnionType();
    var _productions = require_productions();
    Object.keys(_productions).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _productions[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _productions[key];
        }
      });
    });
    var _index2 = require_generated2();
    Object.keys(_index2).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _index2[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _index2[key];
        }
      });
    });
    var _cloneNode = require_cloneNode();
    var _clone = require_clone();
    var _cloneDeep = require_cloneDeep();
    var _cloneDeepWithoutLoc = require_cloneDeepWithoutLoc();
    var _cloneWithoutLoc = require_cloneWithoutLoc();
    var _addComment = require_addComment();
    var _addComments = require_addComments();
    var _inheritInnerComments = require_inheritInnerComments();
    var _inheritLeadingComments = require_inheritLeadingComments();
    var _inheritsComments = require_inheritsComments();
    var _inheritTrailingComments = require_inheritTrailingComments();
    var _removeComments = require_removeComments();
    var _index3 = require_generated4();
    Object.keys(_index3).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _index3[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _index3[key];
        }
      });
    });
    var _index4 = require_constants();
    Object.keys(_index4).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _index4[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _index4[key];
        }
      });
    });
    var _ensureBlock = require_ensureBlock();
    var _toBindingIdentifierName = require_toBindingIdentifierName();
    var _toBlock = require_toBlock();
    var _toComputedKey = require_toComputedKey();
    var _toExpression = require_toExpression();
    var _toIdentifier = require_toIdentifier();
    var _toKeyAlias = require_toKeyAlias();
    var _toStatement = require_toStatement();
    var _valueToNode = require_valueToNode();
    var _index5 = require_definitions();
    Object.keys(_index5).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _index5[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _index5[key];
        }
      });
    });
    var _appendToMemberExpression = require_appendToMemberExpression();
    var _inherits = require_inherits();
    var _prependToMemberExpression = require_prependToMemberExpression();
    var _removeProperties = require_removeProperties();
    var _removePropertiesDeep = require_removePropertiesDeep();
    var _removeTypeDuplicates = require_removeTypeDuplicates();
    var _getAssignmentIdentifiers = require_getAssignmentIdentifiers();
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _getOuterBindingIdentifiers = require_getOuterBindingIdentifiers();
    var _getFunctionName = require_getFunctionName();
    var _traverse2 = require_traverse();
    Object.keys(_traverse2).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _traverse2[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _traverse2[key];
        }
      });
    });
    var _traverseFast = require_traverseFast();
    var _shallowEqual = require_shallowEqual();
    var _is = require_is();
    var _isBinding = require_isBinding();
    var _isBlockScoped = require_isBlockScoped();
    var _isImmutable = require_isImmutable();
    var _isLet = require_isLet();
    var _isNode = require_isNode();
    var _isNodesEquivalent = require_isNodesEquivalent();
    var _isPlaceholderType = require_isPlaceholderType();
    var _isReferenced = require_isReferenced();
    var _isScope = require_isScope();
    var _isSpecifierDefault = require_isSpecifierDefault();
    var _isType = require_isType();
    var _isValidES3Identifier = require_isValidES3Identifier();
    var _isValidIdentifier = require_isValidIdentifier();
    var _isVar = require_isVar();
    var _matchesPattern = require_matchesPattern();
    var _validate = require_validate();
    var _buildMatchMemberExpression = require_buildMatchMemberExpression();
    var _index6 = require_generated();
    Object.keys(_index6).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _index6[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _index6[key];
        }
      });
    });
    var _deprecationWarning = require_deprecationWarning();
    var _toSequenceExpression = require_toSequenceExpression();
    var react = exports.react = {
      isReactComponent: _isReactComponent.default,
      isCompatTag: _isCompatTag.default,
      buildChildren: _buildChildren.default
    };
    exports.toSequenceExpression = _toSequenceExpression.default;
    if (process.env.BABEL_TYPES_8_BREAKING) {
      console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!");
    }
  }
});

// node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
var require_virtual_types_validator = __commonJS({
  "node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isBindingIdentifier = isBindingIdentifier;
    exports.isBlockScoped = isBlockScoped;
    exports.isExpression = isExpression;
    exports.isFlow = isFlow;
    exports.isForAwaitStatement = isForAwaitStatement;
    exports.isGenerated = isGenerated;
    exports.isPure = isPure;
    exports.isReferenced = isReferenced;
    exports.isReferencedIdentifier = isReferencedIdentifier;
    exports.isReferencedMemberExpression = isReferencedMemberExpression;
    exports.isRestProperty = isRestProperty;
    exports.isScope = isScope;
    exports.isSpreadProperty = isSpreadProperty;
    exports.isStatement = isStatement;
    exports.isUser = isUser;
    exports.isVar = isVar;
    var _t = require_lib4();
    var {
      isBinding,
      isBlockScoped: nodeIsBlockScoped,
      isExportDeclaration,
      isExpression: nodeIsExpression,
      isFlow: nodeIsFlow,
      isForStatement,
      isForXStatement,
      isIdentifier,
      isImportDeclaration,
      isImportSpecifier,
      isJSXIdentifier,
      isJSXMemberExpression,
      isMemberExpression,
      isRestElement: nodeIsRestElement,
      isReferenced: nodeIsReferenced,
      isScope: nodeIsScope,
      isStatement: nodeIsStatement,
      isVar: nodeIsVar,
      isVariableDeclaration,
      react,
      isForOfStatement
    } = _t;
    var {
      isCompatTag
    } = react;
    function isReferencedIdentifier(opts) {
      const {
        node,
        parent
      } = this;
      if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {
        if (isJSXIdentifier(node, opts)) {
          if (isCompatTag(node.name)) return false;
        } else {
          return false;
        }
      }
      return nodeIsReferenced(node, parent, this.parentPath.parent);
    }
    function isReferencedMemberExpression() {
      const {
        node,
        parent
      } = this;
      return isMemberExpression(node) && nodeIsReferenced(node, parent);
    }
    function isBindingIdentifier() {
      const {
        node,
        parent
      } = this;
      const grandparent = this.parentPath.parent;
      return isIdentifier(node) && isBinding(node, parent, grandparent);
    }
    function isStatement() {
      const {
        node,
        parent
      } = this;
      if (nodeIsStatement(node)) {
        if (isVariableDeclaration(node)) {
          if (isForXStatement(parent, {
            left: node
          })) return false;
          if (isForStatement(parent, {
            init: node
          })) return false;
        }
        return true;
      } else {
        return false;
      }
    }
    function isExpression() {
      if (this.isIdentifier()) {
        return this.isReferencedIdentifier();
      } else {
        return nodeIsExpression(this.node);
      }
    }
    function isScope() {
      return nodeIsScope(this.node, this.parent);
    }
    function isReferenced() {
      return nodeIsReferenced(this.node, this.parent);
    }
    function isBlockScoped() {
      return nodeIsBlockScoped(this.node);
    }
    function isVar() {
      return nodeIsVar(this.node);
    }
    function isUser() {
      return this.node && !!this.node.loc;
    }
    function isGenerated() {
      return !this.isUser();
    }
    function isPure(constantsOnly) {
      return this.scope.isPure(this.node, constantsOnly);
    }
    function isFlow() {
      const {
        node
      } = this;
      if (nodeIsFlow(node)) {
        return true;
      } else if (isImportDeclaration(node)) {
        return node.importKind === "type" || node.importKind === "typeof";
      } else if (isExportDeclaration(node)) {
        return node.exportKind === "type";
      } else if (isImportSpecifier(node)) {
        return node.importKind === "type" || node.importKind === "typeof";
      } else {
        return false;
      }
    }
    function isRestProperty() {
      var _this$parentPath;
      return nodeIsRestElement(this.node) && ((_this$parentPath = this.parentPath) == null ? void 0 : _this$parentPath.isObjectPattern());
    }
    function isSpreadProperty() {
      var _this$parentPath2;
      return nodeIsRestElement(this.node) && ((_this$parentPath2 = this.parentPath) == null ? void 0 : _this$parentPath2.isObjectExpression());
    }
    function isForAwaitStatement() {
      return isForOfStatement(this.node, {
        await: true
      });
    }
    {
      exports.isExistentialTypeParam = function isExistentialTypeParam() {
        throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
      };
      exports.isNumericLiteralTypeAnnotation = function isNumericLiteralTypeAnnotation() {
        throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
      };
    }
  }
});

// node_modules/@babel/traverse/lib/visitors.js
var require_visitors = __commonJS({
  "node_modules/@babel/traverse/lib/visitors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.environmentVisitor = environmentVisitor;
    exports.explode = explode$1;
    exports.isExplodedVisitor = isExplodedVisitor;
    exports.merge = merge;
    exports.verify = verify$1;
    var virtualTypes = require_virtual_types();
    var virtualTypesValidators = require_virtual_types_validator();
    var _t = require_lib4();
    var _context = require_context2();
    var {
      DEPRECATED_KEYS,
      DEPRECATED_ALIASES,
      FLIPPED_ALIAS_KEYS,
      TYPES,
      __internal__deprecationWarning: deprecationWarning
    } = _t;
    function isVirtualType(type) {
      return type in virtualTypes;
    }
    function isExplodedVisitor(visitor) {
      return visitor == null ? void 0 : visitor._exploded;
    }
    function explode$1(visitor) {
      if (isExplodedVisitor(visitor)) return visitor;
      visitor._exploded = true;
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        const parts = nodeType.split("|");
        if (parts.length === 1) continue;
        const fns2 = visitor[nodeType];
        delete visitor[nodeType];
        for (const part of parts) {
          visitor[part] = fns2;
        }
      }
      verify$1(visitor);
      delete visitor.__esModule;
      ensureEntranceObjects(visitor);
      ensureCallbackArrays(visitor);
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        if (!isVirtualType(nodeType)) continue;
        const fns2 = visitor[nodeType];
        for (const type of Object.keys(fns2)) {
          fns2[type] = wrapCheck(nodeType, fns2[type]);
        }
        delete visitor[nodeType];
        const types = virtualTypes[nodeType];
        if (types !== null) {
          for (const type of types) {
            if (visitor[type]) {
              mergePair(visitor[type], fns2);
            } else {
              visitor[type] = fns2;
            }
          }
        } else {
          mergePair(visitor, fns2);
        }
      }
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        let aliases = FLIPPED_ALIAS_KEYS[nodeType];
        if (nodeType in DEPRECATED_KEYS) {
          const deprecatedKey = DEPRECATED_KEYS[nodeType];
          deprecationWarning(nodeType, deprecatedKey, "Visitor ");
          aliases = [deprecatedKey];
        } else if (nodeType in DEPRECATED_ALIASES) {
          const deprecatedAlias = DEPRECATED_ALIASES[nodeType];
          deprecationWarning(nodeType, deprecatedAlias, "Visitor ");
          aliases = FLIPPED_ALIAS_KEYS[deprecatedAlias];
        }
        if (!aliases) continue;
        const fns2 = visitor[nodeType];
        delete visitor[nodeType];
        for (const alias of aliases) {
          const existing = visitor[alias];
          if (existing) {
            mergePair(existing, fns2);
          } else {
            visitor[alias] = Object.assign({}, fns2);
          }
        }
      }
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        ensureCallbackArrays(visitor[nodeType]);
      }
      return visitor;
    }
    function verify$1(visitor) {
      if (visitor._verified) return;
      if (typeof visitor === "function") {
        throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
      }
      for (const nodeType of Object.keys(visitor)) {
        if (nodeType === "enter" || nodeType === "exit") {
          validateVisitorMethods(nodeType, visitor[nodeType]);
        }
        if (shouldIgnoreKey(nodeType)) continue;
        if (!TYPES.includes(nodeType)) {
          throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type in @babel/traverse ${"7.27.7"}`);
        }
        const visitors = visitor[nodeType];
        if (typeof visitors === "object") {
          for (const visitorKey of Object.keys(visitors)) {
            if (visitorKey === "enter" || visitorKey === "exit") {
              validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);
            } else {
              throw new Error(`You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`);
            }
          }
        }
      }
      visitor._verified = true;
    }
    function validateVisitorMethods(path, val) {
      const fns2 = [].concat(val);
      for (const fn of fns2) {
        if (typeof fn !== "function") {
          throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);
        }
      }
    }
    function merge(visitors, states = [], wrapper) {
      const mergedVisitor = {
        _verified: true,
        _exploded: true
      };
      {
        Object.defineProperty(mergedVisitor, "_exploded", {
          enumerable: false
        });
        Object.defineProperty(mergedVisitor, "_verified", {
          enumerable: false
        });
      }
      for (let i = 0; i < visitors.length; i++) {
        const visitor = explode$1(visitors[i]);
        const state = states[i];
        let topVisitor = visitor;
        if (state || wrapper) {
          topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);
        }
        mergePair(mergedVisitor, topVisitor);
        for (const key of Object.keys(visitor)) {
          if (shouldIgnoreKey(key)) continue;
          let typeVisitor = visitor[key];
          if (state || wrapper) {
            typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);
          }
          const nodeVisitor = mergedVisitor[key] || (mergedVisitor[key] = {});
          mergePair(nodeVisitor, typeVisitor);
        }
      }
      return mergedVisitor;
    }
    function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
      const newVisitor = {};
      for (const phase of ["enter", "exit"]) {
        let fns2 = oldVisitor[phase];
        if (!Array.isArray(fns2)) continue;
        fns2 = fns2.map(function(fn) {
          let newFn = fn;
          if (state) {
            newFn = function(path) {
              fn.call(state, path, state);
            };
          }
          if (wrapper) {
            newFn = wrapper(state == null ? void 0 : state.key, phase, newFn);
          }
          if (newFn !== fn) {
            newFn.toString = () => fn.toString();
          }
          return newFn;
        });
        newVisitor[phase] = fns2;
      }
      return newVisitor;
    }
    function ensureEntranceObjects(obj) {
      for (const key of Object.keys(obj)) {
        if (shouldIgnoreKey(key)) continue;
        const fns2 = obj[key];
        if (typeof fns2 === "function") {
          obj[key] = {
            enter: fns2
          };
        }
      }
    }
    function ensureCallbackArrays(obj) {
      if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
      if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
    }
    function wrapCheck(nodeType, fn) {
      const fnKey = `is${nodeType}`;
      const validator = virtualTypesValidators[fnKey];
      const newFn = function(path) {
        if (validator.call(path)) {
          return fn.apply(this, arguments);
        }
      };
      newFn.toString = () => fn.toString();
      return newFn;
    }
    function shouldIgnoreKey(key) {
      if (key[0] === "_") return true;
      if (key === "enter" || key === "exit" || key === "shouldSkip") return true;
      if (key === "denylist" || key === "noScope" || key === "skipKeys") {
        return true;
      }
      {
        if (key === "blacklist") {
          return true;
        }
      }
      return false;
    }
    function mergePair(dest, src) {
      for (const phase of ["enter", "exit"]) {
        if (!src[phase]) continue;
        dest[phase] = [].concat(dest[phase] || [], src[phase]);
      }
    }
    var _environmentVisitor = {
      FunctionParent(path) {
        if (path.isArrowFunctionExpression()) return;
        path.skip();
        if (path.isMethod()) {
          if (!path.requeueComputedKeyAndDecorators) {
            _context.requeueComputedKeyAndDecorators.call(path);
          } else {
            path.requeueComputedKeyAndDecorators();
          }
        }
      },
      Property(path) {
        if (path.isObjectProperty()) return;
        path.skip();
        if (!path.requeueComputedKeyAndDecorators) {
          _context.requeueComputedKeyAndDecorators.call(path);
        } else {
          path.requeueComputedKeyAndDecorators();
        }
      }
    };
    function environmentVisitor(visitor) {
      return merge([_environmentVisitor, visitor]);
    }
  }
});

// node_modules/@babel/traverse/lib/scope/lib/renamer.js
var require_renamer = __commonJS({
  "node_modules/@babel/traverse/lib/scope/lib/renamer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var t = require_lib4();
    var _t = t;
    var _traverseNode = require_traverse_node();
    var _visitors = require_visitors();
    var _context = require_context2();
    var {
      getAssignmentIdentifiers
    } = _t;
    var renameVisitor = {
      ReferencedIdentifier({
        node
      }, state) {
        if (node.name === state.oldName) {
          node.name = state.newName;
        }
      },
      Scope(path, state) {
        if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
          path.skip();
          if (path.isMethod()) {
            if (!path.requeueComputedKeyAndDecorators) {
              _context.requeueComputedKeyAndDecorators.call(path);
            } else {
              path.requeueComputedKeyAndDecorators();
            }
          }
        }
      },
      ObjectProperty({
        node,
        scope
      }, state) {
        const {
          name: name50
        } = node.key;
        if (node.shorthand && (name50 === state.oldName || name50 === state.newName) && scope.getBindingIdentifier(name50) === state.binding.identifier) {
          node.shorthand = false;
          {
            var _node$extra;
            if ((_node$extra = node.extra) != null && _node$extra.shorthand) node.extra.shorthand = false;
          }
        }
      },
      "AssignmentExpression|Declaration|VariableDeclarator"(path, state) {
        if (path.isVariableDeclaration()) return;
        const ids = path.isAssignmentExpression() ? getAssignmentIdentifiers(path.node) : path.getOuterBindingIdentifiers();
        for (const name50 in ids) {
          if (name50 === state.oldName) ids[name50].name = state.newName;
        }
      }
    };
    var Renamer = class {
      constructor(binding, oldName, newName) {
        this.newName = newName;
        this.oldName = oldName;
        this.binding = binding;
      }
      maybeConvertFromExportDeclaration(parentDeclar) {
        const maybeExportDeclar = parentDeclar.parentPath;
        if (!maybeExportDeclar.isExportDeclaration()) {
          return;
        }
        if (maybeExportDeclar.isExportDefaultDeclaration()) {
          const {
            declaration
          } = maybeExportDeclar.node;
          if (t.isDeclaration(declaration) && !declaration.id) {
            return;
          }
        }
        if (maybeExportDeclar.isExportAllDeclaration()) {
          return;
        }
        maybeExportDeclar.splitExportDeclaration();
      }
      maybeConvertFromClassFunctionDeclaration(path) {
        return path;
      }
      maybeConvertFromClassFunctionExpression(path) {
        return path;
      }
      rename() {
        const {
          binding,
          oldName,
          newName
        } = this;
        const {
          scope,
          path
        } = binding;
        const parentDeclar = path.find((path2) => path2.isDeclaration() || path2.isFunctionExpression() || path2.isClassExpression());
        if (parentDeclar) {
          const bindingIds = parentDeclar.getOuterBindingIdentifiers();
          if (bindingIds[oldName] === binding.identifier) {
            this.maybeConvertFromExportDeclaration(parentDeclar);
          }
        }
        const blockToTraverse = arguments[0] || scope.block;
        const skipKeys = {
          discriminant: true
        };
        if (t.isMethod(blockToTraverse)) {
          if (blockToTraverse.computed) {
            skipKeys.key = true;
          }
          if (!t.isObjectMethod(blockToTraverse)) {
            skipKeys.decorators = true;
          }
        }
        (0, _traverseNode.traverseNode)(blockToTraverse, (0, _visitors.explode)(renameVisitor), scope, this, scope.path, skipKeys);
        if (!arguments[0]) {
          scope.removeOwnBinding(oldName);
          scope.bindings[newName] = binding;
          this.binding.identifier.name = newName;
        }
        if (parentDeclar) {
          this.maybeConvertFromClassFunctionDeclaration(path);
          this.maybeConvertFromClassFunctionExpression(path);
        }
      }
    };
    exports.default = Renamer;
  }
});

// node_modules/@babel/traverse/lib/scope/binding.js
var require_binding = __commonJS({
  "node_modules/@babel/traverse/lib/scope/binding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var Binding = class {
      constructor({
        identifier,
        scope,
        path,
        kind
      }) {
        this.identifier = void 0;
        this.scope = void 0;
        this.path = void 0;
        this.kind = void 0;
        this.constantViolations = [];
        this.constant = true;
        this.referencePaths = [];
        this.referenced = false;
        this.references = 0;
        this.identifier = identifier;
        this.scope = scope;
        this.path = path;
        this.kind = kind;
        if ((kind === "var" || kind === "hoisted") && isInitInLoop(path)) {
          this.reassign(path);
        }
        this.clearValue();
      }
      deoptValue() {
        this.clearValue();
        this.hasDeoptedValue = true;
      }
      setValue(value) {
        if (this.hasDeoptedValue) return;
        this.hasValue = true;
        this.value = value;
      }
      clearValue() {
        this.hasDeoptedValue = false;
        this.hasValue = false;
        this.value = null;
      }
      reassign(path) {
        this.constant = false;
        if (this.constantViolations.includes(path)) {
          return;
        }
        this.constantViolations.push(path);
      }
      reference(path) {
        if (this.referencePaths.includes(path)) {
          return;
        }
        this.referenced = true;
        this.references++;
        this.referencePaths.push(path);
      }
      dereference() {
        this.references--;
        this.referenced = !!this.references;
      }
    };
    exports.default = Binding;
    function isInitInLoop(path) {
      const isFunctionDeclarationOrHasInit = !path.isVariableDeclarator() || path.node.init;
      for (let {
        parentPath,
        key
      } = path; parentPath; {
        parentPath,
        key
      } = parentPath) {
        if (parentPath.isFunctionParent()) return false;
        if (key === "left" && parentPath.isForXStatement() || isFunctionDeclarationOrHasInit && key === "body" && parentPath.isLoop()) {
          return true;
        }
      }
      return false;
    }
  }
});

// node_modules/globals/globals.json
var require_globals = __commonJS({
  "node_modules/globals/globals.json"(exports, module) {
    module.exports = {
      builtin: {
        Array: false,
        ArrayBuffer: false,
        Atomics: false,
        BigInt: false,
        BigInt64Array: false,
        BigUint64Array: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        globalThis: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        SharedArrayBuffer: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      es5: {
        Array: false,
        Boolean: false,
        constructor: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        propertyIsEnumerable: false,
        RangeError: false,
        ReferenceError: false,
        RegExp: false,
        String: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false
      },
      es2015: {
        Array: false,
        ArrayBuffer: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      es2017: {
        Array: false,
        ArrayBuffer: false,
        Atomics: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        SharedArrayBuffer: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      browser: {
        AbortController: false,
        AbortSignal: false,
        addEventListener: false,
        alert: false,
        AnalyserNode: false,
        Animation: false,
        AnimationEffectReadOnly: false,
        AnimationEffectTiming: false,
        AnimationEffectTimingReadOnly: false,
        AnimationEvent: false,
        AnimationPlaybackEvent: false,
        AnimationTimeline: false,
        applicationCache: false,
        ApplicationCache: false,
        ApplicationCacheErrorEvent: false,
        atob: false,
        Attr: false,
        Audio: false,
        AudioBuffer: false,
        AudioBufferSourceNode: false,
        AudioContext: false,
        AudioDestinationNode: false,
        AudioListener: false,
        AudioNode: false,
        AudioParam: false,
        AudioProcessingEvent: false,
        AudioScheduledSourceNode: false,
        "AudioWorkletGlobalScope ": false,
        AudioWorkletNode: false,
        AudioWorkletProcessor: false,
        BarProp: false,
        BaseAudioContext: false,
        BatteryManager: false,
        BeforeUnloadEvent: false,
        BiquadFilterNode: false,
        Blob: false,
        BlobEvent: false,
        blur: false,
        BroadcastChannel: false,
        btoa: false,
        BudgetService: false,
        ByteLengthQueuingStrategy: false,
        Cache: false,
        caches: false,
        CacheStorage: false,
        cancelAnimationFrame: false,
        cancelIdleCallback: false,
        CanvasCaptureMediaStreamTrack: false,
        CanvasGradient: false,
        CanvasPattern: false,
        CanvasRenderingContext2D: false,
        ChannelMergerNode: false,
        ChannelSplitterNode: false,
        CharacterData: false,
        clearInterval: false,
        clearTimeout: false,
        clientInformation: false,
        ClipboardEvent: false,
        close: false,
        closed: false,
        CloseEvent: false,
        Comment: false,
        CompositionEvent: false,
        confirm: false,
        console: false,
        ConstantSourceNode: false,
        ConvolverNode: false,
        CountQueuingStrategy: false,
        createImageBitmap: false,
        Credential: false,
        CredentialsContainer: false,
        crypto: false,
        Crypto: false,
        CryptoKey: false,
        CSS: false,
        CSSConditionRule: false,
        CSSFontFaceRule: false,
        CSSGroupingRule: false,
        CSSImportRule: false,
        CSSKeyframeRule: false,
        CSSKeyframesRule: false,
        CSSMediaRule: false,
        CSSNamespaceRule: false,
        CSSPageRule: false,
        CSSRule: false,
        CSSRuleList: false,
        CSSStyleDeclaration: false,
        CSSStyleRule: false,
        CSSStyleSheet: false,
        CSSSupportsRule: false,
        CustomElementRegistry: false,
        customElements: false,
        CustomEvent: false,
        DataTransfer: false,
        DataTransferItem: false,
        DataTransferItemList: false,
        defaultstatus: false,
        defaultStatus: false,
        DelayNode: false,
        DeviceMotionEvent: false,
        DeviceOrientationEvent: false,
        devicePixelRatio: false,
        dispatchEvent: false,
        document: false,
        Document: false,
        DocumentFragment: false,
        DocumentType: false,
        DOMError: false,
        DOMException: false,
        DOMImplementation: false,
        DOMMatrix: false,
        DOMMatrixReadOnly: false,
        DOMParser: false,
        DOMPoint: false,
        DOMPointReadOnly: false,
        DOMQuad: false,
        DOMRect: false,
        DOMRectReadOnly: false,
        DOMStringList: false,
        DOMStringMap: false,
        DOMTokenList: false,
        DragEvent: false,
        DynamicsCompressorNode: false,
        Element: false,
        ErrorEvent: false,
        event: false,
        Event: false,
        EventSource: false,
        EventTarget: false,
        external: false,
        fetch: false,
        File: false,
        FileList: false,
        FileReader: false,
        find: false,
        focus: false,
        FocusEvent: false,
        FontFace: false,
        FontFaceSetLoadEvent: false,
        FormData: false,
        frameElement: false,
        frames: false,
        GainNode: false,
        Gamepad: false,
        GamepadButton: false,
        GamepadEvent: false,
        getComputedStyle: false,
        getSelection: false,
        HashChangeEvent: false,
        Headers: false,
        history: false,
        History: false,
        HTMLAllCollection: false,
        HTMLAnchorElement: false,
        HTMLAreaElement: false,
        HTMLAudioElement: false,
        HTMLBaseElement: false,
        HTMLBodyElement: false,
        HTMLBRElement: false,
        HTMLButtonElement: false,
        HTMLCanvasElement: false,
        HTMLCollection: false,
        HTMLContentElement: false,
        HTMLDataElement: false,
        HTMLDataListElement: false,
        HTMLDetailsElement: false,
        HTMLDialogElement: false,
        HTMLDirectoryElement: false,
        HTMLDivElement: false,
        HTMLDListElement: false,
        HTMLDocument: false,
        HTMLElement: false,
        HTMLEmbedElement: false,
        HTMLFieldSetElement: false,
        HTMLFontElement: false,
        HTMLFormControlsCollection: false,
        HTMLFormElement: false,
        HTMLFrameElement: false,
        HTMLFrameSetElement: false,
        HTMLHeadElement: false,
        HTMLHeadingElement: false,
        HTMLHRElement: false,
        HTMLHtmlElement: false,
        HTMLIFrameElement: false,
        HTMLImageElement: false,
        HTMLInputElement: false,
        HTMLLabelElement: false,
        HTMLLegendElement: false,
        HTMLLIElement: false,
        HTMLLinkElement: false,
        HTMLMapElement: false,
        HTMLMarqueeElement: false,
        HTMLMediaElement: false,
        HTMLMenuElement: false,
        HTMLMetaElement: false,
        HTMLMeterElement: false,
        HTMLModElement: false,
        HTMLObjectElement: false,
        HTMLOListElement: false,
        HTMLOptGroupElement: false,
        HTMLOptionElement: false,
        HTMLOptionsCollection: false,
        HTMLOutputElement: false,
        HTMLParagraphElement: false,
        HTMLParamElement: false,
        HTMLPictureElement: false,
        HTMLPreElement: false,
        HTMLProgressElement: false,
        HTMLQuoteElement: false,
        HTMLScriptElement: false,
        HTMLSelectElement: false,
        HTMLShadowElement: false,
        HTMLSlotElement: false,
        HTMLSourceElement: false,
        HTMLSpanElement: false,
        HTMLStyleElement: false,
        HTMLTableCaptionElement: false,
        HTMLTableCellElement: false,
        HTMLTableColElement: false,
        HTMLTableElement: false,
        HTMLTableRowElement: false,
        HTMLTableSectionElement: false,
        HTMLTemplateElement: false,
        HTMLTextAreaElement: false,
        HTMLTimeElement: false,
        HTMLTitleElement: false,
        HTMLTrackElement: false,
        HTMLUListElement: false,
        HTMLUnknownElement: false,
        HTMLVideoElement: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        IdleDeadline: false,
        IIRFilterNode: false,
        Image: false,
        ImageBitmap: false,
        ImageBitmapRenderingContext: false,
        ImageCapture: false,
        ImageData: false,
        indexedDB: false,
        innerHeight: false,
        innerWidth: false,
        InputEvent: false,
        IntersectionObserver: false,
        IntersectionObserverEntry: false,
        Intl: false,
        isSecureContext: false,
        KeyboardEvent: false,
        KeyframeEffect: false,
        KeyframeEffectReadOnly: false,
        length: false,
        localStorage: false,
        location: true,
        Location: false,
        locationbar: false,
        matchMedia: false,
        MediaDeviceInfo: false,
        MediaDevices: false,
        MediaElementAudioSourceNode: false,
        MediaEncryptedEvent: false,
        MediaError: false,
        MediaKeyMessageEvent: false,
        MediaKeySession: false,
        MediaKeyStatusMap: false,
        MediaKeySystemAccess: false,
        MediaList: false,
        MediaQueryList: false,
        MediaQueryListEvent: false,
        MediaRecorder: false,
        MediaSettingsRange: false,
        MediaSource: false,
        MediaStream: false,
        MediaStreamAudioDestinationNode: false,
        MediaStreamAudioSourceNode: false,
        MediaStreamEvent: false,
        MediaStreamTrack: false,
        MediaStreamTrackEvent: false,
        menubar: false,
        MessageChannel: false,
        MessageEvent: false,
        MessagePort: false,
        MIDIAccess: false,
        MIDIConnectionEvent: false,
        MIDIInput: false,
        MIDIInputMap: false,
        MIDIMessageEvent: false,
        MIDIOutput: false,
        MIDIOutputMap: false,
        MIDIPort: false,
        MimeType: false,
        MimeTypeArray: false,
        MouseEvent: false,
        moveBy: false,
        moveTo: false,
        MutationEvent: false,
        MutationObserver: false,
        MutationRecord: false,
        name: false,
        NamedNodeMap: false,
        NavigationPreloadManager: false,
        navigator: false,
        Navigator: false,
        NetworkInformation: false,
        Node: false,
        NodeFilter: false,
        NodeIterator: false,
        NodeList: false,
        Notification: false,
        OfflineAudioCompletionEvent: false,
        OfflineAudioContext: false,
        offscreenBuffering: false,
        OffscreenCanvas: true,
        onabort: true,
        onafterprint: true,
        onanimationend: true,
        onanimationiteration: true,
        onanimationstart: true,
        onappinstalled: true,
        onauxclick: true,
        onbeforeinstallprompt: true,
        onbeforeprint: true,
        onbeforeunload: true,
        onblur: true,
        oncancel: true,
        oncanplay: true,
        oncanplaythrough: true,
        onchange: true,
        onclick: true,
        onclose: true,
        oncontextmenu: true,
        oncuechange: true,
        ondblclick: true,
        ondevicemotion: true,
        ondeviceorientation: true,
        ondeviceorientationabsolute: true,
        ondrag: true,
        ondragend: true,
        ondragenter: true,
        ondragleave: true,
        ondragover: true,
        ondragstart: true,
        ondrop: true,
        ondurationchange: true,
        onemptied: true,
        onended: true,
        onerror: true,
        onfocus: true,
        ongotpointercapture: true,
        onhashchange: true,
        oninput: true,
        oninvalid: true,
        onkeydown: true,
        onkeypress: true,
        onkeyup: true,
        onlanguagechange: true,
        onload: true,
        onloadeddata: true,
        onloadedmetadata: true,
        onloadstart: true,
        onlostpointercapture: true,
        onmessage: true,
        onmessageerror: true,
        onmousedown: true,
        onmouseenter: true,
        onmouseleave: true,
        onmousemove: true,
        onmouseout: true,
        onmouseover: true,
        onmouseup: true,
        onmousewheel: true,
        onoffline: true,
        ononline: true,
        onpagehide: true,
        onpageshow: true,
        onpause: true,
        onplay: true,
        onplaying: true,
        onpointercancel: true,
        onpointerdown: true,
        onpointerenter: true,
        onpointerleave: true,
        onpointermove: true,
        onpointerout: true,
        onpointerover: true,
        onpointerup: true,
        onpopstate: true,
        onprogress: true,
        onratechange: true,
        onrejectionhandled: true,
        onreset: true,
        onresize: true,
        onscroll: true,
        onsearch: true,
        onseeked: true,
        onseeking: true,
        onselect: true,
        onstalled: true,
        onstorage: true,
        onsubmit: true,
        onsuspend: true,
        ontimeupdate: true,
        ontoggle: true,
        ontransitionend: true,
        onunhandledrejection: true,
        onunload: true,
        onvolumechange: true,
        onwaiting: true,
        onwheel: true,
        open: false,
        openDatabase: false,
        opener: false,
        Option: false,
        origin: false,
        OscillatorNode: false,
        outerHeight: false,
        outerWidth: false,
        PageTransitionEvent: false,
        pageXOffset: false,
        pageYOffset: false,
        PannerNode: false,
        parent: false,
        Path2D: false,
        PaymentAddress: false,
        PaymentRequest: false,
        PaymentRequestUpdateEvent: false,
        PaymentResponse: false,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceLongTaskTiming: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceNavigationTiming: false,
        PerformanceObserver: false,
        PerformanceObserverEntryList: false,
        PerformancePaintTiming: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        PeriodicWave: false,
        Permissions: false,
        PermissionStatus: false,
        personalbar: false,
        PhotoCapabilities: false,
        Plugin: false,
        PluginArray: false,
        PointerEvent: false,
        PopStateEvent: false,
        postMessage: false,
        Presentation: false,
        PresentationAvailability: false,
        PresentationConnection: false,
        PresentationConnectionAvailableEvent: false,
        PresentationConnectionCloseEvent: false,
        PresentationConnectionList: false,
        PresentationReceiver: false,
        PresentationRequest: false,
        print: false,
        ProcessingInstruction: false,
        ProgressEvent: false,
        PromiseRejectionEvent: false,
        prompt: false,
        PushManager: false,
        PushSubscription: false,
        PushSubscriptionOptions: false,
        queueMicrotask: false,
        RadioNodeList: false,
        Range: false,
        ReadableStream: false,
        registerProcessor: false,
        RemotePlayback: false,
        removeEventListener: false,
        Request: false,
        requestAnimationFrame: false,
        requestIdleCallback: false,
        resizeBy: false,
        ResizeObserver: false,
        ResizeObserverEntry: false,
        resizeTo: false,
        Response: false,
        RTCCertificate: false,
        RTCDataChannel: false,
        RTCDataChannelEvent: false,
        RTCDtlsTransport: false,
        RTCIceCandidate: false,
        RTCIceGatherer: false,
        RTCIceTransport: false,
        RTCPeerConnection: false,
        RTCPeerConnectionIceEvent: false,
        RTCRtpContributingSource: false,
        RTCRtpReceiver: false,
        RTCRtpSender: false,
        RTCSctpTransport: false,
        RTCSessionDescription: false,
        RTCStatsReport: false,
        RTCTrackEvent: false,
        screen: false,
        Screen: false,
        screenLeft: false,
        ScreenOrientation: false,
        screenTop: false,
        screenX: false,
        screenY: false,
        ScriptProcessorNode: false,
        scroll: false,
        scrollbars: false,
        scrollBy: false,
        scrollTo: false,
        scrollX: false,
        scrollY: false,
        SecurityPolicyViolationEvent: false,
        Selection: false,
        self: false,
        ServiceWorker: false,
        ServiceWorkerContainer: false,
        ServiceWorkerRegistration: false,
        sessionStorage: false,
        setInterval: false,
        setTimeout: false,
        ShadowRoot: false,
        SharedWorker: false,
        SourceBuffer: false,
        SourceBufferList: false,
        speechSynthesis: false,
        SpeechSynthesisEvent: false,
        SpeechSynthesisUtterance: false,
        StaticRange: false,
        status: false,
        statusbar: false,
        StereoPannerNode: false,
        stop: false,
        Storage: false,
        StorageEvent: false,
        StorageManager: false,
        styleMedia: false,
        StyleSheet: false,
        StyleSheetList: false,
        SubtleCrypto: false,
        SVGAElement: false,
        SVGAngle: false,
        SVGAnimatedAngle: false,
        SVGAnimatedBoolean: false,
        SVGAnimatedEnumeration: false,
        SVGAnimatedInteger: false,
        SVGAnimatedLength: false,
        SVGAnimatedLengthList: false,
        SVGAnimatedNumber: false,
        SVGAnimatedNumberList: false,
        SVGAnimatedPreserveAspectRatio: false,
        SVGAnimatedRect: false,
        SVGAnimatedString: false,
        SVGAnimatedTransformList: false,
        SVGAnimateElement: false,
        SVGAnimateMotionElement: false,
        SVGAnimateTransformElement: false,
        SVGAnimationElement: false,
        SVGCircleElement: false,
        SVGClipPathElement: false,
        SVGComponentTransferFunctionElement: false,
        SVGDefsElement: false,
        SVGDescElement: false,
        SVGDiscardElement: false,
        SVGElement: false,
        SVGEllipseElement: false,
        SVGFEBlendElement: false,
        SVGFEColorMatrixElement: false,
        SVGFEComponentTransferElement: false,
        SVGFECompositeElement: false,
        SVGFEConvolveMatrixElement: false,
        SVGFEDiffuseLightingElement: false,
        SVGFEDisplacementMapElement: false,
        SVGFEDistantLightElement: false,
        SVGFEDropShadowElement: false,
        SVGFEFloodElement: false,
        SVGFEFuncAElement: false,
        SVGFEFuncBElement: false,
        SVGFEFuncGElement: false,
        SVGFEFuncRElement: false,
        SVGFEGaussianBlurElement: false,
        SVGFEImageElement: false,
        SVGFEMergeElement: false,
        SVGFEMergeNodeElement: false,
        SVGFEMorphologyElement: false,
        SVGFEOffsetElement: false,
        SVGFEPointLightElement: false,
        SVGFESpecularLightingElement: false,
        SVGFESpotLightElement: false,
        SVGFETileElement: false,
        SVGFETurbulenceElement: false,
        SVGFilterElement: false,
        SVGForeignObjectElement: false,
        SVGGElement: false,
        SVGGeometryElement: false,
        SVGGradientElement: false,
        SVGGraphicsElement: false,
        SVGImageElement: false,
        SVGLength: false,
        SVGLengthList: false,
        SVGLinearGradientElement: false,
        SVGLineElement: false,
        SVGMarkerElement: false,
        SVGMaskElement: false,
        SVGMatrix: false,
        SVGMetadataElement: false,
        SVGMPathElement: false,
        SVGNumber: false,
        SVGNumberList: false,
        SVGPathElement: false,
        SVGPatternElement: false,
        SVGPoint: false,
        SVGPointList: false,
        SVGPolygonElement: false,
        SVGPolylineElement: false,
        SVGPreserveAspectRatio: false,
        SVGRadialGradientElement: false,
        SVGRect: false,
        SVGRectElement: false,
        SVGScriptElement: false,
        SVGSetElement: false,
        SVGStopElement: false,
        SVGStringList: false,
        SVGStyleElement: false,
        SVGSVGElement: false,
        SVGSwitchElement: false,
        SVGSymbolElement: false,
        SVGTextContentElement: false,
        SVGTextElement: false,
        SVGTextPathElement: false,
        SVGTextPositioningElement: false,
        SVGTitleElement: false,
        SVGTransform: false,
        SVGTransformList: false,
        SVGTSpanElement: false,
        SVGUnitTypes: false,
        SVGUseElement: false,
        SVGViewElement: false,
        TaskAttributionTiming: false,
        Text: false,
        TextDecoder: false,
        TextEncoder: false,
        TextEvent: false,
        TextMetrics: false,
        TextTrack: false,
        TextTrackCue: false,
        TextTrackCueList: false,
        TextTrackList: false,
        TimeRanges: false,
        toolbar: false,
        top: false,
        Touch: false,
        TouchEvent: false,
        TouchList: false,
        TrackEvent: false,
        TransitionEvent: false,
        TreeWalker: false,
        UIEvent: false,
        URL: false,
        URLSearchParams: false,
        ValidityState: false,
        visualViewport: false,
        VisualViewport: false,
        VTTCue: false,
        WaveShaperNode: false,
        WebAssembly: false,
        WebGL2RenderingContext: false,
        WebGLActiveInfo: false,
        WebGLBuffer: false,
        WebGLContextEvent: false,
        WebGLFramebuffer: false,
        WebGLProgram: false,
        WebGLQuery: false,
        WebGLRenderbuffer: false,
        WebGLRenderingContext: false,
        WebGLSampler: false,
        WebGLShader: false,
        WebGLShaderPrecisionFormat: false,
        WebGLSync: false,
        WebGLTexture: false,
        WebGLTransformFeedback: false,
        WebGLUniformLocation: false,
        WebGLVertexArrayObject: false,
        WebSocket: false,
        WheelEvent: false,
        window: false,
        Window: false,
        Worker: false,
        WritableStream: false,
        XMLDocument: false,
        XMLHttpRequest: false,
        XMLHttpRequestEventTarget: false,
        XMLHttpRequestUpload: false,
        XMLSerializer: false,
        XPathEvaluator: false,
        XPathExpression: false,
        XPathResult: false,
        XSLTProcessor: false
      },
      worker: {
        addEventListener: false,
        applicationCache: false,
        atob: false,
        Blob: false,
        BroadcastChannel: false,
        btoa: false,
        Cache: false,
        caches: false,
        clearInterval: false,
        clearTimeout: false,
        close: true,
        console: false,
        fetch: false,
        FileReaderSync: false,
        FormData: false,
        Headers: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        ImageData: false,
        importScripts: true,
        indexedDB: false,
        location: false,
        MessageChannel: false,
        MessagePort: false,
        name: false,
        navigator: false,
        Notification: false,
        onclose: true,
        onconnect: true,
        onerror: true,
        onlanguagechange: true,
        onmessage: true,
        onoffline: true,
        ononline: true,
        onrejectionhandled: true,
        onunhandledrejection: true,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        postMessage: true,
        Promise: false,
        queueMicrotask: false,
        removeEventListener: false,
        Request: false,
        Response: false,
        self: true,
        ServiceWorkerRegistration: false,
        setInterval: false,
        setTimeout: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false,
        WebSocket: false,
        Worker: false,
        WorkerGlobalScope: false,
        XMLHttpRequest: false
      },
      node: {
        __dirname: false,
        __filename: false,
        Buffer: false,
        clearImmediate: false,
        clearInterval: false,
        clearTimeout: false,
        console: false,
        exports: true,
        global: false,
        Intl: false,
        module: false,
        process: false,
        queueMicrotask: false,
        require: false,
        setImmediate: false,
        setInterval: false,
        setTimeout: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false
      },
      commonjs: {
        exports: true,
        global: false,
        module: false,
        require: false
      },
      amd: {
        define: false,
        require: false
      },
      mocha: {
        after: false,
        afterEach: false,
        before: false,
        beforeEach: false,
        context: false,
        describe: false,
        it: false,
        mocha: false,
        run: false,
        setup: false,
        specify: false,
        suite: false,
        suiteSetup: false,
        suiteTeardown: false,
        teardown: false,
        test: false,
        xcontext: false,
        xdescribe: false,
        xit: false,
        xspecify: false
      },
      jasmine: {
        afterAll: false,
        afterEach: false,
        beforeAll: false,
        beforeEach: false,
        describe: false,
        expect: false,
        fail: false,
        fdescribe: false,
        fit: false,
        it: false,
        jasmine: false,
        pending: false,
        runs: false,
        spyOn: false,
        spyOnProperty: false,
        waits: false,
        waitsFor: false,
        xdescribe: false,
        xit: false
      },
      jest: {
        afterAll: false,
        afterEach: false,
        beforeAll: false,
        beforeEach: false,
        describe: false,
        expect: false,
        fdescribe: false,
        fit: false,
        it: false,
        jest: false,
        pit: false,
        require: false,
        test: false,
        xdescribe: false,
        xit: false,
        xtest: false
      },
      qunit: {
        asyncTest: false,
        deepEqual: false,
        equal: false,
        expect: false,
        module: false,
        notDeepEqual: false,
        notEqual: false,
        notOk: false,
        notPropEqual: false,
        notStrictEqual: false,
        ok: false,
        propEqual: false,
        QUnit: false,
        raises: false,
        start: false,
        stop: false,
        strictEqual: false,
        test: false,
        throws: false
      },
      phantomjs: {
        console: true,
        exports: true,
        phantom: true,
        require: true,
        WebPage: true
      },
      couch: {
        emit: false,
        exports: false,
        getRow: false,
        log: false,
        module: false,
        provides: false,
        require: false,
        respond: false,
        send: false,
        start: false,
        sum: false
      },
      rhino: {
        defineClass: false,
        deserialize: false,
        gc: false,
        help: false,
        importClass: false,
        importPackage: false,
        java: false,
        load: false,
        loadClass: false,
        Packages: false,
        print: false,
        quit: false,
        readFile: false,
        readUrl: false,
        runCommand: false,
        seal: false,
        serialize: false,
        spawn: false,
        sync: false,
        toint32: false,
        version: false
      },
      nashorn: {
        __DIR__: false,
        __FILE__: false,
        __LINE__: false,
        com: false,
        edu: false,
        exit: false,
        java: false,
        Java: false,
        javafx: false,
        JavaImporter: false,
        javax: false,
        JSAdapter: false,
        load: false,
        loadWithNewGlobal: false,
        org: false,
        Packages: false,
        print: false,
        quit: false
      },
      wsh: {
        ActiveXObject: true,
        Enumerator: true,
        GetObject: true,
        ScriptEngine: true,
        ScriptEngineBuildVersion: true,
        ScriptEngineMajorVersion: true,
        ScriptEngineMinorVersion: true,
        VBArray: true,
        WScript: true,
        WSH: true,
        XDomainRequest: true
      },
      jquery: {
        $: false,
        jQuery: false
      },
      yui: {
        YAHOO: false,
        YAHOO_config: false,
        YUI: false,
        YUI_config: false
      },
      shelljs: {
        cat: false,
        cd: false,
        chmod: false,
        config: false,
        cp: false,
        dirs: false,
        echo: false,
        env: false,
        error: false,
        exec: false,
        exit: false,
        find: false,
        grep: false,
        ln: false,
        ls: false,
        mkdir: false,
        mv: false,
        popd: false,
        pushd: false,
        pwd: false,
        rm: false,
        sed: false,
        set: false,
        target: false,
        tempdir: false,
        test: false,
        touch: false,
        which: false
      },
      prototypejs: {
        $: false,
        $$: false,
        $A: false,
        $break: false,
        $continue: false,
        $F: false,
        $H: false,
        $R: false,
        $w: false,
        Abstract: false,
        Ajax: false,
        Autocompleter: false,
        Builder: false,
        Class: false,
        Control: false,
        Draggable: false,
        Draggables: false,
        Droppables: false,
        Effect: false,
        Element: false,
        Enumerable: false,
        Event: false,
        Field: false,
        Form: false,
        Hash: false,
        Insertion: false,
        ObjectRange: false,
        PeriodicalExecuter: false,
        Position: false,
        Prototype: false,
        Scriptaculous: false,
        Selector: false,
        Sortable: false,
        SortableObserver: false,
        Sound: false,
        Template: false,
        Toggle: false,
        Try: false
      },
      meteor: {
        _: false,
        $: false,
        Accounts: false,
        AccountsClient: false,
        AccountsCommon: false,
        AccountsServer: false,
        App: false,
        Assets: false,
        Blaze: false,
        check: false,
        Cordova: false,
        DDP: false,
        DDPRateLimiter: false,
        DDPServer: false,
        Deps: false,
        EJSON: false,
        Email: false,
        HTTP: false,
        Log: false,
        Match: false,
        Meteor: false,
        Mongo: false,
        MongoInternals: false,
        Npm: false,
        Package: false,
        Plugin: false,
        process: false,
        Random: false,
        ReactiveDict: false,
        ReactiveVar: false,
        Router: false,
        ServiceConfiguration: false,
        Session: false,
        share: false,
        Spacebars: false,
        Template: false,
        Tinytest: false,
        Tracker: false,
        UI: false,
        Utils: false,
        WebApp: false,
        WebAppInternals: false
      },
      mongo: {
        _isWindows: false,
        _rand: false,
        BulkWriteResult: false,
        cat: false,
        cd: false,
        connect: false,
        db: false,
        getHostName: false,
        getMemInfo: false,
        hostname: false,
        ISODate: false,
        listFiles: false,
        load: false,
        ls: false,
        md5sumFile: false,
        mkdir: false,
        Mongo: false,
        NumberInt: false,
        NumberLong: false,
        ObjectId: false,
        PlanCache: false,
        print: false,
        printjson: false,
        pwd: false,
        quit: false,
        removeFile: false,
        rs: false,
        sh: false,
        UUID: false,
        version: false,
        WriteResult: false
      },
      applescript: {
        $: false,
        Application: false,
        Automation: false,
        console: false,
        delay: false,
        Library: false,
        ObjC: false,
        ObjectSpecifier: false,
        Path: false,
        Progress: false,
        Ref: false
      },
      serviceworker: {
        addEventListener: false,
        applicationCache: false,
        atob: false,
        Blob: false,
        BroadcastChannel: false,
        btoa: false,
        Cache: false,
        caches: false,
        CacheStorage: false,
        clearInterval: false,
        clearTimeout: false,
        Client: false,
        clients: false,
        Clients: false,
        close: true,
        console: false,
        ExtendableEvent: false,
        ExtendableMessageEvent: false,
        fetch: false,
        FetchEvent: false,
        FileReaderSync: false,
        FormData: false,
        Headers: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        ImageData: false,
        importScripts: false,
        indexedDB: false,
        location: false,
        MessageChannel: false,
        MessagePort: false,
        name: false,
        navigator: false,
        Notification: false,
        onclose: true,
        onconnect: true,
        onerror: true,
        onfetch: true,
        oninstall: true,
        onlanguagechange: true,
        onmessage: true,
        onmessageerror: true,
        onnotificationclick: true,
        onnotificationclose: true,
        onoffline: true,
        ononline: true,
        onpush: true,
        onpushsubscriptionchange: true,
        onrejectionhandled: true,
        onsync: true,
        onunhandledrejection: true,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        postMessage: true,
        Promise: false,
        queueMicrotask: false,
        registration: false,
        removeEventListener: false,
        Request: false,
        Response: false,
        self: false,
        ServiceWorker: false,
        ServiceWorkerContainer: false,
        ServiceWorkerGlobalScope: false,
        ServiceWorkerMessageEvent: false,
        ServiceWorkerRegistration: false,
        setInterval: false,
        setTimeout: false,
        skipWaiting: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false,
        WebSocket: false,
        WindowClient: false,
        Worker: false,
        WorkerGlobalScope: false,
        XMLHttpRequest: false
      },
      atomtest: {
        advanceClock: false,
        fakeClearInterval: false,
        fakeClearTimeout: false,
        fakeSetInterval: false,
        fakeSetTimeout: false,
        resetTimeouts: false,
        waitsForPromise: false
      },
      embertest: {
        andThen: false,
        click: false,
        currentPath: false,
        currentRouteName: false,
        currentURL: false,
        fillIn: false,
        find: false,
        findAll: false,
        findWithAssert: false,
        keyEvent: false,
        pauseTest: false,
        resumeTest: false,
        triggerEvent: false,
        visit: false,
        wait: false
      },
      protractor: {
        $: false,
        $$: false,
        browser: false,
        by: false,
        By: false,
        DartObject: false,
        element: false,
        protractor: false
      },
      "shared-node-browser": {
        clearInterval: false,
        clearTimeout: false,
        console: false,
        setInterval: false,
        setTimeout: false,
        URL: false,
        URLSearchParams: false
      },
      webextensions: {
        browser: false,
        chrome: false,
        opr: false
      },
      greasemonkey: {
        cloneInto: false,
        createObjectIn: false,
        exportFunction: false,
        GM: false,
        GM_addStyle: false,
        GM_deleteValue: false,
        GM_getResourceText: false,
        GM_getResourceURL: false,
        GM_getValue: false,
        GM_info: false,
        GM_listValues: false,
        GM_log: false,
        GM_openInTab: false,
        GM_registerMenuCommand: false,
        GM_setClipboard: false,
        GM_setValue: false,
        GM_xmlhttpRequest: false,
        unsafeWindow: false
      },
      devtools: {
        $: false,
        $_: false,
        $$: false,
        $0: false,
        $1: false,
        $2: false,
        $3: false,
        $4: false,
        $x: false,
        chrome: false,
        clear: false,
        copy: false,
        debug: false,
        dir: false,
        dirxml: false,
        getEventListeners: false,
        inspect: false,
        keys: false,
        monitor: false,
        monitorEvents: false,
        profile: false,
        profileEnd: false,
        queryObjects: false,
        table: false,
        undebug: false,
        unmonitor: false,
        unmonitorEvents: false,
        values: false
      }
    };
  }
});

// node_modules/globals/index.js
var require_globals2 = __commonJS({
  "node_modules/globals/index.js"(exports, module) {
    "use strict";
    module.exports = require_globals();
  }
});

// node_modules/@babel/traverse/lib/cache.js
var require_cache = __commonJS({
  "node_modules/@babel/traverse/lib/cache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.clear = clear;
    exports.clearPath = clearPath;
    exports.clearScope = clearScope;
    exports.getCachedPaths = getCachedPaths;
    exports.getOrCreateCachedPaths = getOrCreateCachedPaths;
    exports.scope = exports.path = void 0;
    var pathsCache = exports.path = /* @__PURE__ */ new WeakMap();
    var scope = exports.scope = /* @__PURE__ */ new WeakMap();
    function clear() {
      clearPath();
      clearScope();
    }
    function clearPath() {
      exports.path = pathsCache = /* @__PURE__ */ new WeakMap();
    }
    function clearScope() {
      exports.scope = scope = /* @__PURE__ */ new WeakMap();
    }
    function getCachedPaths(path) {
      const {
        parent,
        parentPath
      } = path;
      return pathsCache.get(parent);
    }
    function getOrCreateCachedPaths(node, parentPath) {
      ;
      let paths = pathsCache.get(node);
      if (!paths) pathsCache.set(node, paths = /* @__PURE__ */ new Map());
      return paths;
    }
  }
});

// node_modules/@babel/traverse/lib/scope/index.js
var require_scope = __commonJS({
  "node_modules/@babel/traverse/lib/scope/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _renamer = require_renamer();
    var _index = require_lib9();
    var _binding = require_binding();
    var _globals = require_globals2();
    var _t = require_lib4();
    var t = _t;
    var _cache = require_cache();
    var {
      assignmentExpression,
      callExpression,
      cloneNode,
      getBindingIdentifiers,
      identifier,
      isArrayExpression,
      isBinary,
      isCallExpression,
      isClass,
      isClassBody,
      isClassDeclaration,
      isExportAllDeclaration,
      isExportDefaultDeclaration,
      isExportNamedDeclaration,
      isFunctionDeclaration,
      isIdentifier,
      isImportDeclaration,
      isLiteral,
      isMemberExpression,
      isMethod,
      isModuleSpecifier,
      isNullLiteral,
      isObjectExpression,
      isProperty: isProperty2,
      isPureish,
      isRegExpLiteral,
      isSuper,
      isTaggedTemplateExpression,
      isTemplateLiteral,
      isThisExpression,
      isUnaryExpression,
      isVariableDeclaration,
      expressionStatement,
      matchesPattern,
      memberExpression,
      numericLiteral,
      toIdentifier,
      variableDeclaration,
      variableDeclarator,
      isRecordExpression,
      isTupleExpression,
      isObjectProperty,
      isTopicReference,
      isMetaProperty,
      isPrivateName,
      isExportDeclaration,
      buildUndefinedNode,
      sequenceExpression
    } = _t;
    function gatherNodeParts(node, parts) {
      switch (node == null ? void 0 : node.type) {
        default:
          if (isImportDeclaration(node) || isExportDeclaration(node)) {
            var _node$specifiers;
            if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {
              gatherNodeParts(node.source, parts);
            } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && (_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
              for (const e2 of node.specifiers) gatherNodeParts(e2, parts);
            } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {
              gatherNodeParts(node.declaration, parts);
            }
          } else if (isModuleSpecifier(node)) {
            gatherNodeParts(node.local, parts);
          } else if (isLiteral(node) && !isNullLiteral(node) && !isRegExpLiteral(node) && !isTemplateLiteral(node)) {
            parts.push(node.value);
          }
          break;
        case "MemberExpression":
        case "OptionalMemberExpression":
        case "JSXMemberExpression":
          gatherNodeParts(node.object, parts);
          gatherNodeParts(node.property, parts);
          break;
        case "Identifier":
        case "JSXIdentifier":
          parts.push(node.name);
          break;
        case "CallExpression":
        case "OptionalCallExpression":
        case "NewExpression":
          gatherNodeParts(node.callee, parts);
          break;
        case "ObjectExpression":
        case "ObjectPattern":
          for (const e2 of node.properties) {
            gatherNodeParts(e2, parts);
          }
          break;
        case "SpreadElement":
        case "RestElement":
          gatherNodeParts(node.argument, parts);
          break;
        case "ObjectProperty":
        case "ObjectMethod":
        case "ClassProperty":
        case "ClassMethod":
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
          gatherNodeParts(node.key, parts);
          break;
        case "ThisExpression":
          parts.push("this");
          break;
        case "Super":
          parts.push("super");
          break;
        case "Import":
        case "ImportExpression":
          parts.push("import");
          break;
        case "DoExpression":
          parts.push("do");
          break;
        case "YieldExpression":
          parts.push("yield");
          gatherNodeParts(node.argument, parts);
          break;
        case "AwaitExpression":
          parts.push("await");
          gatherNodeParts(node.argument, parts);
          break;
        case "AssignmentExpression":
          gatherNodeParts(node.left, parts);
          break;
        case "VariableDeclarator":
          gatherNodeParts(node.id, parts);
          break;
        case "FunctionExpression":
        case "FunctionDeclaration":
        case "ClassExpression":
        case "ClassDeclaration":
          gatherNodeParts(node.id, parts);
          break;
        case "PrivateName":
          gatherNodeParts(node.id, parts);
          break;
        case "ParenthesizedExpression":
          gatherNodeParts(node.expression, parts);
          break;
        case "UnaryExpression":
        case "UpdateExpression":
          gatherNodeParts(node.argument, parts);
          break;
        case "MetaProperty":
          gatherNodeParts(node.meta, parts);
          gatherNodeParts(node.property, parts);
          break;
        case "JSXElement":
          gatherNodeParts(node.openingElement, parts);
          break;
        case "JSXOpeningElement":
          gatherNodeParts(node.name, parts);
          break;
        case "JSXFragment":
          gatherNodeParts(node.openingFragment, parts);
          break;
        case "JSXOpeningFragment":
          parts.push("Fragment");
          break;
        case "JSXNamespacedName":
          gatherNodeParts(node.namespace, parts);
          gatherNodeParts(node.name, parts);
          break;
      }
    }
    function resetScope(scope) {
      {
        scope.references = /* @__PURE__ */ Object.create(null);
        scope.uids = /* @__PURE__ */ Object.create(null);
      }
      scope.bindings = /* @__PURE__ */ Object.create(null);
      scope.globals = /* @__PURE__ */ Object.create(null);
    }
    {
      NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
    }
    var NOT_LOCAL_BINDING;
    var collectorVisitor = {
      ForStatement(path) {
        const declar = path.get("init");
        if (declar.isVar()) {
          const {
            scope
          } = path;
          const parentScope = scope.getFunctionParent() || scope.getProgramParent();
          parentScope.registerBinding("var", declar);
        }
      },
      Declaration(path) {
        if (path.isBlockScoped()) return;
        if (path.isImportDeclaration()) return;
        if (path.isExportDeclaration()) return;
        const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
        parent.registerDeclaration(path);
      },
      ImportDeclaration(path) {
        const parent = path.scope.getBlockParent();
        parent.registerDeclaration(path);
      },
      TSImportEqualsDeclaration(path) {
        const parent = path.scope.getBlockParent();
        parent.registerDeclaration(path);
      },
      ReferencedIdentifier(path, state) {
        if (t.isTSQualifiedName(path.parent) && path.parent.right === path.node) {
          return;
        }
        if (path.parentPath.isTSImportEqualsDeclaration()) return;
        state.references.push(path);
      },
      ForXStatement(path, state) {
        const left = path.get("left");
        if (left.isPattern() || left.isIdentifier()) {
          state.constantViolations.push(path);
        } else if (left.isVar()) {
          const {
            scope
          } = path;
          const parentScope = scope.getFunctionParent() || scope.getProgramParent();
          parentScope.registerBinding("var", left);
        }
      },
      ExportDeclaration: {
        exit(path) {
          const {
            node,
            scope
          } = path;
          if (isExportAllDeclaration(node)) return;
          const declar = node.declaration;
          if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
            const id = declar.id;
            if (!id) return;
            const binding = scope.getBinding(id.name);
            binding == null || binding.reference(path);
          } else if (isVariableDeclaration(declar)) {
            for (const decl of declar.declarations) {
              for (const name50 of Object.keys(getBindingIdentifiers(decl))) {
                const binding = scope.getBinding(name50);
                binding == null || binding.reference(path);
              }
            }
          }
        }
      },
      LabeledStatement(path) {
        path.scope.getBlockParent().registerDeclaration(path);
      },
      AssignmentExpression(path, state) {
        state.assignments.push(path);
      },
      UpdateExpression(path, state) {
        state.constantViolations.push(path);
      },
      UnaryExpression(path, state) {
        if (path.node.operator === "delete") {
          state.constantViolations.push(path);
        }
      },
      BlockScoped(path) {
        let scope = path.scope;
        if (scope.path === path) scope = scope.parent;
        const parent = scope.getBlockParent();
        parent.registerDeclaration(path);
        if (path.isClassDeclaration() && path.node.id) {
          const id = path.node.id;
          const name50 = id.name;
          path.scope.bindings[name50] = path.scope.parent.getBinding(name50);
        }
      },
      CatchClause(path) {
        path.scope.registerBinding("let", path);
      },
      Function(path) {
        const params = path.get("params");
        for (const param of params) {
          path.scope.registerBinding("param", param);
        }
        if (path.isFunctionExpression() && path.node.id && !path.node.id[NOT_LOCAL_BINDING]) {
          path.scope.registerBinding("local", path.get("id"), path);
        }
      },
      ClassExpression(path) {
        if (path.node.id && !path.node.id[NOT_LOCAL_BINDING]) {
          path.scope.registerBinding("local", path.get("id"), path);
        }
      },
      TSTypeAnnotation(path) {
        path.skip();
      }
    };
    var scopeVisitor;
    var uid = 0;
    var Scope = class _Scope {
      constructor(path) {
        this.uid = void 0;
        this.path = void 0;
        this.block = void 0;
        this.inited = void 0;
        this.labels = void 0;
        this.bindings = void 0;
        this.referencesSet = void 0;
        this.globals = void 0;
        this.uidsSet = void 0;
        this.data = void 0;
        this.crawling = void 0;
        const {
          node
        } = path;
        const cached = _cache.scope.get(node);
        if ((cached == null ? void 0 : cached.path) === path) {
          return cached;
        }
        _cache.scope.set(node, this);
        this.uid = uid++;
        this.block = node;
        this.path = path;
        this.labels = /* @__PURE__ */ new Map();
        this.inited = false;
        {
          Object.defineProperties(this, {
            references: {
              enumerable: true,
              configurable: true,
              writable: true,
              value: /* @__PURE__ */ Object.create(null)
            },
            uids: {
              enumerable: true,
              configurable: true,
              writable: true,
              value: /* @__PURE__ */ Object.create(null)
            }
          });
        }
      }
      get parent() {
        var _parent;
        let parent, path = this.path;
        do {
          var _path;
          const shouldSkip = path.key === "key" || path.listKey === "decorators";
          path = path.parentPath;
          if (shouldSkip && path.isMethod()) path = path.parentPath;
          if ((_path = path) != null && _path.isScope()) parent = path;
        } while (path && !parent);
        return (_parent = parent) == null ? void 0 : _parent.scope;
      }
      get references() {
        throw new Error("Scope#references is not available in Babel 8. Use Scope#referencesSet instead.");
      }
      get uids() {
        throw new Error("Scope#uids is not available in Babel 8. Use Scope#uidsSet instead.");
      }
      generateDeclaredUidIdentifier(name50) {
        const id = this.generateUidIdentifier(name50);
        this.push({
          id
        });
        return cloneNode(id);
      }
      generateUidIdentifier(name50) {
        return identifier(this.generateUid(name50));
      }
      generateUid(name50 = "temp") {
        name50 = toIdentifier(name50).replace(/^_+/, "").replace(/\d+$/g, "");
        let uid2;
        let i = 0;
        do {
          uid2 = `_${name50}`;
          if (i >= 11) uid2 += i - 1;
          else if (i >= 9) uid2 += i - 9;
          else if (i >= 1) uid2 += i + 1;
          i++;
        } while (this.hasLabel(uid2) || this.hasBinding(uid2) || this.hasGlobal(uid2) || this.hasReference(uid2));
        const program = this.getProgramParent();
        {
          program.references[uid2] = true;
          program.uids[uid2] = true;
        }
        return uid2;
      }
      generateUidBasedOnNode(node, defaultName) {
        const parts = [];
        gatherNodeParts(node, parts);
        let id = parts.join("$");
        id = id.replace(/^_/, "") || defaultName || "ref";
        return this.generateUid(id.slice(0, 20));
      }
      generateUidIdentifierBasedOnNode(node, defaultName) {
        return identifier(this.generateUidBasedOnNode(node, defaultName));
      }
      isStatic(node) {
        if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {
          return true;
        }
        if (isIdentifier(node)) {
          const binding = this.getBinding(node.name);
          if (binding) {
            return binding.constant;
          } else {
            return this.hasBinding(node.name);
          }
        }
        return false;
      }
      maybeGenerateMemoised(node, dontPush) {
        if (this.isStatic(node)) {
          return null;
        } else {
          const id = this.generateUidIdentifierBasedOnNode(node);
          if (!dontPush) {
            this.push({
              id
            });
            return cloneNode(id);
          }
          return id;
        }
      }
      checkBlockScopedCollisions(local, kind, name50, id) {
        if (kind === "param") return;
        if (local.kind === "local") return;
        const duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && kind === "const";
        if (duplicate) {
          throw this.path.hub.buildError(id, `Duplicate declaration "${name50}"`, TypeError);
        }
      }
      rename(oldName, newName) {
        const binding = this.getBinding(oldName);
        if (binding) {
          newName || (newName = this.generateUidIdentifier(oldName).name);
          const renamer = new _renamer.default(binding, oldName, newName);
          {
            renamer.rename(arguments[2]);
          }
        }
      }
      dump() {
        const sep = "-".repeat(60);
        console.log(sep);
        let scope = this;
        do {
          console.log("#", scope.block.type);
          for (const name50 of Object.keys(scope.bindings)) {
            const binding = scope.bindings[name50];
            console.log(" -", name50, {
              constant: binding.constant,
              references: binding.references,
              violations: binding.constantViolations.length,
              kind: binding.kind
            });
          }
        } while (scope = scope.parent);
        console.log(sep);
      }
      hasLabel(name50) {
        return !!this.getLabel(name50);
      }
      getLabel(name50) {
        return this.labels.get(name50);
      }
      registerLabel(path) {
        this.labels.set(path.node.label.name, path);
      }
      registerDeclaration(path) {
        if (path.isLabeledStatement()) {
          this.registerLabel(path);
        } else if (path.isFunctionDeclaration()) {
          this.registerBinding("hoisted", path.get("id"), path);
        } else if (path.isVariableDeclaration()) {
          const declarations = path.get("declarations");
          const {
            kind
          } = path.node;
          for (const declar of declarations) {
            this.registerBinding(kind === "using" || kind === "await using" ? "const" : kind, declar);
          }
        } else if (path.isClassDeclaration()) {
          if (path.node.declare) return;
          this.registerBinding("let", path);
        } else if (path.isImportDeclaration()) {
          const isTypeDeclaration = path.node.importKind === "type" || path.node.importKind === "typeof";
          const specifiers = path.get("specifiers");
          for (const specifier of specifiers) {
            const isTypeSpecifier = isTypeDeclaration || specifier.isImportSpecifier() && (specifier.node.importKind === "type" || specifier.node.importKind === "typeof");
            this.registerBinding(isTypeSpecifier ? "unknown" : "module", specifier);
          }
        } else if (path.isExportDeclaration()) {
          const declar = path.get("declaration");
          if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {
            this.registerDeclaration(declar);
          }
        } else {
          this.registerBinding("unknown", path);
        }
      }
      buildUndefinedNode() {
        return buildUndefinedNode();
      }
      registerConstantViolation(path) {
        const ids = path.getAssignmentIdentifiers();
        for (const name50 of Object.keys(ids)) {
          var _this$getBinding;
          (_this$getBinding = this.getBinding(name50)) == null || _this$getBinding.reassign(path);
        }
      }
      registerBinding(kind, path, bindingPath = path) {
        if (!kind) throw new ReferenceError("no `kind`");
        if (path.isVariableDeclaration()) {
          const declarators = path.get("declarations");
          for (const declar of declarators) {
            this.registerBinding(kind, declar);
          }
          return;
        }
        const parent = this.getProgramParent();
        const ids = path.getOuterBindingIdentifiers(true);
        for (const name50 of Object.keys(ids)) {
          {
            parent.references[name50] = true;
          }
          for (const id of ids[name50]) {
            const local = this.getOwnBinding(name50);
            if (local) {
              if (local.identifier === id) continue;
              this.checkBlockScopedCollisions(local, kind, name50, id);
            }
            if (local) {
              local.reassign(bindingPath);
            } else {
              this.bindings[name50] = new _binding.default({
                identifier: id,
                scope: this,
                path: bindingPath,
                kind
              });
            }
          }
        }
      }
      addGlobal(node) {
        this.globals[node.name] = node;
      }
      hasUid(name50) {
        {
          let scope = this;
          do {
            if (scope.uids[name50]) return true;
          } while (scope = scope.parent);
          return false;
        }
      }
      hasGlobal(name50) {
        let scope = this;
        do {
          if (scope.globals[name50]) return true;
        } while (scope = scope.parent);
        return false;
      }
      hasReference(name50) {
        {
          return !!this.getProgramParent().references[name50];
        }
      }
      isPure(node, constantsOnly) {
        if (isIdentifier(node)) {
          const binding = this.getBinding(node.name);
          if (!binding) return false;
          if (constantsOnly) return binding.constant;
          return true;
        } else if (isThisExpression(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName(node)) {
          return true;
        } else if (isClass(node)) {
          var _node$decorators;
          if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
            return false;
          }
          if (((_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length) > 0) {
            return false;
          }
          return this.isPure(node.body, constantsOnly);
        } else if (isClassBody(node)) {
          for (const method of node.body) {
            if (!this.isPure(method, constantsOnly)) return false;
          }
          return true;
        } else if (isBinary(node)) {
          return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
        } else if (isArrayExpression(node) || isTupleExpression(node)) {
          for (const elem of node.elements) {
            if (elem !== null && !this.isPure(elem, constantsOnly)) return false;
          }
          return true;
        } else if (isObjectExpression(node) || isRecordExpression(node)) {
          for (const prop of node.properties) {
            if (!this.isPure(prop, constantsOnly)) return false;
          }
          return true;
        } else if (isMethod(node)) {
          var _node$decorators2;
          if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
          if (((_node$decorators2 = node.decorators) == null ? void 0 : _node$decorators2.length) > 0) {
            return false;
          }
          return true;
        } else if (isProperty2(node)) {
          var _node$decorators3;
          if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
          if (((_node$decorators3 = node.decorators) == null ? void 0 : _node$decorators3.length) > 0) {
            return false;
          }
          if (isObjectProperty(node) || node.static) {
            if (node.value !== null && !this.isPure(node.value, constantsOnly)) {
              return false;
            }
          }
          return true;
        } else if (isUnaryExpression(node)) {
          return this.isPure(node.argument, constantsOnly);
        } else if (isTemplateLiteral(node)) {
          for (const expression of node.expressions) {
            if (!this.isPure(expression, constantsOnly)) return false;
          }
          return true;
        } else if (isTaggedTemplateExpression(node)) {
          return matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", {
            noGlobals: true
          }) && this.isPure(node.quasi, constantsOnly);
        } else if (isMemberExpression(node)) {
          return !node.computed && isIdentifier(node.object) && node.object.name === "Symbol" && isIdentifier(node.property) && node.property.name !== "for" && !this.hasBinding("Symbol", {
            noGlobals: true
          });
        } else if (isCallExpression(node)) {
          return matchesPattern(node.callee, "Symbol.for") && !this.hasBinding("Symbol", {
            noGlobals: true
          }) && node.arguments.length === 1 && t.isStringLiteral(node.arguments[0]);
        } else {
          return isPureish(node);
        }
      }
      setData(key, val) {
        return this.data[key] = val;
      }
      getData(key) {
        let scope = this;
        do {
          const data = scope.data[key];
          if (data != null) return data;
        } while (scope = scope.parent);
      }
      removeData(key) {
        let scope = this;
        do {
          const data = scope.data[key];
          if (data != null) scope.data[key] = null;
        } while (scope = scope.parent);
      }
      init() {
        if (!this.inited) {
          this.inited = true;
          this.crawl();
        }
      }
      crawl() {
        const path = this.path;
        resetScope(this);
        this.data = /* @__PURE__ */ Object.create(null);
        let scope = this;
        do {
          if (scope.crawling) return;
          if (scope.path.isProgram()) {
            break;
          }
        } while (scope = scope.parent);
        const programParent = scope;
        const state = {
          references: [],
          constantViolations: [],
          assignments: []
        };
        this.crawling = true;
        scopeVisitor || (scopeVisitor = _index.default.visitors.merge([{
          Scope(path2) {
            resetScope(path2.scope);
          }
        }, collectorVisitor]));
        if (path.type !== "Program") {
          for (const visit of scopeVisitor.enter) {
            visit.call(state, path, state);
          }
          const typeVisitors = scopeVisitor[path.type];
          if (typeVisitors) {
            for (const visit of typeVisitors.enter) {
              visit.call(state, path, state);
            }
          }
        }
        path.traverse(scopeVisitor, state);
        this.crawling = false;
        for (const path2 of state.assignments) {
          const ids = path2.getAssignmentIdentifiers();
          for (const name50 of Object.keys(ids)) {
            if (path2.scope.getBinding(name50)) continue;
            programParent.addGlobal(ids[name50]);
          }
          path2.scope.registerConstantViolation(path2);
        }
        for (const ref of state.references) {
          const binding = ref.scope.getBinding(ref.node.name);
          if (binding) {
            binding.reference(ref);
          } else {
            programParent.addGlobal(ref.node);
          }
        }
        for (const path2 of state.constantViolations) {
          path2.scope.registerConstantViolation(path2);
        }
      }
      push(opts) {
        let path = this.path;
        if (path.isPattern()) {
          path = this.getPatternParent().path;
        } else if (!path.isBlockStatement() && !path.isProgram()) {
          path = this.getBlockParent().path;
        }
        if (path.isSwitchStatement()) {
          path = (this.getFunctionParent() || this.getProgramParent()).path;
        }
        const {
          init,
          unique,
          kind = "var",
          id
        } = opts;
        if (!init && !unique && (kind === "var" || kind === "let") && path.isFunction() && !path.node.name && isCallExpression(path.parent, {
          callee: path.node
        }) && path.parent.arguments.length <= path.node.params.length && isIdentifier(id)) {
          path.pushContainer("params", id);
          path.scope.registerBinding("param", path.get("params")[path.node.params.length - 1]);
          return;
        }
        if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
          path.ensureBlock();
          path = path.get("body");
        }
        const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
        const dataKey = `declaration:${kind}:${blockHoist}`;
        let declarPath = !unique && path.getData(dataKey);
        if (!declarPath) {
          const declar = variableDeclaration(kind, []);
          declar._blockHoist = blockHoist;
          [declarPath] = path.unshiftContainer("body", [declar]);
          if (!unique) path.setData(dataKey, declarPath);
        }
        const declarator = variableDeclarator(id, init);
        const len = declarPath.node.declarations.push(declarator);
        path.scope.registerBinding(kind, declarPath.get("declarations")[len - 1]);
      }
      getProgramParent() {
        let scope = this;
        do {
          if (scope.path.isProgram()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("Couldn't find a Program");
      }
      getFunctionParent() {
        let scope = this;
        do {
          if (scope.path.isFunctionParent()) {
            return scope;
          }
        } while (scope = scope.parent);
        return null;
      }
      getBlockParent() {
        let scope = this;
        do {
          if (scope.path.isBlockParent()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
      }
      getPatternParent() {
        let scope = this;
        do {
          if (!scope.path.isPattern()) {
            return scope.getBlockParent();
          }
        } while (scope = scope.parent.parent);
        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
      }
      getAllBindings() {
        const ids = /* @__PURE__ */ Object.create(null);
        let scope = this;
        do {
          for (const key of Object.keys(scope.bindings)) {
            if (key in ids === false) {
              ids[key] = scope.bindings[key];
            }
          }
          scope = scope.parent;
        } while (scope);
        return ids;
      }
      bindingIdentifierEquals(name50, node) {
        return this.getBindingIdentifier(name50) === node;
      }
      getBinding(name50) {
        let scope = this;
        let previousPath;
        do {
          const binding = scope.getOwnBinding(name50);
          if (binding) {
            var _previousPath;
            if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== "param" && binding.kind !== "local") {
            } else {
              return binding;
            }
          } else if (!binding && name50 === "arguments" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
            break;
          }
          previousPath = scope.path;
        } while (scope = scope.parent);
      }
      getOwnBinding(name50) {
        return this.bindings[name50];
      }
      getBindingIdentifier(name50) {
        var _this$getBinding2;
        return (_this$getBinding2 = this.getBinding(name50)) == null ? void 0 : _this$getBinding2.identifier;
      }
      getOwnBindingIdentifier(name50) {
        const binding = this.bindings[name50];
        return binding == null ? void 0 : binding.identifier;
      }
      hasOwnBinding(name50) {
        return !!this.getOwnBinding(name50);
      }
      hasBinding(name50, opts) {
        if (!name50) return false;
        let noGlobals;
        let noUids;
        let upToScope;
        if (typeof opts === "object") {
          noGlobals = opts.noGlobals;
          noUids = opts.noUids;
          upToScope = opts.upToScope;
        } else if (typeof opts === "boolean") {
          noGlobals = opts;
        }
        let scope = this;
        do {
          if (upToScope === scope) {
            break;
          }
          if (scope.hasOwnBinding(name50)) {
            return true;
          }
        } while (scope = scope.parent);
        if (!noUids && this.hasUid(name50)) return true;
        if (!noGlobals && _Scope.globals.includes(name50)) return true;
        if (!noGlobals && _Scope.contextVariables.includes(name50)) return true;
        return false;
      }
      parentHasBinding(name50, opts) {
        var _this$parent;
        return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name50, opts);
      }
      moveBindingTo(name50, scope) {
        const info = this.getBinding(name50);
        if (info) {
          info.scope.removeOwnBinding(name50);
          info.scope = scope;
          scope.bindings[name50] = info;
        }
      }
      removeOwnBinding(name50) {
        delete this.bindings[name50];
      }
      removeBinding(name50) {
        var _this$getBinding3;
        (_this$getBinding3 = this.getBinding(name50)) == null || _this$getBinding3.scope.removeOwnBinding(name50);
        {
          let scope = this;
          do {
            if (scope.uids[name50]) {
              scope.uids[name50] = false;
            }
          } while (scope = scope.parent);
        }
      }
      hoistVariables(emit = (id) => this.push({
        id
      })) {
        this.crawl();
        const seen = /* @__PURE__ */ new Set();
        for (const name50 of Object.keys(this.bindings)) {
          const binding = this.bindings[name50];
          if (!binding) continue;
          const {
            path
          } = binding;
          if (!path.isVariableDeclarator()) continue;
          const {
            parent,
            parentPath
          } = path;
          if (parent.kind !== "var" || seen.has(parent)) continue;
          seen.add(path.parent);
          let firstId;
          const init = [];
          for (const decl of parent.declarations) {
            firstId != null ? firstId : firstId = decl.id;
            if (decl.init) {
              init.push(assignmentExpression("=", decl.id, decl.init));
            }
            const ids = Object.keys(getBindingIdentifiers(decl, false, true, true));
            for (const name51 of ids) {
              emit(identifier(name51), decl.init != null);
            }
          }
          if (parentPath.parentPath.isFor({
            left: parent
          })) {
            parentPath.replaceWith(firstId);
          } else if (init.length === 0) {
            parentPath.remove();
          } else {
            const expr = init.length === 1 ? init[0] : sequenceExpression(init);
            if (parentPath.parentPath.isForStatement({
              init: parent
            })) {
              parentPath.replaceWith(expr);
            } else {
              parentPath.replaceWith(expressionStatement(expr));
            }
          }
        }
      }
    };
    exports.default = Scope;
    Scope.globals = Object.keys(_globals.builtin);
    Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
    {
      Scope.prototype._renameFromMap = function _renameFromMap(map, oldName, newName, value) {
        if (map[oldName]) {
          map[newName] = value;
          map[oldName] = null;
        }
      };
      Scope.prototype.traverse = function(node, opts, state) {
        (0, _index.default)(node, opts, this, state, this.path);
      };
      Scope.prototype._generateUid = function _generateUid(name50, i) {
        let id = name50;
        if (i > 1) id += i;
        return `_${id}`;
      };
      Scope.prototype.toArray = function toArray2(node, i, arrayLikeIsIterable) {
        if (isIdentifier(node)) {
          const binding = this.getBinding(node.name);
          if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
            return node;
          }
        }
        if (isArrayExpression(node)) {
          return node;
        }
        if (isIdentifier(node, {
          name: "arguments"
        })) {
          return callExpression(memberExpression(memberExpression(memberExpression(identifier("Array"), identifier("prototype")), identifier("slice")), identifier("call")), [node]);
        }
        let helperName;
        const args = [node];
        if (i === true) {
          helperName = "toConsumableArray";
        } else if (typeof i === "number") {
          args.push(numericLiteral(i));
          helperName = "slicedToArray";
        } else {
          helperName = "toArray";
        }
        if (arrayLikeIsIterable) {
          args.unshift(this.path.hub.addHelper(helperName));
          helperName = "maybeArrayLike";
        }
        return callExpression(this.path.hub.addHelper(helperName), args);
      };
      Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind(...kinds) {
        const ids = /* @__PURE__ */ Object.create(null);
        for (const kind of kinds) {
          let scope = this;
          do {
            for (const name50 of Object.keys(scope.bindings)) {
              const binding = scope.bindings[name50];
              if (binding.kind === kind) ids[name50] = binding;
            }
            scope = scope.parent;
          } while (scope);
        }
        return ids;
      };
      Object.defineProperties(Scope.prototype, {
        parentBlock: {
          configurable: true,
          enumerable: true,
          get() {
            return this.path.parent;
          }
        },
        hub: {
          configurable: true,
          enumerable: true,
          get() {
            return this.path.hub;
          }
        }
      });
    }
  }
});

// node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var require_sourcemap_codec_umd = __commonJS({
  "node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"(exports, module) {
    (function(global4, factory) {
      if (typeof exports === "object" && typeof module !== "undefined") {
        factory(module);
        module.exports = def(module);
      } else if (typeof define === "function" && define.amd) {
        define(["module"], function(mod) {
          factory.apply(this, arguments);
          mod.exports = def(mod);
        });
      } else {
        const mod = { exports: {} };
        factory(mod);
        global4 = typeof globalThis !== "undefined" ? globalThis : global4 || self;
        global4.sourcemapCodec = def(mod);
      }
      function def(m) {
        return "default" in m.exports ? m.exports.default : m.exports;
      }
    })(exports, function(module2) {
      "use strict";
      var __defProp3 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all) => {
        for (var name50 in all)
          __defProp3(target, name50, { get: all[name50], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
      var sourcemap_codec_exports = {};
      __export2(sourcemap_codec_exports, {
        decode: () => decode4,
        decodeGeneratedRanges: () => decodeGeneratedRanges,
        decodeOriginalScopes: () => decodeOriginalScopes,
        encode: () => encode5,
        encodeGeneratedRanges: () => encodeGeneratedRanges,
        encodeOriginalScopes: () => encodeOriginalScopes
      });
      module2.exports = __toCommonJS(sourcemap_codec_exports);
      var comma2 = ",".charCodeAt(0);
      var semicolon2 = ";".charCodeAt(0);
      var chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var intToChar2 = new Uint8Array(64);
      var charToInt2 = new Uint8Array(128);
      for (let i = 0; i < chars2.length; i++) {
        const c = chars2.charCodeAt(i);
        intToChar2[i] = c;
        charToInt2[c] = i;
      }
      function decodeInteger(reader, relative) {
        let value = 0;
        let shift2 = 0;
        let integer2 = 0;
        do {
          const c = reader.next();
          integer2 = charToInt2[c];
          value |= (integer2 & 31) << shift2;
          shift2 += 5;
        } while (integer2 & 32);
        const shouldNegate = value & 1;
        value >>>= 1;
        if (shouldNegate) {
          value = -2147483648 | -value;
        }
        return relative + value;
      }
      function encodeInteger2(builder, num, relative) {
        let delta = num - relative;
        delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
        do {
          let clamped = delta & 31;
          delta >>>= 5;
          if (delta > 0) clamped |= 32;
          builder.write(intToChar2[clamped]);
        } while (delta > 0);
        return num;
      }
      function hasMoreVlq(reader, max) {
        if (reader.pos >= max) return false;
        return reader.peek() !== comma2;
      }
      var bufLength2 = 1024 * 16;
      var td2 = typeof TextDecoder !== "undefined" ? new TextDecoder() : typeof Buffer !== "undefined" ? {
        decode(buf) {
          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
          return out.toString();
        }
      } : {
        decode(buf) {
          let out = "";
          for (let i = 0; i < buf.length; i++) {
            out += String.fromCharCode(buf[i]);
          }
          return out;
        }
      };
      var StringWriter2 = class {
        constructor() {
          this.pos = 0;
          this.out = "";
          this.buffer = new Uint8Array(bufLength2);
        }
        write(v) {
          const { buffer } = this;
          buffer[this.pos++] = v;
          if (this.pos === bufLength2) {
            this.out += td2.decode(buffer);
            this.pos = 0;
          }
        }
        flush() {
          const { buffer, out, pos } = this;
          return pos > 0 ? out + td2.decode(buffer.subarray(0, pos)) : out;
        }
      };
      var StringReader = class {
        constructor(buffer) {
          this.pos = 0;
          this.buffer = buffer;
        }
        next() {
          return this.buffer.charCodeAt(this.pos++);
        }
        peek() {
          return this.buffer.charCodeAt(this.pos);
        }
        indexOf(char) {
          const { buffer, pos } = this;
          const idx = buffer.indexOf(char, pos);
          return idx === -1 ? buffer.length : idx;
        }
      };
      var EMPTY = [];
      function decodeOriginalScopes(input) {
        const { length: length2 } = input;
        const reader = new StringReader(input);
        const scopes = [];
        const stack = [];
        let line = 0;
        for (; reader.pos < length2; reader.pos++) {
          line = decodeInteger(reader, line);
          const column = decodeInteger(reader, 0);
          if (!hasMoreVlq(reader, length2)) {
            const last = stack.pop();
            last[2] = line;
            last[3] = column;
            continue;
          }
          const kind = decodeInteger(reader, 0);
          const fields = decodeInteger(reader, 0);
          const hasName = fields & 1;
          const scope = hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind];
          let vars = EMPTY;
          if (hasMoreVlq(reader, length2)) {
            vars = [];
            do {
              const varsIndex = decodeInteger(reader, 0);
              vars.push(varsIndex);
            } while (hasMoreVlq(reader, length2));
          }
          scope.vars = vars;
          scopes.push(scope);
          stack.push(scope);
        }
        return scopes;
      }
      function encodeOriginalScopes(scopes) {
        const writer = new StringWriter2();
        for (let i = 0; i < scopes.length; ) {
          i = _encodeOriginalScopes(scopes, i, writer, [0]);
        }
        return writer.flush();
      }
      function _encodeOriginalScopes(scopes, index, writer, state) {
        const scope = scopes[index];
        const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;
        if (index > 0) writer.write(comma2);
        state[0] = encodeInteger2(writer, startLine, state[0]);
        encodeInteger2(writer, startColumn, 0);
        encodeInteger2(writer, kind, 0);
        const fields = scope.length === 6 ? 1 : 0;
        encodeInteger2(writer, fields, 0);
        if (scope.length === 6) encodeInteger2(writer, scope[5], 0);
        for (const v of vars) {
          encodeInteger2(writer, v, 0);
        }
        for (index++; index < scopes.length; ) {
          const next = scopes[index];
          const { 0: l, 1: c } = next;
          if (l > endLine || l === endLine && c >= endColumn) {
            break;
          }
          index = _encodeOriginalScopes(scopes, index, writer, state);
        }
        writer.write(comma2);
        state[0] = encodeInteger2(writer, endLine, state[0]);
        encodeInteger2(writer, endColumn, 0);
        return index;
      }
      function decodeGeneratedRanges(input) {
        const { length: length2 } = input;
        const reader = new StringReader(input);
        const ranges = [];
        const stack = [];
        let genLine = 0;
        let definitionSourcesIndex = 0;
        let definitionScopeIndex = 0;
        let callsiteSourcesIndex = 0;
        let callsiteLine = 0;
        let callsiteColumn = 0;
        let bindingLine = 0;
        let bindingColumn = 0;
        do {
          const semi = reader.indexOf(";");
          let genColumn = 0;
          for (; reader.pos < semi; reader.pos++) {
            genColumn = decodeInteger(reader, genColumn);
            if (!hasMoreVlq(reader, semi)) {
              const last = stack.pop();
              last[2] = genLine;
              last[3] = genColumn;
              continue;
            }
            const fields = decodeInteger(reader, 0);
            const hasDefinition = fields & 1;
            const hasCallsite = fields & 2;
            const hasScope = fields & 4;
            let callsite = null;
            let bindings = EMPTY;
            let range;
            if (hasDefinition) {
              const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);
              definitionScopeIndex = decodeInteger(
                reader,
                definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0
              );
              definitionSourcesIndex = defSourcesIndex;
              range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];
            } else {
              range = [genLine, genColumn, 0, 0];
            }
            range.isScope = !!hasScope;
            if (hasCallsite) {
              const prevCsi = callsiteSourcesIndex;
              const prevLine = callsiteLine;
              callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);
              const sameSource = prevCsi === callsiteSourcesIndex;
              callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);
              callsiteColumn = decodeInteger(
                reader,
                sameSource && prevLine === callsiteLine ? callsiteColumn : 0
              );
              callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];
            }
            range.callsite = callsite;
            if (hasMoreVlq(reader, semi)) {
              bindings = [];
              do {
                bindingLine = genLine;
                bindingColumn = genColumn;
                const expressionsCount = decodeInteger(reader, 0);
                let expressionRanges;
                if (expressionsCount < -1) {
                  expressionRanges = [[decodeInteger(reader, 0)]];
                  for (let i = -1; i > expressionsCount; i--) {
                    const prevBl = bindingLine;
                    bindingLine = decodeInteger(reader, bindingLine);
                    bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);
                    const expression = decodeInteger(reader, 0);
                    expressionRanges.push([expression, bindingLine, bindingColumn]);
                  }
                } else {
                  expressionRanges = [[expressionsCount]];
                }
                bindings.push(expressionRanges);
              } while (hasMoreVlq(reader, semi));
            }
            range.bindings = bindings;
            ranges.push(range);
            stack.push(range);
          }
          genLine++;
          reader.pos = semi + 1;
        } while (reader.pos < length2);
        return ranges;
      }
      function encodeGeneratedRanges(ranges) {
        if (ranges.length === 0) return "";
        const writer = new StringWriter2();
        for (let i = 0; i < ranges.length; ) {
          i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);
        }
        return writer.flush();
      }
      function _encodeGeneratedRanges(ranges, index, writer, state) {
        const range = ranges[index];
        const {
          0: startLine,
          1: startColumn,
          2: endLine,
          3: endColumn,
          isScope,
          callsite,
          bindings
        } = range;
        if (state[0] < startLine) {
          catchupLine(writer, state[0], startLine);
          state[0] = startLine;
          state[1] = 0;
        } else if (index > 0) {
          writer.write(comma2);
        }
        state[1] = encodeInteger2(writer, range[1], state[1]);
        const fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);
        encodeInteger2(writer, fields, 0);
        if (range.length === 6) {
          const { 4: sourcesIndex, 5: scopesIndex } = range;
          if (sourcesIndex !== state[2]) {
            state[3] = 0;
          }
          state[2] = encodeInteger2(writer, sourcesIndex, state[2]);
          state[3] = encodeInteger2(writer, scopesIndex, state[3]);
        }
        if (callsite) {
          const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;
          if (sourcesIndex !== state[4]) {
            state[5] = 0;
            state[6] = 0;
          } else if (callLine !== state[5]) {
            state[6] = 0;
          }
          state[4] = encodeInteger2(writer, sourcesIndex, state[4]);
          state[5] = encodeInteger2(writer, callLine, state[5]);
          state[6] = encodeInteger2(writer, callColumn, state[6]);
        }
        if (bindings) {
          for (const binding of bindings) {
            if (binding.length > 1) encodeInteger2(writer, -binding.length, 0);
            const expression = binding[0][0];
            encodeInteger2(writer, expression, 0);
            let bindingStartLine = startLine;
            let bindingStartColumn = startColumn;
            for (let i = 1; i < binding.length; i++) {
              const expRange = binding[i];
              bindingStartLine = encodeInteger2(writer, expRange[1], bindingStartLine);
              bindingStartColumn = encodeInteger2(writer, expRange[2], bindingStartColumn);
              encodeInteger2(writer, expRange[0], 0);
            }
          }
        }
        for (index++; index < ranges.length; ) {
          const next = ranges[index];
          const { 0: l, 1: c } = next;
          if (l > endLine || l === endLine && c >= endColumn) {
            break;
          }
          index = _encodeGeneratedRanges(ranges, index, writer, state);
        }
        if (state[0] < endLine) {
          catchupLine(writer, state[0], endLine);
          state[0] = endLine;
          state[1] = 0;
        } else {
          writer.write(comma2);
        }
        state[1] = encodeInteger2(writer, endColumn, state[1]);
        return index;
      }
      function catchupLine(writer, lastLine, line) {
        do {
          writer.write(semicolon2);
        } while (++lastLine < line);
      }
      function decode4(mappings) {
        const { length: length2 } = mappings;
        const reader = new StringReader(mappings);
        const decoded = [];
        let genColumn = 0;
        let sourcesIndex = 0;
        let sourceLine = 0;
        let sourceColumn = 0;
        let namesIndex = 0;
        do {
          const semi = reader.indexOf(";");
          const line = [];
          let sorted = true;
          let lastCol = 0;
          genColumn = 0;
          while (reader.pos < semi) {
            let seg;
            genColumn = decodeInteger(reader, genColumn);
            if (genColumn < lastCol) sorted = false;
            lastCol = genColumn;
            if (hasMoreVlq(reader, semi)) {
              sourcesIndex = decodeInteger(reader, sourcesIndex);
              sourceLine = decodeInteger(reader, sourceLine);
              sourceColumn = decodeInteger(reader, sourceColumn);
              if (hasMoreVlq(reader, semi)) {
                namesIndex = decodeInteger(reader, namesIndex);
                seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
              } else {
                seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
              }
            } else {
              seg = [genColumn];
            }
            line.push(seg);
            reader.pos++;
          }
          if (!sorted) sort(line);
          decoded.push(line);
          reader.pos = semi + 1;
        } while (reader.pos <= length2);
        return decoded;
      }
      function sort(line) {
        line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[0] - b[0];
      }
      function encode5(decoded) {
        const writer = new StringWriter2();
        let sourcesIndex = 0;
        let sourceLine = 0;
        let sourceColumn = 0;
        let namesIndex = 0;
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          if (i > 0) writer.write(semicolon2);
          if (line.length === 0) continue;
          let genColumn = 0;
          for (let j = 0; j < line.length; j++) {
            const segment = line[j];
            if (j > 0) writer.write(comma2);
            genColumn = encodeInteger2(writer, segment[0], genColumn);
            if (segment.length === 1) continue;
            sourcesIndex = encodeInteger2(writer, segment[1], sourcesIndex);
            sourceLine = encodeInteger2(writer, segment[2], sourceLine);
            sourceColumn = encodeInteger2(writer, segment[3], sourceColumn);
            if (segment.length === 4) continue;
            namesIndex = encodeInteger2(writer, segment[4], namesIndex);
          }
        }
        return writer.flush();
      }
    });
  }
});

// node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var require_resolve_uri_umd = __commonJS({
  "node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"(exports, module) {
    (function(global4, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global4 = typeof globalThis !== "undefined" ? globalThis : global4 || self, global4.resolveURI = factory());
    })(exports, function() {
      "use strict";
      const schemeRegex = /^[\w+.-]+:\/\//;
      const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
      const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
      }
      function isSchemeRelativeUrl(input) {
        return input.startsWith("//");
      }
      function isAbsolutePath(input) {
        return input.startsWith("/");
      }
      function isFileUrl(input) {
        return input.startsWith("file:");
      }
      function isRelative(input) {
        return /^[.?#]/.test(input);
      }
      function parseAbsoluteUrl(input) {
        const match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
      }
      function parseFileUrl(input) {
        const match = fileRegex.exec(input);
        const path = match[2];
        return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path) ? path : "/" + path, match[3] || "", match[4] || "");
      }
      function makeUrl(scheme, user, host, port, path, query, hash3) {
        return {
          scheme,
          user,
          host,
          port,
          path,
          query,
          hash: hash3,
          type: 7
        };
      }
      function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
          const url2 = parseAbsoluteUrl("http:" + input);
          url2.scheme = "";
          url2.type = 6;
          return url2;
        }
        if (isAbsolutePath(input)) {
          const url2 = parseAbsoluteUrl("http://foo.com" + input);
          url2.scheme = "";
          url2.host = "";
          url2.type = 5;
          return url2;
        }
        if (isFileUrl(input))
          return parseFileUrl(input);
        if (isAbsoluteUrl(input))
          return parseAbsoluteUrl(input);
        const url = parseAbsoluteUrl("http://foo.com/" + input);
        url.scheme = "";
        url.host = "";
        url.type = input ? input.startsWith("?") ? 3 : input.startsWith("#") ? 2 : 4 : 1;
        return url;
      }
      function stripPathFilename(path) {
        if (path.endsWith("/.."))
          return path;
        const index = path.lastIndexOf("/");
        return path.slice(0, index + 1);
      }
      function mergePaths(url, base) {
        normalizePath(base, base.type);
        if (url.path === "/") {
          url.path = base.path;
        } else {
          url.path = stripPathFilename(base.path) + url.path;
        }
      }
      function normalizePath(url, type) {
        const rel = type <= 4;
        const pieces = url.path.split("/");
        let pointer = 1;
        let positive = 0;
        let addTrailingSlash = false;
        for (let i = 1; i < pieces.length; i++) {
          const piece = pieces[i];
          if (!piece) {
            addTrailingSlash = true;
            continue;
          }
          addTrailingSlash = false;
          if (piece === ".")
            continue;
          if (piece === "..") {
            if (positive) {
              addTrailingSlash = true;
              positive--;
              pointer--;
            } else if (rel) {
              pieces[pointer++] = piece;
            }
            continue;
          }
          pieces[pointer++] = piece;
          positive++;
        }
        let path = "";
        for (let i = 1; i < pointer; i++) {
          path += "/" + pieces[i];
        }
        if (!path || addTrailingSlash && !path.endsWith("/..")) {
          path += "/";
        }
        url.path = path;
      }
      function resolve(input, base) {
        if (!input && !base)
          return "";
        const url = parseUrl(input);
        let inputType = url.type;
        if (base && inputType !== 7) {
          const baseUrl = parseUrl(base);
          const baseType = baseUrl.type;
          switch (inputType) {
            case 1:
              url.hash = baseUrl.hash;
            case 2:
              url.query = baseUrl.query;
            case 3:
            case 4:
              mergePaths(url, baseUrl);
            case 5:
              url.user = baseUrl.user;
              url.host = baseUrl.host;
              url.port = baseUrl.port;
            case 6:
              url.scheme = baseUrl.scheme;
          }
          if (baseType > inputType)
            inputType = baseType;
        }
        normalizePath(url, inputType);
        const queryHash = url.query + url.hash;
        switch (inputType) {
          case 2:
          case 3:
            return queryHash;
          case 4: {
            const path = url.path.slice(1);
            if (!path)
              return queryHash || ".";
            if (isRelative(base || input) && !isRelative(path)) {
              return "./" + path + queryHash;
            }
            return path + queryHash;
          }
          case 5:
            return url.path + queryHash;
          default:
            return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
        }
      }
      return resolve;
    });
  }
});

// node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var require_trace_mapping_umd = __commonJS({
  "node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"(exports, module) {
    (function(global4, factory) {
      if (typeof exports === "object" && typeof module !== "undefined") {
        factory(module, require_resolve_uri_umd(), require_sourcemap_codec_umd());
        module.exports = def(module);
      } else if (typeof define === "function" && define.amd) {
        define(["module", "@jridgewell/resolve-uri", "@jridgewell/sourcemap-codec"], function(mod) {
          factory.apply(this, arguments);
          mod.exports = def(mod);
        });
      } else {
        const mod = { exports: {} };
        factory(mod, global4.resolveURI, global4.sourcemapCodec);
        global4 = typeof globalThis !== "undefined" ? globalThis : global4 || self;
        global4.traceMapping = def(mod);
      }
      function def(m) {
        return "default" in m.exports ? m.exports.default : m.exports;
      }
    })(exports, function(module2, require_resolveURI, require_sourcemapCodec) {
      "use strict";
      var __create = Object.create;
      var __defProp3 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __getProtoOf = Object.getPrototypeOf;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __commonJS2 = (cb, mod) => function __require() {
        return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      };
      var __export2 = (target, all) => {
        for (var name50 in all)
          __defProp3(target, name50, { get: all[name50], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps2(
        // If the importer is in node compatibility mode or this is not an ESM
        // file that has been converted to a CommonJS file using a Babel-
        // compatible transform (i.e. "__esModule" has not been set), then set
        // "default" to the CommonJS "module.exports" for node compatibility.
        isNodeMode || !mod || !mod.__esModule ? __defProp3(target, "default", { value: mod, enumerable: true }) : target,
        mod
      ));
      var __toCommonJS = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
      var require_sourcemap_codec = __commonJS2({
        "umd:@jridgewell/sourcemap-codec"(exports2, module22) {
          module22.exports = require_sourcemapCodec;
        }
      });
      var require_resolve_uri = __commonJS2({
        "umd:@jridgewell/resolve-uri"(exports2, module22) {
          module22.exports = require_resolveURI;
        }
      });
      var trace_mapping_exports = {};
      __export2(trace_mapping_exports, {
        AnyMap: () => FlattenMap,
        FlattenMap: () => FlattenMap,
        GREATEST_LOWER_BOUND: () => GREATEST_LOWER_BOUND,
        LEAST_UPPER_BOUND: () => LEAST_UPPER_BOUND,
        TraceMap: () => TraceMap,
        allGeneratedPositionsFor: () => allGeneratedPositionsFor,
        decodedMap: () => decodedMap,
        decodedMappings: () => decodedMappings,
        eachMapping: () => eachMapping,
        encodedMap: () => encodedMap,
        encodedMappings: () => encodedMappings,
        generatedPositionFor: () => generatedPositionFor,
        isIgnored: () => isIgnored,
        originalPositionFor: () => originalPositionFor,
        presortedDecodedMap: () => presortedDecodedMap,
        sourceContentFor: () => sourceContentFor,
        traceSegment: () => traceSegment
      });
      module2.exports = __toCommonJS(trace_mapping_exports);
      var import_sourcemap_codec2 = __toESM2(require_sourcemap_codec());
      var import_resolve_uri = __toESM2(require_resolve_uri());
      function stripFilename(path) {
        if (!path) return "";
        const index = path.lastIndexOf("/");
        return path.slice(0, index + 1);
      }
      function resolver(mapUrl, sourceRoot) {
        const from = stripFilename(mapUrl);
        const prefix = sourceRoot ? sourceRoot + "/" : "";
        return (source) => (0, import_resolve_uri.default)(prefix + (source || ""), from);
      }
      var COLUMN = 0;
      var SOURCES_INDEX = 1;
      var SOURCE_LINE = 2;
      var SOURCE_COLUMN = 3;
      var NAMES_INDEX = 4;
      var REV_GENERATED_LINE = 1;
      var REV_GENERATED_COLUMN = 2;
      function maybeSort(mappings, owned) {
        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
        if (unsortedIndex === mappings.length) return mappings;
        if (!owned) mappings = mappings.slice();
        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
          mappings[i] = sortSegments(mappings[i], owned);
        }
        return mappings;
      }
      function nextUnsortedSegmentLine(mappings, start) {
        for (let i = start; i < mappings.length; i++) {
          if (!isSorted(mappings[i])) return i;
        }
        return mappings.length;
      }
      function isSorted(line) {
        for (let j = 1; j < line.length; j++) {
          if (line[j][COLUMN] < line[j - 1][COLUMN]) {
            return false;
          }
        }
        return true;
      }
      function sortSegments(line, owned) {
        if (!owned) line = line.slice();
        return line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[COLUMN] - b[COLUMN];
      }
      function buildBySources(decoded, memos) {
        const sources = memos.map(() => []);
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            if (seg.length === 1) continue;
            const sourceIndex2 = seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            const source = sources[sourceIndex2];
            const segs = source[sourceLine] || (source[sourceLine] = []);
            segs.push([sourceColumn, i, seg[COLUMN]]);
          }
        }
        for (let i = 0; i < sources.length; i++) {
          const source = sources[i];
          for (let j = 0; j < source.length; j++) {
            const line = source[j];
            if (line) line.sort(sortComparator);
          }
        }
        return sources;
      }
      var found = false;
      function binarySearch(haystack, needle, low, high) {
        while (low <= high) {
          const mid = low + (high - low >> 1);
          const cmp = haystack[mid][COLUMN] - needle;
          if (cmp === 0) {
            found = true;
            return mid;
          }
          if (cmp < 0) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        found = false;
        return low - 1;
      }
      function upperBound(haystack, needle, index) {
        for (let i = index + 1; i < haystack.length; index = i++) {
          if (haystack[i][COLUMN] !== needle) break;
        }
        return index;
      }
      function lowerBound(haystack, needle, index) {
        for (let i = index - 1; i >= 0; index = i--) {
          if (haystack[i][COLUMN] !== needle) break;
        }
        return index;
      }
      function memoizedState() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function memoizedBinarySearch(haystack, needle, state, key) {
        const { lastKey, lastNeedle, lastIndex } = state;
        let low = 0;
        let high = haystack.length - 1;
        if (key === lastKey) {
          if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
          }
          if (needle >= lastNeedle) {
            low = lastIndex === -1 ? 0 : lastIndex;
          } else {
            high = lastIndex;
          }
        }
        state.lastKey = key;
        state.lastNeedle = needle;
        return state.lastIndex = binarySearch(haystack, needle, low, high);
      }
      function parse53(map) {
        return typeof map === "string" ? JSON.parse(map) : map;
      }
      var FlattenMap = function(map, mapUrl) {
        const parsed = parse53(map);
        if (!("sections" in parsed)) {
          return new TraceMap(parsed, mapUrl);
        }
        const mappings = [];
        const sources = [];
        const sourcesContent = [];
        const names = [];
        const ignoreList = [];
        recurse(
          parsed,
          mapUrl,
          mappings,
          sources,
          sourcesContent,
          names,
          ignoreList,
          0,
          0,
          Infinity,
          Infinity
        );
        const joined = {
          version: 3,
          file: parsed.file,
          names,
          sources,
          sourcesContent,
          mappings,
          ignoreList
        };
        return presortedDecodedMap(joined);
      };
      function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const { sections } = input;
        for (let i = 0; i < sections.length; i++) {
          const { map, offset } = sections[i];
          let sl = stopLine;
          let sc = stopColumn;
          if (i + 1 < sections.length) {
            const nextOffset = sections[i + 1].offset;
            sl = Math.min(stopLine, lineOffset + nextOffset.line);
            if (sl === stopLine) {
              sc = Math.min(stopColumn, columnOffset + nextOffset.column);
            } else if (sl < stopLine) {
              sc = columnOffset + nextOffset.column;
            }
          }
          addSection(
            map,
            mapUrl,
            mappings,
            sources,
            sourcesContent,
            names,
            ignoreList,
            lineOffset + offset.line,
            columnOffset + offset.column,
            sl,
            sc
          );
        }
      }
      function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const parsed = parse53(input);
        if ("sections" in parsed) return recurse(...arguments);
        const map = new TraceMap(parsed, mapUrl);
        const sourcesOffset = sources.length;
        const namesOffset = names.length;
        const decoded = decodedMappings(map);
        const { resolvedSources, sourcesContent: contents3, ignoreList: ignores } = map;
        append(sources, resolvedSources);
        append(names, map.names);
        if (contents3) append(sourcesContent, contents3);
        else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);
        if (ignores) for (let i = 0; i < ignores.length; i++) ignoreList.push(ignores[i] + sourcesOffset);
        for (let i = 0; i < decoded.length; i++) {
          const lineI = lineOffset + i;
          if (lineI > stopLine) return;
          const out = getLine(mappings, lineI);
          const cOffset = i === 0 ? columnOffset : 0;
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const column = cOffset + seg[COLUMN];
            if (lineI === stopLine && column >= stopColumn) return;
            if (seg.length === 1) {
              out.push([column]);
              continue;
            }
            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            out.push(
              seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]
            );
          }
        }
      }
      function append(arr, other) {
        for (let i = 0; i < other.length; i++) arr.push(other[i]);
      }
      function getLine(arr, index) {
        for (let i = arr.length; i <= index; i++) arr[i] = [];
        return arr[index];
      }
      var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
      var COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
      var LEAST_UPPER_BOUND = -1;
      var GREATEST_LOWER_BOUND = 1;
      var TraceMap = class {
        constructor(map, mapUrl) {
          const isString2 = typeof map === "string";
          if (!isString2 && map._decodedMemo) return map;
          const parsed = parse53(map);
          const { version: version2, file, names, sourceRoot, sources, sourcesContent } = parsed;
          this.version = version2;
          this.file = file;
          this.names = names || [];
          this.sourceRoot = sourceRoot;
          this.sources = sources;
          this.sourcesContent = sourcesContent;
          this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
          const resolve = resolver(mapUrl, sourceRoot);
          this.resolvedSources = sources.map(resolve);
          const { mappings } = parsed;
          if (typeof mappings === "string") {
            this._encoded = mappings;
            this._decoded = void 0;
          } else if (Array.isArray(mappings)) {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString2);
          } else if (parsed.sections) {
            throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);
          } else {
            throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);
          }
          this._decodedMemo = memoizedState();
          this._bySources = void 0;
          this._bySourceMemos = void 0;
        }
      };
      function cast(map) {
        return map;
      }
      function encodedMappings(map) {
        var _a, _b;
        return (_b = (_a = cast(map))._encoded) != null ? _b : _a._encoded = (0, import_sourcemap_codec2.encode)(cast(map)._decoded);
      }
      function decodedMappings(map) {
        var _a;
        return (_a = cast(map))._decoded || (_a._decoded = (0, import_sourcemap_codec2.decode)(cast(map)._encoded));
      }
      function traceSegment(map, line, column) {
        const decoded = decodedMappings(map);
        if (line >= decoded.length) return null;
        const segments = decoded[line];
        const index = traceSegmentInternal(
          segments,
          cast(map)._decodedMemo,
          line,
          column,
          GREATEST_LOWER_BOUND
        );
        return index === -1 ? null : segments[index];
      }
      function originalPositionFor(map, needle) {
        let { line, column, bias } = needle;
        line--;
        if (line < 0) throw new Error(LINE_GTR_ZERO);
        if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
        const decoded = decodedMappings(map);
        if (line >= decoded.length) return OMapping(null, null, null, null);
        const segments = decoded[line];
        const index = traceSegmentInternal(
          segments,
          cast(map)._decodedMemo,
          line,
          column,
          bias || GREATEST_LOWER_BOUND
        );
        if (index === -1) return OMapping(null, null, null, null);
        const segment = segments[index];
        if (segment.length === 1) return OMapping(null, null, null, null);
        const { names, resolvedSources } = map;
        return OMapping(
          resolvedSources[segment[SOURCES_INDEX]],
          segment[SOURCE_LINE] + 1,
          segment[SOURCE_COLUMN],
          segment.length === 5 ? names[segment[NAMES_INDEX]] : null
        );
      }
      function generatedPositionFor(map, needle) {
        const { source, line, column, bias } = needle;
        return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);
      }
      function allGeneratedPositionsFor(map, needle) {
        const { source, line, column, bias } = needle;
        return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);
      }
      function eachMapping(map, cb) {
        const decoded = decodedMappings(map);
        const { names, resolvedSources } = map;
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const generatedLine = i + 1;
            const generatedColumn = seg[0];
            let source = null;
            let originalLine = null;
            let originalColumn = null;
            let name50 = null;
            if (seg.length !== 1) {
              source = resolvedSources[seg[1]];
              originalLine = seg[2] + 1;
              originalColumn = seg[3];
            }
            if (seg.length === 5) name50 = names[seg[4]];
            cb({
              generatedLine,
              generatedColumn,
              source,
              originalLine,
              originalColumn,
              name: name50
            });
          }
        }
      }
      function sourceIndex(map, source) {
        const { sources, resolvedSources } = map;
        let index = sources.indexOf(source);
        if (index === -1) index = resolvedSources.indexOf(source);
        return index;
      }
      function sourceContentFor(map, source) {
        const { sourcesContent } = map;
        if (sourcesContent == null) return null;
        const index = sourceIndex(map, source);
        return index === -1 ? null : sourcesContent[index];
      }
      function isIgnored(map, source) {
        const { ignoreList } = map;
        if (ignoreList == null) return false;
        const index = sourceIndex(map, source);
        return index === -1 ? false : ignoreList.includes(index);
      }
      function presortedDecodedMap(map, mapUrl) {
        const tracer = new TraceMap(clone3(map, []), mapUrl);
        cast(tracer)._decoded = map.mappings;
        return tracer;
      }
      function decodedMap(map) {
        return clone3(map, decodedMappings(map));
      }
      function encodedMap(map) {
        return clone3(map, encodedMappings(map));
      }
      function clone3(map, mappings) {
        return {
          version: map.version,
          file: map.file,
          names: map.names,
          sourceRoot: map.sourceRoot,
          sources: map.sources,
          sourcesContent: map.sourcesContent,
          mappings,
          ignoreList: map.ignoreList || map.x_google_ignoreList
        };
      }
      function OMapping(source, line, column, name50) {
        return { source, line, column, name: name50 };
      }
      function GMapping(line, column) {
        return { line, column };
      }
      function traceSegmentInternal(segments, memo, line, column, bias) {
        let index = memoizedBinarySearch(segments, column, memo, line);
        if (found) {
          index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
        } else if (bias === LEAST_UPPER_BOUND) index++;
        if (index === -1 || index === segments.length) return -1;
        return index;
      }
      function sliceGeneratedPositions(segments, memo, line, column, bias) {
        let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
        if (!found && bias === LEAST_UPPER_BOUND) min++;
        if (min === -1 || min === segments.length) return [];
        const matchedColumn = found ? column : segments[min][COLUMN];
        if (!found) min = lowerBound(segments, matchedColumn, min);
        const max = upperBound(segments, matchedColumn, min);
        const result = [];
        for (; min <= max; min++) {
          const segment = segments[min];
          result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
        }
        return result;
      }
      function generatedPosition(map, source, line, column, bias, all) {
        var _a, _b;
        line--;
        if (line < 0) throw new Error(LINE_GTR_ZERO);
        if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
        const { sources, resolvedSources } = map;
        let sourceIndex2 = sources.indexOf(source);
        if (sourceIndex2 === -1) sourceIndex2 = resolvedSources.indexOf(source);
        if (sourceIndex2 === -1) return all ? [] : GMapping(null, null);
        const bySourceMemos = (_a = cast(map))._bySourceMemos || (_a._bySourceMemos = sources.map(memoizedState));
        const generated = (_b = cast(map))._bySources || (_b._bySources = buildBySources(decodedMappings(map), bySourceMemos));
        const segments = generated[sourceIndex2][line];
        if (segments == null) return all ? [] : GMapping(null, null);
        const memo = bySourceMemos[sourceIndex2];
        if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);
        const index = traceSegmentInternal(segments, memo, line, column, bias);
        if (index === -1) return GMapping(null, null);
        const segment = segments[index];
        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
      }
    });
  }
});

// node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var require_gen_mapping_umd = __commonJS({
  "node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"(exports, module) {
    (function(global4, factory) {
      if (typeof exports === "object" && typeof module !== "undefined") {
        factory(module, require_sourcemap_codec_umd(), require_trace_mapping_umd());
        module.exports = def(module);
      } else if (typeof define === "function" && define.amd) {
        define(["module", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], function(mod) {
          factory.apply(this, arguments);
          mod.exports = def(mod);
        });
      } else {
        const mod = { exports: {} };
        factory(mod, global4.sourcemapCodec, global4.traceMapping);
        global4 = typeof globalThis !== "undefined" ? globalThis : global4 || self;
        global4.genMapping = def(mod);
      }
      function def(m) {
        return "default" in m.exports ? m.exports.default : m.exports;
      }
    })(exports, function(module2, require_sourcemapCodec, require_traceMapping) {
      "use strict";
      var __create = Object.create;
      var __defProp3 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __getProtoOf = Object.getPrototypeOf;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __commonJS2 = (cb, mod) => function __require() {
        return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      };
      var __export2 = (target, all) => {
        for (var name50 in all)
          __defProp3(target, name50, { get: all[name50], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps2(
        // If the importer is in node compatibility mode or this is not an ESM
        // file that has been converted to a CommonJS file using a Babel-
        // compatible transform (i.e. "__esModule" has not been set), then set
        // "default" to the CommonJS "module.exports" for node compatibility.
        isNodeMode || !mod || !mod.__esModule ? __defProp3(target, "default", { value: mod, enumerable: true }) : target,
        mod
      ));
      var __toCommonJS = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
      var require_sourcemap_codec = __commonJS2({
        "umd:@jridgewell/sourcemap-codec"(exports2, module22) {
          module22.exports = require_sourcemapCodec;
        }
      });
      var require_trace_mapping = __commonJS2({
        "umd:@jridgewell/trace-mapping"(exports2, module22) {
          module22.exports = require_traceMapping;
        }
      });
      var gen_mapping_exports = {};
      __export2(gen_mapping_exports, {
        GenMapping: () => GenMapping,
        addMapping: () => addMapping,
        addSegment: () => addSegment,
        allMappings: () => allMappings,
        fromMap: () => fromMap,
        maybeAddMapping: () => maybeAddMapping,
        maybeAddSegment: () => maybeAddSegment,
        setIgnore: () => setIgnore,
        setSourceContent: () => setSourceContent,
        toDecodedMap: () => toDecodedMap,
        toEncodedMap: () => toEncodedMap
      });
      module2.exports = __toCommonJS(gen_mapping_exports);
      var SetArray = class {
        constructor() {
          this._indexes = { __proto__: null };
          this.array = [];
        }
      };
      function cast(set) {
        return set;
      }
      function get(setarr, key) {
        return cast(setarr)._indexes[key];
      }
      function put(setarr, key) {
        const index = get(setarr, key);
        if (index !== void 0) return index;
        const { array, _indexes: indexes } = cast(setarr);
        const length2 = array.push(key);
        return indexes[key] = length2 - 1;
      }
      function remove(setarr, key) {
        const index = get(setarr, key);
        if (index === void 0) return;
        const { array, _indexes: indexes } = cast(setarr);
        for (let i = index + 1; i < array.length; i++) {
          const k = array[i];
          array[i - 1] = k;
          indexes[k]--;
        }
        indexes[key] = void 0;
        array.pop();
      }
      var import_sourcemap_codec2 = __toESM2(require_sourcemap_codec());
      var import_trace_mapping = __toESM2(require_trace_mapping());
      var COLUMN = 0;
      var SOURCES_INDEX = 1;
      var SOURCE_LINE = 2;
      var SOURCE_COLUMN = 3;
      var NAMES_INDEX = 4;
      var NO_NAME = -1;
      var GenMapping = class {
        constructor({ file, sourceRoot } = {}) {
          this._names = new SetArray();
          this._sources = new SetArray();
          this._sourcesContent = [];
          this._mappings = [];
          this.file = file;
          this.sourceRoot = sourceRoot;
          this._ignoreList = new SetArray();
        }
      };
      function cast2(map) {
        return map;
      }
      function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name50, content) {
        return addSegmentInternal(
          false,
          map,
          genLine,
          genColumn,
          source,
          sourceLine,
          sourceColumn,
          name50,
          content
        );
      }
      function addMapping(map, mapping) {
        return addMappingInternal(false, map, mapping);
      }
      var maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name50, content) => {
        return addSegmentInternal(
          true,
          map,
          genLine,
          genColumn,
          source,
          sourceLine,
          sourceColumn,
          name50,
          content
        );
      };
      var maybeAddMapping = (map, mapping) => {
        return addMappingInternal(true, map, mapping);
      };
      function setSourceContent(map, source, content) {
        const {
          _sources: sources,
          _sourcesContent: sourcesContent
          // _originalScopes: originalScopes,
        } = cast2(map);
        const index = put(sources, source);
        sourcesContent[index] = content;
      }
      function setIgnore(map, source, ignore = true) {
        const {
          _sources: sources,
          _sourcesContent: sourcesContent,
          _ignoreList: ignoreList
          // _originalScopes: originalScopes,
        } = cast2(map);
        const index = put(sources, source);
        if (index === sourcesContent.length) sourcesContent[index] = null;
        if (ignore) put(ignoreList, index);
        else remove(ignoreList, index);
      }
      function toDecodedMap(map) {
        const {
          _mappings: mappings,
          _sources: sources,
          _sourcesContent: sourcesContent,
          _names: names,
          _ignoreList: ignoreList
          // _originalScopes: originalScopes,
          // _generatedRanges: generatedRanges,
        } = cast2(map);
        removeEmptyFinalLines(mappings);
        return {
          version: 3,
          file: map.file || void 0,
          names: names.array,
          sourceRoot: map.sourceRoot || void 0,
          sources: sources.array,
          sourcesContent,
          mappings,
          // originalScopes,
          // generatedRanges,
          ignoreList: ignoreList.array
        };
      }
      function toEncodedMap(map) {
        const decoded = toDecodedMap(map);
        return Object.assign({}, decoded, {
          // originalScopes: decoded.originalScopes.map((os) => encodeOriginalScopes(os)),
          // generatedRanges: encodeGeneratedRanges(decoded.generatedRanges as GeneratedRange[]),
          mappings: (0, import_sourcemap_codec2.encode)(decoded.mappings)
        });
      }
      function fromMap(input) {
        const map = new import_trace_mapping.TraceMap(input);
        const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
        putAll(cast2(gen)._names, map.names);
        putAll(cast2(gen)._sources, map.sources);
        cast2(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);
        cast2(gen)._mappings = (0, import_trace_mapping.decodedMappings)(map);
        if (map.ignoreList) putAll(cast2(gen)._ignoreList, map.ignoreList);
        return gen;
      }
      function allMappings(map) {
        const out = [];
        const { _mappings: mappings, _sources: sources, _names: names } = cast2(map);
        for (let i = 0; i < mappings.length; i++) {
          const line = mappings[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const generated = { line: i + 1, column: seg[COLUMN] };
            let source = void 0;
            let original = void 0;
            let name50 = void 0;
            if (seg.length !== 1) {
              source = sources.array[seg[SOURCES_INDEX]];
              original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };
              if (seg.length === 5) name50 = names.array[seg[NAMES_INDEX]];
            }
            out.push({ generated, source, original, name: name50 });
          }
        }
        return out;
      }
      function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name50, content) {
        const {
          _mappings: mappings,
          _sources: sources,
          _sourcesContent: sourcesContent,
          _names: names
          // _originalScopes: originalScopes,
        } = cast2(map);
        const line = getIndex(mappings, genLine);
        const index = getColumnIndex(line, genColumn);
        if (!source) {
          if (skipable && skipSourceless(line, index)) return;
          return insert(line, index, [genColumn]);
        }
        assert(sourceLine);
        assert(sourceColumn);
        const sourcesIndex = put(sources, source);
        const namesIndex = name50 ? put(names, name50) : NO_NAME;
        if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content != null ? content : null;
        if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
          return;
        }
        return insert(
          line,
          index,
          name50 ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]
        );
      }
      function assert(_val) {
      }
      function getIndex(arr, index) {
        for (let i = arr.length; i <= index; i++) {
          arr[i] = [];
        }
        return arr[index];
      }
      function getColumnIndex(line, genColumn) {
        let index = line.length;
        for (let i = index - 1; i >= 0; index = i--) {
          const current = line[i];
          if (genColumn >= current[COLUMN]) break;
        }
        return index;
      }
      function insert(array, index, value) {
        for (let i = array.length; i > index; i--) {
          array[i] = array[i - 1];
        }
        array[index] = value;
      }
      function removeEmptyFinalLines(mappings) {
        const { length: length2 } = mappings;
        let len = length2;
        for (let i = len - 1; i >= 0; len = i, i--) {
          if (mappings[i].length > 0) break;
        }
        if (len < length2) mappings.length = len;
      }
      function putAll(setarr, array) {
        for (let i = 0; i < array.length; i++) put(setarr, array[i]);
      }
      function skipSourceless(line, index) {
        if (index === 0) return true;
        const prev = line[index - 1];
        return prev.length === 1;
      }
      function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
        if (index === 0) return false;
        const prev = line[index - 1];
        if (prev.length === 1) return false;
        return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
      }
      function addMappingInternal(skipable, map, mapping) {
        const { generated, source, original, name: name50, content } = mapping;
        if (!source) {
          return addSegmentInternal(
            skipable,
            map,
            generated.line - 1,
            generated.column,
            null,
            null,
            null,
            null,
            null
          );
        }
        assert(original);
        return addSegmentInternal(
          skipable,
          map,
          generated.line - 1,
          generated.column,
          source,
          original.line - 1,
          original.column,
          name50,
          content
        );
      }
    });
  }
});

// node_modules/@babel/generator/lib/source-map.js
var require_source_map = __commonJS({
  "node_modules/@babel/generator/lib/source-map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _genMapping = require_gen_mapping_umd();
    var _traceMapping = require_trace_mapping_umd();
    var SourceMap2 = class {
      constructor(opts, code2) {
        var _opts$sourceFileName;
        this._map = void 0;
        this._rawMappings = void 0;
        this._sourceFileName = void 0;
        this._lastGenLine = 0;
        this._lastSourceLine = 0;
        this._lastSourceColumn = 0;
        this._inputMap = null;
        const map = this._map = new _genMapping.GenMapping({
          sourceRoot: opts.sourceRoot
        });
        this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\/g, "/");
        this._rawMappings = void 0;
        if (opts.inputSourceMap) {
          this._inputMap = new _traceMapping.TraceMap(opts.inputSourceMap);
          const resolvedSources = this._inputMap.resolvedSources;
          if (resolvedSources.length) {
            for (let i = 0; i < resolvedSources.length; i++) {
              var _this$_inputMap$sourc;
              (0, _genMapping.setSourceContent)(map, resolvedSources[i], (_this$_inputMap$sourc = this._inputMap.sourcesContent) == null ? void 0 : _this$_inputMap$sourc[i]);
            }
          }
        }
        if (typeof code2 === "string" && !opts.inputSourceMap) {
          (0, _genMapping.setSourceContent)(map, this._sourceFileName, code2);
        } else if (typeof code2 === "object") {
          for (const sourceFileName of Object.keys(code2)) {
            (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\/g, "/"), code2[sourceFileName]);
          }
        }
      }
      get() {
        return (0, _genMapping.toEncodedMap)(this._map);
      }
      getDecoded() {
        return (0, _genMapping.toDecodedMap)(this._map);
      }
      getRawMappings() {
        return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));
      }
      mark(generated, line, column, identifierName, identifierNamePos, filename) {
        var _originalMapping;
        this._rawMappings = void 0;
        let originalMapping;
        if (line != null) {
          if (this._inputMap) {
            originalMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, {
              line,
              column
            });
            if (!originalMapping.name && identifierNamePos) {
              const originalIdentifierMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, identifierNamePos);
              if (originalIdentifierMapping.name) {
                identifierName = originalIdentifierMapping.name;
              }
            }
          } else {
            originalMapping = {
              name: null,
              source: (filename == null ? void 0 : filename.replace(/\\/g, "/")) || this._sourceFileName,
              line,
              column
            };
          }
        }
        (0, _genMapping.maybeAddMapping)(this._map, {
          name: identifierName,
          generated,
          source: (_originalMapping = originalMapping) == null ? void 0 : _originalMapping.source,
          original: originalMapping
        });
      }
    };
    exports.default = SourceMap2;
  }
});

// node_modules/@babel/generator/lib/buffer.js
var require_buffer = __commonJS({
  "node_modules/@babel/generator/lib/buffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var Buffer2 = class {
      constructor(map, indentChar) {
        this._map = null;
        this._buf = "";
        this._str = "";
        this._appendCount = 0;
        this._last = 0;
        this._queue = [];
        this._queueCursor = 0;
        this._canMarkIdName = true;
        this._indentChar = "";
        this._fastIndentations = [];
        this._position = {
          line: 1,
          column: 0
        };
        this._sourcePosition = {
          identifierName: void 0,
          identifierNamePos: void 0,
          line: void 0,
          column: void 0,
          filename: void 0
        };
        this._map = map;
        this._indentChar = indentChar;
        for (let i = 0; i < 64; i++) {
          this._fastIndentations.push(indentChar.repeat(i));
        }
        this._allocQueue();
      }
      _allocQueue() {
        const queue = this._queue;
        for (let i = 0; i < 16; i++) {
          queue.push({
            char: 0,
            repeat: 1,
            line: void 0,
            column: void 0,
            identifierName: void 0,
            identifierNamePos: void 0,
            filename: ""
          });
        }
      }
      _pushQueue(char, repeat, line, column, filename) {
        const cursor = this._queueCursor;
        if (cursor === this._queue.length) {
          this._allocQueue();
        }
        const item = this._queue[cursor];
        item.char = char;
        item.repeat = repeat;
        item.line = line;
        item.column = column;
        item.filename = filename;
        this._queueCursor++;
      }
      _popQueue() {
        if (this._queueCursor === 0) {
          throw new Error("Cannot pop from empty queue");
        }
        return this._queue[--this._queueCursor];
      }
      get() {
        this._flush();
        const map = this._map;
        const result = {
          code: (this._buf + this._str).trimRight(),
          decodedMap: map == null ? void 0 : map.getDecoded(),
          get __mergedMap() {
            return this.map;
          },
          get map() {
            const resultMap = map ? map.get() : null;
            result.map = resultMap;
            return resultMap;
          },
          set map(value) {
            Object.defineProperty(result, "map", {
              value,
              writable: true
            });
          },
          get rawMappings() {
            const mappings = map == null ? void 0 : map.getRawMappings();
            result.rawMappings = mappings;
            return mappings;
          },
          set rawMappings(value) {
            Object.defineProperty(result, "rawMappings", {
              value,
              writable: true
            });
          }
        };
        return result;
      }
      append(str, maybeNewline) {
        this._flush();
        this._append(str, this._sourcePosition, maybeNewline);
      }
      appendChar(char) {
        this._flush();
        this._appendChar(char, 1, this._sourcePosition);
      }
      queue(char) {
        if (char === 10) {
          while (this._queueCursor !== 0) {
            const char2 = this._queue[this._queueCursor - 1].char;
            if (char2 !== 32 && char2 !== 9) {
              break;
            }
            this._queueCursor--;
          }
        }
        const sourcePosition = this._sourcePosition;
        this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);
      }
      queueIndentation(repeat) {
        if (repeat === 0) return;
        this._pushQueue(-1, repeat, void 0, void 0, void 0);
      }
      _flush() {
        const queueCursor = this._queueCursor;
        const queue = this._queue;
        for (let i = 0; i < queueCursor; i++) {
          const item = queue[i];
          this._appendChar(item.char, item.repeat, item);
        }
        this._queueCursor = 0;
      }
      _appendChar(char, repeat, sourcePos) {
        this._last = char;
        if (char === -1) {
          const fastIndentation = this._fastIndentations[repeat];
          if (fastIndentation !== void 0) {
            this._str += fastIndentation;
          } else {
            this._str += repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;
          }
        } else {
          this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);
        }
        if (char !== 10) {
          this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);
          this._position.column += repeat;
        } else {
          this._position.line++;
          this._position.column = 0;
        }
        if (this._canMarkIdName) {
          sourcePos.identifierName = void 0;
          sourcePos.identifierNamePos = void 0;
        }
      }
      _append(str, sourcePos, maybeNewline) {
        const len = str.length;
        const position3 = this._position;
        this._last = str.charCodeAt(len - 1);
        if (++this._appendCount > 4096) {
          +this._str;
          this._buf += this._str;
          this._str = str;
          this._appendCount = 0;
        } else {
          this._str += str;
        }
        if (!maybeNewline && !this._map) {
          position3.column += len;
          return;
        }
        const {
          column,
          identifierName,
          identifierNamePos,
          filename
        } = sourcePos;
        let line = sourcePos.line;
        if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {
          sourcePos.identifierName = void 0;
          sourcePos.identifierNamePos = void 0;
        }
        let i = str.indexOf("\n");
        let last = 0;
        if (i !== 0) {
          this._mark(line, column, identifierName, identifierNamePos, filename);
        }
        while (i !== -1) {
          position3.line++;
          position3.column = 0;
          last = i + 1;
          if (last < len && line !== void 0) {
            this._mark(++line, 0, void 0, void 0, filename);
          }
          i = str.indexOf("\n", last);
        }
        position3.column += len - last;
      }
      _mark(line, column, identifierName, identifierNamePos, filename) {
        var _this$_map;
        (_this$_map = this._map) == null || _this$_map.mark(this._position, line, column, identifierName, identifierNamePos, filename);
      }
      removeTrailingNewline() {
        const queueCursor = this._queueCursor;
        if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {
          this._queueCursor--;
        }
      }
      removeLastSemicolon() {
        const queueCursor = this._queueCursor;
        if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {
          this._queueCursor--;
        }
      }
      getLastChar() {
        const queueCursor = this._queueCursor;
        return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;
      }
      getNewlineCount() {
        const queueCursor = this._queueCursor;
        let count = 0;
        if (queueCursor === 0) return this._last === 10 ? 1 : 0;
        for (let i = queueCursor - 1; i >= 0; i--) {
          if (this._queue[i].char !== 10) {
            break;
          }
          count++;
        }
        return count === queueCursor && this._last === 10 ? count + 1 : count;
      }
      endsWithCharAndNewline() {
        const queue = this._queue;
        const queueCursor = this._queueCursor;
        if (queueCursor !== 0) {
          const lastCp = queue[queueCursor - 1].char;
          if (lastCp !== 10) return;
          if (queueCursor > 1) {
            return queue[queueCursor - 2].char;
          } else {
            return this._last;
          }
        }
      }
      hasContent() {
        return this._queueCursor !== 0 || !!this._last;
      }
      exactSource(loc, cb) {
        if (!this._map) {
          cb();
          return;
        }
        this.source("start", loc);
        const identifierName = loc.identifierName;
        const sourcePos = this._sourcePosition;
        if (identifierName) {
          this._canMarkIdName = false;
          sourcePos.identifierName = identifierName;
        }
        cb();
        if (identifierName) {
          this._canMarkIdName = true;
          sourcePos.identifierName = void 0;
          sourcePos.identifierNamePos = void 0;
        }
        this.source("end", loc);
      }
      source(prop, loc) {
        if (!this._map) return;
        this._normalizePosition(prop, loc, 0);
      }
      sourceWithOffset(prop, loc, columnOffset) {
        if (!this._map) return;
        this._normalizePosition(prop, loc, columnOffset);
      }
      _normalizePosition(prop, loc, columnOffset) {
        const pos = loc[prop];
        const target = this._sourcePosition;
        if (pos) {
          target.line = pos.line;
          target.column = Math.max(pos.column + columnOffset, 0);
          target.filename = loc.filename;
        }
      }
      getCurrentColumn() {
        const queue = this._queue;
        const queueCursor = this._queueCursor;
        let lastIndex = -1;
        let len = 0;
        for (let i = 0; i < queueCursor; i++) {
          const item = queue[i];
          if (item.char === 10) {
            lastIndex = len;
          }
          len += item.repeat;
        }
        return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;
      }
      getCurrentLine() {
        let count = 0;
        const queue = this._queue;
        for (let i = 0; i < this._queueCursor; i++) {
          if (queue[i].char === 10) {
            count++;
          }
        }
        return this._position.line + count;
      }
    };
    exports.default = Buffer2;
  }
});

// node_modules/@babel/generator/lib/node/whitespace.js
var require_whitespace = __commonJS({
  "node_modules/@babel/generator/lib/node/whitespace.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.nodes = void 0;
    var _t = require_lib4();
    var {
      FLIPPED_ALIAS_KEYS,
      isArrayExpression,
      isAssignmentExpression,
      isBinary,
      isBlockStatement,
      isCallExpression,
      isFunction,
      isIdentifier,
      isLiteral,
      isMemberExpression,
      isObjectExpression,
      isOptionalCallExpression,
      isOptionalMemberExpression,
      isStringLiteral
    } = _t;
    function crawlInternal(node, state) {
      if (!node) return state;
      if (isMemberExpression(node) || isOptionalMemberExpression(node)) {
        crawlInternal(node.object, state);
        if (node.computed) crawlInternal(node.property, state);
      } else if (isBinary(node) || isAssignmentExpression(node)) {
        crawlInternal(node.left, state);
        crawlInternal(node.right, state);
      } else if (isCallExpression(node) || isOptionalCallExpression(node)) {
        state.hasCall = true;
        crawlInternal(node.callee, state);
      } else if (isFunction(node)) {
        state.hasFunction = true;
      } else if (isIdentifier(node)) {
        state.hasHelper = state.hasHelper || node.callee && isHelper(node.callee);
      }
      return state;
    }
    function crawl(node) {
      return crawlInternal(node, {
        hasCall: false,
        hasFunction: false,
        hasHelper: false
      });
    }
    function isHelper(node) {
      if (!node) return false;
      if (isMemberExpression(node)) {
        return isHelper(node.object) || isHelper(node.property);
      } else if (isIdentifier(node)) {
        return node.name === "require" || node.name.charCodeAt(0) === 95;
      } else if (isCallExpression(node)) {
        return isHelper(node.callee);
      } else if (isBinary(node) || isAssignmentExpression(node)) {
        return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
      } else {
        return false;
      }
    }
    function isType2(node) {
      return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);
    }
    var nodes = exports.nodes = {
      AssignmentExpression(node) {
        const state = crawl(node.right);
        if (state.hasCall && state.hasHelper || state.hasFunction) {
          return state.hasFunction ? 1 | 2 : 2;
        }
        return 0;
      },
      SwitchCase(node, parent) {
        return (!!node.consequent.length || parent.cases[0] === node ? 1 : 0) | (!node.consequent.length && parent.cases[parent.cases.length - 1] === node ? 2 : 0);
      },
      LogicalExpression(node) {
        if (isFunction(node.left) || isFunction(node.right)) {
          return 2;
        }
        return 0;
      },
      Literal(node) {
        if (isStringLiteral(node) && node.value === "use strict") {
          return 2;
        }
        return 0;
      },
      CallExpression(node) {
        if (isFunction(node.callee) || isHelper(node)) {
          return 1 | 2;
        }
        return 0;
      },
      OptionalCallExpression(node) {
        if (isFunction(node.callee)) {
          return 1 | 2;
        }
        return 0;
      },
      VariableDeclaration(node) {
        for (let i = 0; i < node.declarations.length; i++) {
          const declar = node.declarations[i];
          let enabled = isHelper(declar.id) && !isType2(declar.init);
          if (!enabled && declar.init) {
            const state = crawl(declar.init);
            enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
          }
          if (enabled) {
            return 1 | 2;
          }
        }
        return 0;
      },
      IfStatement(node) {
        if (isBlockStatement(node.consequent)) {
          return 1 | 2;
        }
        return 0;
      }
    };
    nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(node, parent) {
      if (parent.properties[0] === node) {
        return 1;
      }
      return 0;
    };
    nodes.ObjectTypeCallProperty = function(node, parent) {
      var _parent$properties;
      if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {
        return 1;
      }
      return 0;
    };
    nodes.ObjectTypeIndexer = function(node, parent) {
      var _parent$properties2, _parent$callPropertie;
      if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {
        return 1;
      }
      return 0;
    };
    nodes.ObjectTypeInternalSlot = function(node, parent) {
      var _parent$properties3, _parent$callPropertie2, _parent$indexers;
      if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {
        return 1;
      }
      return 0;
    };
    [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function([type, amounts]) {
      [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function(type2) {
        const ret = amounts ? 1 | 2 : 0;
        nodes[type2] = () => ret;
      });
    });
  }
});

// node_modules/@babel/generator/lib/node/parentheses.js
var require_parentheses = __commonJS({
  "node_modules/@babel/generator/lib/node/parentheses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AssignmentExpression = AssignmentExpression;
    exports.Binary = Binary;
    exports.BinaryExpression = BinaryExpression;
    exports.ClassExpression = ClassExpression;
    exports.ArrowFunctionExpression = exports.ConditionalExpression = ConditionalExpression;
    exports.DoExpression = DoExpression;
    exports.FunctionExpression = FunctionExpression;
    exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
    exports.Identifier = Identifier;
    exports.LogicalExpression = LogicalExpression;
    exports.NullableTypeAnnotation = NullableTypeAnnotation;
    exports.ObjectExpression = ObjectExpression;
    exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
    exports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;
    exports.SequenceExpression = SequenceExpression;
    exports.TSSatisfiesExpression = exports.TSAsExpression = TSAsExpression;
    exports.TSConditionalType = TSConditionalType;
    exports.TSConstructorType = exports.TSFunctionType = TSFunctionType;
    exports.TSInferType = TSInferType;
    exports.TSInstantiationExpression = TSInstantiationExpression;
    exports.TSIntersectionType = TSIntersectionType;
    exports.UnaryLike = exports.TSTypeAssertion = UnaryLike;
    exports.TSTypeOperator = TSTypeOperator;
    exports.TSUnionType = TSUnionType;
    exports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;
    exports.UpdateExpression = UpdateExpression;
    exports.AwaitExpression = exports.YieldExpression = YieldExpression;
    var _t = require_lib4();
    var _index = require_node();
    var {
      isArrayTypeAnnotation,
      isBinaryExpression,
      isCallExpression,
      isForOfStatement,
      isIndexedAccessType,
      isMemberExpression,
      isObjectPattern,
      isOptionalMemberExpression,
      isYieldExpression,
      isStatement
    } = _t;
    var PRECEDENCE = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
    function getBinaryPrecedence(node, nodeType) {
      if (nodeType === "BinaryExpression" || nodeType === "LogicalExpression") {
        return PRECEDENCE.get(node.operator);
      }
      if (nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression") {
        return PRECEDENCE.get("in");
      }
    }
    function isTSTypeExpression(nodeType) {
      return nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression" || nodeType === "TSTypeAssertion";
    }
    var isClassExtendsClause = (node, parent) => {
      const parentType = parent.type;
      return (parentType === "ClassDeclaration" || parentType === "ClassExpression") && parent.superClass === node;
    };
    var hasPostfixPart = (node, parent) => {
      const parentType = parent.type;
      return (parentType === "MemberExpression" || parentType === "OptionalMemberExpression") && parent.object === node || (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression") && parent.callee === node || parentType === "TaggedTemplateExpression" && parent.tag === node || parentType === "TSNonNullExpression";
    };
    function NullableTypeAnnotation(node, parent) {
      return isArrayTypeAnnotation(parent);
    }
    function FunctionTypeAnnotation(node, parent, tokenContext) {
      const parentType = parent.type;
      return parentType === "UnionTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "ArrayTypeAnnotation" || Boolean(tokenContext & _index.TokenContext.arrowFlowReturnType);
    }
    function UpdateExpression(node, parent) {
      return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
    }
    function needsParenBeforeExpressionBrace(tokenContext) {
      return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.arrowBody));
    }
    function ObjectExpression(node, parent, tokenContext) {
      return needsParenBeforeExpressionBrace(tokenContext);
    }
    function DoExpression(node, parent, tokenContext) {
      return !node.async && Boolean(tokenContext & _index.TokenContext.expressionStatement);
    }
    function Binary(node, parent) {
      const parentType = parent.type;
      if (node.type === "BinaryExpression" && node.operator === "**" && parentType === "BinaryExpression" && parent.operator === "**") {
        return parent.left === node;
      }
      if (isClassExtendsClause(node, parent)) {
        return true;
      }
      if (hasPostfixPart(node, parent) || parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "AwaitExpression") {
        return true;
      }
      const parentPos = getBinaryPrecedence(parent, parentType);
      if (parentPos != null) {
        const nodePos = getBinaryPrecedence(node, node.type);
        if (parentPos === nodePos && parentType === "BinaryExpression" && parent.right === node || parentPos > nodePos) {
          return true;
        }
      }
    }
    function UnionTypeAnnotation(node, parent) {
      const parentType = parent.type;
      return parentType === "ArrayTypeAnnotation" || parentType === "NullableTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "UnionTypeAnnotation";
    }
    function OptionalIndexedAccessType(node, parent) {
      return isIndexedAccessType(parent) && parent.objectType === node;
    }
    function TSAsExpression(node, parent) {
      if ((parent.type === "AssignmentExpression" || parent.type === "AssignmentPattern") && parent.left === node) {
        return true;
      }
      if (parent.type === "BinaryExpression" && (parent.operator === "|" || parent.operator === "&") && node === parent.left) {
        return true;
      }
      return Binary(node, parent);
    }
    function TSConditionalType(node, parent) {
      const parentType = parent.type;
      if (parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType" || parentType === "TSTypeOperator" || parentType === "TSTypeParameter") {
        return true;
      }
      if ((parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node) {
        return true;
      }
      if (parentType === "TSConditionalType" && (parent.checkType === node || parent.extendsType === node)) {
        return true;
      }
      return false;
    }
    function TSUnionType(node, parent) {
      const parentType = parent.type;
      return parentType === "TSIntersectionType" || parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
    }
    function TSIntersectionType(node, parent) {
      const parentType = parent.type;
      return parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
    }
    function TSInferType(node, parent) {
      const parentType = parent.type;
      if (parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType") {
        return true;
      }
      if (node.typeParameter.constraint) {
        if ((parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node) {
          return true;
        }
      }
      return false;
    }
    function TSTypeOperator(node, parent) {
      const parentType = parent.type;
      return parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
    }
    function TSInstantiationExpression(node, parent) {
      const parentType = parent.type;
      return (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression" || parentType === "TSInstantiationExpression") && !!parent.typeParameters;
    }
    function TSFunctionType(node, parent) {
      const parentType = parent.type;
      return parentType === "TSIntersectionType" || parentType === "TSUnionType" || parentType === "TSTypeOperator" || parentType === "TSOptionalType" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSConditionalType" && (parent.checkType === node || parent.extendsType === node);
    }
    function BinaryExpression(node, parent, tokenContext) {
      return node.operator === "in" && Boolean(tokenContext & _index.TokenContext.forInOrInitHeadAccumulate);
    }
    function SequenceExpression(node, parent) {
      const parentType = parent.type;
      if (parentType === "SequenceExpression" || parentType === "ParenthesizedExpression" || parentType === "MemberExpression" && parent.property === node || parentType === "OptionalMemberExpression" && parent.property === node || parentType === "TemplateLiteral") {
        return false;
      }
      if (parentType === "ClassDeclaration") {
        return true;
      }
      if (parentType === "ForOfStatement") {
        return parent.right === node;
      }
      if (parentType === "ExportDefaultDeclaration") {
        return true;
      }
      return !isStatement(parent);
    }
    function YieldExpression(node, parent) {
      const parentType = parent.type;
      return parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "UnaryExpression" || parentType === "SpreadElement" || hasPostfixPart(node, parent) || parentType === "AwaitExpression" && isYieldExpression(node) || parentType === "ConditionalExpression" && node === parent.test || isClassExtendsClause(node, parent) || isTSTypeExpression(parentType);
    }
    function ClassExpression(node, parent, tokenContext) {
      return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
    }
    function UnaryLike(node, parent) {
      return hasPostfixPart(node, parent) || isBinaryExpression(parent) && parent.operator === "**" && parent.left === node || isClassExtendsClause(node, parent);
    }
    function FunctionExpression(node, parent, tokenContext) {
      return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
    }
    function ConditionalExpression(node, parent) {
      const parentType = parent.type;
      if (parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "ConditionalExpression" && parent.test === node || parentType === "AwaitExpression" || isTSTypeExpression(parentType)) {
        return true;
      }
      return UnaryLike(node, parent);
    }
    function OptionalMemberExpression(node, parent) {
      return isCallExpression(parent) && parent.callee === node || isMemberExpression(parent) && parent.object === node;
    }
    function AssignmentExpression(node, parent, tokenContext) {
      if (needsParenBeforeExpressionBrace(tokenContext) && isObjectPattern(node.left)) {
        return true;
      } else {
        return ConditionalExpression(node, parent);
      }
    }
    function LogicalExpression(node, parent) {
      const parentType = parent.type;
      if (isTSTypeExpression(parentType)) return true;
      if (parentType !== "LogicalExpression") return false;
      switch (node.operator) {
        case "||":
          return parent.operator === "??" || parent.operator === "&&";
        case "&&":
          return parent.operator === "??";
        case "??":
          return parent.operator !== "??";
      }
    }
    function Identifier(node, parent, tokenContext, getRawIdentifier) {
      var _node$extra;
      const parentType = parent.type;
      if ((_node$extra = node.extra) != null && _node$extra.parenthesized && parentType === "AssignmentExpression" && parent.left === node) {
        const rightType = parent.right.type;
        if ((rightType === "FunctionExpression" || rightType === "ClassExpression") && parent.right.id == null) {
          return true;
        }
      }
      if (getRawIdentifier && getRawIdentifier(node) !== node.name) {
        return false;
      }
      if (node.name === "let") {
        const isFollowedByBracket = isMemberExpression(parent, {
          object: node,
          computed: true
        }) || isOptionalMemberExpression(parent, {
          object: node,
          computed: true,
          optional: false
        });
        if (isFollowedByBracket && tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.forInitHead | _index.TokenContext.forInHead)) {
          return true;
        }
        return Boolean(tokenContext & _index.TokenContext.forOfHead);
      }
      return node.name === "async" && isForOfStatement(parent, {
        left: node,
        await: false
      });
    }
  }
});

// node_modules/@babel/generator/lib/node/index.js
var require_node = __commonJS({
  "node_modules/@babel/generator/lib/node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TokenContext = void 0;
    exports.isLastChild = isLastChild;
    exports.needsParens = needsParens;
    exports.needsWhitespace = needsWhitespace;
    exports.needsWhitespaceAfter = needsWhitespaceAfter;
    exports.needsWhitespaceBefore = needsWhitespaceBefore;
    var whitespace = require_whitespace();
    var parens = require_parentheses();
    var _t = require_lib4();
    var {
      FLIPPED_ALIAS_KEYS,
      VISITOR_KEYS,
      isCallExpression,
      isDecorator,
      isExpressionStatement,
      isMemberExpression,
      isNewExpression,
      isParenthesizedExpression
    } = _t;
    var TokenContext = exports.TokenContext = {
      normal: 0,
      expressionStatement: 1,
      arrowBody: 2,
      exportDefault: 4,
      arrowFlowReturnType: 8,
      forInitHead: 16,
      forInHead: 32,
      forOfHead: 64,
      forInOrInitHeadAccumulate: 128,
      forInOrInitHeadAccumulatePassThroughMask: 128
    };
    function expandAliases(obj) {
      const map = /* @__PURE__ */ new Map();
      function add2(type, func) {
        const fn = map.get(type);
        map.set(type, fn ? function(node, parent, stack, getRawIdentifier) {
          var _fn;
          return (_fn = fn(node, parent, stack, getRawIdentifier)) != null ? _fn : func(node, parent, stack, getRawIdentifier);
        } : func);
      }
      for (const type of Object.keys(obj)) {
        const aliases = FLIPPED_ALIAS_KEYS[type];
        if (aliases) {
          for (const alias of aliases) {
            add2(alias, obj[type]);
          }
        } else {
          add2(type, obj[type]);
        }
      }
      return map;
    }
    var expandedParens = expandAliases(parens);
    var expandedWhitespaceNodes = expandAliases(whitespace.nodes);
    function isOrHasCallExpression(node) {
      if (isCallExpression(node)) {
        return true;
      }
      return isMemberExpression(node) && isOrHasCallExpression(node.object);
    }
    function needsWhitespace(node, parent, type) {
      var _expandedWhitespaceNo;
      if (!node) return false;
      if (isExpressionStatement(node)) {
        node = node.expression;
      }
      const flag = (_expandedWhitespaceNo = expandedWhitespaceNodes.get(node.type)) == null ? void 0 : _expandedWhitespaceNo(node, parent);
      if (typeof flag === "number") {
        return (flag & type) !== 0;
      }
      return false;
    }
    function needsWhitespaceBefore(node, parent) {
      return needsWhitespace(node, parent, 1);
    }
    function needsWhitespaceAfter(node, parent) {
      return needsWhitespace(node, parent, 2);
    }
    function needsParens(node, parent, tokenContext, getRawIdentifier) {
      var _expandedParens$get;
      if (!parent) return false;
      if (isNewExpression(parent) && parent.callee === node) {
        if (isOrHasCallExpression(node)) return true;
      }
      if (isDecorator(parent)) {
        return !isDecoratorMemberExpression(node) && !(isCallExpression(node) && isDecoratorMemberExpression(node.callee)) && !isParenthesizedExpression(node);
      }
      return ((_expandedParens$get = expandedParens.get(node.type)) == null ? void 0 : _expandedParens$get(node, parent, tokenContext, getRawIdentifier)) || false;
    }
    function isDecoratorMemberExpression(node) {
      switch (node.type) {
        case "Identifier":
          return true;
        case "MemberExpression":
          return !node.computed && node.property.type === "Identifier" && isDecoratorMemberExpression(node.object);
        default:
          return false;
      }
    }
    function isLastChild(parent, child) {
      const visitorKeys = VISITOR_KEYS[parent.type];
      for (let i = visitorKeys.length - 1; i >= 0; i--) {
        const val = parent[visitorKeys[i]];
        if (val === child) {
          return true;
        } else if (Array.isArray(val)) {
          let j = val.length - 1;
          while (j >= 0 && val[j] === null) j--;
          return j >= 0 && val[j] === child;
        } else if (val) {
          return false;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/generator/lib/token-map.js
var require_token_map = __commonJS({
  "node_modules/@babel/generator/lib/token-map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TokenMap = void 0;
    var _t = require_lib4();
    var {
      traverseFast,
      VISITOR_KEYS
    } = _t;
    var TokenMap = class {
      constructor(ast, tokens, source) {
        this._tokens = void 0;
        this._source = void 0;
        this._nodesToTokenIndexes = /* @__PURE__ */ new Map();
        this._nodesOccurrencesCountCache = /* @__PURE__ */ new Map();
        this._tokensCache = /* @__PURE__ */ new Map();
        this._tokens = tokens;
        this._source = source;
        traverseFast(ast, (node) => {
          const indexes = this._getTokensIndexesOfNode(node);
          if (indexes.length > 0) this._nodesToTokenIndexes.set(node, indexes);
        });
        this._tokensCache.clear();
      }
      has(node) {
        return this._nodesToTokenIndexes.has(node);
      }
      getIndexes(node) {
        return this._nodesToTokenIndexes.get(node);
      }
      find(node, condition) {
        const indexes = this._nodesToTokenIndexes.get(node);
        if (indexes) {
          for (let k = 0; k < indexes.length; k++) {
            const index = indexes[k];
            const tok = this._tokens[index];
            if (condition(tok, index)) return tok;
          }
        }
        return null;
      }
      findLastIndex(node, condition) {
        const indexes = this._nodesToTokenIndexes.get(node);
        if (indexes) {
          for (let k = indexes.length - 1; k >= 0; k--) {
            const index = indexes[k];
            const tok = this._tokens[index];
            if (condition(tok, index)) return index;
          }
        }
        return -1;
      }
      findMatching(node, test, occurrenceCount = 0) {
        const indexes = this._nodesToTokenIndexes.get(node);
        if (indexes) {
          let i = 0;
          const count = occurrenceCount;
          if (count > 1) {
            const cache = this._nodesOccurrencesCountCache.get(node);
            if ((cache == null ? void 0 : cache.test) === test && cache.count < count) {
              i = cache.i + 1;
              occurrenceCount -= cache.count + 1;
            }
          }
          for (; i < indexes.length; i++) {
            const tok = this._tokens[indexes[i]];
            if (this.matchesOriginal(tok, test)) {
              if (occurrenceCount === 0) {
                if (count > 0) {
                  this._nodesOccurrencesCountCache.set(node, {
                    test,
                    count,
                    i
                  });
                }
                return tok;
              }
              occurrenceCount--;
            }
          }
        }
        return null;
      }
      matchesOriginal(token, test) {
        if (token.end - token.start !== test.length) return false;
        if (token.value != null) return token.value === test;
        return this._source.startsWith(test, token.start);
      }
      startMatches(node, test) {
        const indexes = this._nodesToTokenIndexes.get(node);
        if (!indexes) return false;
        const tok = this._tokens[indexes[0]];
        if (tok.start !== node.start) return false;
        return this.matchesOriginal(tok, test);
      }
      endMatches(node, test) {
        const indexes = this._nodesToTokenIndexes.get(node);
        if (!indexes) return false;
        const tok = this._tokens[indexes[indexes.length - 1]];
        if (tok.end !== node.end) return false;
        return this.matchesOriginal(tok, test);
      }
      _getTokensIndexesOfNode(node) {
        var _node$declaration;
        if (node.start == null || node.end == null) return [];
        const {
          first,
          last
        } = this._findTokensOfNode(node, 0, this._tokens.length - 1);
        let low = first;
        const children = childrenIterator(node);
        if ((node.type === "ExportNamedDeclaration" || node.type === "ExportDefaultDeclaration") && ((_node$declaration = node.declaration) == null ? void 0 : _node$declaration.type) === "ClassDeclaration") {
          children.next();
        }
        const indexes = [];
        for (const child of children) {
          if (child == null) continue;
          if (child.start == null || child.end == null) continue;
          const childTok = this._findTokensOfNode(child, low, last);
          const high = childTok.first;
          for (let k = low; k < high; k++) indexes.push(k);
          low = childTok.last + 1;
        }
        for (let k = low; k <= last; k++) indexes.push(k);
        return indexes;
      }
      _findTokensOfNode(node, low, high) {
        const cached = this._tokensCache.get(node);
        if (cached) return cached;
        const first = this._findFirstTokenOfNode(node.start, low, high);
        const last = this._findLastTokenOfNode(node.end, first, high);
        this._tokensCache.set(node, {
          first,
          last
        });
        return {
          first,
          last
        };
      }
      _findFirstTokenOfNode(start, low, high) {
        while (low <= high) {
          const mid = high + low >> 1;
          if (start < this._tokens[mid].start) {
            high = mid - 1;
          } else if (start > this._tokens[mid].start) {
            low = mid + 1;
          } else {
            return mid;
          }
        }
        return low;
      }
      _findLastTokenOfNode(end, low, high) {
        while (low <= high) {
          const mid = high + low >> 1;
          if (end < this._tokens[mid].end) {
            high = mid - 1;
          } else if (end > this._tokens[mid].end) {
            low = mid + 1;
          } else {
            return mid;
          }
        }
        return high;
      }
    };
    exports.TokenMap = TokenMap;
    function* childrenIterator(node) {
      if (node.type === "TemplateLiteral") {
        yield node.quasis[0];
        for (let i = 1; i < node.quasis.length; i++) {
          yield node.expressions[i - 1];
          yield node.quasis[i];
        }
        return;
      }
      const keys = VISITOR_KEYS[node.type];
      for (const key of keys) {
        const child = node[key];
        if (!child) continue;
        if (Array.isArray(child)) {
          yield* child;
        } else {
          yield child;
        }
      }
    }
  }
});

// node_modules/@babel/generator/lib/generators/template-literals.js
var require_template_literals = __commonJS({
  "node_modules/@babel/generator/lib/generators/template-literals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TaggedTemplateExpression = TaggedTemplateExpression;
    exports.TemplateElement = TemplateElement;
    exports.TemplateLiteral = TemplateLiteral;
    exports._printTemplate = _printTemplate;
    function TaggedTemplateExpression(node) {
      this.print(node.tag);
      this.print(node.typeParameters);
      this.print(node.quasi);
    }
    function TemplateElement() {
      throw new Error("TemplateElement printing is handled in TemplateLiteral");
    }
    function _printTemplate(node, substitutions) {
      const quasis = node.quasis;
      let partRaw = "`";
      for (let i = 0; i < quasis.length - 1; i++) {
        partRaw += quasis[i].value.raw;
        this.token(partRaw + "${", true);
        this.print(substitutions[i]);
        partRaw = "}";
        if (this.tokenMap) {
          const token = this.tokenMap.findMatching(node, "}", i);
          if (token) this._catchUpTo(token.loc.start);
        }
      }
      partRaw += quasis[quasis.length - 1].value.raw;
      this.token(partRaw + "`", true);
    }
    function TemplateLiteral(node) {
      this._printTemplate(node, node.expressions);
    }
  }
});

// node_modules/@babel/generator/lib/generators/expressions.js
var require_expressions = __commonJS({
  "node_modules/@babel/generator/lib/generators/expressions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;
    exports.AssignmentPattern = AssignmentPattern;
    exports.AwaitExpression = AwaitExpression;
    exports.BindExpression = BindExpression;
    exports.CallExpression = CallExpression;
    exports.ConditionalExpression = ConditionalExpression;
    exports.Decorator = Decorator;
    exports.DoExpression = DoExpression;
    exports.EmptyStatement = EmptyStatement;
    exports.ExpressionStatement = ExpressionStatement;
    exports.Import = Import;
    exports.MemberExpression = MemberExpression;
    exports.MetaProperty = MetaProperty;
    exports.ModuleExpression = ModuleExpression;
    exports.NewExpression = NewExpression;
    exports.OptionalCallExpression = OptionalCallExpression;
    exports.OptionalMemberExpression = OptionalMemberExpression;
    exports.ParenthesizedExpression = ParenthesizedExpression;
    exports.PrivateName = PrivateName;
    exports.SequenceExpression = SequenceExpression;
    exports.Super = Super;
    exports.ThisExpression = ThisExpression;
    exports.UnaryExpression = UnaryExpression;
    exports.UpdateExpression = UpdateExpression;
    exports.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
    exports.YieldExpression = YieldExpression;
    exports._shouldPrintDecoratorsBeforeExport = _shouldPrintDecoratorsBeforeExport;
    var _t = require_lib4();
    var _index = require_node();
    var {
      isCallExpression,
      isLiteral,
      isMemberExpression,
      isNewExpression,
      isPattern
    } = _t;
    function UnaryExpression(node) {
      const {
        operator
      } = node;
      if (operator === "void" || operator === "delete" || operator === "typeof" || operator === "throw") {
        this.word(operator);
        this.space();
      } else {
        this.token(operator);
      }
      this.print(node.argument);
    }
    function DoExpression(node) {
      if (node.async) {
        this.word("async", true);
        this.space();
      }
      this.word("do");
      this.space();
      this.print(node.body);
    }
    function ParenthesizedExpression(node) {
      this.tokenChar(40);
      const exit = this.enterDelimited();
      this.print(node.expression);
      exit();
      this.rightParens(node);
    }
    function UpdateExpression(node) {
      if (node.prefix) {
        this.token(node.operator);
        this.print(node.argument);
      } else {
        this.print(node.argument, true);
        this.token(node.operator);
      }
    }
    function ConditionalExpression(node) {
      this.print(node.test);
      this.space();
      this.tokenChar(63);
      this.space();
      this.print(node.consequent);
      this.space();
      this.tokenChar(58);
      this.space();
      this.print(node.alternate);
    }
    function NewExpression(node, parent) {
      this.word("new");
      this.space();
      this.print(node.callee);
      if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {
        callee: node
      }) && !isMemberExpression(parent) && !isNewExpression(parent)) {
        return;
      }
      this.print(node.typeArguments);
      this.print(node.typeParameters);
      if (node.optional) {
        this.token("?.");
      }
      if (node.arguments.length === 0 && this.tokenMap && !this.tokenMap.endMatches(node, ")")) {
        return;
      }
      this.tokenChar(40);
      const exit = this.enterDelimited();
      this.printList(node.arguments, this.shouldPrintTrailingComma(")"));
      exit();
      this.rightParens(node);
    }
    function SequenceExpression(node) {
      this.printList(node.expressions);
    }
    function ThisExpression() {
      this.word("this");
    }
    function Super() {
      this.word("super");
    }
    function _shouldPrintDecoratorsBeforeExport(node) {
      if (typeof this.format.decoratorsBeforeExport === "boolean") {
        return this.format.decoratorsBeforeExport;
      }
      return typeof node.start === "number" && node.start === node.declaration.start;
    }
    function Decorator(node) {
      this.tokenChar(64);
      this.print(node.expression);
      this.newline();
    }
    function OptionalMemberExpression(node) {
      let {
        computed
      } = node;
      const {
        optional,
        property: property4
      } = node;
      this.print(node.object);
      if (!computed && isMemberExpression(property4)) {
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      }
      if (isLiteral(property4) && typeof property4.value === "number") {
        computed = true;
      }
      if (optional) {
        this.token("?.");
      }
      if (computed) {
        this.tokenChar(91);
        this.print(property4);
        this.tokenChar(93);
      } else {
        if (!optional) {
          this.tokenChar(46);
        }
        this.print(property4);
      }
    }
    function OptionalCallExpression(node) {
      this.print(node.callee);
      this.print(node.typeParameters);
      if (node.optional) {
        this.token("?.");
      }
      this.print(node.typeArguments);
      this.tokenChar(40);
      const exit = this.enterDelimited();
      this.printList(node.arguments);
      exit();
      this.rightParens(node);
    }
    function CallExpression(node) {
      this.print(node.callee);
      this.print(node.typeArguments);
      this.print(node.typeParameters);
      this.tokenChar(40);
      const exit = this.enterDelimited();
      this.printList(node.arguments, this.shouldPrintTrailingComma(")"));
      exit();
      this.rightParens(node);
    }
    function Import() {
      this.word("import");
    }
    function AwaitExpression(node) {
      this.word("await");
      this.space();
      this.print(node.argument);
    }
    function YieldExpression(node) {
      if (node.delegate) {
        this.word("yield", true);
        this.tokenChar(42);
        if (node.argument) {
          this.space();
          this.print(node.argument);
        }
      } else if (node.argument) {
        this.word("yield", true);
        this.space();
        this.print(node.argument);
      } else {
        this.word("yield");
      }
    }
    function EmptyStatement() {
      this.semicolon(true);
    }
    function ExpressionStatement(node) {
      this.tokenContext |= _index.TokenContext.expressionStatement;
      this.print(node.expression);
      this.semicolon();
    }
    function AssignmentPattern(node) {
      this.print(node.left);
      if (node.left.type === "Identifier" || isPattern(node.left)) {
        if (node.left.optional) this.tokenChar(63);
        this.print(node.left.typeAnnotation);
      }
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.right);
    }
    function AssignmentExpression(node) {
      this.print(node.left);
      this.space();
      if (node.operator === "in" || node.operator === "instanceof") {
        this.word(node.operator);
      } else {
        this.token(node.operator);
        this._endsWithDiv = node.operator === "/";
      }
      this.space();
      this.print(node.right);
    }
    function BindExpression(node) {
      this.print(node.object);
      this.token("::");
      this.print(node.callee);
    }
    function MemberExpression(node) {
      this.print(node.object);
      if (!node.computed && isMemberExpression(node.property)) {
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      }
      let computed = node.computed;
      if (isLiteral(node.property) && typeof node.property.value === "number") {
        computed = true;
      }
      if (computed) {
        const exit = this.enterDelimited();
        this.tokenChar(91);
        this.print(node.property);
        this.tokenChar(93);
        exit();
      } else {
        this.tokenChar(46);
        this.print(node.property);
      }
    }
    function MetaProperty(node) {
      this.print(node.meta);
      this.tokenChar(46);
      this.print(node.property);
    }
    function PrivateName(node) {
      this.tokenChar(35);
      this.print(node.id);
    }
    function V8IntrinsicIdentifier(node) {
      this.tokenChar(37);
      this.word(node.name);
    }
    function ModuleExpression(node) {
      this.word("module", true);
      this.space();
      this.tokenChar(123);
      this.indent();
      const {
        body
      } = node;
      if (body.body.length || body.directives.length) {
        this.newline();
      }
      this.print(body);
      this.dedent();
      this.rightBrace(node);
    }
  }
});

// node_modules/@babel/generator/lib/generators/statements.js
var require_statements = __commonJS({
  "node_modules/@babel/generator/lib/generators/statements.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BreakStatement = BreakStatement;
    exports.CatchClause = CatchClause;
    exports.ContinueStatement = ContinueStatement;
    exports.DebuggerStatement = DebuggerStatement;
    exports.DoWhileStatement = DoWhileStatement;
    exports.ForOfStatement = exports.ForInStatement = void 0;
    exports.ForStatement = ForStatement;
    exports.IfStatement = IfStatement;
    exports.LabeledStatement = LabeledStatement;
    exports.ReturnStatement = ReturnStatement;
    exports.SwitchCase = SwitchCase;
    exports.SwitchStatement = SwitchStatement;
    exports.ThrowStatement = ThrowStatement;
    exports.TryStatement = TryStatement;
    exports.VariableDeclaration = VariableDeclaration;
    exports.VariableDeclarator = VariableDeclarator;
    exports.WhileStatement = WhileStatement;
    exports.WithStatement = WithStatement;
    var _t = require_lib4();
    var {
      isFor,
      isForStatement,
      isIfStatement,
      isStatement
    } = _t;
    function WithStatement(node) {
      this.word("with");
      this.space();
      this.tokenChar(40);
      this.print(node.object);
      this.tokenChar(41);
      this.printBlock(node);
    }
    function IfStatement(node) {
      this.word("if");
      this.space();
      this.tokenChar(40);
      this.print(node.test);
      this.tokenChar(41);
      this.space();
      const needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));
      if (needsBlock) {
        this.tokenChar(123);
        this.newline();
        this.indent();
      }
      this.printAndIndentOnComments(node.consequent);
      if (needsBlock) {
        this.dedent();
        this.newline();
        this.tokenChar(125);
      }
      if (node.alternate) {
        if (this.endsWith(125)) this.space();
        this.word("else");
        this.space();
        this.printAndIndentOnComments(node.alternate);
      }
    }
    function getLastStatement(statement) {
      const {
        body
      } = statement;
      if (isStatement(body) === false) {
        return statement;
      }
      return getLastStatement(body);
    }
    function ForStatement(node) {
      this.word("for");
      this.space();
      this.tokenChar(40);
      {
        const exit = this.enterForStatementInit();
        this.print(node.init);
        exit();
      }
      this.tokenChar(59);
      if (node.test) {
        this.space();
        this.print(node.test);
      }
      this.token(";", false, 1);
      if (node.update) {
        this.space();
        this.print(node.update);
      }
      this.tokenChar(41);
      this.printBlock(node);
    }
    function WhileStatement(node) {
      this.word("while");
      this.space();
      this.tokenChar(40);
      this.print(node.test);
      this.tokenChar(41);
      this.printBlock(node);
    }
    function ForXStatement(node) {
      this.word("for");
      this.space();
      const isForOf = node.type === "ForOfStatement";
      if (isForOf && node.await) {
        this.word("await");
        this.space();
      }
      this.noIndentInnerCommentsHere();
      this.tokenChar(40);
      {
        const exit = this.enterForXStatementInit(isForOf);
        this.print(node.left);
        exit == null || exit();
      }
      this.space();
      this.word(isForOf ? "of" : "in");
      this.space();
      this.print(node.right);
      this.tokenChar(41);
      this.printBlock(node);
    }
    var ForInStatement = exports.ForInStatement = ForXStatement;
    var ForOfStatement = exports.ForOfStatement = ForXStatement;
    function DoWhileStatement(node) {
      this.word("do");
      this.space();
      this.print(node.body);
      this.space();
      this.word("while");
      this.space();
      this.tokenChar(40);
      this.print(node.test);
      this.tokenChar(41);
      this.semicolon();
    }
    function printStatementAfterKeyword(printer, node) {
      if (node) {
        printer.space();
        printer.printTerminatorless(node);
      }
      printer.semicolon();
    }
    function BreakStatement(node) {
      this.word("break");
      printStatementAfterKeyword(this, node.label);
    }
    function ContinueStatement(node) {
      this.word("continue");
      printStatementAfterKeyword(this, node.label);
    }
    function ReturnStatement(node) {
      this.word("return");
      printStatementAfterKeyword(this, node.argument);
    }
    function ThrowStatement(node) {
      this.word("throw");
      printStatementAfterKeyword(this, node.argument);
    }
    function LabeledStatement(node) {
      this.print(node.label);
      this.tokenChar(58);
      this.space();
      this.print(node.body);
    }
    function TryStatement(node) {
      this.word("try");
      this.space();
      this.print(node.block);
      this.space();
      if (node.handlers) {
        this.print(node.handlers[0]);
      } else {
        this.print(node.handler);
      }
      if (node.finalizer) {
        this.space();
        this.word("finally");
        this.space();
        this.print(node.finalizer);
      }
    }
    function CatchClause(node) {
      this.word("catch");
      this.space();
      if (node.param) {
        this.tokenChar(40);
        this.print(node.param);
        this.print(node.param.typeAnnotation);
        this.tokenChar(41);
        this.space();
      }
      this.print(node.body);
    }
    function SwitchStatement(node) {
      this.word("switch");
      this.space();
      this.tokenChar(40);
      this.print(node.discriminant);
      this.tokenChar(41);
      this.space();
      this.tokenChar(123);
      this.printSequence(node.cases, true);
      this.rightBrace(node);
    }
    function SwitchCase(node) {
      if (node.test) {
        this.word("case");
        this.space();
        this.print(node.test);
        this.tokenChar(58);
      } else {
        this.word("default");
        this.tokenChar(58);
      }
      if (node.consequent.length) {
        this.newline();
        this.printSequence(node.consequent, true);
      }
    }
    function DebuggerStatement() {
      this.word("debugger");
      this.semicolon();
    }
    function VariableDeclaration(node, parent) {
      if (node.declare) {
        this.word("declare");
        this.space();
      }
      const {
        kind
      } = node;
      if (kind === "await using") {
        this.word("await");
        this.space();
        this.word("using", true);
      } else {
        this.word(kind, kind === "using");
      }
      this.space();
      let hasInits = false;
      if (!isFor(parent)) {
        for (const declar of node.declarations) {
          if (declar.init) {
            hasInits = true;
          }
        }
      }
      this.printList(node.declarations, void 0, void 0, node.declarations.length > 1, hasInits ? function(occurrenceCount) {
        this.token(",", false, occurrenceCount);
        this.newline();
      } : void 0);
      if (isFor(parent)) {
        if (isForStatement(parent)) {
          if (parent.init === node) return;
        } else {
          if (parent.left === node) return;
        }
      }
      this.semicolon();
    }
    function VariableDeclarator(node) {
      this.print(node.id);
      if (node.definite) this.tokenChar(33);
      this.print(node.id.typeAnnotation);
      if (node.init) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.init);
      }
    }
  }
});

// node_modules/@babel/generator/lib/generators/classes.js
var require_classes = __commonJS({
  "node_modules/@babel/generator/lib/generators/classes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ClassAccessorProperty = ClassAccessorProperty;
    exports.ClassBody = ClassBody;
    exports.ClassExpression = exports.ClassDeclaration = ClassDeclaration;
    exports.ClassMethod = ClassMethod;
    exports.ClassPrivateMethod = ClassPrivateMethod;
    exports.ClassPrivateProperty = ClassPrivateProperty;
    exports.ClassProperty = ClassProperty;
    exports.StaticBlock = StaticBlock;
    exports._classMethodHead = _classMethodHead;
    var _t = require_lib4();
    var {
      isExportDefaultDeclaration,
      isExportNamedDeclaration
    } = _t;
    function ClassDeclaration(node, parent) {
      const inExport = isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);
      if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) {
        this.printJoin(node.decorators);
      }
      if (node.declare) {
        this.word("declare");
        this.space();
      }
      if (node.abstract) {
        this.word("abstract");
        this.space();
      }
      this.word("class");
      if (node.id) {
        this.space();
        this.print(node.id);
      }
      this.print(node.typeParameters);
      if (node.superClass) {
        this.space();
        this.word("extends");
        this.space();
        this.print(node.superClass);
        this.print(node.superTypeParameters);
      }
      if (node.implements) {
        this.space();
        this.word("implements");
        this.space();
        this.printList(node.implements);
      }
      this.space();
      this.print(node.body);
    }
    function ClassBody(node) {
      this.tokenChar(123);
      if (node.body.length === 0) {
        this.tokenChar(125);
      } else {
        this.newline();
        const separator = classBodyEmptySemicolonsPrinter(this, node);
        separator == null || separator(-1);
        const exit = this.enterDelimited();
        this.printJoin(node.body, true, true, separator, true);
        exit();
        if (!this.endsWith(10)) this.newline();
        this.rightBrace(node);
      }
    }
    function classBodyEmptySemicolonsPrinter(printer, node) {
      if (!printer.tokenMap || node.start == null || node.end == null) {
        return null;
      }
      const indexes = printer.tokenMap.getIndexes(node);
      if (!indexes) return null;
      let k = 1;
      let occurrenceCount = 0;
      let nextLocIndex = 0;
      const advanceNextLocIndex = () => {
        while (nextLocIndex < node.body.length && node.body[nextLocIndex].start == null) {
          nextLocIndex++;
        }
      };
      advanceNextLocIndex();
      return (i) => {
        if (nextLocIndex <= i) {
          nextLocIndex = i + 1;
          advanceNextLocIndex();
        }
        const end = nextLocIndex === node.body.length ? node.end : node.body[nextLocIndex].start;
        let tok;
        while (k < indexes.length && printer.tokenMap.matchesOriginal(tok = printer._tokens[indexes[k]], ";") && tok.start < end) {
          printer.token(";", void 0, occurrenceCount++);
          k++;
        }
      };
    }
    function ClassProperty(node) {
      this.printJoin(node.decorators);
      if (!node.static && !this.format.preserveFormat) {
        var _node$key$loc;
        const endLine = (_node$key$loc = node.key.loc) == null || (_node$key$loc = _node$key$loc.end) == null ? void 0 : _node$key$loc.line;
        if (endLine) this.catchUp(endLine);
      }
      this.tsPrintClassMemberModifiers(node);
      if (node.computed) {
        this.tokenChar(91);
        this.print(node.key);
        this.tokenChar(93);
      } else {
        this._variance(node);
        this.print(node.key);
      }
      if (node.optional) {
        this.tokenChar(63);
      }
      if (node.definite) {
        this.tokenChar(33);
      }
      this.print(node.typeAnnotation);
      if (node.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.value);
      }
      this.semicolon();
    }
    function ClassAccessorProperty(node) {
      var _node$key$loc2;
      this.printJoin(node.decorators);
      const endLine = (_node$key$loc2 = node.key.loc) == null || (_node$key$loc2 = _node$key$loc2.end) == null ? void 0 : _node$key$loc2.line;
      if (endLine) this.catchUp(endLine);
      this.tsPrintClassMemberModifiers(node);
      this.word("accessor", true);
      this.space();
      if (node.computed) {
        this.tokenChar(91);
        this.print(node.key);
        this.tokenChar(93);
      } else {
        this._variance(node);
        this.print(node.key);
      }
      if (node.optional) {
        this.tokenChar(63);
      }
      if (node.definite) {
        this.tokenChar(33);
      }
      this.print(node.typeAnnotation);
      if (node.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.value);
      }
      this.semicolon();
    }
    function ClassPrivateProperty(node) {
      this.printJoin(node.decorators);
      this.tsPrintClassMemberModifiers(node);
      this.print(node.key);
      if (node.optional) {
        this.tokenChar(63);
      }
      if (node.definite) {
        this.tokenChar(33);
      }
      this.print(node.typeAnnotation);
      if (node.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.value);
      }
      this.semicolon();
    }
    function ClassMethod(node) {
      this._classMethodHead(node);
      this.space();
      this.print(node.body);
    }
    function ClassPrivateMethod(node) {
      this._classMethodHead(node);
      this.space();
      this.print(node.body);
    }
    function _classMethodHead(node) {
      this.printJoin(node.decorators);
      if (!this.format.preserveFormat) {
        var _node$key$loc3;
        const endLine = (_node$key$loc3 = node.key.loc) == null || (_node$key$loc3 = _node$key$loc3.end) == null ? void 0 : _node$key$loc3.line;
        if (endLine) this.catchUp(endLine);
      }
      this.tsPrintClassMemberModifiers(node);
      this._methodHead(node);
    }
    function StaticBlock(node) {
      this.word("static");
      this.space();
      this.tokenChar(123);
      if (node.body.length === 0) {
        this.tokenChar(125);
      } else {
        this.newline();
        this.printSequence(node.body, true);
        this.rightBrace(node);
      }
    }
  }
});

// node_modules/@babel/generator/lib/generators/methods.js
var require_methods = __commonJS({
  "node_modules/@babel/generator/lib/generators/methods.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ArrowFunctionExpression = ArrowFunctionExpression;
    exports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;
    exports._functionHead = _functionHead;
    exports._methodHead = _methodHead;
    exports._param = _param;
    exports._parameters = _parameters;
    exports._params = _params;
    exports._predicate = _predicate;
    exports._shouldPrintArrowParamsParens = _shouldPrintArrowParamsParens;
    var _t = require_lib4();
    var _index = require_node();
    var {
      isIdentifier
    } = _t;
    function _params(node, idNode, parentNode) {
      this.print(node.typeParameters);
      const nameInfo = _getFuncIdName.call(this, idNode, parentNode);
      if (nameInfo) {
        this.sourceIdentifierName(nameInfo.name, nameInfo.pos);
      }
      this.tokenChar(40);
      this._parameters(node.params, ")");
      const noLineTerminator = node.type === "ArrowFunctionExpression";
      this.print(node.returnType, noLineTerminator);
      this._noLineTerminator = noLineTerminator;
    }
    function _parameters(parameters, endToken) {
      const exit = this.enterDelimited();
      const trailingComma = this.shouldPrintTrailingComma(endToken);
      const paramLength = parameters.length;
      for (let i = 0; i < paramLength; i++) {
        this._param(parameters[i]);
        if (trailingComma || i < paramLength - 1) {
          this.token(",", void 0, i);
          this.space();
        }
      }
      this.token(endToken);
      exit();
    }
    function _param(parameter) {
      this.printJoin(parameter.decorators);
      this.print(parameter);
      if (parameter.optional) {
        this.tokenChar(63);
      }
      this.print(parameter.typeAnnotation);
    }
    function _methodHead(node) {
      const kind = node.kind;
      const key = node.key;
      if (kind === "get" || kind === "set") {
        this.word(kind);
        this.space();
      }
      if (node.async) {
        this.word("async", true);
        this.space();
      }
      if (kind === "method" || kind === "init") {
        if (node.generator) {
          this.tokenChar(42);
        }
      }
      if (node.computed) {
        this.tokenChar(91);
        this.print(key);
        this.tokenChar(93);
      } else {
        this.print(key);
      }
      if (node.optional) {
        this.tokenChar(63);
      }
      this._params(node, node.computed && node.key.type !== "StringLiteral" ? void 0 : node.key);
    }
    function _predicate(node, noLineTerminatorAfter) {
      if (node.predicate) {
        if (!node.returnType) {
          this.tokenChar(58);
        }
        this.space();
        this.print(node.predicate, noLineTerminatorAfter);
      }
    }
    function _functionHead(node, parent) {
      if (node.async) {
        this.word("async");
        if (!this.format.preserveFormat) {
          this._endsWithInnerRaw = false;
        }
        this.space();
      }
      this.word("function");
      if (node.generator) {
        if (!this.format.preserveFormat) {
          this._endsWithInnerRaw = false;
        }
        this.tokenChar(42);
      }
      this.space();
      if (node.id) {
        this.print(node.id);
      }
      this._params(node, node.id, parent);
      if (node.type !== "TSDeclareFunction") {
        this._predicate(node);
      }
    }
    function FunctionExpression(node, parent) {
      this._functionHead(node, parent);
      this.space();
      this.print(node.body);
    }
    function ArrowFunctionExpression(node, parent) {
      if (node.async) {
        this.word("async", true);
        this.space();
      }
      if (this._shouldPrintArrowParamsParens(node)) {
        this._params(node, void 0, parent);
      } else {
        this.print(node.params[0], true);
      }
      this._predicate(node, true);
      this.space();
      this.printInnerComments();
      this.token("=>");
      this.space();
      this.tokenContext |= _index.TokenContext.arrowBody;
      this.print(node.body);
    }
    function _shouldPrintArrowParamsParens(node) {
      var _firstParam$leadingCo, _firstParam$trailingC;
      if (node.params.length !== 1) return true;
      if (node.typeParameters || node.returnType || node.predicate) {
        return true;
      }
      const firstParam = node.params[0];
      if (!isIdentifier(firstParam) || firstParam.typeAnnotation || firstParam.optional || (_firstParam$leadingCo = firstParam.leadingComments) != null && _firstParam$leadingCo.length || (_firstParam$trailingC = firstParam.trailingComments) != null && _firstParam$trailingC.length) {
        return true;
      }
      if (this.tokenMap) {
        if (node.loc == null) return true;
        if (this.tokenMap.findMatching(node, "(") !== null) return true;
        const arrowToken = this.tokenMap.findMatching(node, "=>");
        if ((arrowToken == null ? void 0 : arrowToken.loc) == null) return true;
        return arrowToken.loc.start.line !== node.loc.start.line;
      }
      if (this.format.retainLines) return true;
      return false;
    }
    function _getFuncIdName(idNode, parent) {
      let id = idNode;
      if (!id && parent) {
        const parentType = parent.type;
        if (parentType === "VariableDeclarator") {
          id = parent.id;
        } else if (parentType === "AssignmentExpression" || parentType === "AssignmentPattern") {
          id = parent.left;
        } else if (parentType === "ObjectProperty" || parentType === "ClassProperty") {
          if (!parent.computed || parent.key.type === "StringLiteral") {
            id = parent.key;
          }
        } else if (parentType === "ClassPrivateProperty" || parentType === "ClassAccessorProperty") {
          id = parent.key;
        }
      }
      if (!id) return;
      let nameInfo;
      if (id.type === "Identifier") {
        var _id$loc, _id$loc2;
        nameInfo = {
          pos: (_id$loc = id.loc) == null ? void 0 : _id$loc.start,
          name: ((_id$loc2 = id.loc) == null ? void 0 : _id$loc2.identifierName) || id.name
        };
      } else if (id.type === "PrivateName") {
        var _id$loc3;
        nameInfo = {
          pos: (_id$loc3 = id.loc) == null ? void 0 : _id$loc3.start,
          name: "#" + id.id.name
        };
      } else if (id.type === "StringLiteral") {
        var _id$loc4;
        nameInfo = {
          pos: (_id$loc4 = id.loc) == null ? void 0 : _id$loc4.start,
          name: id.value
        };
      }
      return nameInfo;
    }
  }
});

// node_modules/@babel/generator/lib/generators/modules.js
var require_modules = __commonJS({
  "node_modules/@babel/generator/lib/generators/modules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ExportAllDeclaration = ExportAllDeclaration;
    exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
    exports.ExportDefaultSpecifier = ExportDefaultSpecifier;
    exports.ExportNamedDeclaration = ExportNamedDeclaration;
    exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
    exports.ExportSpecifier = ExportSpecifier;
    exports.ImportAttribute = ImportAttribute;
    exports.ImportDeclaration = ImportDeclaration;
    exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
    exports.ImportExpression = ImportExpression;
    exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
    exports.ImportSpecifier = ImportSpecifier;
    exports._printAttributes = _printAttributes;
    var _t = require_lib4();
    var _index = require_node();
    var {
      isClassDeclaration,
      isExportDefaultSpecifier,
      isExportNamespaceSpecifier,
      isImportDefaultSpecifier,
      isImportNamespaceSpecifier,
      isStatement
    } = _t;
    function ImportSpecifier(node) {
      if (node.importKind === "type" || node.importKind === "typeof") {
        this.word(node.importKind);
        this.space();
      }
      this.print(node.imported);
      if (node.local && node.local.name !== node.imported.name) {
        this.space();
        this.word("as");
        this.space();
        this.print(node.local);
      }
    }
    function ImportDefaultSpecifier(node) {
      this.print(node.local);
    }
    function ExportDefaultSpecifier(node) {
      this.print(node.exported);
    }
    function ExportSpecifier(node) {
      if (node.exportKind === "type") {
        this.word("type");
        this.space();
      }
      this.print(node.local);
      if (node.exported && node.local.name !== node.exported.name) {
        this.space();
        this.word("as");
        this.space();
        this.print(node.exported);
      }
    }
    function ExportNamespaceSpecifier(node) {
      this.tokenChar(42);
      this.space();
      this.word("as");
      this.space();
      this.print(node.exported);
    }
    var warningShown = false;
    function _printAttributes(node, hasPreviousBrace) {
      var _node$extra;
      const {
        attributes
      } = node;
      var {
        assertions
      } = node;
      const {
        importAttributesKeyword
      } = this.format;
      if (attributes && !importAttributesKeyword && node.extra && (node.extra.deprecatedAssertSyntax || node.extra.deprecatedWithLegacySyntax) && !warningShown) {
        warningShown = true;
        console.warn(`You are using import attributes, without specifying the desired output syntax.
Please specify the "importAttributesKeyword" generator option, whose value can be one of:
 - "with"        : \`import { a } from "b" with { type: "json" };\`
 - "assert"      : \`import { a } from "b" assert { type: "json" };\`
 - "with-legacy" : \`import { a } from "b" with type: "json";\`
`);
      }
      const useAssertKeyword = importAttributesKeyword === "assert" || !importAttributesKeyword && assertions;
      this.word(useAssertKeyword ? "assert" : "with");
      this.space();
      if (!useAssertKeyword && (importAttributesKeyword === "with-legacy" || !importAttributesKeyword && (_node$extra = node.extra) != null && _node$extra.deprecatedWithLegacySyntax)) {
        this.printList(attributes || assertions);
        return;
      }
      const occurrenceCount = hasPreviousBrace ? 1 : 0;
      this.token("{", void 0, occurrenceCount);
      this.space();
      this.printList(attributes || assertions, this.shouldPrintTrailingComma("}"));
      this.space();
      this.token("}", void 0, occurrenceCount);
    }
    function ExportAllDeclaration(node) {
      var _node$attributes, _node$assertions;
      this.word("export");
      this.space();
      if (node.exportKind === "type") {
        this.word("type");
        this.space();
      }
      this.tokenChar(42);
      this.space();
      this.word("from");
      this.space();
      if ((_node$attributes = node.attributes) != null && _node$attributes.length || (_node$assertions = node.assertions) != null && _node$assertions.length) {
        this.print(node.source, true);
        this.space();
        this._printAttributes(node, false);
      } else {
        this.print(node.source);
      }
      this.semicolon();
    }
    function maybePrintDecoratorsBeforeExport(printer, node) {
      if (isClassDeclaration(node.declaration) && printer._shouldPrintDecoratorsBeforeExport(node)) {
        printer.printJoin(node.declaration.decorators);
      }
    }
    function ExportNamedDeclaration(node) {
      maybePrintDecoratorsBeforeExport(this, node);
      this.word("export");
      this.space();
      if (node.declaration) {
        const declar = node.declaration;
        this.print(declar);
        if (!isStatement(declar)) this.semicolon();
      } else {
        if (node.exportKind === "type") {
          this.word("type");
          this.space();
        }
        const specifiers = node.specifiers.slice(0);
        let hasSpecial = false;
        for (; ; ) {
          const first = specifiers[0];
          if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
            hasSpecial = true;
            this.print(specifiers.shift());
            if (specifiers.length) {
              this.tokenChar(44);
              this.space();
            }
          } else {
            break;
          }
        }
        let hasBrace = false;
        if (specifiers.length || !specifiers.length && !hasSpecial) {
          hasBrace = true;
          this.tokenChar(123);
          if (specifiers.length) {
            this.space();
            this.printList(specifiers, this.shouldPrintTrailingComma("}"));
            this.space();
          }
          this.tokenChar(125);
        }
        if (node.source) {
          var _node$attributes2, _node$assertions2;
          this.space();
          this.word("from");
          this.space();
          if ((_node$attributes2 = node.attributes) != null && _node$attributes2.length || (_node$assertions2 = node.assertions) != null && _node$assertions2.length) {
            this.print(node.source, true);
            this.space();
            this._printAttributes(node, hasBrace);
          } else {
            this.print(node.source);
          }
        }
        this.semicolon();
      }
    }
    function ExportDefaultDeclaration(node) {
      maybePrintDecoratorsBeforeExport(this, node);
      this.word("export");
      this.noIndentInnerCommentsHere();
      this.space();
      this.word("default");
      this.space();
      this.tokenContext |= _index.TokenContext.exportDefault;
      const declar = node.declaration;
      this.print(declar);
      if (!isStatement(declar)) this.semicolon();
    }
    function ImportDeclaration(node) {
      var _node$attributes3, _node$assertions3;
      this.word("import");
      this.space();
      const isTypeKind = node.importKind === "type" || node.importKind === "typeof";
      if (isTypeKind) {
        this.noIndentInnerCommentsHere();
        this.word(node.importKind);
        this.space();
      } else if (node.module) {
        this.noIndentInnerCommentsHere();
        this.word("module");
        this.space();
      } else if (node.phase) {
        this.noIndentInnerCommentsHere();
        this.word(node.phase);
        this.space();
      }
      const specifiers = node.specifiers.slice(0);
      const hasSpecifiers = !!specifiers.length;
      while (hasSpecifiers) {
        const first = specifiers[0];
        if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
          this.print(specifiers.shift());
          if (specifiers.length) {
            this.tokenChar(44);
            this.space();
          }
        } else {
          break;
        }
      }
      let hasBrace = false;
      if (specifiers.length) {
        hasBrace = true;
        this.tokenChar(123);
        this.space();
        this.printList(specifiers, this.shouldPrintTrailingComma("}"));
        this.space();
        this.tokenChar(125);
      } else if (isTypeKind && !hasSpecifiers) {
        hasBrace = true;
        this.tokenChar(123);
        this.tokenChar(125);
      }
      if (hasSpecifiers || isTypeKind) {
        this.space();
        this.word("from");
        this.space();
      }
      if ((_node$attributes3 = node.attributes) != null && _node$attributes3.length || (_node$assertions3 = node.assertions) != null && _node$assertions3.length) {
        this.print(node.source, true);
        this.space();
        this._printAttributes(node, hasBrace);
      } else {
        this.print(node.source);
      }
      this.semicolon();
    }
    function ImportAttribute(node) {
      this.print(node.key);
      this.tokenChar(58);
      this.space();
      this.print(node.value);
    }
    function ImportNamespaceSpecifier(node) {
      this.tokenChar(42);
      this.space();
      this.word("as");
      this.space();
      this.print(node.local);
    }
    function ImportExpression(node) {
      this.word("import");
      if (node.phase) {
        this.tokenChar(46);
        this.word(node.phase);
      }
      this.tokenChar(40);
      const shouldPrintTrailingComma = this.shouldPrintTrailingComma(")");
      this.print(node.source);
      if (node.options != null) {
        this.tokenChar(44);
        this.space();
        this.print(node.options);
      }
      if (shouldPrintTrailingComma) {
        this.tokenChar(44);
      }
      this.rightParens(node);
    }
  }
});

// node_modules/jsesc/jsesc.js
var require_jsesc = __commonJS({
  "node_modules/jsesc/jsesc.js"(exports, module) {
    "use strict";
    var object = {};
    var hasOwnProperty5 = object.hasOwnProperty;
    var forOwn = (object2, callback) => {
      for (const key in object2) {
        if (hasOwnProperty5.call(object2, key)) {
          callback(key, object2[key]);
        }
      }
    };
    var extend = (destination, source) => {
      if (!source) {
        return destination;
      }
      forOwn(source, (key, value) => {
        destination[key] = value;
      });
      return destination;
    };
    var forEach = (array, callback) => {
      const length2 = array.length;
      let index = -1;
      while (++index < length2) {
        callback(array[index]);
      }
    };
    var fourHexEscape = (hex) => {
      return "\\u" + ("0000" + hex).slice(-4);
    };
    var hexadecimal = (code2, lowercase) => {
      let hexadecimal2 = code2.toString(16);
      if (lowercase) return hexadecimal2;
      return hexadecimal2.toUpperCase();
    };
    var toString2 = object.toString;
    var isArray = Array.isArray;
    var isBuffer = (value) => {
      return typeof Buffer === "function" && Buffer.isBuffer(value);
    };
    var isObject3 = (value) => {
      return toString2.call(value) == "[object Object]";
    };
    var isString2 = (value) => {
      return typeof value == "string" || toString2.call(value) == "[object String]";
    };
    var isNumber = (value) => {
      return typeof value == "number" || toString2.call(value) == "[object Number]";
    };
    var isBigInt = (value) => {
      return typeof value == "bigint";
    };
    var isFunction = (value) => {
      return typeof value == "function";
    };
    var isMap = (value) => {
      return toString2.call(value) == "[object Map]";
    };
    var isSet = (value) => {
      return toString2.call(value) == "[object Set]";
    };
    var singleEscapes = {
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t"
      // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
      // '\v': '\\x0B'
    };
    var regexSingleEscape = /[\\\b\f\n\r\t]/;
    var regexDigit = /[0-9]/;
    var regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
    var escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
    var escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
    var jsesc = (argument, options) => {
      const increaseIndentation = () => {
        oldIndent = indent;
        ++options.indentLevel;
        indent = options.indent.repeat(options.indentLevel);
      };
      const defaults2 = {
        "escapeEverything": false,
        "minimal": false,
        "isScriptContext": false,
        "quotes": "single",
        "wrap": false,
        "es6": false,
        "json": false,
        "compact": true,
        "lowercaseHex": false,
        "numbers": "decimal",
        "indent": "	",
        "indentLevel": 0,
        "__inline1__": false,
        "__inline2__": false
      };
      const json = options && options.json;
      if (json) {
        defaults2.quotes = "double";
        defaults2.wrap = true;
      }
      options = extend(defaults2, options);
      if (options.quotes != "single" && options.quotes != "double" && options.quotes != "backtick") {
        options.quotes = "single";
      }
      const quote = options.quotes == "double" ? '"' : options.quotes == "backtick" ? "`" : "'";
      const compact = options.compact;
      const lowercaseHex = options.lowercaseHex;
      let indent = options.indent.repeat(options.indentLevel);
      let oldIndent = "";
      const inline1 = options.__inline1__;
      const inline2 = options.__inline2__;
      const newLine = compact ? "" : "\n";
      let result;
      let isEmpty = true;
      const useBinNumbers = options.numbers == "binary";
      const useOctNumbers = options.numbers == "octal";
      const useDecNumbers = options.numbers == "decimal";
      const useHexNumbers = options.numbers == "hexadecimal";
      if (json && argument && isFunction(argument.toJSON)) {
        argument = argument.toJSON();
      }
      if (!isString2(argument)) {
        if (isMap(argument)) {
          if (argument.size == 0) {
            return "new Map()";
          }
          if (!compact) {
            options.__inline1__ = true;
            options.__inline2__ = false;
          }
          return "new Map(" + jsesc(Array.from(argument), options) + ")";
        }
        if (isSet(argument)) {
          if (argument.size == 0) {
            return "new Set()";
          }
          return "new Set(" + jsesc(Array.from(argument), options) + ")";
        }
        if (isBuffer(argument)) {
          if (argument.length == 0) {
            return "Buffer.from([])";
          }
          return "Buffer.from(" + jsesc(Array.from(argument), options) + ")";
        }
        if (isArray(argument)) {
          result = [];
          options.wrap = true;
          if (inline1) {
            options.__inline1__ = false;
            options.__inline2__ = true;
          }
          if (!inline2) {
            increaseIndentation();
          }
          forEach(argument, (value) => {
            isEmpty = false;
            if (inline2) {
              options.__inline2__ = false;
            }
            result.push(
              (compact || inline2 ? "" : indent) + jsesc(value, options)
            );
          });
          if (isEmpty) {
            return "[]";
          }
          if (inline2) {
            return "[" + result.join(", ") + "]";
          }
          return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
        } else if (isNumber(argument) || isBigInt(argument)) {
          if (json) {
            return JSON.stringify(Number(argument));
          }
          let result2;
          if (useDecNumbers) {
            result2 = String(argument);
          } else if (useHexNumbers) {
            let hexadecimal2 = argument.toString(16);
            if (!lowercaseHex) {
              hexadecimal2 = hexadecimal2.toUpperCase();
            }
            result2 = "0x" + hexadecimal2;
          } else if (useBinNumbers) {
            result2 = "0b" + argument.toString(2);
          } else if (useOctNumbers) {
            result2 = "0o" + argument.toString(8);
          }
          if (isBigInt(argument)) {
            return result2 + "n";
          }
          return result2;
        } else if (isBigInt(argument)) {
          if (json) {
            return JSON.stringify(Number(argument));
          }
          return argument + "n";
        } else if (!isObject3(argument)) {
          if (json) {
            return JSON.stringify(argument) || "null";
          }
          return String(argument);
        } else {
          result = [];
          options.wrap = true;
          increaseIndentation();
          forOwn(argument, (key, value) => {
            isEmpty = false;
            result.push(
              (compact ? "" : indent) + jsesc(key, options) + ":" + (compact ? "" : " ") + jsesc(value, options)
            );
          });
          if (isEmpty) {
            return "{}";
          }
          return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
        }
      }
      const regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
      result = argument.replace(regex, (char, pair, lone, quoteChar, index, string) => {
        if (pair) {
          if (options.minimal) return pair;
          const first = pair.charCodeAt(0);
          const second = pair.charCodeAt(1);
          if (options.es6) {
            const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
            const hex2 = hexadecimal(codePoint, lowercaseHex);
            return "\\u{" + hex2 + "}";
          }
          return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
        }
        if (lone) {
          return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
        }
        if (char == "\0" && !json && !regexDigit.test(string.charAt(index + 1))) {
          return "\\0";
        }
        if (quoteChar) {
          if (quoteChar == quote || options.escapeEverything) {
            return "\\" + quoteChar;
          }
          return quoteChar;
        }
        if (regexSingleEscape.test(char)) {
          return singleEscapes[char];
        }
        if (options.minimal && !regexWhitespace.test(char)) {
          return char;
        }
        const hex = hexadecimal(char.charCodeAt(0), lowercaseHex);
        if (json || hex.length > 2) {
          return fourHexEscape(hex);
        }
        return "\\x" + ("00" + hex).slice(-2);
      });
      if (quote == "`") {
        result = result.replace(/\$\{/g, "\\${");
      }
      if (options.isScriptContext) {
        result = result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--");
      }
      if (options.wrap) {
        result = quote + result + quote;
      }
      return result;
    };
    jsesc.version = "3.0.2";
    module.exports = jsesc;
  }
});

// node_modules/@babel/generator/lib/generators/types.js
var require_types = __commonJS({
  "node_modules/@babel/generator/lib/generators/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ArgumentPlaceholder = ArgumentPlaceholder;
    exports.ArrayPattern = exports.ArrayExpression = ArrayExpression;
    exports.BigIntLiteral = BigIntLiteral;
    exports.BooleanLiteral = BooleanLiteral;
    exports.Identifier = Identifier;
    exports.NullLiteral = NullLiteral;
    exports.NumericLiteral = NumericLiteral;
    exports.ObjectPattern = exports.ObjectExpression = ObjectExpression;
    exports.ObjectMethod = ObjectMethod;
    exports.ObjectProperty = ObjectProperty;
    exports.PipelineBareFunction = PipelineBareFunction;
    exports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
    exports.PipelineTopicExpression = PipelineTopicExpression;
    exports.RegExpLiteral = RegExpLiteral;
    exports.SpreadElement = exports.RestElement = RestElement;
    exports.StringLiteral = StringLiteral;
    exports.TopicReference = TopicReference;
    exports.VoidPattern = VoidPattern;
    exports._getRawIdentifier = _getRawIdentifier;
    var _t = require_lib4();
    var _jsesc = require_jsesc();
    var {
      isAssignmentPattern,
      isIdentifier
    } = _t;
    var lastRawIdentNode = null;
    var lastRawIdentResult = "";
    function _getRawIdentifier(node) {
      if (node === lastRawIdentNode) return lastRawIdentResult;
      lastRawIdentNode = node;
      const {
        name: name50
      } = node;
      const token = this.tokenMap.find(node, (tok) => tok.value === name50);
      if (token) {
        lastRawIdentResult = this._originalCode.slice(token.start, token.end);
        return lastRawIdentResult;
      }
      return lastRawIdentResult = node.name;
    }
    function Identifier(node) {
      var _node$loc;
      this.sourceIdentifierName(((_node$loc = node.loc) == null ? void 0 : _node$loc.identifierName) || node.name);
      this.word(this.tokenMap ? this._getRawIdentifier(node) : node.name);
    }
    function ArgumentPlaceholder() {
      this.tokenChar(63);
    }
    function RestElement(node) {
      this.token("...");
      this.print(node.argument);
    }
    function ObjectExpression(node) {
      const props = node.properties;
      this.tokenChar(123);
      if (props.length) {
        const exit = this.enterDelimited();
        this.space();
        this.printList(props, this.shouldPrintTrailingComma("}"), true, true);
        this.space();
        exit();
      }
      this.sourceWithOffset("end", node.loc, -1);
      this.tokenChar(125);
    }
    function ObjectMethod(node) {
      this.printJoin(node.decorators);
      this._methodHead(node);
      this.space();
      this.print(node.body);
    }
    function ObjectProperty(node) {
      this.printJoin(node.decorators);
      if (node.computed) {
        this.tokenChar(91);
        this.print(node.key);
        this.tokenChar(93);
      } else {
        if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name) {
          this.print(node.value);
          return;
        }
        this.print(node.key);
        if (node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name) {
          return;
        }
      }
      this.tokenChar(58);
      this.space();
      this.print(node.value);
    }
    function ArrayExpression(node) {
      const elems = node.elements;
      const len = elems.length;
      this.tokenChar(91);
      const exit = this.enterDelimited();
      for (let i = 0; i < elems.length; i++) {
        const elem = elems[i];
        if (elem) {
          if (i > 0) this.space();
          this.print(elem);
          if (i < len - 1 || this.shouldPrintTrailingComma("]")) {
            this.token(",", false, i);
          }
        } else {
          this.token(",", false, i);
        }
      }
      exit();
      this.tokenChar(93);
    }
    function RegExpLiteral(node) {
      this.word(`/${node.pattern}/${node.flags}`);
    }
    function BooleanLiteral(node) {
      this.word(node.value ? "true" : "false");
    }
    function NullLiteral() {
      this.word("null");
    }
    function NumericLiteral(node) {
      const raw = this.getPossibleRaw(node);
      const opts = this.format.jsescOption;
      const value = node.value;
      const str = value + "";
      if (opts.numbers) {
        this.number(_jsesc(value, opts), value);
      } else if (raw == null) {
        this.number(str, value);
      } else if (this.format.minified) {
        this.number(raw.length < str.length ? raw : str, value);
      } else {
        this.number(raw, value);
      }
    }
    function StringLiteral(node) {
      const raw = this.getPossibleRaw(node);
      if (!this.format.minified && raw !== void 0) {
        this.token(raw);
        return;
      }
      const val = _jsesc(node.value, this.format.jsescOption);
      this.token(val);
    }
    function BigIntLiteral(node) {
      const raw = this.getPossibleRaw(node);
      if (!this.format.minified && raw !== void 0) {
        this.word(raw);
        return;
      }
      this.word(node.value + "n");
    }
    var validTopicTokenSet = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
    function TopicReference() {
      const {
        topicToken
      } = this.format;
      if (validTopicTokenSet.has(topicToken)) {
        this.token(topicToken);
      } else {
        const givenTopicTokenJSON = JSON.stringify(topicToken);
        const validTopics = Array.from(validTopicTokenSet, (v) => JSON.stringify(v));
        throw new Error(`The "topicToken" generator option must be one of ${validTopics.join(", ")} (${givenTopicTokenJSON} received instead).`);
      }
    }
    function PipelineTopicExpression(node) {
      this.print(node.expression);
    }
    function PipelineBareFunction(node) {
      this.print(node.callee);
    }
    function PipelinePrimaryTopicReference() {
      this.tokenChar(35);
    }
    function VoidPattern() {
      this.word("void");
    }
  }
});

// node_modules/@babel/generator/lib/generators/flow.js
var require_flow2 = __commonJS({
  "node_modules/@babel/generator/lib/generators/flow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AnyTypeAnnotation = AnyTypeAnnotation;
    exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
    exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
    exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
    exports.DeclareClass = DeclareClass;
    exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
    exports.DeclareExportDeclaration = DeclareExportDeclaration;
    exports.DeclareFunction = DeclareFunction;
    exports.DeclareInterface = DeclareInterface;
    exports.DeclareModule = DeclareModule;
    exports.DeclareModuleExports = DeclareModuleExports;
    exports.DeclareOpaqueType = DeclareOpaqueType;
    exports.DeclareTypeAlias = DeclareTypeAlias;
    exports.DeclareVariable = DeclareVariable;
    exports.DeclaredPredicate = DeclaredPredicate;
    exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
    exports.EnumBooleanBody = EnumBooleanBody;
    exports.EnumBooleanMember = EnumBooleanMember;
    exports.EnumDeclaration = EnumDeclaration;
    exports.EnumDefaultedMember = EnumDefaultedMember;
    exports.EnumNumberBody = EnumNumberBody;
    exports.EnumNumberMember = EnumNumberMember;
    exports.EnumStringBody = EnumStringBody;
    exports.EnumStringMember = EnumStringMember;
    exports.EnumSymbolBody = EnumSymbolBody;
    exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
    exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
    exports.FunctionTypeParam = FunctionTypeParam;
    exports.IndexedAccessType = IndexedAccessType;
    exports.InferredPredicate = InferredPredicate;
    exports.InterfaceDeclaration = InterfaceDeclaration;
    exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;
    exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
    exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
    exports.MixedTypeAnnotation = MixedTypeAnnotation;
    exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
    exports.NullableTypeAnnotation = NullableTypeAnnotation;
    Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _types2.NumericLiteral;
      }
    });
    exports.NumberTypeAnnotation = NumberTypeAnnotation;
    exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
    exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
    exports.ObjectTypeIndexer = ObjectTypeIndexer;
    exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
    exports.ObjectTypeProperty = ObjectTypeProperty;
    exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
    exports.OpaqueType = OpaqueType;
    exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
    exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
    Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _types2.StringLiteral;
      }
    });
    exports.StringTypeAnnotation = StringTypeAnnotation;
    exports.SymbolTypeAnnotation = SymbolTypeAnnotation;
    exports.ThisTypeAnnotation = ThisTypeAnnotation;
    exports.TupleTypeAnnotation = TupleTypeAnnotation;
    exports.TypeAlias = TypeAlias;
    exports.TypeAnnotation = TypeAnnotation;
    exports.TypeCastExpression = TypeCastExpression;
    exports.TypeParameter = TypeParameter;
    exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;
    exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
    exports.UnionTypeAnnotation = UnionTypeAnnotation;
    exports.Variance = Variance;
    exports.VoidTypeAnnotation = VoidTypeAnnotation;
    exports._interfaceish = _interfaceish;
    exports._variance = _variance;
    var _t = require_lib4();
    var _modules = require_modules();
    var _index = require_node();
    var _types2 = require_types();
    var {
      isDeclareExportDeclaration,
      isStatement
    } = _t;
    function AnyTypeAnnotation() {
      this.word("any");
    }
    function ArrayTypeAnnotation(node) {
      this.print(node.elementType, true);
      this.tokenChar(91);
      this.tokenChar(93);
    }
    function BooleanTypeAnnotation() {
      this.word("boolean");
    }
    function BooleanLiteralTypeAnnotation(node) {
      this.word(node.value ? "true" : "false");
    }
    function NullLiteralTypeAnnotation() {
      this.word("null");
    }
    function DeclareClass(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("class");
      this.space();
      this._interfaceish(node);
    }
    function DeclareFunction(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("function");
      this.space();
      this.print(node.id);
      this.print(node.id.typeAnnotation.typeAnnotation);
      if (node.predicate) {
        this.space();
        this.print(node.predicate);
      }
      this.semicolon();
    }
    function InferredPredicate() {
      this.tokenChar(37);
      this.word("checks");
    }
    function DeclaredPredicate(node) {
      this.tokenChar(37);
      this.word("checks");
      this.tokenChar(40);
      this.print(node.value);
      this.tokenChar(41);
    }
    function DeclareInterface(node) {
      this.word("declare");
      this.space();
      this.InterfaceDeclaration(node);
    }
    function DeclareModule(node) {
      this.word("declare");
      this.space();
      this.word("module");
      this.space();
      this.print(node.id);
      this.space();
      this.print(node.body);
    }
    function DeclareModuleExports(node) {
      this.word("declare");
      this.space();
      this.word("module");
      this.tokenChar(46);
      this.word("exports");
      this.print(node.typeAnnotation);
    }
    function DeclareTypeAlias(node) {
      this.word("declare");
      this.space();
      this.TypeAlias(node);
    }
    function DeclareOpaqueType(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.OpaqueType(node);
    }
    function DeclareVariable(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("var");
      this.space();
      this.print(node.id);
      this.print(node.id.typeAnnotation);
      this.semicolon();
    }
    function DeclareExportDeclaration(node) {
      this.word("declare");
      this.space();
      this.word("export");
      this.space();
      if (node.default) {
        this.word("default");
        this.space();
      }
      FlowExportDeclaration.call(this, node);
    }
    function DeclareExportAllDeclaration(node) {
      this.word("declare");
      this.space();
      _modules.ExportAllDeclaration.call(this, node);
    }
    function EnumDeclaration(node) {
      const {
        id,
        body
      } = node;
      this.word("enum");
      this.space();
      this.print(id);
      this.print(body);
    }
    function enumExplicitType(context, name50, hasExplicitType) {
      if (hasExplicitType) {
        context.space();
        context.word("of");
        context.space();
        context.word(name50);
      }
      context.space();
    }
    function enumBody(context, node) {
      const {
        members
      } = node;
      context.token("{");
      context.indent();
      context.newline();
      for (const member of members) {
        context.print(member);
        context.newline();
      }
      if (node.hasUnknownMembers) {
        context.token("...");
        context.newline();
      }
      context.dedent();
      context.token("}");
    }
    function EnumBooleanBody(node) {
      const {
        explicitType
      } = node;
      enumExplicitType(this, "boolean", explicitType);
      enumBody(this, node);
    }
    function EnumNumberBody(node) {
      const {
        explicitType
      } = node;
      enumExplicitType(this, "number", explicitType);
      enumBody(this, node);
    }
    function EnumStringBody(node) {
      const {
        explicitType
      } = node;
      enumExplicitType(this, "string", explicitType);
      enumBody(this, node);
    }
    function EnumSymbolBody(node) {
      enumExplicitType(this, "symbol", true);
      enumBody(this, node);
    }
    function EnumDefaultedMember(node) {
      const {
        id
      } = node;
      this.print(id);
      this.tokenChar(44);
    }
    function enumInitializedMember(context, node) {
      context.print(node.id);
      context.space();
      context.token("=");
      context.space();
      context.print(node.init);
      context.token(",");
    }
    function EnumBooleanMember(node) {
      enumInitializedMember(this, node);
    }
    function EnumNumberMember(node) {
      enumInitializedMember(this, node);
    }
    function EnumStringMember(node) {
      enumInitializedMember(this, node);
    }
    function FlowExportDeclaration(node) {
      if (node.declaration) {
        const declar = node.declaration;
        this.print(declar);
        if (!isStatement(declar)) this.semicolon();
      } else {
        this.tokenChar(123);
        if (node.specifiers.length) {
          this.space();
          this.printList(node.specifiers);
          this.space();
        }
        this.tokenChar(125);
        if (node.source) {
          this.space();
          this.word("from");
          this.space();
          this.print(node.source);
        }
        this.semicolon();
      }
    }
    function ExistsTypeAnnotation() {
      this.tokenChar(42);
    }
    function FunctionTypeAnnotation(node, parent) {
      this.print(node.typeParameters);
      this.tokenChar(40);
      if (node.this) {
        this.word("this");
        this.tokenChar(58);
        this.space();
        this.print(node.this.typeAnnotation);
        if (node.params.length || node.rest) {
          this.tokenChar(44);
          this.space();
        }
      }
      this.printList(node.params);
      if (node.rest) {
        if (node.params.length) {
          this.tokenChar(44);
          this.space();
        }
        this.token("...");
        this.print(node.rest);
      }
      this.tokenChar(41);
      const type = parent == null ? void 0 : parent.type;
      if (type != null && (type === "ObjectTypeCallProperty" || type === "ObjectTypeInternalSlot" || type === "DeclareFunction" || type === "ObjectTypeProperty" && parent.method)) {
        this.tokenChar(58);
      } else {
        this.space();
        this.token("=>");
      }
      this.space();
      this.print(node.returnType);
    }
    function FunctionTypeParam(node) {
      this.print(node.name);
      if (node.optional) this.tokenChar(63);
      if (node.name) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node.typeAnnotation);
    }
    function InterfaceExtends(node) {
      this.print(node.id);
      this.print(node.typeParameters, true);
    }
    function _interfaceish(node) {
      var _node$extends;
      this.print(node.id);
      this.print(node.typeParameters);
      if ((_node$extends = node.extends) != null && _node$extends.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node.extends);
      }
      if (node.type === "DeclareClass") {
        var _node$mixins, _node$implements;
        if ((_node$mixins = node.mixins) != null && _node$mixins.length) {
          this.space();
          this.word("mixins");
          this.space();
          this.printList(node.mixins);
        }
        if ((_node$implements = node.implements) != null && _node$implements.length) {
          this.space();
          this.word("implements");
          this.space();
          this.printList(node.implements);
        }
      }
      this.space();
      this.print(node.body);
    }
    function _variance(node) {
      var _node$variance;
      const kind = (_node$variance = node.variance) == null ? void 0 : _node$variance.kind;
      if (kind != null) {
        if (kind === "plus") {
          this.tokenChar(43);
        } else if (kind === "minus") {
          this.tokenChar(45);
        }
      }
    }
    function InterfaceDeclaration(node) {
      this.word("interface");
      this.space();
      this._interfaceish(node);
    }
    function andSeparator(occurrenceCount) {
      this.space();
      this.token("&", false, occurrenceCount);
      this.space();
    }
    function InterfaceTypeAnnotation(node) {
      var _node$extends2;
      this.word("interface");
      if ((_node$extends2 = node.extends) != null && _node$extends2.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node.extends);
      }
      this.space();
      this.print(node.body);
    }
    function IntersectionTypeAnnotation(node) {
      this.printJoin(node.types, void 0, void 0, andSeparator);
    }
    function MixedTypeAnnotation() {
      this.word("mixed");
    }
    function EmptyTypeAnnotation() {
      this.word("empty");
    }
    function NullableTypeAnnotation(node) {
      this.tokenChar(63);
      this.print(node.typeAnnotation);
    }
    function NumberTypeAnnotation() {
      this.word("number");
    }
    function StringTypeAnnotation() {
      this.word("string");
    }
    function ThisTypeAnnotation() {
      this.word("this");
    }
    function TupleTypeAnnotation(node) {
      this.tokenChar(91);
      this.printList(node.types);
      this.tokenChar(93);
    }
    function TypeofTypeAnnotation(node) {
      this.word("typeof");
      this.space();
      this.print(node.argument);
    }
    function TypeAlias(node) {
      this.word("type");
      this.space();
      this.print(node.id);
      this.print(node.typeParameters);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.right);
      this.semicolon();
    }
    function TypeAnnotation(node, parent) {
      this.tokenChar(58);
      this.space();
      if (parent.type === "ArrowFunctionExpression") {
        this.tokenContext |= _index.TokenContext.arrowFlowReturnType;
      } else if (node.optional) {
        this.tokenChar(63);
      }
      this.print(node.typeAnnotation);
    }
    function TypeParameterInstantiation(node) {
      this.tokenChar(60);
      this.printList(node.params);
      this.tokenChar(62);
    }
    function TypeParameter(node) {
      this._variance(node);
      this.word(node.name);
      if (node.bound) {
        this.print(node.bound);
      }
      if (node.default) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.default);
      }
    }
    function OpaqueType(node) {
      this.word("opaque");
      this.space();
      this.word("type");
      this.space();
      this.print(node.id);
      this.print(node.typeParameters);
      if (node.supertype) {
        this.tokenChar(58);
        this.space();
        this.print(node.supertype);
      }
      if (node.impltype) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.impltype);
      }
      this.semicolon();
    }
    function ObjectTypeAnnotation(node) {
      if (node.exact) {
        this.token("{|");
      } else {
        this.tokenChar(123);
      }
      const props = [...node.properties, ...node.callProperties || [], ...node.indexers || [], ...node.internalSlots || []];
      if (props.length) {
        this.newline();
        this.space();
        this.printJoin(props, true, true, void 0, void 0, () => {
          if (props.length !== 1 || node.inexact) {
            this.tokenChar(44);
            this.space();
          }
        });
        this.space();
      }
      if (node.inexact) {
        this.indent();
        this.token("...");
        if (props.length) {
          this.newline();
        }
        this.dedent();
      }
      if (node.exact) {
        this.token("|}");
      } else {
        this.tokenChar(125);
      }
    }
    function ObjectTypeInternalSlot(node) {
      if (node.static) {
        this.word("static");
        this.space();
      }
      this.tokenChar(91);
      this.tokenChar(91);
      this.print(node.id);
      this.tokenChar(93);
      this.tokenChar(93);
      if (node.optional) this.tokenChar(63);
      if (!node.method) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node.value);
    }
    function ObjectTypeCallProperty(node) {
      if (node.static) {
        this.word("static");
        this.space();
      }
      this.print(node.value);
    }
    function ObjectTypeIndexer(node) {
      if (node.static) {
        this.word("static");
        this.space();
      }
      this._variance(node);
      this.tokenChar(91);
      if (node.id) {
        this.print(node.id);
        this.tokenChar(58);
        this.space();
      }
      this.print(node.key);
      this.tokenChar(93);
      this.tokenChar(58);
      this.space();
      this.print(node.value);
    }
    function ObjectTypeProperty(node) {
      if (node.proto) {
        this.word("proto");
        this.space();
      }
      if (node.static) {
        this.word("static");
        this.space();
      }
      if (node.kind === "get" || node.kind === "set") {
        this.word(node.kind);
        this.space();
      }
      this._variance(node);
      this.print(node.key);
      if (node.optional) this.tokenChar(63);
      if (!node.method) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node.value);
    }
    function ObjectTypeSpreadProperty(node) {
      this.token("...");
      this.print(node.argument);
    }
    function QualifiedTypeIdentifier(node) {
      this.print(node.qualification);
      this.tokenChar(46);
      this.print(node.id);
    }
    function SymbolTypeAnnotation() {
      this.word("symbol");
    }
    function orSeparator(occurrenceCount) {
      this.space();
      this.token("|", false, occurrenceCount);
      this.space();
    }
    function UnionTypeAnnotation(node) {
      this.printJoin(node.types, void 0, void 0, orSeparator);
    }
    function TypeCastExpression(node) {
      this.tokenChar(40);
      this.print(node.expression);
      this.print(node.typeAnnotation);
      this.tokenChar(41);
    }
    function Variance(node) {
      if (node.kind === "plus") {
        this.tokenChar(43);
      } else {
        this.tokenChar(45);
      }
    }
    function VoidTypeAnnotation() {
      this.word("void");
    }
    function IndexedAccessType(node) {
      this.print(node.objectType, true);
      this.tokenChar(91);
      this.print(node.indexType);
      this.tokenChar(93);
    }
    function OptionalIndexedAccessType(node) {
      this.print(node.objectType);
      if (node.optional) {
        this.token("?.");
      }
      this.tokenChar(91);
      this.print(node.indexType);
      this.tokenChar(93);
    }
  }
});

// node_modules/@babel/generator/lib/generators/base.js
var require_base = __commonJS({
  "node_modules/@babel/generator/lib/generators/base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BlockStatement = BlockStatement;
    exports.Directive = Directive;
    exports.DirectiveLiteral = DirectiveLiteral;
    exports.File = File;
    exports.InterpreterDirective = InterpreterDirective;
    exports.Placeholder = Placeholder;
    exports.Program = Program;
    function File(node) {
      if (node.program) {
        this.print(node.program.interpreter);
      }
      this.print(node.program);
    }
    function Program(node) {
      var _node$directives;
      this.noIndentInnerCommentsHere();
      this.printInnerComments();
      const directivesLen = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;
      if (directivesLen) {
        var _node$directives$trai;
        const newline = node.body.length ? 2 : 1;
        this.printSequence(node.directives, void 0, newline);
        if (!((_node$directives$trai = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai.length)) {
          this.newline(newline);
        }
      }
      this.printSequence(node.body);
    }
    function BlockStatement(node) {
      var _node$directives2;
      this.tokenChar(123);
      const exit = this.enterDelimited();
      const directivesLen = (_node$directives2 = node.directives) == null ? void 0 : _node$directives2.length;
      if (directivesLen) {
        var _node$directives$trai2;
        const newline = node.body.length ? 2 : 1;
        this.printSequence(node.directives, true, newline);
        if (!((_node$directives$trai2 = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai2.length)) {
          this.newline(newline);
        }
      }
      this.printSequence(node.body, true);
      exit();
      this.rightBrace(node);
    }
    function Directive(node) {
      this.print(node.value);
      this.semicolon();
    }
    var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
    var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
    function DirectiveLiteral(node) {
      const raw = this.getPossibleRaw(node);
      if (!this.format.minified && raw !== void 0) {
        this.token(raw);
        return;
      }
      const {
        value
      } = node;
      if (!unescapedDoubleQuoteRE.test(value)) {
        this.token(`"${value}"`);
      } else if (!unescapedSingleQuoteRE.test(value)) {
        this.token(`'${value}'`);
      } else {
        throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
      }
    }
    function InterpreterDirective(node) {
      this.token(`#!${node.value}`);
      this.newline(1, true);
    }
    function Placeholder(node) {
      this.token("%%");
      this.print(node.name);
      this.token("%%");
      if (node.expectedNode === "Statement") {
        this.semicolon();
      }
    }
  }
});

// node_modules/@babel/generator/lib/generators/jsx.js
var require_jsx2 = __commonJS({
  "node_modules/@babel/generator/lib/generators/jsx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JSXAttribute = JSXAttribute;
    exports.JSXClosingElement = JSXClosingElement;
    exports.JSXClosingFragment = JSXClosingFragment;
    exports.JSXElement = JSXElement;
    exports.JSXEmptyExpression = JSXEmptyExpression;
    exports.JSXExpressionContainer = JSXExpressionContainer;
    exports.JSXFragment = JSXFragment;
    exports.JSXIdentifier = JSXIdentifier;
    exports.JSXMemberExpression = JSXMemberExpression;
    exports.JSXNamespacedName = JSXNamespacedName;
    exports.JSXOpeningElement = JSXOpeningElement;
    exports.JSXOpeningFragment = JSXOpeningFragment;
    exports.JSXSpreadAttribute = JSXSpreadAttribute;
    exports.JSXSpreadChild = JSXSpreadChild;
    exports.JSXText = JSXText;
    function JSXAttribute(node) {
      this.print(node.name);
      if (node.value) {
        this.tokenChar(61);
        this.print(node.value);
      }
    }
    function JSXIdentifier(node) {
      this.word(node.name);
    }
    function JSXNamespacedName(node) {
      this.print(node.namespace);
      this.tokenChar(58);
      this.print(node.name);
    }
    function JSXMemberExpression(node) {
      this.print(node.object);
      this.tokenChar(46);
      this.print(node.property);
    }
    function JSXSpreadAttribute(node) {
      this.tokenChar(123);
      this.token("...");
      this.print(node.argument);
      this.rightBrace(node);
    }
    function JSXExpressionContainer(node) {
      this.tokenChar(123);
      this.print(node.expression);
      this.rightBrace(node);
    }
    function JSXSpreadChild(node) {
      this.tokenChar(123);
      this.token("...");
      this.print(node.expression);
      this.rightBrace(node);
    }
    function JSXText(node) {
      const raw = this.getPossibleRaw(node);
      if (raw !== void 0) {
        this.token(raw, true);
      } else {
        this.token(node.value, true);
      }
    }
    function JSXElement(node) {
      const open = node.openingElement;
      this.print(open);
      if (open.selfClosing) return;
      this.indent();
      for (const child of node.children) {
        this.print(child);
      }
      this.dedent();
      this.print(node.closingElement);
    }
    function spaceSeparator() {
      this.space();
    }
    function JSXOpeningElement(node) {
      this.tokenChar(60);
      this.print(node.name);
      if (node.typeArguments) {
        this.print(node.typeArguments);
      }
      this.print(node.typeParameters);
      if (node.attributes.length > 0) {
        this.space();
        this.printJoin(node.attributes, void 0, void 0, spaceSeparator);
      }
      if (node.selfClosing) {
        this.space();
        this.tokenChar(47);
      }
      this.tokenChar(62);
    }
    function JSXClosingElement(node) {
      this.tokenChar(60);
      this.tokenChar(47);
      this.print(node.name);
      this.tokenChar(62);
    }
    function JSXEmptyExpression() {
      this.printInnerComments();
    }
    function JSXFragment(node) {
      this.print(node.openingFragment);
      this.indent();
      for (const child of node.children) {
        this.print(child);
      }
      this.dedent();
      this.print(node.closingFragment);
    }
    function JSXOpeningFragment() {
      this.tokenChar(60);
      this.tokenChar(62);
    }
    function JSXClosingFragment() {
      this.token("</");
      this.tokenChar(62);
    }
  }
});

// node_modules/@babel/generator/lib/generators/typescript.js
var require_typescript2 = __commonJS({
  "node_modules/@babel/generator/lib/generators/typescript.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TSAnyKeyword = TSAnyKeyword;
    exports.TSArrayType = TSArrayType;
    exports.TSSatisfiesExpression = exports.TSAsExpression = TSTypeExpression;
    exports.TSBigIntKeyword = TSBigIntKeyword;
    exports.TSBooleanKeyword = TSBooleanKeyword;
    exports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
    exports.TSInterfaceHeritage = exports.TSClassImplements = TSClassImplements;
    exports.TSConditionalType = TSConditionalType;
    exports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
    exports.TSConstructorType = TSConstructorType;
    exports.TSDeclareFunction = TSDeclareFunction;
    exports.TSDeclareMethod = TSDeclareMethod;
    exports.TSEnumBody = TSEnumBody;
    exports.TSEnumDeclaration = TSEnumDeclaration;
    exports.TSEnumMember = TSEnumMember;
    exports.TSExportAssignment = TSExportAssignment;
    exports.TSExternalModuleReference = TSExternalModuleReference;
    exports.TSFunctionType = TSFunctionType;
    exports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
    exports.TSImportType = TSImportType;
    exports.TSIndexSignature = TSIndexSignature;
    exports.TSIndexedAccessType = TSIndexedAccessType;
    exports.TSInferType = TSInferType;
    exports.TSInstantiationExpression = TSInstantiationExpression;
    exports.TSInterfaceBody = TSInterfaceBody;
    exports.TSInterfaceDeclaration = TSInterfaceDeclaration;
    exports.TSIntersectionType = TSIntersectionType;
    exports.TSIntrinsicKeyword = TSIntrinsicKeyword;
    exports.TSLiteralType = TSLiteralType;
    exports.TSMappedType = TSMappedType;
    exports.TSMethodSignature = TSMethodSignature;
    exports.TSModuleBlock = TSModuleBlock;
    exports.TSModuleDeclaration = TSModuleDeclaration;
    exports.TSNamedTupleMember = TSNamedTupleMember;
    exports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
    exports.TSNeverKeyword = TSNeverKeyword;
    exports.TSNonNullExpression = TSNonNullExpression;
    exports.TSNullKeyword = TSNullKeyword;
    exports.TSNumberKeyword = TSNumberKeyword;
    exports.TSObjectKeyword = TSObjectKeyword;
    exports.TSOptionalType = TSOptionalType;
    exports.TSParameterProperty = TSParameterProperty;
    exports.TSParenthesizedType = TSParenthesizedType;
    exports.TSPropertySignature = TSPropertySignature;
    exports.TSQualifiedName = TSQualifiedName;
    exports.TSRestType = TSRestType;
    exports.TSStringKeyword = TSStringKeyword;
    exports.TSSymbolKeyword = TSSymbolKeyword;
    exports.TSTemplateLiteralType = TSTemplateLiteralType;
    exports.TSThisType = TSThisType;
    exports.TSTupleType = TSTupleType;
    exports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
    exports.TSTypeAnnotation = TSTypeAnnotation;
    exports.TSTypeAssertion = TSTypeAssertion;
    exports.TSTypeLiteral = TSTypeLiteral;
    exports.TSTypeOperator = TSTypeOperator;
    exports.TSTypeParameter = TSTypeParameter;
    exports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
    exports.TSTypePredicate = TSTypePredicate;
    exports.TSTypeQuery = TSTypeQuery;
    exports.TSTypeReference = TSTypeReference;
    exports.TSUndefinedKeyword = TSUndefinedKeyword;
    exports.TSUnionType = TSUnionType;
    exports.TSUnknownKeyword = TSUnknownKeyword;
    exports.TSVoidKeyword = TSVoidKeyword;
    exports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;
    exports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
    exports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
    exports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
    function TSTypeAnnotation(node, parent) {
      this.token((parent.type === "TSFunctionType" || parent.type === "TSConstructorType") && parent.typeAnnotation === node ? "=>" : ":");
      this.space();
      if (node.optional) this.tokenChar(63);
      this.print(node.typeAnnotation);
    }
    function TSTypeParameterInstantiation(node, parent) {
      this.tokenChar(60);
      let printTrailingSeparator = parent.type === "ArrowFunctionExpression" && node.params.length === 1;
      if (this.tokenMap && node.start != null && node.end != null) {
        printTrailingSeparator && (printTrailingSeparator = !!this.tokenMap.find(node, (t) => this.tokenMap.matchesOriginal(t, ",")));
        printTrailingSeparator || (printTrailingSeparator = this.shouldPrintTrailingComma(">"));
      }
      this.printList(node.params, printTrailingSeparator);
      this.tokenChar(62);
    }
    function TSTypeParameter(node) {
      if (node.const) {
        this.word("const");
        this.space();
      }
      if (node.in) {
        this.word("in");
        this.space();
      }
      if (node.out) {
        this.word("out");
        this.space();
      }
      this.word(node.name);
      if (node.constraint) {
        this.space();
        this.word("extends");
        this.space();
        this.print(node.constraint);
      }
      if (node.default) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.default);
      }
    }
    function TSParameterProperty(node) {
      if (node.accessibility) {
        this.word(node.accessibility);
        this.space();
      }
      if (node.readonly) {
        this.word("readonly");
        this.space();
      }
      this._param(node.parameter);
    }
    function TSDeclareFunction(node, parent) {
      if (node.declare) {
        this.word("declare");
        this.space();
      }
      this._functionHead(node, parent);
      this.semicolon();
    }
    function TSDeclareMethod(node) {
      this._classMethodHead(node);
      this.semicolon();
    }
    function TSQualifiedName(node) {
      this.print(node.left);
      this.tokenChar(46);
      this.print(node.right);
    }
    function TSCallSignatureDeclaration(node) {
      this.tsPrintSignatureDeclarationBase(node);
      maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function maybePrintTrailingCommaOrSemicolon(printer, node) {
      if (!printer.tokenMap || !node.start || !node.end) {
        printer.semicolon();
        return;
      }
      if (printer.tokenMap.endMatches(node, ",")) {
        printer.token(",");
      } else if (printer.tokenMap.endMatches(node, ";")) {
        printer.semicolon();
      }
    }
    function TSConstructSignatureDeclaration(node) {
      this.word("new");
      this.space();
      this.tsPrintSignatureDeclarationBase(node);
      maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function TSPropertySignature(node) {
      const {
        readonly
      } = node;
      if (readonly) {
        this.word("readonly");
        this.space();
      }
      this.tsPrintPropertyOrMethodName(node);
      this.print(node.typeAnnotation);
      maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function tsPrintPropertyOrMethodName(node) {
      if (node.computed) {
        this.tokenChar(91);
      }
      this.print(node.key);
      if (node.computed) {
        this.tokenChar(93);
      }
      if (node.optional) {
        this.tokenChar(63);
      }
    }
    function TSMethodSignature(node) {
      const {
        kind
      } = node;
      if (kind === "set" || kind === "get") {
        this.word(kind);
        this.space();
      }
      this.tsPrintPropertyOrMethodName(node);
      this.tsPrintSignatureDeclarationBase(node);
      maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function TSIndexSignature(node) {
      const {
        readonly,
        static: isStatic
      } = node;
      if (isStatic) {
        this.word("static");
        this.space();
      }
      if (readonly) {
        this.word("readonly");
        this.space();
      }
      this.tokenChar(91);
      this._parameters(node.parameters, "]");
      this.print(node.typeAnnotation);
      maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function TSAnyKeyword() {
      this.word("any");
    }
    function TSBigIntKeyword() {
      this.word("bigint");
    }
    function TSUnknownKeyword() {
      this.word("unknown");
    }
    function TSNumberKeyword() {
      this.word("number");
    }
    function TSObjectKeyword() {
      this.word("object");
    }
    function TSBooleanKeyword() {
      this.word("boolean");
    }
    function TSStringKeyword() {
      this.word("string");
    }
    function TSSymbolKeyword() {
      this.word("symbol");
    }
    function TSVoidKeyword() {
      this.word("void");
    }
    function TSUndefinedKeyword() {
      this.word("undefined");
    }
    function TSNullKeyword() {
      this.word("null");
    }
    function TSNeverKeyword() {
      this.word("never");
    }
    function TSIntrinsicKeyword() {
      this.word("intrinsic");
    }
    function TSThisType() {
      this.word("this");
    }
    function TSFunctionType(node) {
      this.tsPrintFunctionOrConstructorType(node);
    }
    function TSConstructorType(node) {
      if (node.abstract) {
        this.word("abstract");
        this.space();
      }
      this.word("new");
      this.space();
      this.tsPrintFunctionOrConstructorType(node);
    }
    function tsPrintFunctionOrConstructorType(node) {
      const {
        typeParameters
      } = node;
      const parameters = node.parameters;
      this.print(typeParameters);
      this.tokenChar(40);
      this._parameters(parameters, ")");
      this.space();
      const returnType = node.typeAnnotation;
      this.print(returnType);
    }
    function TSTypeReference(node) {
      const typeArguments = node.typeParameters;
      this.print(node.typeName, !!typeArguments);
      this.print(typeArguments);
    }
    function TSTypePredicate(node) {
      if (node.asserts) {
        this.word("asserts");
        this.space();
      }
      this.print(node.parameterName);
      if (node.typeAnnotation) {
        this.space();
        this.word("is");
        this.space();
        this.print(node.typeAnnotation.typeAnnotation);
      }
    }
    function TSTypeQuery(node) {
      this.word("typeof");
      this.space();
      this.print(node.exprName);
      const typeArguments = node.typeParameters;
      if (typeArguments) {
        this.print(typeArguments);
      }
    }
    function TSTypeLiteral(node) {
      printBraced(this, node, () => this.printJoin(node.members, true, true));
    }
    function TSArrayType(node) {
      this.print(node.elementType, true);
      this.tokenChar(91);
      this.tokenChar(93);
    }
    function TSTupleType(node) {
      this.tokenChar(91);
      this.printList(node.elementTypes, this.shouldPrintTrailingComma("]"));
      this.tokenChar(93);
    }
    function TSOptionalType(node) {
      this.print(node.typeAnnotation);
      this.tokenChar(63);
    }
    function TSRestType(node) {
      this.token("...");
      this.print(node.typeAnnotation);
    }
    function TSNamedTupleMember(node) {
      this.print(node.label);
      if (node.optional) this.tokenChar(63);
      this.tokenChar(58);
      this.space();
      this.print(node.elementType);
    }
    function TSUnionType(node) {
      tsPrintUnionOrIntersectionType(this, node, "|");
    }
    function TSIntersectionType(node) {
      tsPrintUnionOrIntersectionType(this, node, "&");
    }
    function tsPrintUnionOrIntersectionType(printer, node, sep) {
      var _printer$tokenMap;
      let hasLeadingToken = 0;
      if ((_printer$tokenMap = printer.tokenMap) != null && _printer$tokenMap.startMatches(node, sep)) {
        hasLeadingToken = 1;
        printer.token(sep);
      }
      printer.printJoin(node.types, void 0, void 0, function(i) {
        this.space();
        this.token(sep, void 0, i + hasLeadingToken);
        this.space();
      });
    }
    function TSConditionalType(node) {
      this.print(node.checkType);
      this.space();
      this.word("extends");
      this.space();
      this.print(node.extendsType);
      this.space();
      this.tokenChar(63);
      this.space();
      this.print(node.trueType);
      this.space();
      this.tokenChar(58);
      this.space();
      this.print(node.falseType);
    }
    function TSInferType(node) {
      this.word("infer");
      this.print(node.typeParameter);
    }
    function TSParenthesizedType(node) {
      this.tokenChar(40);
      this.print(node.typeAnnotation);
      this.tokenChar(41);
    }
    function TSTypeOperator(node) {
      this.word(node.operator);
      this.space();
      this.print(node.typeAnnotation);
    }
    function TSIndexedAccessType(node) {
      this.print(node.objectType, true);
      this.tokenChar(91);
      this.print(node.indexType);
      this.tokenChar(93);
    }
    function TSMappedType(node) {
      const {
        nameType,
        optional,
        readonly,
        typeAnnotation
      } = node;
      this.tokenChar(123);
      const exit = this.enterDelimited();
      this.space();
      if (readonly) {
        tokenIfPlusMinus(this, readonly);
        this.word("readonly");
        this.space();
      }
      this.tokenChar(91);
      this.word(node.typeParameter.name);
      this.space();
      this.word("in");
      this.space();
      this.print(node.typeParameter.constraint);
      if (nameType) {
        this.space();
        this.word("as");
        this.space();
        this.print(nameType);
      }
      this.tokenChar(93);
      if (optional) {
        tokenIfPlusMinus(this, optional);
        this.tokenChar(63);
      }
      if (typeAnnotation) {
        this.tokenChar(58);
        this.space();
        this.print(typeAnnotation);
      }
      this.space();
      exit();
      this.tokenChar(125);
    }
    function tokenIfPlusMinus(self2, tok) {
      if (tok !== true) {
        self2.token(tok);
      }
    }
    function TSTemplateLiteralType(node) {
      this._printTemplate(node, node.types);
    }
    function TSLiteralType(node) {
      this.print(node.literal);
    }
    function TSClassImplements(node) {
      this.print(node.expression);
      this.print(node.typeArguments);
    }
    function TSInterfaceDeclaration(node) {
      const {
        declare,
        id,
        typeParameters,
        extends: extendz,
        body
      } = node;
      if (declare) {
        this.word("declare");
        this.space();
      }
      this.word("interface");
      this.space();
      this.print(id);
      this.print(typeParameters);
      if (extendz != null && extendz.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(extendz);
      }
      this.space();
      this.print(body);
    }
    function TSInterfaceBody(node) {
      printBraced(this, node, () => this.printJoin(node.body, true, true));
    }
    function TSTypeAliasDeclaration(node) {
      const {
        declare,
        id,
        typeParameters,
        typeAnnotation
      } = node;
      if (declare) {
        this.word("declare");
        this.space();
      }
      this.word("type");
      this.space();
      this.print(id);
      this.print(typeParameters);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(typeAnnotation);
      this.semicolon();
    }
    function TSTypeExpression(node) {
      const {
        type,
        expression,
        typeAnnotation
      } = node;
      this.print(expression, true);
      this.space();
      this.word(type === "TSAsExpression" ? "as" : "satisfies");
      this.space();
      this.print(typeAnnotation);
    }
    function TSTypeAssertion(node) {
      const {
        typeAnnotation,
        expression
      } = node;
      this.tokenChar(60);
      this.print(typeAnnotation);
      this.tokenChar(62);
      this.space();
      this.print(expression);
    }
    function TSInstantiationExpression(node) {
      this.print(node.expression);
      this.print(node.typeParameters);
    }
    function TSEnumDeclaration(node) {
      const {
        declare,
        const: isConst,
        id
      } = node;
      if (declare) {
        this.word("declare");
        this.space();
      }
      if (isConst) {
        this.word("const");
        this.space();
      }
      this.word("enum");
      this.space();
      this.print(id);
      this.space();
      TSEnumBody.call(this, node);
    }
    function TSEnumBody(node) {
      printBraced(this, node, () => {
        var _this$shouldPrintTrai;
        return this.printList(node.members, (_this$shouldPrintTrai = this.shouldPrintTrailingComma("}")) != null ? _this$shouldPrintTrai : true, true, true);
      });
    }
    function TSEnumMember(node) {
      const {
        id,
        initializer
      } = node;
      this.print(id);
      if (initializer) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(initializer);
      }
    }
    function TSModuleDeclaration(node) {
      const {
        declare,
        id,
        kind
      } = node;
      if (declare) {
        this.word("declare");
        this.space();
      }
      if (!node.global) {
        this.word(kind != null ? kind : id.type === "Identifier" ? "namespace" : "module");
        this.space();
      }
      this.print(id);
      if (!node.body) {
        this.semicolon();
        return;
      }
      let body = node.body;
      while (body.type === "TSModuleDeclaration") {
        this.tokenChar(46);
        this.print(body.id);
        body = body.body;
      }
      this.space();
      this.print(body);
    }
    function TSModuleBlock(node) {
      printBraced(this, node, () => this.printSequence(node.body, true));
    }
    function TSImportType(node) {
      const {
        qualifier,
        options
      } = node;
      this.word("import");
      this.tokenChar(40);
      this.print(node.argument);
      if (options) {
        this.tokenChar(44);
        this.print(options);
      }
      this.tokenChar(41);
      if (qualifier) {
        this.tokenChar(46);
        this.print(qualifier);
      }
      const typeArguments = node.typeParameters;
      if (typeArguments) {
        this.print(typeArguments);
      }
    }
    function TSImportEqualsDeclaration(node) {
      const {
        id,
        moduleReference
      } = node;
      if (node.isExport) {
        this.word("export");
        this.space();
      }
      this.word("import");
      this.space();
      this.print(id);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(moduleReference);
      this.semicolon();
    }
    function TSExternalModuleReference(node) {
      this.token("require(");
      this.print(node.expression);
      this.tokenChar(41);
    }
    function TSNonNullExpression(node) {
      this.print(node.expression);
      this.tokenChar(33);
    }
    function TSExportAssignment(node) {
      this.word("export");
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.expression);
      this.semicolon();
    }
    function TSNamespaceExportDeclaration(node) {
      this.word("export");
      this.space();
      this.word("as");
      this.space();
      this.word("namespace");
      this.space();
      this.print(node.id);
      this.semicolon();
    }
    function tsPrintSignatureDeclarationBase(node) {
      const {
        typeParameters
      } = node;
      const parameters = node.parameters;
      this.print(typeParameters);
      this.tokenChar(40);
      this._parameters(parameters, ")");
      const returnType = node.typeAnnotation;
      this.print(returnType);
    }
    function tsPrintClassMemberModifiers(node) {
      const isPrivateField = node.type === "ClassPrivateProperty";
      const isPublicField = node.type === "ClassAccessorProperty" || node.type === "ClassProperty";
      printModifiersList(this, node, [isPublicField && node.declare && "declare", !isPrivateField && node.accessibility]);
      if (node.static) {
        this.word("static");
        this.space();
      }
      printModifiersList(this, node, [!isPrivateField && node.abstract && "abstract", !isPrivateField && node.override && "override", (isPublicField || isPrivateField) && node.readonly && "readonly"]);
    }
    function printBraced(printer, node, cb) {
      printer.token("{");
      const exit = printer.enterDelimited();
      cb();
      exit();
      printer.rightBrace(node);
    }
    function printModifiersList(printer, node, modifiers2) {
      var _printer$tokenMap2;
      const modifiersSet = /* @__PURE__ */ new Set();
      for (const modifier of modifiers2) {
        if (modifier) modifiersSet.add(modifier);
      }
      (_printer$tokenMap2 = printer.tokenMap) == null || _printer$tokenMap2.find(node, (tok) => {
        if (modifiersSet.has(tok.value)) {
          printer.token(tok.value);
          printer.space();
          modifiersSet.delete(tok.value);
          return modifiersSet.size === 0;
        }
        return false;
      });
      for (const modifier of modifiersSet) {
        printer.word(modifier);
        printer.space();
      }
    }
  }
});

// node_modules/@babel/generator/lib/generators/index.js
var require_generators = __commonJS({
  "node_modules/@babel/generator/lib/generators/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _templateLiterals = require_template_literals();
    Object.keys(_templateLiterals).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _templateLiterals[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _templateLiterals[key];
        }
      });
    });
    var _expressions = require_expressions();
    Object.keys(_expressions).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _expressions[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _expressions[key];
        }
      });
    });
    var _statements = require_statements();
    Object.keys(_statements).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _statements[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _statements[key];
        }
      });
    });
    var _classes = require_classes();
    Object.keys(_classes).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _classes[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _classes[key];
        }
      });
    });
    var _methods = require_methods();
    Object.keys(_methods).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _methods[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _methods[key];
        }
      });
    });
    var _modules = require_modules();
    Object.keys(_modules).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _modules[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _modules[key];
        }
      });
    });
    var _types = require_types();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _types[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _types[key];
        }
      });
    });
    var _flow = require_flow2();
    Object.keys(_flow).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _flow[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _flow[key];
        }
      });
    });
    var _base = require_base();
    Object.keys(_base).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _base[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _base[key];
        }
      });
    });
    var _jsx = require_jsx2();
    Object.keys(_jsx).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _jsx[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _jsx[key];
        }
      });
    });
    var _typescript = require_typescript2();
    Object.keys(_typescript).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _typescript[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _typescript[key];
        }
      });
    });
  }
});

// node_modules/@babel/generator/lib/generators/deprecated.js
var require_deprecated = __commonJS({
  "node_modules/@babel/generator/lib/generators/deprecated.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.addDeprecatedGenerators = addDeprecatedGenerators;
    function addDeprecatedGenerators(PrinterClass) {
      const deprecatedBabel7Generators = {
        Noop() {
        },
        TSExpressionWithTypeArguments(node) {
          this.print(node.expression);
          this.print(node.typeParameters);
        },
        DecimalLiteral(node) {
          const raw = this.getPossibleRaw(node);
          if (!this.format.minified && raw !== void 0) {
            this.word(raw);
            return;
          }
          this.word(node.value + "m");
        },
        RecordExpression(node) {
          const props = node.properties;
          let startToken;
          let endToken;
          if (this.format.recordAndTupleSyntaxType === "bar") {
            startToken = "{|";
            endToken = "|}";
          } else if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) {
            throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
          } else {
            startToken = "#{";
            endToken = "}";
          }
          this.token(startToken);
          if (props.length) {
            this.space();
            this.printList(props, this.shouldPrintTrailingComma(endToken), true, true);
            this.space();
          }
          this.token(endToken);
        },
        TupleExpression(node) {
          const elems = node.elements;
          const len = elems.length;
          let startToken;
          let endToken;
          if (this.format.recordAndTupleSyntaxType === "bar") {
            startToken = "[|";
            endToken = "|]";
          } else if (this.format.recordAndTupleSyntaxType === "hash") {
            startToken = "#[";
            endToken = "]";
          } else {
            throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
          }
          this.token(startToken);
          for (let i = 0; i < elems.length; i++) {
            const elem = elems[i];
            if (elem) {
              if (i > 0) this.space();
              this.print(elem);
              if (i < len - 1 || this.shouldPrintTrailingComma(endToken)) {
                this.token(",", false, i);
              }
            }
          }
          this.token(endToken);
        }
      };
      Object.assign(PrinterClass.prototype, deprecatedBabel7Generators);
    }
  }
});

// node_modules/@babel/generator/lib/printer.js
var require_printer = __commonJS({
  "node_modules/@babel/generator/lib/printer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _buffer = require_buffer();
    var _index = require_node();
    var n2 = _index;
    var _t = require_lib4();
    var _tokenMap = require_token_map();
    var generatorFunctions = require_generators();
    var _deprecated = require_deprecated();
    var {
      isExpression,
      isFunction,
      isStatement,
      isClassBody,
      isTSInterfaceBody,
      isTSEnumMember
    } = _t;
    var SCIENTIFIC_NOTATION = /e/i;
    var ZERO_DECIMAL_INTEGER = /\.0+$/;
    var HAS_NEWLINE = /[\n\r\u2028\u2029]/;
    var HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\n\r\u2028\u2029]|\*\//;
    function commentIsNewline(c) {
      return c.type === "CommentLine" || HAS_NEWLINE.test(c.value);
    }
    var {
      needsParens
    } = n2;
    var Printer = class {
      constructor(format, map, tokens = null, originalCode = null) {
        this.tokenContext = _index.TokenContext.normal;
        this._tokens = null;
        this._originalCode = null;
        this._currentNode = null;
        this._indent = 0;
        this._indentRepeat = 0;
        this._insideAux = false;
        this._noLineTerminator = false;
        this._noLineTerminatorAfterNode = null;
        this._printAuxAfterOnNextUserNode = false;
        this._printedComments = /* @__PURE__ */ new Set();
        this._endsWithInteger = false;
        this._endsWithWord = false;
        this._endsWithDiv = false;
        this._lastCommentLine = 0;
        this._endsWithInnerRaw = false;
        this._indentInnerComments = true;
        this.tokenMap = null;
        this._boundGetRawIdentifier = this._getRawIdentifier.bind(this);
        this._printSemicolonBeforeNextNode = -1;
        this._printSemicolonBeforeNextToken = -1;
        this.format = format;
        this._tokens = tokens;
        this._originalCode = originalCode;
        this._indentRepeat = format.indent.style.length;
        this._inputMap = (map == null ? void 0 : map._inputMap) || null;
        this._buf = new _buffer.default(map, format.indent.style[0]);
      }
      enterForStatementInit() {
        this.tokenContext |= _index.TokenContext.forInitHead | _index.TokenContext.forInOrInitHeadAccumulate;
        return () => this.tokenContext = _index.TokenContext.normal;
      }
      enterForXStatementInit(isForOf) {
        if (isForOf) {
          this.tokenContext |= _index.TokenContext.forOfHead;
          return null;
        } else {
          this.tokenContext |= _index.TokenContext.forInHead | _index.TokenContext.forInOrInitHeadAccumulate;
          return () => this.tokenContext = _index.TokenContext.normal;
        }
      }
      enterDelimited() {
        const oldTokenContext = this.tokenContext;
        const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
        if (!(oldTokenContext & _index.TokenContext.forInOrInitHeadAccumulate) && oldNoLineTerminatorAfterNode === null) {
          return () => {
          };
        }
        this._noLineTerminatorAfterNode = null;
        this.tokenContext = _index.TokenContext.normal;
        return () => {
          this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
          this.tokenContext = oldTokenContext;
        };
      }
      generate(ast) {
        if (this.format.preserveFormat) {
          this.tokenMap = new _tokenMap.TokenMap(ast, this._tokens, this._originalCode);
        }
        this.print(ast);
        this._maybeAddAuxComment();
        return this._buf.get();
      }
      indent() {
        const {
          format
        } = this;
        if (format.preserveFormat || format.compact || format.concise) {
          return;
        }
        this._indent++;
      }
      dedent() {
        const {
          format
        } = this;
        if (format.preserveFormat || format.compact || format.concise) {
          return;
        }
        this._indent--;
      }
      semicolon(force = false) {
        this._maybeAddAuxComment();
        if (force) {
          this._appendChar(59);
          this._noLineTerminator = false;
          return;
        }
        if (this.tokenMap) {
          const node = this._currentNode;
          if (node.start != null && node.end != null) {
            if (!this.tokenMap.endMatches(node, ";")) {
              this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
              return;
            }
            const indexes = this.tokenMap.getIndexes(this._currentNode);
            this._catchUpTo(this._tokens[indexes[indexes.length - 1]].loc.start);
          }
        }
        this._queue(59);
        this._noLineTerminator = false;
      }
      rightBrace(node) {
        if (this.format.minified) {
          this._buf.removeLastSemicolon();
        }
        this.sourceWithOffset("end", node.loc, -1);
        this.tokenChar(125);
      }
      rightParens(node) {
        this.sourceWithOffset("end", node.loc, -1);
        this.tokenChar(41);
      }
      space(force = false) {
        const {
          format
        } = this;
        if (format.compact || format.preserveFormat) return;
        if (force) {
          this._space();
        } else if (this._buf.hasContent()) {
          const lastCp = this.getLastChar();
          if (lastCp !== 32 && lastCp !== 10) {
            this._space();
          }
        }
      }
      word(str, noLineTerminatorAfter = false) {
        this.tokenContext &= _index.TokenContext.forInOrInitHeadAccumulatePassThroughMask;
        this._maybePrintInnerComments(str);
        this._maybeAddAuxComment();
        if (this.tokenMap) this._catchUpToCurrentToken(str);
        if (this._endsWithWord || this._endsWithDiv && str.charCodeAt(0) === 47) {
          this._space();
        }
        this._append(str, false);
        this._endsWithWord = true;
        this._noLineTerminator = noLineTerminatorAfter;
      }
      number(str, number4) {
        function isNonDecimalLiteral(str2) {
          if (str2.length > 2 && str2.charCodeAt(0) === 48) {
            const secondChar = str2.charCodeAt(1);
            return secondChar === 98 || secondChar === 111 || secondChar === 120;
          }
          return false;
        }
        this.word(str);
        this._endsWithInteger = Number.isInteger(number4) && !isNonDecimalLiteral(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
      }
      token(str, maybeNewline = false, occurrenceCount = 0) {
        this.tokenContext &= _index.TokenContext.forInOrInitHeadAccumulatePassThroughMask;
        this._maybePrintInnerComments(str, occurrenceCount);
        this._maybeAddAuxComment();
        if (this.tokenMap) this._catchUpToCurrentToken(str, occurrenceCount);
        const lastChar = this.getLastChar();
        const strFirst = str.charCodeAt(0);
        if (lastChar === 33 && (str === "--" || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {
          this._space();
        }
        this._append(str, maybeNewline);
        this._noLineTerminator = false;
      }
      tokenChar(char) {
        this.tokenContext &= _index.TokenContext.forInOrInitHeadAccumulatePassThroughMask;
        const str = String.fromCharCode(char);
        this._maybePrintInnerComments(str);
        this._maybeAddAuxComment();
        if (this.tokenMap) this._catchUpToCurrentToken(str);
        const lastChar = this.getLastChar();
        if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {
          this._space();
        }
        this._appendChar(char);
        this._noLineTerminator = false;
      }
      newline(i = 1, force) {
        if (i <= 0) return;
        if (!force) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        if (i > 2) i = 2;
        i -= this._buf.getNewlineCount();
        for (let j = 0; j < i; j++) {
          this._newline();
        }
        return;
      }
      endsWith(char) {
        return this.getLastChar() === char;
      }
      getLastChar() {
        return this._buf.getLastChar();
      }
      endsWithCharAndNewline() {
        return this._buf.endsWithCharAndNewline();
      }
      removeTrailingNewline() {
        this._buf.removeTrailingNewline();
      }
      exactSource(loc, cb) {
        if (!loc) {
          cb();
          return;
        }
        this._catchUp("start", loc);
        this._buf.exactSource(loc, cb);
      }
      source(prop, loc) {
        if (!loc) return;
        this._catchUp(prop, loc);
        this._buf.source(prop, loc);
      }
      sourceWithOffset(prop, loc, columnOffset) {
        if (!loc || this.format.preserveFormat) return;
        this._catchUp(prop, loc);
        this._buf.sourceWithOffset(prop, loc, columnOffset);
      }
      sourceIdentifierName(identifierName, pos) {
        if (!this._buf._canMarkIdName) return;
        const sourcePosition = this._buf._sourcePosition;
        sourcePosition.identifierNamePos = pos;
        sourcePosition.identifierName = identifierName;
      }
      _space() {
        this._queue(32);
      }
      _newline() {
        this._queue(10);
      }
      _catchUpToCurrentToken(str, occurrenceCount = 0) {
        const token = this.tokenMap.findMatching(this._currentNode, str, occurrenceCount);
        if (token) this._catchUpTo(token.loc.start);
        if (this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()) {
          this._buf.appendChar(59);
          this._endsWithWord = false;
          this._endsWithInteger = false;
          this._endsWithDiv = false;
        }
        this._printSemicolonBeforeNextToken = -1;
        this._printSemicolonBeforeNextNode = -1;
      }
      _append(str, maybeNewline) {
        this._maybeIndent(str.charCodeAt(0));
        this._buf.append(str, maybeNewline);
        this._endsWithWord = false;
        this._endsWithInteger = false;
        this._endsWithDiv = false;
      }
      _appendChar(char) {
        this._maybeIndent(char);
        this._buf.appendChar(char);
        this._endsWithWord = false;
        this._endsWithInteger = false;
        this._endsWithDiv = false;
      }
      _queue(char) {
        this._maybeIndent(char);
        this._buf.queue(char);
        this._endsWithWord = false;
        this._endsWithInteger = false;
      }
      _maybeIndent(firstChar) {
        if (this._indent && firstChar !== 10 && this.endsWith(10)) {
          this._buf.queueIndentation(this._getIndent());
        }
      }
      _shouldIndent(firstChar) {
        if (this._indent && firstChar !== 10 && this.endsWith(10)) {
          return true;
        }
      }
      catchUp(line) {
        if (!this.format.retainLines) return;
        const count = line - this._buf.getCurrentLine();
        for (let i = 0; i < count; i++) {
          this._newline();
        }
      }
      _catchUp(prop, loc) {
        const {
          format
        } = this;
        if (!format.preserveFormat) {
          if (format.retainLines && loc != null && loc[prop]) {
            this.catchUp(loc[prop].line);
          }
          return;
        }
        const pos = loc == null ? void 0 : loc[prop];
        if (pos != null) this._catchUpTo(pos);
      }
      _catchUpTo({
        line,
        column,
        index
      }) {
        const count = line - this._buf.getCurrentLine();
        if (count > 0 && this._noLineTerminator) {
          return;
        }
        for (let i = 0; i < count; i++) {
          this._newline();
        }
        const spacesCount = count > 0 ? column : column - this._buf.getCurrentColumn();
        if (spacesCount > 0) {
          const spaces3 = this._originalCode ? this._originalCode.slice(index - spacesCount, index).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu, " ") : " ".repeat(spacesCount);
          this._append(spaces3, false);
        }
      }
      _getIndent() {
        return this._indentRepeat * this._indent;
      }
      printTerminatorless(node) {
        this._noLineTerminator = true;
        this.print(node);
      }
      print(node, noLineTerminatorAfter = false, trailingCommentsLineOffset) {
        var _node$extra, _node$leadingComments, _node$leadingComments2;
        if (!node) return;
        this._endsWithInnerRaw = false;
        const nodeType = node.type;
        const format = this.format;
        const oldConcise = format.concise;
        if (node._compact) {
          format.concise = true;
        }
        const printMethod = this[nodeType];
        if (printMethod === void 0) {
          throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`);
        }
        const parent = this._currentNode;
        this._currentNode = node;
        if (this.tokenMap) {
          this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;
        }
        const oldInAux = this._insideAux;
        this._insideAux = node.loc == null;
        this._maybeAddAuxComment(this._insideAux && !oldInAux);
        const parenthesized = (_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized;
        let shouldPrintParens = parenthesized && format.preserveFormat || parenthesized && format.retainFunctionParens && nodeType === "FunctionExpression" || needsParens(node, parent, this.tokenContext, format.preserveFormat ? this._boundGetRawIdentifier : void 0);
        if (!shouldPrintParens && parenthesized && (_node$leadingComments = node.leadingComments) != null && _node$leadingComments.length && node.leadingComments[0].type === "CommentBlock") {
          const parentType = parent == null ? void 0 : parent.type;
          switch (parentType) {
            case "ExpressionStatement":
            case "VariableDeclarator":
            case "AssignmentExpression":
            case "ReturnStatement":
              break;
            case "CallExpression":
            case "OptionalCallExpression":
            case "NewExpression":
              if (parent.callee !== node) break;
            default:
              shouldPrintParens = true;
          }
        }
        let indentParenthesized = false;
        if (!shouldPrintParens && this._noLineTerminator && ((_node$leadingComments2 = node.leadingComments) != null && _node$leadingComments2.some(commentIsNewline) || this.format.retainLines && node.loc && node.loc.start.line > this._buf.getCurrentLine())) {
          shouldPrintParens = true;
          indentParenthesized = true;
        }
        let oldNoLineTerminatorAfterNode;
        let oldTokenContext;
        if (!shouldPrintParens) {
          noLineTerminatorAfter || (noLineTerminatorAfter = !!parent && this._noLineTerminatorAfterNode === parent && n2.isLastChild(parent, node));
          if (noLineTerminatorAfter) {
            var _node$trailingComment;
            if ((_node$trailingComment = node.trailingComments) != null && _node$trailingComment.some(commentIsNewline)) {
              if (isExpression(node)) shouldPrintParens = true;
            } else {
              oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
              this._noLineTerminatorAfterNode = node;
            }
          }
        }
        if (shouldPrintParens) {
          this.tokenChar(40);
          if (indentParenthesized) this.indent();
          this._endsWithInnerRaw = false;
          if (this.tokenContext & _index.TokenContext.forInOrInitHeadAccumulate) {
            oldTokenContext = this.tokenContext;
            this.tokenContext = _index.TokenContext.normal;
          }
          oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
          this._noLineTerminatorAfterNode = null;
        }
        this._lastCommentLine = 0;
        this._printLeadingComments(node, parent);
        const loc = nodeType === "Program" || nodeType === "File" ? null : node.loc;
        this.exactSource(loc, printMethod.bind(this, node, parent));
        if (shouldPrintParens) {
          this._printTrailingComments(node, parent);
          if (indentParenthesized) {
            this.dedent();
            this.newline();
          }
          this.tokenChar(41);
          this._noLineTerminator = noLineTerminatorAfter;
          if (oldTokenContext) this.tokenContext = oldTokenContext;
        } else if (noLineTerminatorAfter && !this._noLineTerminator) {
          this._noLineTerminator = true;
          this._printTrailingComments(node, parent);
        } else {
          this._printTrailingComments(node, parent, trailingCommentsLineOffset);
        }
        this._currentNode = parent;
        format.concise = oldConcise;
        this._insideAux = oldInAux;
        if (oldNoLineTerminatorAfterNode !== void 0) {
          this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
        }
        this._endsWithInnerRaw = false;
      }
      _maybeAddAuxComment(enteredPositionlessNode) {
        if (enteredPositionlessNode) this._printAuxBeforeComment();
        if (!this._insideAux) this._printAuxAfterComment();
      }
      _printAuxBeforeComment() {
        if (this._printAuxAfterOnNextUserNode) return;
        this._printAuxAfterOnNextUserNode = true;
        const comment = this.format.auxiliaryCommentBefore;
        if (comment) {
          this._printComment({
            type: "CommentBlock",
            value: comment
          }, 0);
        }
      }
      _printAuxAfterComment() {
        if (!this._printAuxAfterOnNextUserNode) return;
        this._printAuxAfterOnNextUserNode = false;
        const comment = this.format.auxiliaryCommentAfter;
        if (comment) {
          this._printComment({
            type: "CommentBlock",
            value: comment
          }, 0);
        }
      }
      getPossibleRaw(node) {
        const extra = node.extra;
        if ((extra == null ? void 0 : extra.raw) != null && extra.rawValue != null && node.value === extra.rawValue) {
          return extra.raw;
        }
      }
      printJoin(nodes, statement, indent, separator, printTrailingSeparator, iterator, trailingCommentsLineOffset) {
        if (!(nodes != null && nodes.length)) return;
        if (indent == null && this.format.retainLines) {
          var _nodes$0$loc;
          const startLine = (_nodes$0$loc = nodes[0].loc) == null ? void 0 : _nodes$0$loc.start.line;
          if (startLine != null && startLine !== this._buf.getCurrentLine()) {
            indent = true;
          }
        }
        if (indent) this.indent();
        const newlineOpts = {
          nextNodeStartLine: 0
        };
        const boundSeparator = separator == null ? void 0 : separator.bind(this);
        const len = nodes.length;
        for (let i = 0; i < len; i++) {
          const node = nodes[i];
          if (!node) continue;
          if (statement) this._printNewline(i === 0, newlineOpts);
          this.print(node, void 0, trailingCommentsLineOffset || 0);
          iterator == null || iterator(node, i);
          if (boundSeparator != null) {
            if (i < len - 1) boundSeparator(i, false);
            else if (printTrailingSeparator) boundSeparator(i, true);
          }
          if (statement) {
            var _node$trailingComment2;
            if (!((_node$trailingComment2 = node.trailingComments) != null && _node$trailingComment2.length)) {
              this._lastCommentLine = 0;
            }
            if (i + 1 === len) {
              this.newline(1);
            } else {
              var _nextNode$loc;
              const nextNode = nodes[i + 1];
              newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? void 0 : _nextNode$loc.start.line) || 0;
              this._printNewline(true, newlineOpts);
            }
          }
        }
        if (indent) this.dedent();
      }
      printAndIndentOnComments(node) {
        const indent = node.leadingComments && node.leadingComments.length > 0;
        if (indent) this.indent();
        this.print(node);
        if (indent) this.dedent();
      }
      printBlock(parent) {
        const node = parent.body;
        if (node.type !== "EmptyStatement") {
          this.space();
        }
        this.print(node);
      }
      _printTrailingComments(node, parent, lineOffset) {
        const {
          innerComments,
          trailingComments
        } = node;
        if (innerComments != null && innerComments.length) {
          this._printComments(2, innerComments, node, parent, lineOffset);
        }
        if (trailingComments != null && trailingComments.length) {
          this._printComments(2, trailingComments, node, parent, lineOffset);
        }
      }
      _printLeadingComments(node, parent) {
        const comments = node.leadingComments;
        if (!(comments != null && comments.length)) return;
        this._printComments(0, comments, node, parent);
      }
      _maybePrintInnerComments(nextTokenStr, nextTokenOccurrenceCount) {
        if (this._endsWithInnerRaw) {
          var _this$tokenMap;
          this.printInnerComments((_this$tokenMap = this.tokenMap) == null ? void 0 : _this$tokenMap.findMatching(this._currentNode, nextTokenStr, nextTokenOccurrenceCount));
        }
        this._endsWithInnerRaw = true;
        this._indentInnerComments = true;
      }
      printInnerComments(nextToken) {
        const node = this._currentNode;
        const comments = node.innerComments;
        if (!(comments != null && comments.length)) return;
        const hasSpace = this.endsWith(32);
        const indent = this._indentInnerComments;
        const printedCommentsCount = this._printedComments.size;
        if (indent) this.indent();
        this._printComments(1, comments, node, void 0, void 0, nextToken);
        if (hasSpace && printedCommentsCount !== this._printedComments.size) {
          this.space();
        }
        if (indent) this.dedent();
      }
      noIndentInnerCommentsHere() {
        this._indentInnerComments = false;
      }
      printSequence(nodes, indent, trailingCommentsLineOffset) {
        this.printJoin(nodes, true, indent != null ? indent : false, void 0, void 0, void 0, trailingCommentsLineOffset);
      }
      printList(items, printTrailingSeparator, statement, indent, separator, iterator) {
        this.printJoin(items, statement, indent, separator != null ? separator : commaSeparator, printTrailingSeparator, iterator);
      }
      shouldPrintTrailingComma(listEnd) {
        if (!this.tokenMap) return null;
        const listEndIndex = this.tokenMap.findLastIndex(this._currentNode, (token) => this.tokenMap.matchesOriginal(token, listEnd));
        if (listEndIndex <= 0) return null;
        return this.tokenMap.matchesOriginal(this._tokens[listEndIndex - 1], ",");
      }
      _printNewline(newLine, opts) {
        const format = this.format;
        if (format.retainLines || format.compact) return;
        if (format.concise) {
          this.space();
          return;
        }
        if (!newLine) {
          return;
        }
        const startLine = opts.nextNodeStartLine;
        const lastCommentLine = this._lastCommentLine;
        if (startLine > 0 && lastCommentLine > 0) {
          const offset = startLine - lastCommentLine;
          if (offset >= 0) {
            this.newline(offset || 1);
            return;
          }
        }
        if (this._buf.hasContent()) {
          this.newline(1);
        }
      }
      _shouldPrintComment(comment, nextToken) {
        if (comment.ignore) return 0;
        if (this._printedComments.has(comment)) return 0;
        if (this._noLineTerminator && HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)) {
          return 2;
        }
        if (nextToken && this.tokenMap) {
          const commentTok = this.tokenMap.find(this._currentNode, (token) => token.value === comment.value);
          if (commentTok && commentTok.start > nextToken.start) {
            return 2;
          }
        }
        this._printedComments.add(comment);
        if (!this.format.shouldPrintComment(comment.value)) {
          return 0;
        }
        return 1;
      }
      _printComment(comment, skipNewLines) {
        const noLineTerminator = this._noLineTerminator;
        const isBlockComment = comment.type === "CommentBlock";
        const printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;
        if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {
          this.newline(1);
        }
        const lastCharCode = this.getLastChar();
        if (lastCharCode !== 91 && lastCharCode !== 123 && lastCharCode !== 40) {
          this.space();
        }
        let val;
        if (isBlockComment) {
          val = `/*${comment.value}*/`;
          if (this.format.indent.adjustMultilineComment) {
            var _comment$loc;
            const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;
            if (offset) {
              const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
              val = val.replace(newlineRegex, "\n");
            }
            if (this.format.concise) {
              val = val.replace(/\n(?!$)/g, `
`);
            } else {
              let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
              if (this._shouldIndent(47) || this.format.retainLines) {
                indentSize += this._getIndent();
              }
              val = val.replace(/\n(?!$)/g, `
${" ".repeat(indentSize)}`);
            }
          }
        } else if (!noLineTerminator) {
          val = `//${comment.value}`;
        } else {
          val = `/*${comment.value}*/`;
        }
        if (this._endsWithDiv) this._space();
        if (this.tokenMap) {
          const {
            _printSemicolonBeforeNextToken,
            _printSemicolonBeforeNextNode
          } = this;
          this._printSemicolonBeforeNextToken = -1;
          this._printSemicolonBeforeNextNode = -1;
          this.source("start", comment.loc);
          this._append(val, isBlockComment);
          this._printSemicolonBeforeNextNode = _printSemicolonBeforeNextNode;
          this._printSemicolonBeforeNextToken = _printSemicolonBeforeNextToken;
        } else {
          this.source("start", comment.loc);
          this._append(val, isBlockComment);
        }
        if (!isBlockComment && !noLineTerminator) {
          this.newline(1, true);
        }
        if (printNewLines && skipNewLines !== 3) {
          this.newline(1);
        }
      }
      _printComments(type, comments, node, parent, lineOffset = 0, nextToken) {
        const nodeLoc = node.loc;
        const len = comments.length;
        let hasLoc = !!nodeLoc;
        const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;
        const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;
        let lastLine = 0;
        let leadingCommentNewline = 0;
        const maybeNewline = this._noLineTerminator ? function() {
        } : this.newline.bind(this);
        for (let i = 0; i < len; i++) {
          const comment = comments[i];
          const shouldPrint = this._shouldPrintComment(comment, nextToken);
          if (shouldPrint === 2) {
            hasLoc = false;
            break;
          }
          if (hasLoc && comment.loc && shouldPrint === 1) {
            const commentStartLine = comment.loc.start.line;
            const commentEndLine = comment.loc.end.line;
            if (type === 0) {
              let offset = 0;
              if (i === 0) {
                if (this._buf.hasContent() && (comment.type === "CommentLine" || commentStartLine !== commentEndLine)) {
                  offset = leadingCommentNewline = 1;
                }
              } else {
                offset = commentStartLine - lastLine;
              }
              lastLine = commentEndLine;
              maybeNewline(offset);
              this._printComment(comment, 1);
              if (i + 1 === len) {
                maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));
                lastLine = nodeStartLine;
              }
            } else if (type === 1) {
              const offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);
              lastLine = commentEndLine;
              maybeNewline(offset);
              this._printComment(comment, 1);
              if (i + 1 === len) {
                maybeNewline(Math.min(1, nodeEndLine - lastLine));
                lastLine = nodeEndLine;
              }
            } else {
              const offset = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);
              lastLine = commentEndLine;
              maybeNewline(offset);
              this._printComment(comment, 1);
            }
          } else {
            hasLoc = false;
            if (shouldPrint !== 1) {
              continue;
            }
            if (len === 1) {
              const singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);
              const shouldSkipNewline = singleLine && !isStatement(node) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumMember(node);
              if (type === 0) {
                this._printComment(comment, shouldSkipNewline && node.type !== "ObjectExpression" || singleLine && isFunction(parent, {
                  body: node
                }) ? 1 : 0);
              } else if (shouldSkipNewline && type === 2) {
                this._printComment(comment, 1);
              } else {
                this._printComment(comment, 0);
              }
            } else if (type === 1 && !(node.type === "ObjectExpression" && node.properties.length > 1) && node.type !== "ClassBody" && node.type !== "TSInterfaceBody") {
              this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);
            } else {
              this._printComment(comment, 0);
            }
          }
        }
        if (type === 2 && hasLoc && lastLine) {
          this._lastCommentLine = lastLine;
        }
      }
    };
    Object.assign(Printer.prototype, generatorFunctions);
    (0, _deprecated.addDeprecatedGenerators)(Printer);
    var _default = exports.default = Printer;
    function commaSeparator(occurrenceCount, last) {
      this.token(",", false, occurrenceCount);
      if (!last) this.space();
    }
  }
});

// node_modules/@babel/generator/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@babel/generator/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    exports.generate = generate52;
    var _sourceMap = require_source_map();
    var _printer = require_printer();
    function normalizeOptions(code2, opts, ast) {
      var _opts$recordAndTupleS;
      if (opts.experimental_preserveFormat) {
        if (typeof code2 !== "string") {
          throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
        }
        if (!opts.retainLines) {
          throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
        }
        if (opts.compact && opts.compact !== "auto") {
          throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
        }
        if (opts.minified) {
          throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
        }
        if (opts.jsescOption) {
          throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
        }
        if (!Array.isArray(ast.tokens)) {
          throw new Error("`experimental_preserveFormat` requires the AST to have attached the token of the input code. Make sure to enable the `tokens: true` parser option.");
        }
      }
      const format = {
        auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
        auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
        shouldPrintComment: opts.shouldPrintComment,
        preserveFormat: opts.experimental_preserveFormat,
        retainLines: opts.retainLines,
        retainFunctionParens: opts.retainFunctionParens,
        comments: opts.comments == null || opts.comments,
        compact: opts.compact,
        minified: opts.minified,
        concise: opts.concise,
        indent: {
          adjustMultilineComment: true,
          style: "  "
        },
        jsescOption: Object.assign({
          quotes: "double",
          wrap: true,
          minimal: false
        }, opts.jsescOption),
        topicToken: opts.topicToken
      };
      format.decoratorsBeforeExport = opts.decoratorsBeforeExport;
      format.jsescOption.json = opts.jsonCompatibleStrings;
      format.recordAndTupleSyntaxType = (_opts$recordAndTupleS = opts.recordAndTupleSyntaxType) != null ? _opts$recordAndTupleS : "hash";
      format.importAttributesKeyword = opts.importAttributesKeyword;
      if (format.minified) {
        format.compact = true;
        format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);
      } else {
        format.shouldPrintComment = format.shouldPrintComment || ((value) => format.comments || value.includes("@license") || value.includes("@preserve"));
      }
      if (format.compact === "auto") {
        format.compact = typeof code2 === "string" && code2.length > 5e5;
        if (format.compact) {
          console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${opts.filename} as it exceeds the max of ${"500KB"}.`);
        }
      }
      if (format.compact || format.preserveFormat) {
        format.indent.adjustMultilineComment = false;
      }
      const {
        auxiliaryCommentBefore,
        auxiliaryCommentAfter,
        shouldPrintComment
      } = format;
      if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {
        format.auxiliaryCommentBefore = void 0;
      }
      if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {
        format.auxiliaryCommentAfter = void 0;
      }
      return format;
    }
    exports.CodeGenerator = class CodeGenerator {
      constructor(ast, opts = {}, code2) {
        this._ast = void 0;
        this._format = void 0;
        this._map = void 0;
        this._ast = ast;
        this._format = normalizeOptions(code2, opts, ast);
        this._map = opts.sourceMaps ? new _sourceMap.default(opts, code2) : null;
      }
      generate() {
        const printer = new _printer.default(this._format, this._map);
        return printer.generate(this._ast);
      }
    };
    function generate52(ast, opts = {}, code2) {
      const format = normalizeOptions(code2, opts, ast);
      const map = opts.sourceMaps ? new _sourceMap.default(opts, code2) : null;
      const printer = new _printer.default(format, map, ast.tokens, typeof code2 === "string" ? code2 : null);
      return printer.generate(ast);
    }
    var _default = exports.default = generate52;
  }
});

// node_modules/@babel/traverse/lib/path/ancestry.js
var require_ancestry = __commonJS({
  "node_modules/@babel/traverse/lib/path/ancestry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.find = find2;
    exports.findParent = findParent;
    exports.getAncestry = getAncestry;
    exports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
    exports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
    exports.getFunctionParent = getFunctionParent;
    exports.getStatementParent = getStatementParent;
    exports.inType = inType;
    exports.isAncestor = isAncestor;
    exports.isDescendant = isDescendant;
    var _t = require_lib4();
    var {
      VISITOR_KEYS
    } = _t;
    function findParent(callback) {
      let path = this;
      while (path = path.parentPath) {
        if (callback(path)) return path;
      }
      return null;
    }
    function find2(callback) {
      let path = this;
      do {
        if (callback(path)) return path;
      } while (path = path.parentPath);
      return null;
    }
    function getFunctionParent() {
      return this.findParent((p) => p.isFunction());
    }
    function getStatementParent() {
      let path = this;
      do {
        if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
          break;
        } else {
          path = path.parentPath;
        }
      } while (path);
      if (path && (path.isProgram() || path.isFile())) {
        throw new Error("File/Program node, we can't possibly find a statement parent to this");
      }
      return path;
    }
    function getEarliestCommonAncestorFrom(paths) {
      return this.getDeepestCommonAncestorFrom(paths, function(deepest, i, ancestries) {
        let earliest;
        const keys = VISITOR_KEYS[deepest.type];
        for (const ancestry of ancestries) {
          const path = ancestry[i + 1];
          if (!earliest) {
            earliest = path;
            continue;
          }
          if (path.listKey && earliest.listKey === path.listKey) {
            if (path.key < earliest.key) {
              earliest = path;
              continue;
            }
          }
          const earliestKeyIndex = keys.indexOf(earliest.parentKey);
          const currentKeyIndex = keys.indexOf(path.parentKey);
          if (earliestKeyIndex > currentKeyIndex) {
            earliest = path;
          }
        }
        return earliest;
      });
    }
    function getDeepestCommonAncestorFrom(paths, filter) {
      if (!paths.length) {
        return this;
      }
      if (paths.length === 1) {
        return paths[0];
      }
      let minDepth = Infinity;
      let lastCommonIndex, lastCommon;
      const ancestries = paths.map((path) => {
        const ancestry = [];
        do {
          ancestry.unshift(path);
        } while ((path = path.parentPath) && path !== this);
        if (ancestry.length < minDepth) {
          minDepth = ancestry.length;
        }
        return ancestry;
      });
      const first = ancestries[0];
      depthLoop: for (let i = 0; i < minDepth; i++) {
        const shouldMatch = first[i];
        for (const ancestry of ancestries) {
          if (ancestry[i] !== shouldMatch) {
            break depthLoop;
          }
        }
        lastCommonIndex = i;
        lastCommon = shouldMatch;
      }
      if (lastCommon) {
        if (filter) {
          return filter(lastCommon, lastCommonIndex, ancestries);
        } else {
          return lastCommon;
        }
      } else {
        throw new Error("Couldn't find intersection");
      }
    }
    function getAncestry() {
      let path = this;
      const paths = [];
      do {
        paths.push(path);
      } while (path = path.parentPath);
      return paths;
    }
    function isAncestor(maybeDescendant) {
      return maybeDescendant.isDescendant(this);
    }
    function isDescendant(maybeAncestor) {
      return !!this.findParent((parent) => parent === maybeAncestor);
    }
    function inType(...candidateTypes) {
      let path = this;
      while (path) {
        if (candidateTypes.includes(path.node.type)) return true;
        path = path.parentPath;
      }
      return false;
    }
  }
});

// node_modules/@babel/traverse/lib/path/inference/util.js
var require_util = __commonJS({
  "node_modules/@babel/traverse/lib/path/inference/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createUnionType = createUnionType;
    var _t = require_lib4();
    var {
      createFlowUnionType,
      createTSUnionType,
      createUnionTypeAnnotation,
      isFlowType,
      isTSType
    } = _t;
    function createUnionType(types) {
      {
        if (types.every((v) => isFlowType(v))) {
          if (createFlowUnionType) {
            return createFlowUnionType(types);
          }
          return createUnionTypeAnnotation(types);
        } else if (types.every((v) => isTSType(v))) {
          if (createTSUnionType) {
            return createTSUnionType(types);
          }
        }
      }
    }
  }
});

// node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
var require_inferer_reference = __commonJS({
  "node_modules/@babel/traverse/lib/path/inference/inferer-reference.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _default;
    var _t = require_lib4();
    var _util = require_util();
    var {
      BOOLEAN_NUMBER_BINARY_OPERATORS,
      createTypeAnnotationBasedOnTypeof,
      numberTypeAnnotation,
      voidTypeAnnotation
    } = _t;
    function _default(node) {
      if (!this.isReferenced()) return;
      const binding = this.scope.getBinding(node.name);
      if (binding) {
        if (binding.identifier.typeAnnotation) {
          return binding.identifier.typeAnnotation;
        } else {
          return getTypeAnnotationBindingConstantViolations(binding, this, node.name);
        }
      }
      if (node.name === "undefined") {
        return voidTypeAnnotation();
      } else if (node.name === "NaN" || node.name === "Infinity") {
        return numberTypeAnnotation();
      } else if (node.name === "arguments") {
      }
    }
    function getTypeAnnotationBindingConstantViolations(binding, path, name50) {
      const types = [];
      const functionConstantViolations = [];
      let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
      const testType = getConditionalAnnotation(binding, path, name50);
      if (testType) {
        const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
        constantViolations = constantViolations.filter((path2) => !testConstantViolations.includes(path2));
        types.push(testType.typeAnnotation);
      }
      if (constantViolations.length) {
        constantViolations.push(...functionConstantViolations);
        for (const violation of constantViolations) {
          types.push(violation.getTypeAnnotation());
        }
      }
      if (!types.length) {
        return;
      }
      return (0, _util.createUnionType)(types);
    }
    function getConstantViolationsBefore(binding, path, functions) {
      const violations = binding.constantViolations.slice();
      violations.unshift(binding.path);
      return violations.filter((violation) => {
        violation = violation.resolve();
        const status = violation._guessExecutionStatusRelativeTo(path);
        if (functions && status === "unknown") functions.push(violation);
        return status === "before";
      });
    }
    function inferAnnotationFromBinaryExpression(name50, path) {
      const operator = path.node.operator;
      const right = path.get("right").resolve();
      const left = path.get("left").resolve();
      let target;
      if (left.isIdentifier({
        name: name50
      })) {
        target = right;
      } else if (right.isIdentifier({
        name: name50
      })) {
        target = left;
      }
      if (target) {
        if (operator === "===") {
          return target.getTypeAnnotation();
        }
        if (BOOLEAN_NUMBER_BINARY_OPERATORS.includes(operator)) {
          return numberTypeAnnotation();
        }
        return;
      }
      if (operator !== "===" && operator !== "==") return;
      let typeofPath;
      let typePath;
      if (left.isUnaryExpression({
        operator: "typeof"
      })) {
        typeofPath = left;
        typePath = right;
      } else if (right.isUnaryExpression({
        operator: "typeof"
      })) {
        typeofPath = right;
        typePath = left;
      }
      if (!typeofPath) return;
      if (!typeofPath.get("argument").isIdentifier({
        name: name50
      })) return;
      typePath = typePath.resolve();
      if (!typePath.isLiteral()) return;
      const typeValue = typePath.node.value;
      if (typeof typeValue !== "string") return;
      return createTypeAnnotationBasedOnTypeof(typeValue);
    }
    function getParentConditionalPath(binding, path, name50) {
      let parentPath;
      while (parentPath = path.parentPath) {
        if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
          if (path.key === "test") {
            return;
          }
          return parentPath;
        }
        if (parentPath.isFunction()) {
          if (parentPath.parentPath.scope.getBinding(name50) !== binding) return;
        }
        path = parentPath;
      }
    }
    function getConditionalAnnotation(binding, path, name50) {
      const ifStatement = getParentConditionalPath(binding, path, name50);
      if (!ifStatement) return;
      const test = ifStatement.get("test");
      const paths = [test];
      const types = [];
      for (let i = 0; i < paths.length; i++) {
        const path2 = paths[i];
        if (path2.isLogicalExpression()) {
          if (path2.node.operator === "&&") {
            paths.push(path2.get("left"));
            paths.push(path2.get("right"));
          }
        } else if (path2.isBinaryExpression()) {
          const type = inferAnnotationFromBinaryExpression(name50, path2);
          if (type) types.push(type);
        }
      }
      if (types.length) {
        return {
          typeAnnotation: (0, _util.createUnionType)(types),
          ifStatement
        };
      }
      return getConditionalAnnotation(binding, ifStatement, name50);
    }
  }
});

// node_modules/@babel/traverse/lib/path/inference/inferers.js
var require_inferers = __commonJS({
  "node_modules/@babel/traverse/lib/path/inference/inferers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ArrayExpression = ArrayExpression;
    exports.AssignmentExpression = AssignmentExpression;
    exports.BinaryExpression = BinaryExpression;
    exports.BooleanLiteral = BooleanLiteral;
    exports.CallExpression = CallExpression;
    exports.ConditionalExpression = ConditionalExpression;
    exports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;
    Object.defineProperty(exports, "Identifier", {
      enumerable: true,
      get: function() {
        return _infererReference.default;
      }
    });
    exports.LogicalExpression = LogicalExpression;
    exports.NewExpression = NewExpression;
    exports.NullLiteral = NullLiteral;
    exports.NumericLiteral = NumericLiteral;
    exports.ObjectExpression = ObjectExpression;
    exports.ParenthesizedExpression = ParenthesizedExpression;
    exports.RegExpLiteral = RegExpLiteral;
    exports.RestElement = RestElement;
    exports.SequenceExpression = SequenceExpression;
    exports.StringLiteral = StringLiteral;
    exports.TSAsExpression = TSAsExpression;
    exports.TSNonNullExpression = TSNonNullExpression;
    exports.TaggedTemplateExpression = TaggedTemplateExpression;
    exports.TemplateLiteral = TemplateLiteral;
    exports.TypeCastExpression = TypeCastExpression;
    exports.UnaryExpression = UnaryExpression;
    exports.UpdateExpression = UpdateExpression;
    exports.VariableDeclarator = VariableDeclarator;
    var _t = require_lib4();
    var _infererReference = require_inferer_reference();
    var _util = require_util();
    var {
      BOOLEAN_BINARY_OPERATORS,
      BOOLEAN_UNARY_OPERATORS,
      NUMBER_BINARY_OPERATORS,
      NUMBER_UNARY_OPERATORS,
      STRING_UNARY_OPERATORS,
      anyTypeAnnotation,
      arrayTypeAnnotation,
      booleanTypeAnnotation,
      buildMatchMemberExpression,
      genericTypeAnnotation,
      identifier,
      nullLiteralTypeAnnotation,
      numberTypeAnnotation,
      stringTypeAnnotation,
      tupleTypeAnnotation,
      unionTypeAnnotation,
      voidTypeAnnotation,
      isIdentifier
    } = _t;
    function VariableDeclarator() {
      if (!this.get("id").isIdentifier()) return;
      return this.get("init").getTypeAnnotation();
    }
    function TypeCastExpression(node) {
      return node.typeAnnotation;
    }
    TypeCastExpression.validParent = true;
    function TSAsExpression(node) {
      return node.typeAnnotation;
    }
    TSAsExpression.validParent = true;
    function TSNonNullExpression() {
      return this.get("expression").getTypeAnnotation();
    }
    function NewExpression(node) {
      if (node.callee.type === "Identifier") {
        return genericTypeAnnotation(node.callee);
      }
    }
    function TemplateLiteral() {
      return stringTypeAnnotation();
    }
    function UnaryExpression(node) {
      const operator = node.operator;
      if (operator === "void") {
        return voidTypeAnnotation();
      } else if (NUMBER_UNARY_OPERATORS.includes(operator)) {
        return numberTypeAnnotation();
      } else if (STRING_UNARY_OPERATORS.includes(operator)) {
        return stringTypeAnnotation();
      } else if (BOOLEAN_UNARY_OPERATORS.includes(operator)) {
        return booleanTypeAnnotation();
      }
    }
    function BinaryExpression(node) {
      const operator = node.operator;
      if (NUMBER_BINARY_OPERATORS.includes(operator)) {
        return numberTypeAnnotation();
      } else if (BOOLEAN_BINARY_OPERATORS.includes(operator)) {
        return booleanTypeAnnotation();
      } else if (operator === "+") {
        const right = this.get("right");
        const left = this.get("left");
        if (left.isBaseType("number") && right.isBaseType("number")) {
          return numberTypeAnnotation();
        } else if (left.isBaseType("string") || right.isBaseType("string")) {
          return stringTypeAnnotation();
        }
        return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);
      }
    }
    function LogicalExpression() {
      const argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
      return (0, _util.createUnionType)(argumentTypes);
    }
    function ConditionalExpression() {
      const argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
      return (0, _util.createUnionType)(argumentTypes);
    }
    function SequenceExpression() {
      return this.get("expressions").pop().getTypeAnnotation();
    }
    function ParenthesizedExpression() {
      return this.get("expression").getTypeAnnotation();
    }
    function AssignmentExpression() {
      return this.get("right").getTypeAnnotation();
    }
    function UpdateExpression(node) {
      const operator = node.operator;
      if (operator === "++" || operator === "--") {
        return numberTypeAnnotation();
      }
    }
    function StringLiteral() {
      return stringTypeAnnotation();
    }
    function NumericLiteral() {
      return numberTypeAnnotation();
    }
    function BooleanLiteral() {
      return booleanTypeAnnotation();
    }
    function NullLiteral() {
      return nullLiteralTypeAnnotation();
    }
    function RegExpLiteral() {
      return genericTypeAnnotation(identifier("RegExp"));
    }
    function ObjectExpression() {
      return genericTypeAnnotation(identifier("Object"));
    }
    function ArrayExpression() {
      return genericTypeAnnotation(identifier("Array"));
    }
    function RestElement() {
      return ArrayExpression();
    }
    RestElement.validParent = true;
    function Func() {
      return genericTypeAnnotation(identifier("Function"));
    }
    var isArrayFrom = buildMatchMemberExpression("Array.from");
    var isObjectKeys = buildMatchMemberExpression("Object.keys");
    var isObjectValues = buildMatchMemberExpression("Object.values");
    var isObjectEntries = buildMatchMemberExpression("Object.entries");
    function CallExpression() {
      const {
        callee
      } = this.node;
      if (isObjectKeys(callee)) {
        return arrayTypeAnnotation(stringTypeAnnotation());
      } else if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier(callee, {
        name: "Array"
      })) {
        return arrayTypeAnnotation(anyTypeAnnotation());
      } else if (isObjectEntries(callee)) {
        return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));
      }
      return resolveCall(this.get("callee"));
    }
    function TaggedTemplateExpression() {
      return resolveCall(this.get("tag"));
    }
    function resolveCall(callee) {
      callee = callee.resolve();
      if (callee.isFunction()) {
        const {
          node
        } = callee;
        if (node.async) {
          if (node.generator) {
            return genericTypeAnnotation(identifier("AsyncIterator"));
          } else {
            return genericTypeAnnotation(identifier("Promise"));
          }
        } else {
          if (node.generator) {
            return genericTypeAnnotation(identifier("Iterator"));
          } else if (callee.node.returnType) {
            return callee.node.returnType;
          } else {
          }
        }
      }
    }
  }
});

// node_modules/@babel/traverse/lib/path/inference/index.js
var require_inference = __commonJS({
  "node_modules/@babel/traverse/lib/path/inference/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports._getTypeAnnotation = _getTypeAnnotation;
    exports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
    exports.couldBeBaseType = couldBeBaseType;
    exports.getTypeAnnotation = getTypeAnnotation;
    exports.isBaseType = isBaseType;
    exports.isGenericType = isGenericType;
    var inferers = require_inferers();
    var _t = require_lib4();
    var {
      anyTypeAnnotation,
      isAnyTypeAnnotation,
      isArrayTypeAnnotation,
      isBooleanTypeAnnotation,
      isEmptyTypeAnnotation,
      isFlowBaseAnnotation,
      isGenericTypeAnnotation,
      isIdentifier,
      isMixedTypeAnnotation,
      isNumberTypeAnnotation,
      isStringTypeAnnotation,
      isTSArrayType,
      isTSTypeAnnotation,
      isTSTypeReference,
      isTupleTypeAnnotation,
      isTypeAnnotation,
      isUnionTypeAnnotation,
      isVoidTypeAnnotation,
      stringTypeAnnotation,
      voidTypeAnnotation
    } = _t;
    function getTypeAnnotation() {
      let type = this.getData("typeAnnotation");
      if (type != null) {
        return type;
      }
      type = _getTypeAnnotation.call(this) || anyTypeAnnotation();
      if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {
        type = type.typeAnnotation;
      }
      this.setData("typeAnnotation", type);
      return type;
    }
    var typeAnnotationInferringNodes = /* @__PURE__ */ new WeakSet();
    function _getTypeAnnotation() {
      const node = this.node;
      if (!node) {
        if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
          const declar = this.parentPath.parentPath;
          const declarParent = declar.parentPath;
          if (declar.key === "left" && declarParent.isForInStatement()) {
            return stringTypeAnnotation();
          }
          if (declar.key === "left" && declarParent.isForOfStatement()) {
            return anyTypeAnnotation();
          }
          return voidTypeAnnotation();
        } else {
          return;
        }
      }
      if (node.typeAnnotation) {
        return node.typeAnnotation;
      }
      if (typeAnnotationInferringNodes.has(node)) {
        return;
      }
      typeAnnotationInferringNodes.add(node);
      try {
        var _inferer;
        let inferer = inferers[node.type];
        if (inferer) {
          return inferer.call(this, node);
        }
        inferer = inferers[this.parentPath.type];
        if ((_inferer = inferer) != null && _inferer.validParent) {
          return this.parentPath.getTypeAnnotation();
        }
      } finally {
        typeAnnotationInferringNodes.delete(node);
      }
    }
    function isBaseType(baseName, soft) {
      return _isBaseType(baseName, this.getTypeAnnotation(), soft);
    }
    function _isBaseType(baseName, type, soft) {
      if (baseName === "string") {
        return isStringTypeAnnotation(type);
      } else if (baseName === "number") {
        return isNumberTypeAnnotation(type);
      } else if (baseName === "boolean") {
        return isBooleanTypeAnnotation(type);
      } else if (baseName === "any") {
        return isAnyTypeAnnotation(type);
      } else if (baseName === "mixed") {
        return isMixedTypeAnnotation(type);
      } else if (baseName === "empty") {
        return isEmptyTypeAnnotation(type);
      } else if (baseName === "void") {
        return isVoidTypeAnnotation(type);
      } else {
        if (soft) {
          return false;
        } else {
          throw new Error(`Unknown base type ${baseName}`);
        }
      }
    }
    function couldBeBaseType(name50) {
      const type = this.getTypeAnnotation();
      if (isAnyTypeAnnotation(type)) return true;
      if (isUnionTypeAnnotation(type)) {
        for (const type2 of type.types) {
          if (isAnyTypeAnnotation(type2) || _isBaseType(name50, type2, true)) {
            return true;
          }
        }
        return false;
      } else {
        return _isBaseType(name50, type, true);
      }
    }
    function baseTypeStrictlyMatches(rightArg) {
      const left = this.getTypeAnnotation();
      const right = rightArg.getTypeAnnotation();
      if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {
        return right.type === left.type;
      }
      return false;
    }
    function isGenericType(genericName) {
      const type = this.getTypeAnnotation();
      if (genericName === "Array") {
        if (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)) {
          return true;
        }
      }
      return isGenericTypeAnnotation(type) && isIdentifier(type.id, {
        name: genericName
      }) || isTSTypeReference(type) && isIdentifier(type.typeName, {
        name: genericName
      });
    }
  }
});

// node_modules/picocolors/picocolors.browser.js
var require_picocolors_browser = __commonJS({
  "node_modules/picocolors/picocolors.browser.js"(exports, module) {
    var x = String;
    var create = function() {
      return { isColorSupported: false, reset: x, bold: x, dim: x, italic: x, underline: x, inverse: x, hidden: x, strikethrough: x, black: x, red: x, green: x, yellow: x, blue: x, magenta: x, cyan: x, white: x, gray: x, bgBlack: x, bgRed: x, bgGreen: x, bgYellow: x, bgBlue: x, bgMagenta: x, bgCyan: x, bgWhite: x, blackBright: x, redBright: x, greenBright: x, yellowBright: x, blueBright: x, magentaBright: x, cyanBright: x, whiteBright: x, bgBlackBright: x, bgRedBright: x, bgGreenBright: x, bgYellowBright: x, bgBlueBright: x, bgMagentaBright: x, bgCyanBright: x, bgWhiteBright: x };
    };
    module.exports = create();
    module.exports.createColors = create;
  }
});

// node_modules/js-tokens/index.js
var require_js_tokens = __commonJS({
  "node_modules/js-tokens/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    exports.matchToToken = function(match) {
      var token = { type: "invalid", value: match[0], closed: void 0 };
      if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);
      else if (match[5]) token.type = "comment";
      else if (match[6]) token.type = "comment", token.closed = !!match[7];
      else if (match[8]) token.type = "regex";
      else if (match[9]) token.type = "number";
      else if (match[10]) token.type = "name";
      else if (match[11]) token.type = "punctuator";
      else if (match[12]) token.type = "whitespace";
      return token;
    };
  }
});

// node_modules/@babel/code-frame/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/@babel/code-frame/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var picocolors = require_picocolors_browser();
    var jsTokens = require_js_tokens();
    var helperValidatorIdentifier = require_lib2();
    function isColorSupported() {
      return typeof process === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? false : picocolors.isColorSupported;
    }
    var compose = (f, g) => (v) => f(g(v));
    function buildDefs(colors3) {
      return {
        keyword: colors3.cyan,
        capitalized: colors3.yellow,
        jsxIdentifier: colors3.yellow,
        punctuator: colors3.yellow,
        number: colors3.magenta,
        string: colors3.green,
        regex: colors3.magenta,
        comment: colors3.gray,
        invalid: compose(compose(colors3.white, colors3.bgRed), colors3.bold),
        gutter: colors3.gray,
        marker: compose(colors3.red, colors3.bold),
        message: compose(colors3.red, colors3.bold),
        reset: colors3.reset
      };
    }
    var defsOn = buildDefs(picocolors.createColors(true));
    var defsOff = buildDefs(picocolors.createColors(false));
    function getDefs(enabled) {
      return enabled ? defsOn : defsOff;
    }
    var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
    var NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
    var BRACKET = /^[()[\]{}]$/;
    var tokenize3;
    var JSX_TAG = /^[a-z][\w-]*$/i;
    var getTokenType = function(token, offset, text2) {
      if (token.type === "name") {
        const tokenValue = token.value;
        if (helperValidatorIdentifier.isKeyword(tokenValue) || helperValidatorIdentifier.isStrictReservedWord(tokenValue, true) || sometimesKeywords.has(tokenValue)) {
          return "keyword";
        }
        if (JSX_TAG.test(tokenValue) && (text2[offset - 1] === "<" || text2.slice(offset - 2, offset) === "</")) {
          return "jsxIdentifier";
        }
        const firstChar = String.fromCodePoint(tokenValue.codePointAt(0));
        if (firstChar !== firstChar.toLowerCase()) {
          return "capitalized";
        }
      }
      if (token.type === "punctuator" && BRACKET.test(token.value)) {
        return "bracket";
      }
      if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
        return "punctuator";
      }
      return token.type;
    };
    tokenize3 = function* (text2) {
      let match;
      while (match = jsTokens.default.exec(text2)) {
        const token = jsTokens.matchToToken(match);
        yield {
          type: getTokenType(token, match.index, text2),
          value: token.value
        };
      }
    };
    function highlight(text2) {
      if (text2 === "") return "";
      const defs = getDefs(true);
      let highlighted = "";
      for (const {
        type,
        value
      } of tokenize3(text2)) {
        if (type in defs) {
          highlighted += value.split(NEWLINE$1).map((str) => defs[type](str)).join("\n");
        } else {
          highlighted += value;
        }
      }
      return highlighted;
    }
    var deprecationWarningShown = false;
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    function getMarkerLines(loc, source, opts) {
      const startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start);
      const endLoc = Object.assign({}, startLoc, loc.end);
      const {
        linesAbove = 2,
        linesBelow = 3
      } = opts || {};
      const startLine = startLoc.line;
      const startColumn = startLoc.column;
      const endLine = endLoc.line;
      const endColumn = endLoc.column;
      let start = Math.max(startLine - (linesAbove + 1), 0);
      let end = Math.min(source.length, endLine + linesBelow);
      if (startLine === -1) {
        start = 0;
      }
      if (endLine === -1) {
        end = source.length;
      }
      const lineDiff = endLine - startLine;
      const markerLines = {};
      if (lineDiff) {
        for (let i = 0; i <= lineDiff; i++) {
          const lineNumber = i + startLine;
          if (!startColumn) {
            markerLines[lineNumber] = true;
          } else if (i === 0) {
            const sourceLength = source[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i === lineDiff) {
            markerLines[lineNumber] = [0, endColumn];
          } else {
            const sourceLength = source[lineNumber - i].length;
            markerLines[lineNumber] = [0, sourceLength];
          }
        }
      } else {
        if (startColumn === endColumn) {
          if (startColumn) {
            markerLines[startLine] = [startColumn, 0];
          } else {
            markerLines[startLine] = true;
          }
        } else {
          markerLines[startLine] = [startColumn, endColumn - startColumn];
        }
      }
      return {
        start,
        end,
        markerLines
      };
    }
    function codeFrameColumns(rawLines, loc, opts = {}) {
      const shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode;
      const defs = getDefs(shouldHighlight);
      const lines = rawLines.split(NEWLINE);
      const {
        start,
        end,
        markerLines
      } = getMarkerLines(loc, lines, opts);
      const hasColumns = loc.start && typeof loc.start.column === "number";
      const numberMaxWidth = String(end).length;
      const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;
      let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index2) => {
        const number4 = start + 1 + index2;
        const paddedNumber = ` ${number4}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} |`;
        const hasMarker = markerLines[number4];
        const lastMarkerLine = !markerLines[number4 + 1];
        if (hasMarker) {
          let markerLine = "";
          if (Array.isArray(hasMarker)) {
            const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
            const numberOfMarkers = hasMarker[1] || 1;
            markerLine = ["\n ", defs.gutter(gutter.replace(/\d/g, " ")), " ", markerSpacing, defs.marker("^").repeat(numberOfMarkers)].join("");
            if (lastMarkerLine && opts.message) {
              markerLine += " " + defs.message(opts.message);
            }
          }
          return [defs.marker(">"), defs.gutter(gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
        } else {
          return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : ""}`;
        }
      }).join("\n");
      if (opts.message && !hasColumns) {
        frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
      }
      if (shouldHighlight) {
        return defs.reset(frame);
      } else {
        return frame;
      }
    }
    function index(rawLines, lineNumber, colNumber, opts = {}) {
      if (!deprecationWarningShown) {
        deprecationWarningShown = true;
        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning) {
          process.emitWarning(message, "DeprecationWarning");
        } else {
          const deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning";
          console.warn(new Error(message));
        }
      }
      colNumber = Math.max(colNumber, 0);
      const location = {
        start: {
          column: colNumber,
          line: lineNumber
        }
      };
      return codeFrameColumns(rawLines, location, opts);
    }
    exports.codeFrameColumns = codeFrameColumns;
    exports.default = index;
    exports.highlight = highlight;
  }
});

// node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
var require_removal_hooks = __commonJS({
  "node_modules/@babel/traverse/lib/path/lib/removal-hooks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.hooks = void 0;
    var hooks = exports.hooks = [function(self2, parent) {
      const removeParent = self2.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self2.key === "declaration" && parent.isExportDeclaration() || self2.key === "body" && parent.isLabeledStatement() || self2.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self2.key === "expression" && parent.isExpressionStatement();
      if (removeParent) {
        parent.remove();
        return true;
      }
    }, function(self2, parent) {
      if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
        parent.replaceWith(parent.node.expressions[0]);
        return true;
      }
    }, function(self2, parent) {
      if (parent.isBinary()) {
        if (self2.key === "left") {
          parent.replaceWith(parent.node.right);
        } else {
          parent.replaceWith(parent.node.left);
        }
        return true;
      }
    }, function(self2, parent) {
      if (parent.isIfStatement() && self2.key === "consequent" || self2.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
        self2.replaceWith({
          type: "BlockStatement",
          body: []
        });
        return true;
      }
    }];
  }
});

// node_modules/@babel/traverse/lib/path/removal.js
var require_removal = __commonJS({
  "node_modules/@babel/traverse/lib/path/removal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports._assertUnremoved = _assertUnremoved;
    exports._callRemovalHooks = _callRemovalHooks;
    exports._markRemoved = _markRemoved;
    exports._remove = _remove;
    exports._removeFromScope = _removeFromScope;
    exports.remove = remove;
    var _removalHooks = require_removal_hooks();
    var _cache = require_cache();
    var _replacement = require_replacement();
    var _index = require_path();
    var _t = require_lib4();
    var _modification = require_modification();
    var _context = require_context2();
    var {
      getBindingIdentifiers
    } = _t;
    function remove() {
      var _this$opts;
      _assertUnremoved.call(this);
      _context.resync.call(this);
      if (_callRemovalHooks.call(this)) {
        _markRemoved.call(this);
        return;
      }
      if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {
        _removeFromScope.call(this);
      }
      this.shareCommentsWithSiblings();
      _remove.call(this);
      _markRemoved.call(this);
    }
    function _removeFromScope() {
      const bindings = getBindingIdentifiers(this.node, false, false, true);
      Object.keys(bindings).forEach((name50) => this.scope.removeBinding(name50));
    }
    function _callRemovalHooks() {
      if (this.parentPath) {
        for (const fn of _removalHooks.hooks) {
          if (fn(this, this.parentPath)) return true;
        }
      }
    }
    function _remove() {
      if (Array.isArray(this.container)) {
        this.container.splice(this.key, 1);
        _modification.updateSiblingKeys.call(this, this.key, -1);
      } else {
        _replacement._replaceWith.call(this, null);
      }
    }
    function _markRemoved() {
      this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;
      if (this.parent) {
        var _getCachedPaths;
        (_getCachedPaths = (0, _cache.getCachedPaths)(this)) == null || _getCachedPaths.delete(this.node);
      }
      this.node = null;
    }
    function _assertUnremoved() {
      if (this.removed) {
        throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
      }
    }
  }
});

// node_modules/@babel/traverse/lib/path/lib/hoister.js
var require_hoister = __commonJS({
  "node_modules/@babel/traverse/lib/path/lib/hoister.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _t = require_lib4();
    var _t2 = _t;
    var {
      react
    } = _t;
    var {
      cloneNode,
      jsxExpressionContainer,
      variableDeclaration,
      variableDeclarator
    } = _t2;
    var referenceVisitor = {
      ReferencedIdentifier(path, state) {
        if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {
          return;
        }
        if (path.node.name === "this") {
          let scope = path.scope;
          do {
            if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
              break;
            }
          } while (scope = scope.parent);
          if (scope) state.breakOnScopePaths.push(scope.path);
        }
        const binding = path.scope.getBinding(path.node.name);
        if (!binding) return;
        for (const violation of binding.constantViolations) {
          if (violation.scope !== binding.path.scope) {
            state.mutableBinding = true;
            path.stop();
            return;
          }
        }
        if (binding !== state.scope.getBinding(path.node.name)) return;
        state.bindings[path.node.name] = binding;
      }
    };
    var PathHoister = class {
      constructor(path, scope) {
        this.breakOnScopePaths = void 0;
        this.bindings = void 0;
        this.mutableBinding = void 0;
        this.scopes = void 0;
        this.scope = void 0;
        this.path = void 0;
        this.attachAfter = void 0;
        this.breakOnScopePaths = [];
        this.bindings = {};
        this.mutableBinding = false;
        this.scopes = [];
        this.scope = scope;
        this.path = path;
        this.attachAfter = false;
      }
      isCompatibleScope(scope) {
        for (const key of Object.keys(this.bindings)) {
          const binding = this.bindings[key];
          if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
            return false;
          }
        }
        return true;
      }
      getCompatibleScopes() {
        let scope = this.path.scope;
        do {
          if (this.isCompatibleScope(scope)) {
            this.scopes.push(scope);
          } else {
            break;
          }
          if (this.breakOnScopePaths.includes(scope.path)) {
            break;
          }
        } while (scope = scope.parent);
      }
      getAttachmentPath() {
        let path = this._getAttachmentPath();
        if (!path) return;
        let targetScope = path.scope;
        if (targetScope.path === path) {
          targetScope = path.scope.parent;
        }
        if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
          for (const name50 of Object.keys(this.bindings)) {
            if (!targetScope.hasOwnBinding(name50)) continue;
            const binding = this.bindings[name50];
            if (binding.kind === "param" || binding.path.parentKey === "params") {
              continue;
            }
            const bindingParentPath = this.getAttachmentParentForPath(binding.path);
            if (bindingParentPath.key >= path.key) {
              this.attachAfter = true;
              path = binding.path;
              for (const violationPath of binding.constantViolations) {
                if (this.getAttachmentParentForPath(violationPath).key > path.key) {
                  path = violationPath;
                }
              }
            }
          }
        }
        return path;
      }
      _getAttachmentPath() {
        const scopes = this.scopes;
        const scope = scopes.pop();
        if (!scope) return;
        if (scope.path.isFunction()) {
          if (this.hasOwnParamBindings(scope)) {
            if (this.scope === scope) return;
            const bodies = scope.path.get("body").get("body");
            for (let i = 0; i < bodies.length; i++) {
              if (bodies[i].node._blockHoist) continue;
              return bodies[i];
            }
          } else {
            return this.getNextScopeAttachmentParent();
          }
        } else if (scope.path.isProgram()) {
          return this.getNextScopeAttachmentParent();
        }
      }
      getNextScopeAttachmentParent() {
        const scope = this.scopes.pop();
        if (scope) return this.getAttachmentParentForPath(scope.path);
      }
      getAttachmentParentForPath(path) {
        do {
          if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
            return path;
          }
        } while (path = path.parentPath);
      }
      hasOwnParamBindings(scope) {
        for (const name50 of Object.keys(this.bindings)) {
          if (!scope.hasOwnBinding(name50)) continue;
          const binding = this.bindings[name50];
          if (binding.kind === "param" && binding.constant) return true;
        }
        return false;
      }
      run() {
        this.path.traverse(referenceVisitor, this);
        if (this.mutableBinding) return;
        this.getCompatibleScopes();
        const attachTo = this.getAttachmentPath();
        if (!attachTo) return;
        if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;
        let uid = attachTo.scope.generateUidIdentifier("ref");
        const declarator = variableDeclarator(uid, this.path.node);
        const insertFn = this.attachAfter ? "insertAfter" : "insertBefore";
        const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration("var", [declarator])]);
        const parent = this.path.parentPath;
        if (parent.isJSXElement() && this.path.container === parent.node.children) {
          uid = jsxExpressionContainer(uid);
        }
        this.path.replaceWith(cloneNode(uid));
        return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
      }
    };
    exports.default = PathHoister;
  }
});

// node_modules/@babel/traverse/lib/path/modification.js
var require_modification = __commonJS({
  "node_modules/@babel/traverse/lib/path/modification.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports._containerInsert = _containerInsert;
    exports._containerInsertAfter = _containerInsertAfter;
    exports._containerInsertBefore = _containerInsertBefore;
    exports._verifyNodeList = _verifyNodeList;
    exports.insertAfter = insertAfter;
    exports.insertBefore = insertBefore;
    exports.pushContainer = pushContainer;
    exports.unshiftContainer = unshiftContainer;
    exports.updateSiblingKeys = updateSiblingKeys;
    var _cache = require_cache();
    var _index = require_path();
    var _context = require_context2();
    var _removal = require_removal();
    var _t = require_lib4();
    var _hoister = require_hoister();
    var {
      arrowFunctionExpression,
      assertExpression,
      assignmentExpression,
      blockStatement,
      callExpression,
      cloneNode,
      expressionStatement,
      isAssignmentExpression,
      isCallExpression,
      isExportNamedDeclaration,
      isExpression,
      isIdentifier,
      isSequenceExpression,
      isSuper,
      thisExpression
    } = _t;
    function insertBefore(nodes_) {
      _removal._assertUnremoved.call(this);
      const nodes = _verifyNodeList.call(this, nodes_);
      const {
        parentPath,
        parent
      } = this;
      if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
        return parentPath.insertBefore(nodes);
      } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
        if (this.node) nodes.push(this.node);
        return this.replaceExpressionWithStatements(nodes);
      } else if (Array.isArray(this.container)) {
        return _containerInsertBefore.call(this, nodes);
      } else if (this.isStatementOrBlock()) {
        const node = this.node;
        const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
        this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));
        return this.unshiftContainer("body", nodes);
      } else {
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
      }
    }
    function _containerInsert(from, nodes) {
      updateSiblingKeys.call(this, from, nodes.length);
      const paths = [];
      this.container.splice(from, 0, ...nodes);
      for (let i = 0; i < nodes.length; i++) {
        var _this$context;
        const to = from + i;
        const path = this.getSibling(to);
        paths.push(path);
        if ((_this$context = this.context) != null && _this$context.queue) {
          _context.pushContext.call(path, this.context);
        }
      }
      const contexts = _context._getQueueContexts.call(this);
      for (const path of paths) {
        _context.setScope.call(path);
        path.debug("Inserted.");
        for (const context of contexts) {
          context.maybeQueue(path, true);
        }
      }
      return paths;
    }
    function _containerInsertBefore(nodes) {
      return _containerInsert.call(this, this.key, nodes);
    }
    function _containerInsertAfter(nodes) {
      return _containerInsert.call(this, this.key + 1, nodes);
    }
    var last = (arr) => arr[arr.length - 1];
    function isHiddenInSequenceExpression(path) {
      return isSequenceExpression(path.parent) && (last(path.parent.expressions) !== path.node || isHiddenInSequenceExpression(path.parentPath));
    }
    function isAlmostConstantAssignment(node, scope) {
      if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {
        return false;
      }
      const blockScope = scope.getBlockParent();
      return blockScope.hasOwnBinding(node.left.name) && blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1;
    }
    function insertAfter(nodes_) {
      _removal._assertUnremoved.call(this);
      if (this.isSequenceExpression()) {
        return last(this.get("expressions")).insertAfter(nodes_);
      }
      const nodes = _verifyNodeList.call(this, nodes_);
      const {
        parentPath,
        parent
      } = this;
      if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
        return parentPath.insertAfter(nodes.map((node) => {
          return isExpression(node) ? expressionStatement(node) : node;
        }));
      } else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
        const self2 = this;
        if (self2.node) {
          const node = self2.node;
          let {
            scope
          } = this;
          if (scope.path.isPattern()) {
            assertExpression(node);
            self2.replaceWith(callExpression(arrowFunctionExpression([], node), []));
            self2.get("callee.body").insertAfter(nodes);
            return [self2];
          }
          if (isHiddenInSequenceExpression(self2)) {
            nodes.unshift(node);
          } else if (isCallExpression(node) && isSuper(node.callee)) {
            nodes.unshift(node);
            nodes.push(thisExpression());
          } else if (isAlmostConstantAssignment(node, scope)) {
            nodes.unshift(node);
            nodes.push(cloneNode(node.left));
          } else if (scope.isPure(node, true)) {
            nodes.push(node);
          } else {
            if (parentPath.isMethod({
              computed: true,
              key: node
            })) {
              scope = scope.parent;
            }
            const temp = scope.generateDeclaredUidIdentifier();
            nodes.unshift(expressionStatement(assignmentExpression("=", cloneNode(temp), node)));
            nodes.push(expressionStatement(cloneNode(temp)));
          }
        }
        return this.replaceExpressionWithStatements(nodes);
      } else if (Array.isArray(this.container)) {
        return _containerInsertAfter.call(this, nodes);
      } else if (this.isStatementOrBlock()) {
        const node = this.node;
        const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
        this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));
        return this.pushContainer("body", nodes);
      } else {
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
      }
    }
    function updateSiblingKeys(fromIndex, incrementBy) {
      if (!this.parent) return;
      const paths = (0, _cache.getCachedPaths)(this);
      if (!paths) return;
      for (const [, path] of paths) {
        if (typeof path.key === "number" && path.container === this.container && path.key >= fromIndex) {
          path.key += incrementBy;
        }
      }
    }
    function _verifyNodeList(nodes) {
      if (!nodes) {
        return [];
      }
      if (!Array.isArray(nodes)) {
        nodes = [nodes];
      }
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        let msg;
        if (!node) {
          msg = "has falsy node";
        } else if (typeof node !== "object") {
          msg = "contains a non-object node";
        } else if (!node.type) {
          msg = "without a type";
        } else if (node instanceof _index.default) {
          msg = "has a NodePath when it expected a raw object";
        }
        if (msg) {
          const type = Array.isArray(node) ? "array" : typeof node;
          throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);
        }
      }
      return nodes;
    }
    function unshiftContainer(listKey, nodes) {
      _removal._assertUnremoved.call(this);
      nodes = _verifyNodeList.call(this, nodes);
      const path = _index.default.get({
        parentPath: this,
        parent: this.node,
        container: this.node[listKey],
        listKey,
        key: 0
      }).setContext(this.context);
      return _containerInsertBefore.call(path, nodes);
    }
    function pushContainer(listKey, nodes) {
      _removal._assertUnremoved.call(this);
      const verifiedNodes = _verifyNodeList.call(this, nodes);
      const container4 = this.node[listKey];
      const path = _index.default.get({
        parentPath: this,
        parent: this.node,
        container: container4,
        listKey,
        key: container4.length
      }).setContext(this.context);
      return path.replaceWithMultiple(verifiedNodes);
    }
    {
      exports.hoist = function hoist(scope = this.scope) {
        const hoister = new _hoister.default(this, scope);
        return hoister.run();
      };
    }
  }
});

// node_modules/@babel/traverse/lib/path/replacement.js
var require_replacement = __commonJS({
  "node_modules/@babel/traverse/lib/path/replacement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports._replaceWith = _replaceWith;
    exports.replaceExpressionWithStatements = replaceExpressionWithStatements;
    exports.replaceInline = replaceInline;
    exports.replaceWith = replaceWith;
    exports.replaceWithMultiple = replaceWithMultiple;
    exports.replaceWithSourceString = replaceWithSourceString;
    var _codeFrame = require_lib6();
    var _index = require_lib9();
    var _index2 = require_path();
    var _cache = require_cache();
    var _modification = require_modification();
    var _parser = require_lib();
    var _t = require_lib4();
    var _context = require_context2();
    var {
      FUNCTION_TYPES,
      arrowFunctionExpression,
      assignmentExpression,
      awaitExpression,
      blockStatement,
      buildUndefinedNode,
      callExpression,
      cloneNode,
      conditionalExpression,
      expressionStatement,
      getBindingIdentifiers,
      identifier,
      inheritLeadingComments,
      inheritTrailingComments,
      inheritsComments,
      isBlockStatement,
      isEmptyStatement,
      isExpression,
      isExpressionStatement,
      isIfStatement,
      isProgram,
      isStatement,
      isVariableDeclaration,
      removeComments: removeComments2,
      returnStatement,
      sequenceExpression,
      validate,
      yieldExpression
    } = _t;
    function replaceWithMultiple(nodes) {
      var _getCachedPaths;
      _context.resync.call(this);
      nodes = _modification._verifyNodeList.call(this, nodes);
      inheritLeadingComments(nodes[0], this.node);
      inheritTrailingComments(nodes[nodes.length - 1], this.node);
      (_getCachedPaths = (0, _cache.getCachedPaths)(this)) == null || _getCachedPaths.delete(this.node);
      this.node = this.container[this.key] = null;
      const paths = this.insertAfter(nodes);
      if (this.node) {
        this.requeue();
      } else {
        this.remove();
      }
      return paths;
    }
    function replaceWithSourceString(replacement) {
      _context.resync.call(this);
      let ast;
      try {
        replacement = `(${replacement})`;
        ast = (0, _parser.parse)(replacement);
      } catch (err) {
        const loc = err.loc;
        if (loc) {
          err.message += " - make sure this is an expression.\n" + (0, _codeFrame.codeFrameColumns)(replacement, {
            start: {
              line: loc.line,
              column: loc.column + 1
            }
          });
          err.code = "BABEL_REPLACE_SOURCE_ERROR";
        }
        throw err;
      }
      const expressionAST = ast.program.body[0].expression;
      _index.default.removeProperties(expressionAST);
      return this.replaceWith(expressionAST);
    }
    function replaceWith(replacementPath) {
      _context.resync.call(this);
      if (this.removed) {
        throw new Error("You can't replace this node, we've already removed it");
      }
      let replacement = replacementPath instanceof _index2.default ? replacementPath.node : replacementPath;
      if (!replacement) {
        throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
      }
      if (this.node === replacement) {
        return [this];
      }
      if (this.isProgram() && !isProgram(replacement)) {
        throw new Error("You can only replace a Program root node with another Program node");
      }
      if (Array.isArray(replacement)) {
        throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
      }
      if (typeof replacement === "string") {
        throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
      }
      let nodePath = "";
      if (this.isNodeType("Statement") && isExpression(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
          replacement = expressionStatement(replacement);
          nodePath = "expression";
        }
      }
      if (this.isNodeType("Expression") && isStatement(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
          return this.replaceExpressionWithStatements([replacement]);
        }
      }
      const oldNode = this.node;
      if (oldNode) {
        inheritsComments(replacement, oldNode);
        removeComments2(oldNode);
      }
      _replaceWith.call(this, replacement);
      this.type = replacement.type;
      _context.setScope.call(this);
      this.requeue();
      return [nodePath ? this.get(nodePath) : this];
    }
    function _replaceWith(node) {
      var _getCachedPaths2;
      if (!this.container) {
        throw new ReferenceError("Container is falsy");
      }
      if (this.inList) {
        validate(this.parent, this.key, [node]);
      } else {
        validate(this.parent, this.key, node);
      }
      this.debug(`Replace with ${node == null ? void 0 : node.type}`);
      (_getCachedPaths2 = (0, _cache.getCachedPaths)(this)) == null || _getCachedPaths2.set(node, this).delete(this.node);
      this.node = this.container[this.key] = node;
    }
    function replaceExpressionWithStatements(nodes) {
      _context.resync.call(this);
      const declars = [];
      const nodesAsSingleExpression = gatherSequenceExpressions(nodes, declars);
      if (nodesAsSingleExpression) {
        for (const id of declars) this.scope.push({
          id
        });
        return this.replaceWith(nodesAsSingleExpression)[0].get("expressions");
      }
      const functionParent = this.getFunctionParent();
      const isParentAsync = functionParent == null ? void 0 : functionParent.node.async;
      const isParentGenerator = functionParent == null ? void 0 : functionParent.node.generator;
      const container4 = arrowFunctionExpression([], blockStatement(nodes));
      this.replaceWith(callExpression(container4, []));
      const callee = this.get("callee");
      callee.get("body").scope.hoistVariables((id) => this.scope.push({
        id
      }));
      const completionRecords = callee.getCompletionRecords();
      for (const path of completionRecords) {
        if (!path.isExpressionStatement()) continue;
        const loop = path.findParent((path2) => path2.isLoop());
        if (loop) {
          let uid = loop.getData("expressionReplacementReturnUid");
          if (!uid) {
            uid = callee.scope.generateDeclaredUidIdentifier("ret");
            callee.get("body").pushContainer("body", returnStatement(cloneNode(uid)));
            loop.setData("expressionReplacementReturnUid", uid);
          } else {
            uid = identifier(uid.name);
          }
          path.get("expression").replaceWith(assignmentExpression("=", cloneNode(uid), path.node.expression));
        } else {
          path.replaceWith(returnStatement(path.node.expression));
        }
      }
      callee.arrowFunctionToExpression();
      const newCallee = callee;
      const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES);
      const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES);
      if (needToAwaitFunction) {
        newCallee.set("async", true);
        if (!needToYieldFunction) {
          this.replaceWith(awaitExpression(this.node));
        }
      }
      if (needToYieldFunction) {
        newCallee.set("generator", true);
        this.replaceWith(yieldExpression(this.node, true));
      }
      return newCallee.get("body.body");
    }
    function gatherSequenceExpressions(nodes, declars) {
      const exprs = [];
      let ensureLastUndefined = true;
      for (const node of nodes) {
        if (!isEmptyStatement(node)) {
          ensureLastUndefined = false;
        }
        if (isExpression(node)) {
          exprs.push(node);
        } else if (isExpressionStatement(node)) {
          exprs.push(node.expression);
        } else if (isVariableDeclaration(node)) {
          if (node.kind !== "var") return;
          for (const declar of node.declarations) {
            const bindings = getBindingIdentifiers(declar);
            for (const key of Object.keys(bindings)) {
              declars.push(cloneNode(bindings[key]));
            }
            if (declar.init) {
              exprs.push(assignmentExpression("=", declar.id, declar.init));
            }
          }
          ensureLastUndefined = true;
        } else if (isIfStatement(node)) {
          const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], declars) : buildUndefinedNode();
          const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], declars) : buildUndefinedNode();
          if (!consequent || !alternate) return;
          exprs.push(conditionalExpression(node.test, consequent, alternate));
        } else if (isBlockStatement(node)) {
          const body = gatherSequenceExpressions(node.body, declars);
          if (!body) return;
          exprs.push(body);
        } else if (isEmptyStatement(node)) {
          if (nodes.indexOf(node) === 0) {
            ensureLastUndefined = true;
          }
        } else {
          return;
        }
      }
      if (ensureLastUndefined) exprs.push(buildUndefinedNode());
      if (exprs.length === 1) {
        return exprs[0];
      } else {
        return sequenceExpression(exprs);
      }
    }
    function replaceInline(nodes) {
      _context.resync.call(this);
      if (Array.isArray(nodes)) {
        if (Array.isArray(this.container)) {
          nodes = _modification._verifyNodeList.call(this, nodes);
          const paths = _modification._containerInsertAfter.call(this, nodes);
          this.remove();
          return paths;
        } else {
          return this.replaceWithMultiple(nodes);
        }
      } else {
        return this.replaceWith(nodes);
      }
    }
  }
});

// node_modules/@babel/traverse/lib/path/evaluation.js
var require_evaluation = __commonJS({
  "node_modules/@babel/traverse/lib/path/evaluation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.evaluate = evaluate;
    exports.evaluateTruthy = evaluateTruthy;
    var VALID_OBJECT_CALLEES = ["Number", "String", "Math"];
    var VALID_IDENTIFIER_CALLEES = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null];
    var INVALID_METHODS = ["random"];
    function isValidObjectCallee(val) {
      return VALID_OBJECT_CALLEES.includes(val);
    }
    function isValidIdentifierCallee(val) {
      return VALID_IDENTIFIER_CALLEES.includes(val);
    }
    function isInvalidMethod(val) {
      return INVALID_METHODS.includes(val);
    }
    function evaluateTruthy() {
      const res = this.evaluate();
      if (res.confident) return !!res.value;
    }
    function deopt(path, state) {
      if (!state.confident) return;
      state.deoptPath = path;
      state.confident = false;
    }
    var Globals = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", Infinity], ["NaN", NaN]]);
    function evaluateCached(path, state) {
      const {
        node
      } = path;
      const {
        seen
      } = state;
      if (seen.has(node)) {
        const existing = seen.get(node);
        if (existing.resolved) {
          return existing.value;
        } else {
          deopt(path, state);
          return;
        }
      } else {
        const item = {
          resolved: false
        };
        seen.set(node, item);
        const val = _evaluate(path, state);
        if (state.confident) {
          item.resolved = true;
          item.value = val;
        }
        return val;
      }
    }
    function _evaluate(path, state) {
      if (!state.confident) return;
      if (path.isSequenceExpression()) {
        const exprs = path.get("expressions");
        return evaluateCached(exprs[exprs.length - 1], state);
      }
      if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
        return path.node.value;
      }
      if (path.isNullLiteral()) {
        return null;
      }
      if (path.isTemplateLiteral()) {
        return evaluateQuasis(path, path.node.quasis, state);
      }
      if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
        const object = path.get("tag.object");
        const {
          node: {
            name: name50
          }
        } = object;
        const property4 = path.get("tag.property");
        if (object.isIdentifier() && name50 === "String" && !path.scope.getBinding(name50) && property4.isIdentifier() && property4.node.name === "raw") {
          return evaluateQuasis(path, path.node.quasi.quasis, state, true);
        }
      }
      if (path.isConditionalExpression()) {
        const testResult = evaluateCached(path.get("test"), state);
        if (!state.confident) return;
        if (testResult) {
          return evaluateCached(path.get("consequent"), state);
        } else {
          return evaluateCached(path.get("alternate"), state);
        }
      }
      if (path.isExpressionWrapper()) {
        return evaluateCached(path.get("expression"), state);
      }
      if (path.isMemberExpression() && !path.parentPath.isCallExpression({
        callee: path.node
      })) {
        const property4 = path.get("property");
        const object = path.get("object");
        if (object.isLiteral()) {
          const value = object.node.value;
          const type = typeof value;
          let key = null;
          if (path.node.computed) {
            key = evaluateCached(property4, state);
            if (!state.confident) return;
          } else if (property4.isIdentifier()) {
            key = property4.node.name;
          }
          if ((type === "number" || type === "string") && key != null && (typeof key === "number" || typeof key === "string")) {
            return value[key];
          }
        }
      }
      if (path.isReferencedIdentifier()) {
        const binding = path.scope.getBinding(path.node.name);
        if (binding) {
          if (binding.constantViolations.length > 0 || path.node.start < binding.path.node.end) {
            deopt(binding.path, state);
            return;
          }
          const bindingPathScope = binding.path.scope;
          if (binding.kind === "var" && bindingPathScope !== binding.scope) {
            let hasUnsafeBlock = !bindingPathScope.path.parentPath.isBlockStatement();
            for (let scope = bindingPathScope.parent; scope; scope = scope.parent) {
              var _scope$path$parentPat;
              if (scope === path.scope) {
                if (hasUnsafeBlock) {
                  deopt(binding.path, state);
                  return;
                }
                break;
              }
              if ((_scope$path$parentPat = scope.path.parentPath) != null && _scope$path$parentPat.isBlockStatement()) {
                hasUnsafeBlock = true;
              }
            }
          }
          if (binding.hasValue) {
            return binding.value;
          }
        }
        const name50 = path.node.name;
        if (Globals.has(name50)) {
          if (!binding) {
            return Globals.get(name50);
          }
          deopt(binding.path, state);
          return;
        }
        const resolved = path.resolve();
        if (resolved === path) {
          deopt(path, state);
          return;
        }
        const value = evaluateCached(resolved, state);
        if (typeof value === "object" && value !== null && binding.references > 1) {
          deopt(resolved, state);
          return;
        }
        return value;
      }
      if (path.isUnaryExpression({
        prefix: true
      })) {
        if (path.node.operator === "void") {
          return void 0;
        }
        const argument = path.get("argument");
        if (path.node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
          return "function";
        }
        const arg = evaluateCached(argument, state);
        if (!state.confident) return;
        switch (path.node.operator) {
          case "!":
            return !arg;
          case "+":
            return +arg;
          case "-":
            return -arg;
          case "~":
            return ~arg;
          case "typeof":
            return typeof arg;
        }
      }
      if (path.isArrayExpression()) {
        const arr = [];
        const elems = path.get("elements");
        for (const elem of elems) {
          const elemValue = elem.evaluate();
          if (elemValue.confident) {
            arr.push(elemValue.value);
          } else {
            deopt(elemValue.deopt, state);
            return;
          }
        }
        return arr;
      }
      if (path.isObjectExpression()) {
        const obj = {};
        const props = path.get("properties");
        for (const prop of props) {
          if (prop.isObjectMethod() || prop.isSpreadElement()) {
            deopt(prop, state);
            return;
          }
          const keyPath = prop.get("key");
          let key;
          if (prop.node.computed) {
            key = keyPath.evaluate();
            if (!key.confident) {
              deopt(key.deopt, state);
              return;
            }
            key = key.value;
          } else if (keyPath.isIdentifier()) {
            key = keyPath.node.name;
          } else {
            key = keyPath.node.value;
          }
          const valuePath = prop.get("value");
          let value = valuePath.evaluate();
          if (!value.confident) {
            deopt(value.deopt, state);
            return;
          }
          value = value.value;
          obj[key] = value;
        }
        return obj;
      }
      if (path.isLogicalExpression()) {
        const wasConfident = state.confident;
        const left = evaluateCached(path.get("left"), state);
        const leftConfident = state.confident;
        state.confident = wasConfident;
        const right = evaluateCached(path.get("right"), state);
        const rightConfident = state.confident;
        switch (path.node.operator) {
          case "||":
            state.confident = leftConfident && (!!left || rightConfident);
            if (!state.confident) return;
            return left || right;
          case "&&":
            state.confident = leftConfident && (!left || rightConfident);
            if (!state.confident) return;
            return left && right;
          case "??":
            state.confident = leftConfident && (left != null || rightConfident);
            if (!state.confident) return;
            return left != null ? left : right;
        }
      }
      if (path.isBinaryExpression()) {
        const left = evaluateCached(path.get("left"), state);
        if (!state.confident) return;
        const right = evaluateCached(path.get("right"), state);
        if (!state.confident) return;
        switch (path.node.operator) {
          case "-":
            return left - right;
          case "+":
            return left + right;
          case "/":
            return left / right;
          case "*":
            return left * right;
          case "%":
            return left % right;
          case "**":
            return Math.pow(left, right);
          case "<":
            return left < right;
          case ">":
            return left > right;
          case "<=":
            return left <= right;
          case ">=":
            return left >= right;
          case "==":
            return left == right;
          case "!=":
            return left != right;
          case "===":
            return left === right;
          case "!==":
            return left !== right;
          case "|":
            return left | right;
          case "&":
            return left & right;
          case "^":
            return left ^ right;
          case "<<":
            return left << right;
          case ">>":
            return left >> right;
          case ">>>":
            return left >>> right;
        }
      }
      if (path.isCallExpression()) {
        const callee = path.get("callee");
        let context;
        let func;
        if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && (isValidObjectCallee(callee.node.name) || isValidIdentifierCallee(callee.node.name))) {
          func = global[callee.node.name];
        }
        if (callee.isMemberExpression()) {
          const object = callee.get("object");
          const property4 = callee.get("property");
          if (object.isIdentifier() && property4.isIdentifier() && isValidObjectCallee(object.node.name) && !isInvalidMethod(property4.node.name)) {
            context = global[object.node.name];
            const key = property4.node.name;
            if (hasOwnProperty.call(context, key)) {
              func = context[key];
            }
          }
          if (object.isLiteral() && property4.isIdentifier()) {
            const type = typeof object.node.value;
            if (type === "string" || type === "number") {
              context = object.node.value;
              func = context[property4.node.name];
            }
          }
        }
        if (func) {
          const args = path.get("arguments").map((arg) => evaluateCached(arg, state));
          if (!state.confident) return;
          return func.apply(context, args);
        }
      }
      deopt(path, state);
    }
    function evaluateQuasis(path, quasis, state, raw = false) {
      let str = "";
      let i = 0;
      const exprs = path.isTemplateLiteral() ? path.get("expressions") : path.get("quasi.expressions");
      for (const elem of quasis) {
        if (!state.confident) break;
        str += raw ? elem.value.raw : elem.value.cooked;
        const expr = exprs[i++];
        if (expr) str += String(evaluateCached(expr, state));
      }
      if (!state.confident) return;
      return str;
    }
    function evaluate() {
      const state = {
        confident: true,
        deoptPath: null,
        seen: /* @__PURE__ */ new Map()
      };
      let value = evaluateCached(this, state);
      if (!state.confident) value = void 0;
      return {
        confident: state.confident,
        deopt: state.deoptPath,
        value
      };
    }
  }
});

// node_modules/@babel/template/lib/formatters.js
var require_formatters = __commonJS({
  "node_modules/@babel/template/lib/formatters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.statements = exports.statement = exports.smart = exports.program = exports.expression = void 0;
    var _t = require_lib4();
    var {
      assertExpressionStatement
    } = _t;
    function makeStatementFormatter(fn) {
      return {
        code: (str) => `/* @babel/template */;
${str}`,
        validate: () => {
        },
        unwrap: (ast) => {
          return fn(ast.program.body.slice(1));
        }
      };
    }
    var smart = exports.smart = makeStatementFormatter((body) => {
      if (body.length > 1) {
        return body;
      } else {
        return body[0];
      }
    });
    var statements = exports.statements = makeStatementFormatter((body) => body);
    var statement = exports.statement = makeStatementFormatter((body) => {
      if (body.length === 0) {
        throw new Error("Found nothing to return.");
      }
      if (body.length > 1) {
        throw new Error("Found multiple statements but wanted one");
      }
      return body[0];
    });
    var expression = exports.expression = {
      code: (str) => `(
${str}
)`,
      validate: (ast) => {
        if (ast.program.body.length > 1) {
          throw new Error("Found multiple statements but wanted one");
        }
        if (expression.unwrap(ast).start === 0) {
          throw new Error("Parse result included parens.");
        }
      },
      unwrap: ({
        program: program2
      }) => {
        const [stmt] = program2.body;
        assertExpressionStatement(stmt);
        return stmt.expression;
      }
    };
    var program = exports.program = {
      code: (str) => str,
      validate: () => {
      },
      unwrap: (ast) => ast.program
    };
  }
});

// node_modules/@babel/template/lib/options.js
var require_options = __commonJS({
  "node_modules/@babel/template/lib/options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.merge = merge;
    exports.normalizeReplacements = normalizeReplacements;
    exports.validate = validate;
    var _excluded = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
    function _objectWithoutPropertiesLoose(r, e2) {
      if (null == r) return {};
      var t = {};
      for (var n2 in r) if ({}.hasOwnProperty.call(r, n2)) {
        if (-1 !== e2.indexOf(n2)) continue;
        t[n2] = r[n2];
      }
      return t;
    }
    function merge(a, b) {
      const {
        placeholderWhitelist = a.placeholderWhitelist,
        placeholderPattern = a.placeholderPattern,
        preserveComments = a.preserveComments,
        syntacticPlaceholders = a.syntacticPlaceholders
      } = b;
      return {
        parser: Object.assign({}, a.parser, b.parser),
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders
      };
    }
    function validate(opts) {
      if (opts != null && typeof opts !== "object") {
        throw new Error("Unknown template options.");
      }
      const _ref = opts || {}, {
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders
      } = _ref, parser = _objectWithoutPropertiesLoose(_ref, _excluded);
      if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
        throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
      }
      if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
        throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
      }
      if (preserveComments != null && typeof preserveComments !== "boolean") {
        throw new Error("'.preserveComments' must be a boolean, null, or undefined");
      }
      if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
        throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
      }
      if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
        throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
      }
      return {
        parser,
        placeholderWhitelist: placeholderWhitelist || void 0,
        placeholderPattern: placeholderPattern == null ? void 0 : placeholderPattern,
        preserveComments: preserveComments == null ? void 0 : preserveComments,
        syntacticPlaceholders: syntacticPlaceholders == null ? void 0 : syntacticPlaceholders
      };
    }
    function normalizeReplacements(replacements) {
      if (Array.isArray(replacements)) {
        return replacements.reduce((acc, replacement, i) => {
          acc["$" + i] = replacement;
          return acc;
        }, {});
      } else if (typeof replacements === "object" || replacements == null) {
        return replacements || void 0;
      }
      throw new Error("Template replacements must be an array, object, null, or undefined");
    }
  }
});

// node_modules/@babel/template/node_modules/@babel/parser/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/@babel/template/node_modules/@babel/parser/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _objectWithoutPropertiesLoose(r, e2) {
      if (null == r) return {};
      var t = {};
      for (var n2 in r) if ({}.hasOwnProperty.call(r, n2)) {
        if (-1 !== e2.indexOf(n2)) continue;
        t[n2] = r[n2];
      }
      return t;
    }
    var Position = class {
      constructor(line, col, index) {
        this.line = void 0;
        this.column = void 0;
        this.index = void 0;
        this.line = line;
        this.column = col;
        this.index = index;
      }
    };
    var SourceLocation = class {
      constructor(start, end) {
        this.start = void 0;
        this.end = void 0;
        this.filename = void 0;
        this.identifierName = void 0;
        this.start = start;
        this.end = end;
      }
    };
    function createPositionWithColumnOffset(position3, columnOffset) {
      const {
        line,
        column,
        index
      } = position3;
      return new Position(line, column + columnOffset, index + columnOffset);
    }
    var code2 = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
    var ModuleErrors = {
      ImportMetaOutsideModule: {
        message: `import.meta may appear only with 'sourceType: "module"'`,
        code: code2
      },
      ImportOutsideModule: {
        message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
        code: code2
      }
    };
    var NodeDescriptions = {
      ArrayPattern: "array destructuring pattern",
      AssignmentExpression: "assignment expression",
      AssignmentPattern: "assignment expression",
      ArrowFunctionExpression: "arrow function expression",
      ConditionalExpression: "conditional expression",
      CatchClause: "catch clause",
      ForOfStatement: "for-of statement",
      ForInStatement: "for-in statement",
      ForStatement: "for-loop",
      FormalParameters: "function parameter list",
      Identifier: "identifier",
      ImportSpecifier: "import specifier",
      ImportDefaultSpecifier: "import default specifier",
      ImportNamespaceSpecifier: "import namespace specifier",
      ObjectPattern: "object destructuring pattern",
      ParenthesizedExpression: "parenthesized expression",
      RestElement: "rest element",
      UpdateExpression: {
        true: "prefix operation",
        false: "postfix operation"
      },
      VariableDeclarator: "variable declaration",
      YieldExpression: "yield expression"
    };
    var toNodeDescription = (node) => node.type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[`${node.prefix}`] : NodeDescriptions[node.type];
    var StandardErrors = {
      AccessorIsGenerator: ({
        kind
      }) => `A ${kind}ter cannot be a generator.`,
      ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
      AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
      AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
      AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
      AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
      AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
      AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
      BadGetterArity: "A 'get' accessor must not have any formal parameters.",
      BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
      BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
      ConstructorClassField: "Classes may not have a field named 'constructor'.",
      ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
      ConstructorIsAccessor: "Class constructor may not be an accessor.",
      ConstructorIsAsync: "Constructor can't be an async function.",
      ConstructorIsGenerator: "Constructor can't be a generator.",
      DeclarationMissingInitializer: ({
        kind
      }) => `Missing initializer in ${kind} declaration.`,
      DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
      DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
      DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
      DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
      DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
      DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
      DecoratorStaticBlock: "Decorators can't be used with a static block.",
      DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
      DeletePrivateField: "Deleting a private field is not allowed.",
      DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
      DuplicateConstructor: "Duplicate constructor in the same class.",
      DuplicateDefaultExport: "Only one default export allowed per module.",
      DuplicateExport: ({
        exportName
      }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
      DuplicateProto: "Redefinition of __proto__ property.",
      DuplicateRegExpFlags: "Duplicate regular expression flag.",
      ElementAfterRest: "Rest element must be last element.",
      EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
      ExportBindingIsString: ({
        localName,
        exportName
      }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
      ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
      ForInOfLoopInitializer: ({
        type
      }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
      ForInUsing: "For-in loop may not start with 'using' declaration.",
      ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
      ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
      GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
      IllegalBreakContinue: ({
        type
      }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
      IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
      IllegalReturn: "'return' outside of function.",
      ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
      ImportBindingIsString: ({
        importName
      }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
      ImportCallArity: `\`import()\` requires exactly one or two arguments.`,
      ImportCallNotNewExpression: "Cannot use new with import(...).",
      ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
      ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
      ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
      ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
      IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
      InvalidBigIntLiteral: "Invalid BigIntLiteral.",
      InvalidCodePoint: "Code point out of bounds.",
      InvalidCoverDiscardElement: "'void' must be followed by an expression when not used in a binding position.",
      InvalidCoverInitializedName: "Invalid shorthand property initializer.",
      InvalidDecimal: "Invalid decimal.",
      InvalidDigit: ({
        radix
      }) => `Expected number in radix ${radix}.`,
      InvalidEscapeSequence: "Bad character escape sequence.",
      InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
      InvalidEscapedReservedWord: ({
        reservedWord
      }) => `Escape sequence in keyword ${reservedWord}.`,
      InvalidIdentifier: ({
        identifierName
      }) => `Invalid identifier ${identifierName}.`,
      InvalidLhs: ({
        ancestor
      }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
      InvalidLhsBinding: ({
        ancestor
      }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
      InvalidLhsOptionalChaining: ({
        ancestor
      }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
      InvalidNumber: "Invalid number.",
      InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
      InvalidOrUnexpectedToken: ({
        unexpected
      }) => `Unexpected character '${unexpected}'.`,
      InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
      InvalidPrivateFieldResolution: ({
        identifierName
      }) => `Private name #${identifierName} is not defined.`,
      InvalidPropertyBindingPattern: "Binding member expression.",
      InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
      InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
      LabelRedeclaration: ({
        labelName
      }) => `Label '${labelName}' is already declared.`,
      LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
      LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
      MalformedRegExpFlags: "Invalid regular expression flag.",
      MissingClassName: "A class name is required.",
      MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
      MissingSemicolon: "Missing semicolon.",
      MissingPlugin: ({
        missingPlugin
      }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name50) => JSON.stringify(name50)).join(", ")}.`,
      MissingOneOfPlugins: ({
        missingPlugin
      }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name50) => JSON.stringify(name50)).join(", ")}.`,
      MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
      MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
      ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
      ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
      ModuleAttributesWithDuplicateKeys: ({
        key
      }) => `Duplicate key "${key}" is not allowed in module attributes.`,
      ModuleExportNameHasLoneSurrogate: ({
        surrogateCharCode
      }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
      ModuleExportUndefined: ({
        localName
      }) => `Export '${localName}' is not defined.`,
      MultipleDefaultsInSwitch: "Multiple default clauses.",
      NewlineAfterThrow: "Illegal newline after throw.",
      NoCatchOrFinally: "Missing catch or finally clause.",
      NumberIdentifier: "Identifier directly after number.",
      NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
      ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
      OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
      OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
      OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
      ParamDupe: "Argument name clash.",
      PatternHasAccessor: "Object pattern can't contain getter or setter.",
      PatternHasMethod: "Object pattern can't contain methods.",
      PrivateInExpectedIn: ({
        identifierName
      }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
      PrivateNameRedeclaration: ({
        identifierName
      }) => `Duplicate private name #${identifierName}.`,
      RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      RecordNoProto: "'__proto__' is not allowed in Record expressions.",
      RestTrailingComma: "Unexpected trailing comma after rest element.",
      SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
      SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
      SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
      StaticPrototype: "Classes may not have static property named prototype.",
      SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
      SuperPrivateField: "Private fields can't be accessed on super.",
      TrailingDecorator: "Decorators must be attached to a class element.",
      TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
      UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
      UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
      UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
      UnexpectedKeyword: ({
        keyword: keyword2
      }) => `Unexpected keyword '${keyword2}'.`,
      UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
      UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
      UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
      UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
      UnexpectedPrivateField: "Unexpected private name.",
      UnexpectedReservedWord: ({
        reservedWord
      }) => `Unexpected reserved word '${reservedWord}'.`,
      UnexpectedSuper: "'super' is only allowed in object methods and classes.",
      UnexpectedToken: ({
        expected,
        unexpected
      }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
      UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
      UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script` or in the bare case statement.",
      UnexpectedVoidPattern: "Unexpected void binding.",
      UnsupportedBind: "Binding should be performed on object property.",
      UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
      UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
      UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
      UnsupportedMetaProperty: ({
        target,
        onlyValidPropertyName
      }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
      UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
      UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
      UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
      UnterminatedComment: "Unterminated comment.",
      UnterminatedRegExp: "Unterminated regular expression.",
      UnterminatedString: "Unterminated string constant.",
      UnterminatedTemplate: "Unterminated template.",
      UsingDeclarationExport: "Using declaration cannot be exported.",
      UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
      VarRedeclaration: ({
        identifierName
      }) => `Identifier '${identifierName}' has already been declared.`,
      VoidPatternCatchClauseParam: "A void binding can not be the catch clause parameter. Use `try { ... } catch { ... }` if you want to discard the caught error.",
      VoidPatternInitializer: "A void binding may not have an initializer.",
      YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
      YieldInParameter: "Yield expression is not allowed in formal parameters.",
      YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.",
      ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
    };
    var StrictModeErrors = {
      StrictDelete: "Deleting local variable in strict mode.",
      StrictEvalArguments: ({
        referenceName
      }) => `Assigning to '${referenceName}' in strict mode.`,
      StrictEvalArgumentsBinding: ({
        bindingName
      }) => `Binding '${bindingName}' in strict mode.`,
      StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
      StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
      StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
      StrictWith: "'with' in strict mode."
    };
    var ParseExpressionErrors = {
      ParseExpressionEmptyInput: "Unexpected parseExpression() input: The input is empty or contains only comments.",
      ParseExpressionExpectsEOF: ({
        unexpected
      }) => `Unexpected parseExpression() input: The input should contain exactly one expression, but the first expression is followed by the unexpected character \`${String.fromCodePoint(unexpected)}\`.`
    };
    var UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
    var PipelineOperatorErrors = Object.assign({
      PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
      PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
      PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
      PipeTopicUnconfiguredToken: ({
        token
      }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
      PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
      PipeUnparenthesizedBody: ({
        type
      }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
        type
      })}; please wrap it in parentheses.`
    }, {
      PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
      PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
      PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
      PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
      PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
      PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
    });
    var _excluded = ["message"];
    function defineHidden(obj, key, value) {
      Object.defineProperty(obj, key, {
        enumerable: false,
        configurable: true,
        value
      });
    }
    function toParseErrorConstructor({
      toMessage,
      code: code3,
      reasonCode,
      syntaxPlugin
    }) {
      const hasMissingPlugin = reasonCode === "MissingPlugin" || reasonCode === "MissingOneOfPlugins";
      const oldReasonCodes = {
        AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
        AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
        ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference",
        SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
        SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
        SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
      };
      if (oldReasonCodes[reasonCode]) {
        reasonCode = oldReasonCodes[reasonCode];
      }
      return function constructor(loc, details) {
        const error = new SyntaxError();
        error.code = code3;
        error.reasonCode = reasonCode;
        error.loc = loc;
        error.pos = loc.index;
        error.syntaxPlugin = syntaxPlugin;
        if (hasMissingPlugin) {
          error.missingPlugin = details.missingPlugin;
        }
        defineHidden(error, "clone", function clone3(overrides = {}) {
          var _overrides$loc;
          const {
            line,
            column,
            index
          } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;
          return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));
        });
        defineHidden(error, "details", details);
        Object.defineProperty(error, "message", {
          configurable: true,
          get() {
            const message = `${toMessage(details)} (${loc.line}:${loc.column})`;
            this.message = message;
            return message;
          },
          set(value) {
            Object.defineProperty(this, "message", {
              value,
              writable: true
            });
          }
        });
        return error;
      };
    }
    function ParseErrorEnum(argument, syntaxPlugin) {
      if (Array.isArray(argument)) {
        return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
      }
      const ParseErrorConstructors = {};
      for (const reasonCode of Object.keys(argument)) {
        const template = argument[reasonCode];
        const _ref = typeof template === "string" ? {
          message: () => template
        } : typeof template === "function" ? {
          message: template
        } : template, {
          message
        } = _ref, rest = _objectWithoutPropertiesLoose(_ref, _excluded);
        const toMessage = typeof message === "string" ? () => message : message;
        ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
          code: "BABEL_PARSER_SYNTAX_ERROR",
          reasonCode,
          toMessage
        }, syntaxPlugin ? {
          syntaxPlugin
        } : {}, rest));
      }
      return ParseErrorConstructors;
    }
    var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum(ParseExpressionErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
    function createDefaultOptions() {
      return {
        sourceType: "script",
        sourceFilename: void 0,
        startIndex: 0,
        startColumn: 0,
        startLine: 1,
        allowAwaitOutsideFunction: false,
        allowReturnOutsideFunction: false,
        allowNewTargetOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowSuperOutsideMethod: false,
        allowUndeclaredExports: false,
        allowYieldOutsideFunction: false,
        plugins: [],
        strictMode: void 0,
        ranges: false,
        tokens: false,
        createImportExpressions: false,
        createParenthesizedExpressions: false,
        errorRecovery: false,
        attachComment: true,
        annexB: true
      };
    }
    function getOptions(opts) {
      const options = createDefaultOptions();
      if (opts == null) {
        return options;
      }
      if (opts.annexB != null && opts.annexB !== false) {
        throw new Error("The `annexB` option can only be set to `false`.");
      }
      for (const key of Object.keys(options)) {
        if (opts[key] != null) options[key] = opts[key];
      }
      if (options.startLine === 1) {
        if (opts.startIndex == null && options.startColumn > 0) {
          options.startIndex = options.startColumn;
        } else if (opts.startColumn == null && options.startIndex > 0) {
          options.startColumn = options.startIndex;
        }
      } else if (opts.startColumn == null || opts.startIndex == null) {
        if (opts.startIndex != null) {
          throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
        }
      }
      if (options.sourceType === "commonjs") {
        if (opts.allowAwaitOutsideFunction != null) {
          throw new Error("The `allowAwaitOutsideFunction` option cannot be used with `sourceType: 'commonjs'`.");
        }
        if (opts.allowReturnOutsideFunction != null) {
          throw new Error("`sourceType: 'commonjs'` implies `allowReturnOutsideFunction: true`, please remove the `allowReturnOutsideFunction` option or use `sourceType: 'script'`.");
        }
        if (opts.allowNewTargetOutsideFunction != null) {
          throw new Error("`sourceType: 'commonjs'` implies `allowNewTargetOutsideFunction: true`, please remove the `allowNewTargetOutsideFunction` option or use `sourceType: 'script'`.");
        }
      }
      return options;
    }
    var {
      defineProperty: defineProperty2
    } = Object;
    var toUnenumerable = (object, key) => {
      if (object) {
        defineProperty2(object, key, {
          enumerable: false,
          value: object[key]
        });
      }
    };
    function toESTreeLocation(node) {
      toUnenumerable(node.loc.start, "index");
      toUnenumerable(node.loc.end, "index");
      return node;
    }
    var estree = (superClass) => class ESTreeParserMixin extends superClass {
      parse() {
        const file = toESTreeLocation(super.parse());
        if (this.optionFlags & 256) {
          file.tokens = file.tokens.map(toESTreeLocation);
        }
        return file;
      }
      parseRegExpLiteral({
        pattern,
        flags
      }) {
        let regex = null;
        try {
          regex = new RegExp(pattern, flags);
        } catch (_) {
        }
        const node = this.estreeParseLiteral(regex);
        node.regex = {
          pattern,
          flags
        };
        return node;
      }
      parseBigIntLiteral(value) {
        let bigInt;
        try {
          bigInt = BigInt(value);
        } catch (_unused) {
          bigInt = null;
        }
        const node = this.estreeParseLiteral(bigInt);
        node.bigint = String(node.value || value);
        return node;
      }
      parseDecimalLiteral(value) {
        const decimal = null;
        const node = this.estreeParseLiteral(decimal);
        node.decimal = String(node.value || value);
        return node;
      }
      estreeParseLiteral(value) {
        return this.parseLiteral(value, "Literal");
      }
      parseStringLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      parseNumericLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      parseNullLiteral() {
        return this.estreeParseLiteral(null);
      }
      parseBooleanLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      estreeParseChainExpression(node, endLoc) {
        const chain = this.startNodeAtNode(node);
        chain.expression = node;
        return this.finishNodeAt(chain, "ChainExpression", endLoc);
      }
      directiveToStmt(directive) {
        const expression = directive.value;
        delete directive.value;
        this.castNodeTo(expression, "Literal");
        expression.raw = expression.extra.raw;
        expression.value = expression.extra.expressionValue;
        const stmt = this.castNodeTo(directive, "ExpressionStatement");
        stmt.expression = expression;
        stmt.directive = expression.extra.rawValue;
        delete expression.extra;
        return stmt;
      }
      fillOptionalPropertiesForTSESLint(node) {
      }
      cloneEstreeStringLiteral(node) {
        const {
          start,
          end,
          loc,
          range,
          raw,
          value
        } = node;
        const cloned = Object.create(node.constructor.prototype);
        cloned.type = "Literal";
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        cloned.raw = raw;
        cloned.value = value;
        return cloned;
      }
      initFunction(node, isAsync) {
        super.initFunction(node, isAsync);
        node.expression = false;
      }
      checkDeclaration(node) {
        if (node != null && this.isObjectProperty(node)) {
          this.checkDeclaration(node.value);
        } else {
          super.checkDeclaration(node);
        }
      }
      getObjectOrClassMethodParams(method) {
        return method.value.params;
      }
      isValidDirective(stmt) {
        var _stmt$expression$extr;
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
      }
      parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
        const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
        node.body = directiveStatements.concat(node.body);
        delete node.directives;
      }
      parsePrivateName() {
        const node = super.parsePrivateName();
        if (!this.getPluginOption("estree", "classFeatures")) {
          return node;
        }
        return this.convertPrivateNameToPrivateIdentifier(node);
      }
      convertPrivateNameToPrivateIdentifier(node) {
        const name50 = super.getPrivateNameSV(node);
        delete node.id;
        node.name = name50;
        return this.castNodeTo(node, "PrivateIdentifier");
      }
      isPrivateName(node) {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return super.isPrivateName(node);
        }
        return node.type === "PrivateIdentifier";
      }
      getPrivateNameSV(node) {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return super.getPrivateNameSV(node);
        }
        return node.name;
      }
      parseLiteral(value, type) {
        const node = super.parseLiteral(value, type);
        node.raw = node.extra.raw;
        delete node.extra;
        return node;
      }
      parseFunctionBody(node, allowExpression, isMethod = false) {
        super.parseFunctionBody(node, allowExpression, isMethod);
        node.expression = node.body.type !== "BlockStatement";
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        let funcNode = this.startNode();
        funcNode.kind = node.kind;
        funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        delete funcNode.kind;
        const {
          typeParameters
        } = node;
        if (typeParameters) {
          delete node.typeParameters;
          funcNode.typeParameters = typeParameters;
          this.resetStartLocationFromNode(funcNode, typeParameters);
        }
        const valueNode = this.castNodeTo(funcNode, "FunctionExpression");
        node.value = valueNode;
        if (type === "ClassPrivateMethod") {
          node.computed = false;
        }
        if (type === "ObjectMethod") {
          if (node.kind === "method") {
            node.kind = "init";
          }
          node.shorthand = false;
          return this.finishNode(node, "Property");
        } else {
          return this.finishNode(node, "MethodDefinition");
        }
      }
      nameIsConstructor(key) {
        if (key.type === "Literal") return key.value === "constructor";
        return super.nameIsConstructor(key);
      }
      parseClassProperty(...args) {
        const propertyNode = super.parseClassProperty(...args);
        if (!this.getPluginOption("estree", "classFeatures")) {
          return propertyNode;
        }
        this.castNodeTo(propertyNode, "PropertyDefinition");
        return propertyNode;
      }
      parseClassPrivateProperty(...args) {
        const propertyNode = super.parseClassPrivateProperty(...args);
        if (!this.getPluginOption("estree", "classFeatures")) {
          return propertyNode;
        }
        this.castNodeTo(propertyNode, "PropertyDefinition");
        propertyNode.computed = false;
        return propertyNode;
      }
      parseClassAccessorProperty(node) {
        const accessorPropertyNode = super.parseClassAccessorProperty(node);
        if (!this.getPluginOption("estree", "classFeatures")) {
          return accessorPropertyNode;
        }
        if (accessorPropertyNode.abstract && this.hasPlugin("typescript")) {
          delete accessorPropertyNode.abstract;
          this.castNodeTo(accessorPropertyNode, "TSAbstractAccessorProperty");
        } else {
          this.castNodeTo(accessorPropertyNode, "AccessorProperty");
        }
        return accessorPropertyNode;
      }
      parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
        if (node) {
          node.kind = "init";
          this.castNodeTo(node, "Property");
        }
        return node;
      }
      finishObjectProperty(node) {
        node.kind = "init";
        return this.finishNode(node, "Property");
      }
      isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding) {
        return type === "Property" ? "value" : super.isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding);
      }
      isAssignable(node, isBinding) {
        if (node != null && this.isObjectProperty(node)) {
          return this.isAssignable(node.value, isBinding);
        }
        return super.isAssignable(node, isBinding);
      }
      toAssignable(node, isLHS = false) {
        if (node != null && this.isObjectProperty(node)) {
          const {
            key,
            value
          } = node;
          if (this.isPrivateName(key)) {
            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
          }
          this.toAssignable(value, isLHS);
        } else {
          super.toAssignable(node, isLHS);
        }
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === "Property" && (prop.kind === "get" || prop.kind === "set")) {
          this.raise(Errors.PatternHasAccessor, prop.key);
        } else if (prop.type === "Property" && prop.method) {
          this.raise(Errors.PatternHasMethod, prop.key);
        } else {
          super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
        }
      }
      finishCallExpression(unfinished, optional) {
        const node = super.finishCallExpression(unfinished, optional);
        if (node.callee.type === "Import") {
          var _ref, _ref2;
          this.castNodeTo(node, "ImportExpression");
          node.source = node.arguments[0];
          node.options = (_ref = node.arguments[1]) != null ? _ref : null;
          node.attributes = (_ref2 = node.arguments[1]) != null ? _ref2 : null;
          delete node.arguments;
          delete node.callee;
        } else if (node.type === "OptionalCallExpression") {
          this.castNodeTo(node, "CallExpression");
        } else {
          node.optional = false;
        }
        return node;
      }
      toReferencedArguments(node) {
        if (node.type === "ImportExpression") {
          return;
        }
        super.toReferencedArguments(node);
      }
      parseExport(unfinished, decorators) {
        const exportStartLoc = this.state.lastTokStartLoc;
        const node = super.parseExport(unfinished, decorators);
        switch (node.type) {
          case "ExportAllDeclaration":
            node.exported = null;
            break;
          case "ExportNamedDeclaration":
            if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
              this.castNodeTo(node, "ExportAllDeclaration");
              node.exported = node.specifiers[0].exported;
              delete node.specifiers;
            }
          case "ExportDefaultDeclaration":
            {
              var _declaration$decorato;
              const {
                declaration
              } = node;
              if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {
                this.resetStartLocation(node, exportStartLoc);
              }
            }
            break;
        }
        return node;
      }
      stopParseSubscript(base, state) {
        const node = super.stopParseSubscript(base, state);
        if (state.optionalChainMember) {
          return this.estreeParseChainExpression(node, base.loc.end);
        }
        return node;
      }
      parseMember(base, startLoc, state, computed, optional) {
        const node = super.parseMember(base, startLoc, state, computed, optional);
        if (node.type === "OptionalMemberExpression") {
          this.castNodeTo(node, "MemberExpression");
        } else {
          node.optional = false;
        }
        return node;
      }
      isOptionalMemberExpression(node) {
        if (node.type === "ChainExpression") {
          return node.expression.type === "MemberExpression";
        }
        return super.isOptionalMemberExpression(node);
      }
      hasPropertyAsPrivateName(node) {
        if (node.type === "ChainExpression") {
          node = node.expression;
        }
        return super.hasPropertyAsPrivateName(node);
      }
      isObjectProperty(node) {
        return node.type === "Property" && node.kind === "init" && !node.method;
      }
      isObjectMethod(node) {
        return node.type === "Property" && (node.method || node.kind === "get" || node.kind === "set");
      }
      castNodeTo(node, type) {
        const result = super.castNodeTo(node, type);
        this.fillOptionalPropertiesForTSESLint(result);
        return result;
      }
      cloneIdentifier(node) {
        const cloned = super.cloneIdentifier(node);
        this.fillOptionalPropertiesForTSESLint(cloned);
        return cloned;
      }
      cloneStringLiteral(node) {
        if (node.type === "Literal") {
          return this.cloneEstreeStringLiteral(node);
        }
        return super.cloneStringLiteral(node);
      }
      finishNodeAt(node, type, endLoc) {
        return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
      }
      finishNode(node, type) {
        const result = super.finishNode(node, type);
        this.fillOptionalPropertiesForTSESLint(result);
        return result;
      }
      resetStartLocation(node, startLoc) {
        super.resetStartLocation(node, startLoc);
        toESTreeLocation(node);
      }
      resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        super.resetEndLocation(node, endLoc);
        toESTreeLocation(node);
      }
    };
    var TokContext = class {
      constructor(token, preserveSpace) {
        this.token = void 0;
        this.preserveSpace = void 0;
        this.token = token;
        this.preserveSpace = !!preserveSpace;
      }
    };
    var types = {
      brace: new TokContext("{"),
      j_oTag: new TokContext("<tag"),
      j_cTag: new TokContext("</tag"),
      j_expr: new TokContext("<tag>...</tag>", true)
    };
    types.template = new TokContext("`", true);
    var beforeExpr = true;
    var startsExpr = true;
    var isLoop = true;
    var isAssign = true;
    var prefix = true;
    var postfix = true;
    var ExportedTokenType = class {
      constructor(label, conf = {}) {
        this.label = void 0;
        this.keyword = void 0;
        this.beforeExpr = void 0;
        this.startsExpr = void 0;
        this.rightAssociative = void 0;
        this.isLoop = void 0;
        this.isAssign = void 0;
        this.prefix = void 0;
        this.postfix = void 0;
        this.binop = void 0;
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.rightAssociative = !!conf.rightAssociative;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop != null ? conf.binop : null;
        this.updateContext = null;
      }
    };
    var keywords$1 = /* @__PURE__ */ new Map();
    function createKeyword(name50, options = {}) {
      options.keyword = name50;
      const token = createToken(name50, options);
      keywords$1.set(name50, token);
      return token;
    }
    function createBinop(name50, binop) {
      return createToken(name50, {
        beforeExpr,
        binop
      });
    }
    var tokenTypeCounter = -1;
    var tokenTypes2 = [];
    var tokenLabels = [];
    var tokenBinops = [];
    var tokenBeforeExprs = [];
    var tokenStartsExprs = [];
    var tokenPrefixes = [];
    function createToken(name50, options = {}) {
      var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
      ++tokenTypeCounter;
      tokenLabels.push(name50);
      tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
      tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
      tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
      tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
      tokenTypes2.push(new ExportedTokenType(name50, options));
      return tokenTypeCounter;
    }
    function createKeywordLike(name50, options = {}) {
      var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
      ++tokenTypeCounter;
      keywords$1.set(name50, tokenTypeCounter);
      tokenLabels.push(name50);
      tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
      tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
      tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
      tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
      tokenTypes2.push(new ExportedTokenType("name", options));
      return tokenTypeCounter;
    }
    var tt = {
      bracketL: createToken("[", {
        beforeExpr,
        startsExpr
      }),
      bracketHashL: createToken("#[", {
        beforeExpr,
        startsExpr
      }),
      bracketBarL: createToken("[|", {
        beforeExpr,
        startsExpr
      }),
      bracketR: createToken("]"),
      bracketBarR: createToken("|]"),
      braceL: createToken("{", {
        beforeExpr,
        startsExpr
      }),
      braceBarL: createToken("{|", {
        beforeExpr,
        startsExpr
      }),
      braceHashL: createToken("#{", {
        beforeExpr,
        startsExpr
      }),
      braceR: createToken("}"),
      braceBarR: createToken("|}"),
      parenL: createToken("(", {
        beforeExpr,
        startsExpr
      }),
      parenR: createToken(")"),
      comma: createToken(",", {
        beforeExpr
      }),
      semi: createToken(";", {
        beforeExpr
      }),
      colon: createToken(":", {
        beforeExpr
      }),
      doubleColon: createToken("::", {
        beforeExpr
      }),
      dot: createToken("."),
      question: createToken("?", {
        beforeExpr
      }),
      questionDot: createToken("?."),
      arrow: createToken("=>", {
        beforeExpr
      }),
      template: createToken("template"),
      ellipsis: createToken("...", {
        beforeExpr
      }),
      backQuote: createToken("`", {
        startsExpr
      }),
      dollarBraceL: createToken("${", {
        beforeExpr,
        startsExpr
      }),
      templateTail: createToken("...`", {
        startsExpr
      }),
      templateNonTail: createToken("...${", {
        beforeExpr,
        startsExpr
      }),
      at: createToken("@"),
      hash: createToken("#", {
        startsExpr
      }),
      interpreterDirective: createToken("#!..."),
      eq: createToken("=", {
        beforeExpr,
        isAssign
      }),
      assign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      slashAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      xorAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      moduloAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      incDec: createToken("++/--", {
        prefix,
        postfix,
        startsExpr
      }),
      bang: createToken("!", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      tilde: createToken("~", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      doubleCaret: createToken("^^", {
        startsExpr
      }),
      doubleAt: createToken("@@", {
        startsExpr
      }),
      pipeline: createBinop("|>", 0),
      nullishCoalescing: createBinop("??", 1),
      logicalOR: createBinop("||", 1),
      logicalAND: createBinop("&&", 2),
      bitwiseOR: createBinop("|", 3),
      bitwiseXOR: createBinop("^", 4),
      bitwiseAND: createBinop("&", 5),
      equality: createBinop("==/!=/===/!==", 6),
      lt: createBinop("</>/<=/>=", 7),
      gt: createBinop("</>/<=/>=", 7),
      relational: createBinop("</>/<=/>=", 7),
      bitShift: createBinop("<</>>/>>>", 8),
      bitShiftL: createBinop("<</>>/>>>", 8),
      bitShiftR: createBinop("<</>>/>>>", 8),
      plusMin: createToken("+/-", {
        beforeExpr,
        binop: 9,
        prefix,
        startsExpr
      }),
      modulo: createToken("%", {
        binop: 10,
        startsExpr
      }),
      star: createToken("*", {
        binop: 10
      }),
      slash: createBinop("/", 10),
      exponent: createToken("**", {
        beforeExpr,
        binop: 11,
        rightAssociative: true
      }),
      _in: createKeyword("in", {
        beforeExpr,
        binop: 7
      }),
      _instanceof: createKeyword("instanceof", {
        beforeExpr,
        binop: 7
      }),
      _break: createKeyword("break"),
      _case: createKeyword("case", {
        beforeExpr
      }),
      _catch: createKeyword("catch"),
      _continue: createKeyword("continue"),
      _debugger: createKeyword("debugger"),
      _default: createKeyword("default", {
        beforeExpr
      }),
      _else: createKeyword("else", {
        beforeExpr
      }),
      _finally: createKeyword("finally"),
      _function: createKeyword("function", {
        startsExpr
      }),
      _if: createKeyword("if"),
      _return: createKeyword("return", {
        beforeExpr
      }),
      _switch: createKeyword("switch"),
      _throw: createKeyword("throw", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _try: createKeyword("try"),
      _var: createKeyword("var"),
      _const: createKeyword("const"),
      _with: createKeyword("with"),
      _new: createKeyword("new", {
        beforeExpr,
        startsExpr
      }),
      _this: createKeyword("this", {
        startsExpr
      }),
      _super: createKeyword("super", {
        startsExpr
      }),
      _class: createKeyword("class", {
        startsExpr
      }),
      _extends: createKeyword("extends", {
        beforeExpr
      }),
      _export: createKeyword("export"),
      _import: createKeyword("import", {
        startsExpr
      }),
      _null: createKeyword("null", {
        startsExpr
      }),
      _true: createKeyword("true", {
        startsExpr
      }),
      _false: createKeyword("false", {
        startsExpr
      }),
      _typeof: createKeyword("typeof", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _void: createKeyword("void", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _delete: createKeyword("delete", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _do: createKeyword("do", {
        isLoop,
        beforeExpr
      }),
      _for: createKeyword("for", {
        isLoop
      }),
      _while: createKeyword("while", {
        isLoop
      }),
      _as: createKeywordLike("as", {
        startsExpr
      }),
      _assert: createKeywordLike("assert", {
        startsExpr
      }),
      _async: createKeywordLike("async", {
        startsExpr
      }),
      _await: createKeywordLike("await", {
        startsExpr
      }),
      _defer: createKeywordLike("defer", {
        startsExpr
      }),
      _from: createKeywordLike("from", {
        startsExpr
      }),
      _get: createKeywordLike("get", {
        startsExpr
      }),
      _let: createKeywordLike("let", {
        startsExpr
      }),
      _meta: createKeywordLike("meta", {
        startsExpr
      }),
      _of: createKeywordLike("of", {
        startsExpr
      }),
      _sent: createKeywordLike("sent", {
        startsExpr
      }),
      _set: createKeywordLike("set", {
        startsExpr
      }),
      _source: createKeywordLike("source", {
        startsExpr
      }),
      _static: createKeywordLike("static", {
        startsExpr
      }),
      _using: createKeywordLike("using", {
        startsExpr
      }),
      _yield: createKeywordLike("yield", {
        startsExpr
      }),
      _asserts: createKeywordLike("asserts", {
        startsExpr
      }),
      _checks: createKeywordLike("checks", {
        startsExpr
      }),
      _exports: createKeywordLike("exports", {
        startsExpr
      }),
      _global: createKeywordLike("global", {
        startsExpr
      }),
      _implements: createKeywordLike("implements", {
        startsExpr
      }),
      _intrinsic: createKeywordLike("intrinsic", {
        startsExpr
      }),
      _infer: createKeywordLike("infer", {
        startsExpr
      }),
      _is: createKeywordLike("is", {
        startsExpr
      }),
      _mixins: createKeywordLike("mixins", {
        startsExpr
      }),
      _proto: createKeywordLike("proto", {
        startsExpr
      }),
      _require: createKeywordLike("require", {
        startsExpr
      }),
      _satisfies: createKeywordLike("satisfies", {
        startsExpr
      }),
      _keyof: createKeywordLike("keyof", {
        startsExpr
      }),
      _readonly: createKeywordLike("readonly", {
        startsExpr
      }),
      _unique: createKeywordLike("unique", {
        startsExpr
      }),
      _abstract: createKeywordLike("abstract", {
        startsExpr
      }),
      _declare: createKeywordLike("declare", {
        startsExpr
      }),
      _enum: createKeywordLike("enum", {
        startsExpr
      }),
      _module: createKeywordLike("module", {
        startsExpr
      }),
      _namespace: createKeywordLike("namespace", {
        startsExpr
      }),
      _interface: createKeywordLike("interface", {
        startsExpr
      }),
      _type: createKeywordLike("type", {
        startsExpr
      }),
      _opaque: createKeywordLike("opaque", {
        startsExpr
      }),
      name: createToken("name", {
        startsExpr
      }),
      placeholder: createToken("%%", {
        startsExpr
      }),
      string: createToken("string", {
        startsExpr
      }),
      num: createToken("num", {
        startsExpr
      }),
      bigint: createToken("bigint", {
        startsExpr
      }),
      decimal: createToken("decimal", {
        startsExpr
      }),
      regexp: createToken("regexp", {
        startsExpr
      }),
      privateName: createToken("#name", {
        startsExpr
      }),
      eof: createToken("eof"),
      jsxName: createToken("jsxName"),
      jsxText: createToken("jsxText", {
        beforeExpr
      }),
      jsxTagStart: createToken("jsxTagStart", {
        startsExpr
      }),
      jsxTagEnd: createToken("jsxTagEnd")
    };
    function tokenIsIdentifier(token) {
      return token >= 93 && token <= 133;
    }
    function tokenKeywordOrIdentifierIsKeyword(token) {
      return token <= 92;
    }
    function tokenIsKeywordOrIdentifier(token) {
      return token >= 58 && token <= 133;
    }
    function tokenIsLiteralPropertyName(token) {
      return token >= 58 && token <= 137;
    }
    function tokenComesBeforeExpression(token) {
      return tokenBeforeExprs[token];
    }
    function tokenCanStartExpression(token) {
      return tokenStartsExprs[token];
    }
    function tokenIsAssignment(token) {
      return token >= 29 && token <= 33;
    }
    function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
      return token >= 129 && token <= 131;
    }
    function tokenIsLoop(token) {
      return token >= 90 && token <= 92;
    }
    function tokenIsKeyword(token) {
      return token >= 58 && token <= 92;
    }
    function tokenIsOperator(token) {
      return token >= 39 && token <= 59;
    }
    function tokenIsPostfix(token) {
      return token === 34;
    }
    function tokenIsPrefix(token) {
      return tokenPrefixes[token];
    }
    function tokenIsTSTypeOperator(token) {
      return token >= 121 && token <= 123;
    }
    function tokenIsTSDeclarationStart(token) {
      return token >= 124 && token <= 130;
    }
    function tokenLabelName(token) {
      return tokenLabels[token];
    }
    function tokenOperatorPrecedence(token) {
      return tokenBinops[token];
    }
    function tokenIsRightAssociative(token) {
      return token === 57;
    }
    function tokenIsTemplate(token) {
      return token >= 24 && token <= 25;
    }
    function getExportedToken(token) {
      return tokenTypes2[token];
    }
    tokenTypes2[8].updateContext = (context) => {
      context.pop();
    };
    tokenTypes2[5].updateContext = tokenTypes2[7].updateContext = tokenTypes2[23].updateContext = (context) => {
      context.push(types.brace);
    };
    tokenTypes2[22].updateContext = (context) => {
      if (context[context.length - 1] === types.template) {
        context.pop();
      } else {
        context.push(types.template);
      }
    };
    tokenTypes2[143].updateContext = (context) => {
      context.push(types.j_expr, types.j_oTag);
    };
    var nonASCIIidentifierStartChars = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
    var nonASCIIidentifierChars = "------------------------------------------------------------------------------------------------------------------------------------------------------";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 7, 25, 39, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 5, 57, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 24, 43, 261, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 33, 24, 3, 24, 45, 74, 6, 0, 67, 12, 65, 1, 2, 0, 15, 4, 10, 7381, 42, 31, 98, 114, 8702, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 208, 30, 2, 2, 2, 1, 2, 6, 3, 4, 10, 1, 225, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4381, 3, 5773, 3, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 8489];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 78, 5, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 199, 7, 137, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 55, 9, 266, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 233, 0, 3, 0, 8, 1, 6, 0, 475, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code3, set) {
      let pos = 65536;
      for (let i = 0, length2 = set.length; i < length2; i += 2) {
        pos += set[i];
        if (pos > code3) return false;
        pos += set[i + 1];
        if (pos >= code3) return true;
      }
      return false;
    }
    function isIdentifierStart2(code3) {
      if (code3 < 65) return code3 === 36;
      if (code3 <= 90) return true;
      if (code3 < 97) return code3 === 95;
      if (code3 <= 122) return true;
      if (code3 <= 65535) {
        return code3 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code3));
      }
      return isInAstralSet(code3, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code3) {
      if (code3 < 48) return code3 === 36;
      if (code3 < 58) return true;
      if (code3 < 65) return false;
      if (code3 <= 90) return true;
      if (code3 < 97) return code3 === 95;
      if (code3 <= 122) return true;
      if (code3 <= 65535) {
        return code3 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code3));
      }
      return isInAstralSet(code3, astralIdentifierStartCodes) || isInAstralSet(code3, astralIdentifierCodes);
    }
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords2 = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword2(word) {
      return keywords2.has(word);
    }
    function isIteratorStart(current, next, next2) {
      return current === 64 && next === 64 && isIdentifierStart2(next2);
    }
    var reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
    function canBeReservedWord(word) {
      return reservedWordLikeSet.has(word);
    }
    var Scope = class {
      constructor(flags) {
        this.flags = 0;
        this.names = /* @__PURE__ */ new Map();
        this.firstLexicalName = "";
        this.flags = flags;
      }
    };
    var ScopeHandler = class {
      constructor(parser, inModule) {
        this.parser = void 0;
        this.scopeStack = [];
        this.inModule = void 0;
        this.undefinedExports = /* @__PURE__ */ new Map();
        this.parser = parser;
        this.inModule = inModule;
      }
      get inTopLevel() {
        return (this.currentScope().flags & 1) > 0;
      }
      get inFunction() {
        return (this.currentVarScopeFlags() & 2) > 0;
      }
      get allowSuper() {
        return (this.currentThisScopeFlags() & 16) > 0;
      }
      get allowDirectSuper() {
        return (this.currentThisScopeFlags() & 32) > 0;
      }
      get allowNewTarget() {
        return (this.currentThisScopeFlags() & 512) > 0;
      }
      get inClass() {
        return (this.currentThisScopeFlags() & 64) > 0;
      }
      get inClassAndNotInNonArrowFunction() {
        const flags = this.currentThisScopeFlags();
        return (flags & 64) > 0 && (flags & 2) === 0;
      }
      get inStaticBlock() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & 128) {
            return true;
          }
          if (flags & (1667 | 64)) {
            return false;
          }
        }
      }
      get inNonArrowFunction() {
        return (this.currentThisScopeFlags() & 2) > 0;
      }
      get inBareCaseStatement() {
        return (this.currentScope().flags & 256) > 0;
      }
      get treatFunctionsAsVar() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }
      createScope(flags) {
        return new Scope(flags);
      }
      enter(flags) {
        this.scopeStack.push(this.createScope(flags));
      }
      exit() {
        const scope = this.scopeStack.pop();
        return scope.flags;
      }
      treatFunctionsAsVarInScope(scope) {
        return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);
      }
      declareName(name50, bindingType, loc) {
        let scope = this.currentScope();
        if (bindingType & 8 || bindingType & 16) {
          this.checkRedeclarationInScope(scope, name50, bindingType, loc);
          let type = scope.names.get(name50) || 0;
          if (bindingType & 16) {
            type = type | 4;
          } else {
            if (!scope.firstLexicalName) {
              scope.firstLexicalName = name50;
            }
            type = type | 2;
          }
          scope.names.set(name50, type);
          if (bindingType & 8) {
            this.maybeExportDefined(scope, name50);
          }
        } else if (bindingType & 4) {
          for (let i = this.scopeStack.length - 1; i >= 0; --i) {
            scope = this.scopeStack[i];
            this.checkRedeclarationInScope(scope, name50, bindingType, loc);
            scope.names.set(name50, (scope.names.get(name50) || 0) | 1);
            this.maybeExportDefined(scope, name50);
            if (scope.flags & 1667) break;
          }
        }
        if (this.parser.inModule && scope.flags & 1) {
          this.undefinedExports.delete(name50);
        }
      }
      maybeExportDefined(scope, name50) {
        if (this.parser.inModule && scope.flags & 1) {
          this.undefinedExports.delete(name50);
        }
      }
      checkRedeclarationInScope(scope, name50, bindingType, loc) {
        if (this.isRedeclaredInScope(scope, name50, bindingType)) {
          this.parser.raise(Errors.VarRedeclaration, loc, {
            identifierName: name50
          });
        }
      }
      isRedeclaredInScope(scope, name50, bindingType) {
        if (!(bindingType & 1)) return false;
        if (bindingType & 8) {
          return scope.names.has(name50);
        }
        const type = scope.names.get(name50) || 0;
        if (bindingType & 16) {
          return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;
        }
        return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name50) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;
      }
      checkLocalExport(id) {
        const {
          name: name50
        } = id;
        const topLevelScope = this.scopeStack[0];
        if (!topLevelScope.names.has(name50)) {
          this.undefinedExports.set(name50, id.loc.start);
        }
      }
      currentScope() {
        return this.scopeStack[this.scopeStack.length - 1];
      }
      currentVarScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & 1667) {
            return flags;
          }
        }
      }
      currentThisScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & (1667 | 64) && !(flags & 4)) {
            return flags;
          }
        }
      }
    };
    var FlowScope = class extends Scope {
      constructor(...args) {
        super(...args);
        this.declareFunctions = /* @__PURE__ */ new Set();
      }
    };
    var FlowScopeHandler = class extends ScopeHandler {
      createScope(flags) {
        return new FlowScope(flags);
      }
      declareName(name50, bindingType, loc) {
        const scope = this.currentScope();
        if (bindingType & 2048) {
          this.checkRedeclarationInScope(scope, name50, bindingType, loc);
          this.maybeExportDefined(scope, name50);
          scope.declareFunctions.add(name50);
          return;
        }
        super.declareName(name50, bindingType, loc);
      }
      isRedeclaredInScope(scope, name50, bindingType) {
        if (super.isRedeclaredInScope(scope, name50, bindingType)) return true;
        if (bindingType & 2048 && !scope.declareFunctions.has(name50)) {
          const type = scope.names.get(name50);
          return (type & 4) > 0 || (type & 2) > 0;
        }
        return false;
      }
      checkLocalExport(id) {
        if (!this.scopeStack[0].declareFunctions.has(id.name)) {
          super.checkLocalExport(id);
        }
      }
    };
    var reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
    var FlowErrors = ParseErrorEnum`flow`({
      AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
      AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
      AssignReservedType: ({
        reservedType
      }) => `Cannot overwrite reserved type ${reservedType}.`,
      DeclareClassElement: "The `declare` modifier can only appear on class fields.",
      DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
      DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
      EnumBooleanMemberNotInitialized: ({
        memberName,
        enumName
      }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
      EnumDuplicateMemberName: ({
        memberName,
        enumName
      }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
      EnumInconsistentMemberValues: ({
        enumName
      }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
      EnumInvalidExplicitType: ({
        invalidEnumType,
        enumName
      }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
      EnumInvalidExplicitTypeUnknownSupplied: ({
        enumName
      }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
      EnumInvalidMemberInitializerPrimaryType: ({
        enumName,
        memberName,
        explicitType
      }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
      EnumInvalidMemberInitializerSymbolType: ({
        enumName,
        memberName
      }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
      EnumInvalidMemberInitializerUnknownType: ({
        enumName,
        memberName
      }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
      EnumInvalidMemberName: ({
        enumName,
        memberName,
        suggestion
      }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
      EnumNumberMemberNotInitialized: ({
        enumName,
        memberName
      }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
      EnumStringMemberInconsistentlyInitialized: ({
        enumName
      }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
      GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
      ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
      InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
      InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
      InexactVariance: "Explicit inexact syntax cannot have variance.",
      InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
      MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
      NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
      NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
      PatternIsOptional: Object.assign({
        message: "A binding pattern parameter cannot be optional in an implementation signature."
      }, {
        reasonCode: "OptionalBindingPattern"
      }),
      SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
      SpreadVariance: "Spread properties cannot have variance.",
      ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
      ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
      ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
      ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
      ThisParamNoDefault: "The `this` parameter may not have a default value.",
      TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
      UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
      UnexpectedReservedType: ({
        reservedType
      }) => `Unexpected reserved type ${reservedType}.`,
      UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
      UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
      UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
      UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
      UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
      UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
      UnsupportedDeclareExportKind: ({
        unsupportedExportKind,
        suggestion
      }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
      UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
      UnterminatedFlowComment: "Unterminated flow-comment."
    });
    function isEsModuleType(bodyElement) {
      return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
    }
    function hasTypeImportKind(node) {
      return node.importKind === "type" || node.importKind === "typeof";
    }
    var exportSuggestions = {
      const: "declare export var",
      let: "declare export var",
      type: "export type",
      interface: "export interface"
    };
    function partition(list, test) {
      const list1 = [];
      const list2 = [];
      for (let i = 0; i < list.length; i++) {
        (test(list[i], i, list) ? list1 : list2).push(list[i]);
      }
      return [list1, list2];
    }
    var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
    var flow = (superClass) => class FlowParserMixin extends superClass {
      constructor(...args) {
        super(...args);
        this.flowPragma = void 0;
      }
      getScopeHandler() {
        return FlowScopeHandler;
      }
      shouldParseTypes() {
        return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
      }
      finishToken(type, val) {
        if (type !== 134 && type !== 13 && type !== 28) {
          if (this.flowPragma === void 0) {
            this.flowPragma = null;
          }
        }
        super.finishToken(type, val);
      }
      addComment(comment) {
        if (this.flowPragma === void 0) {
          const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
          if (!matches) ;
          else if (matches[1] === "flow") {
            this.flowPragma = "flow";
          } else if (matches[1] === "noflow") {
            this.flowPragma = "noflow";
          } else {
            throw new Error("Unexpected flow pragma");
          }
        }
        super.addComment(comment);
      }
      flowParseTypeInitialiser(tok) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(tok || 14);
        const type = this.flowParseType();
        this.state.inType = oldInType;
        return type;
      }
      flowParsePredicate() {
        const node = this.startNode();
        const moduloLoc = this.state.startLoc;
        this.next();
        this.expectContextual(110);
        if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {
          this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);
        }
        if (this.eat(10)) {
          node.value = super.parseExpression();
          this.expect(11);
          return this.finishNode(node, "DeclaredPredicate");
        } else {
          return this.finishNode(node, "InferredPredicate");
        }
      }
      flowParseTypeAndPredicateInitialiser() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(14);
        let type = null;
        let predicate = null;
        if (this.match(54)) {
          this.state.inType = oldInType;
          predicate = this.flowParsePredicate();
        } else {
          type = this.flowParseType();
          this.state.inType = oldInType;
          if (this.match(54)) {
            predicate = this.flowParsePredicate();
          }
        }
        return [type, predicate];
      }
      flowParseDeclareClass(node) {
        this.next();
        this.flowParseInterfaceish(node, true);
        return this.finishNode(node, "DeclareClass");
      }
      flowParseDeclareFunction(node) {
        this.next();
        const id = node.id = this.parseIdentifier();
        const typeNode = this.startNode();
        const typeContainer = this.startNode();
        if (this.match(47)) {
          typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          typeNode.typeParameters = null;
        }
        this.expect(10);
        const tmp = this.flowParseFunctionTypeParams();
        typeNode.params = tmp.params;
        typeNode.rest = tmp.rest;
        typeNode.this = tmp._this;
        this.expect(11);
        [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
        typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
        id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
        this.resetEndLocation(id);
        this.semicolon();
        this.scope.declareName(node.id.name, 2048, node.id.loc.start);
        return this.finishNode(node, "DeclareFunction");
      }
      flowParseDeclare(node, insideModule) {
        if (this.match(80)) {
          return this.flowParseDeclareClass(node);
        } else if (this.match(68)) {
          return this.flowParseDeclareFunction(node);
        } else if (this.match(74)) {
          return this.flowParseDeclareVariable(node);
        } else if (this.eatContextual(127)) {
          if (this.match(16)) {
            return this.flowParseDeclareModuleExports(node);
          } else {
            if (insideModule) {
              this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);
            }
            return this.flowParseDeclareModule(node);
          }
        } else if (this.isContextual(130)) {
          return this.flowParseDeclareTypeAlias(node);
        } else if (this.isContextual(131)) {
          return this.flowParseDeclareOpaqueType(node);
        } else if (this.isContextual(129)) {
          return this.flowParseDeclareInterface(node);
        } else if (this.match(82)) {
          return this.flowParseDeclareExportDeclaration(node, insideModule);
        }
        throw this.unexpected();
      }
      flowParseDeclareVariable(node) {
        this.next();
        node.id = this.flowParseTypeAnnotatableIdentifier(true);
        this.scope.declareName(node.id.name, 5, node.id.loc.start);
        this.semicolon();
        return this.finishNode(node, "DeclareVariable");
      }
      flowParseDeclareModule(node) {
        this.scope.enter(0);
        if (this.match(134)) {
          node.id = super.parseExprAtom();
        } else {
          node.id = this.parseIdentifier();
        }
        const bodyNode = node.body = this.startNode();
        const body = bodyNode.body = [];
        this.expect(5);
        while (!this.match(8)) {
          const bodyNode2 = this.startNode();
          if (this.match(83)) {
            this.next();
            if (!this.isContextual(130) && !this.match(87)) {
              this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);
            }
            body.push(super.parseImport(bodyNode2));
          } else {
            this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);
            body.push(this.flowParseDeclare(bodyNode2, true));
          }
        }
        this.scope.exit();
        this.expect(8);
        this.finishNode(bodyNode, "BlockStatement");
        let kind = null;
        let hasModuleExport = false;
        body.forEach((bodyElement) => {
          if (isEsModuleType(bodyElement)) {
            if (kind === "CommonJS") {
              this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
            }
            kind = "ES";
          } else if (bodyElement.type === "DeclareModuleExports") {
            if (hasModuleExport) {
              this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);
            }
            if (kind === "ES") {
              this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
            }
            kind = "CommonJS";
            hasModuleExport = true;
          }
        });
        node.kind = kind || "CommonJS";
        return this.finishNode(node, "DeclareModule");
      }
      flowParseDeclareExportDeclaration(node, insideModule) {
        this.expect(82);
        if (this.eat(65)) {
          if (this.match(68) || this.match(80)) {
            node.declaration = this.flowParseDeclare(this.startNode());
          } else {
            node.declaration = this.flowParseType();
            this.semicolon();
          }
          node.default = true;
          return this.finishNode(node, "DeclareExportDeclaration");
        } else {
          if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
            const label = this.state.value;
            throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {
              unsupportedExportKind: label,
              suggestion: exportSuggestions[label]
            });
          }
          if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {
            node.declaration = this.flowParseDeclare(this.startNode());
            node.default = false;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
            node = this.parseExport(node, null);
            if (node.type === "ExportNamedDeclaration") {
              node.default = false;
              delete node.exportKind;
              return this.castNodeTo(node, "DeclareExportDeclaration");
            } else {
              return this.castNodeTo(node, "DeclareExportAllDeclaration");
            }
          }
        }
        throw this.unexpected();
      }
      flowParseDeclareModuleExports(node) {
        this.next();
        this.expectContextual(111);
        node.typeAnnotation = this.flowParseTypeAnnotation();
        this.semicolon();
        return this.finishNode(node, "DeclareModuleExports");
      }
      flowParseDeclareTypeAlias(node) {
        this.next();
        const finished = this.flowParseTypeAlias(node);
        this.castNodeTo(finished, "DeclareTypeAlias");
        return finished;
      }
      flowParseDeclareOpaqueType(node) {
        this.next();
        const finished = this.flowParseOpaqueType(node, true);
        this.castNodeTo(finished, "DeclareOpaqueType");
        return finished;
      }
      flowParseDeclareInterface(node) {
        this.next();
        this.flowParseInterfaceish(node, false);
        return this.finishNode(node, "DeclareInterface");
      }
      flowParseInterfaceish(node, isClass) {
        node.id = this.flowParseRestrictedIdentifier(!isClass, true);
        this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.extends = [];
        if (this.eat(81)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (!isClass && this.eat(12));
        }
        if (isClass) {
          node.implements = [];
          node.mixins = [];
          if (this.eatContextual(117)) {
            do {
              node.mixins.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          if (this.eatContextual(113)) {
            do {
              node.implements.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
        }
        node.body = this.flowParseObjectType({
          allowStatic: isClass,
          allowExact: false,
          allowSpread: false,
          allowProto: isClass,
          allowInexact: false
        });
      }
      flowParseInterfaceExtends() {
        const node = this.startNode();
        node.id = this.flowParseQualifiedTypeIdentifier();
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        } else {
          node.typeParameters = null;
        }
        return this.finishNode(node, "InterfaceExtends");
      }
      flowParseInterface(node) {
        this.flowParseInterfaceish(node, false);
        return this.finishNode(node, "InterfaceDeclaration");
      }
      checkNotUnderscore(word) {
        if (word === "_") {
          this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);
        }
      }
      checkReservedType(word, startLoc, declaration) {
        if (!reservedTypes.has(word)) return;
        this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {
          reservedType: word
        });
      }
      flowParseRestrictedIdentifier(liberal, declaration) {
        this.checkReservedType(this.state.value, this.state.startLoc, declaration);
        return this.parseIdentifier(liberal);
      }
      flowParseTypeAlias(node) {
        node.id = this.flowParseRestrictedIdentifier(false, true);
        this.scope.declareName(node.id.name, 8201, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.right = this.flowParseTypeInitialiser(29);
        this.semicolon();
        return this.finishNode(node, "TypeAlias");
      }
      flowParseOpaqueType(node, declare) {
        this.expectContextual(130);
        node.id = this.flowParseRestrictedIdentifier(true, true);
        this.scope.declareName(node.id.name, 8201, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.supertype = null;
        if (this.match(14)) {
          node.supertype = this.flowParseTypeInitialiser(14);
        }
        node.impltype = null;
        if (!declare) {
          node.impltype = this.flowParseTypeInitialiser(29);
        }
        this.semicolon();
        return this.finishNode(node, "OpaqueType");
      }
      flowParseTypeParameter(requireDefault = false) {
        const nodeStartLoc = this.state.startLoc;
        const node = this.startNode();
        const variance = this.flowParseVariance();
        const ident = this.flowParseTypeAnnotatableIdentifier();
        node.name = ident.name;
        node.variance = variance;
        node.bound = ident.typeAnnotation;
        if (this.match(29)) {
          this.eat(29);
          node.default = this.flowParseType();
        } else {
          if (requireDefault) {
            this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);
          }
        }
        return this.finishNode(node, "TypeParameter");
      }
      flowParseTypeParameterDeclaration() {
        const oldInType = this.state.inType;
        const node = this.startNode();
        node.params = [];
        this.state.inType = true;
        if (this.match(47) || this.match(143)) {
          this.next();
        } else {
          this.unexpected();
        }
        let defaultRequired = false;
        do {
          const typeParameter = this.flowParseTypeParameter(defaultRequired);
          node.params.push(typeParameter);
          if (typeParameter.default) {
            defaultRequired = true;
          }
          if (!this.match(48)) {
            this.expect(12);
          }
        } while (!this.match(48));
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterDeclaration");
      }
      flowInTopLevelContext(cb) {
        if (this.curContext() !== types.brace) {
          const oldContext = this.state.context;
          this.state.context = [oldContext[0]];
          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        } else {
          return cb();
        }
      }
      flowParseTypeParameterInstantiationInExpression() {
        if (this.reScan_lt() !== 47) return;
        return this.flowParseTypeParameterInstantiation();
      }
      flowParseTypeParameterInstantiation() {
        const node = this.startNode();
        const oldInType = this.state.inType;
        this.state.inType = true;
        node.params = [];
        this.flowInTopLevelContext(() => {
          this.expect(47);
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = false;
          while (!this.match(48)) {
            node.params.push(this.flowParseType());
            if (!this.match(48)) {
              this.expect(12);
            }
          }
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        });
        this.state.inType = oldInType;
        if (!this.state.inType && this.curContext() === types.brace) {
          this.reScan_lt_gt();
        }
        this.expect(48);
        return this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseTypeParameterInstantiationCallOrNew() {
        if (this.reScan_lt() !== 47) return null;
        const node = this.startNode();
        const oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expect(47);
        while (!this.match(48)) {
          node.params.push(this.flowParseTypeOrImplicitInstantiation());
          if (!this.match(48)) {
            this.expect(12);
          }
        }
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseInterfaceType() {
        const node = this.startNode();
        this.expectContextual(129);
        node.extends = [];
        if (this.eat(81)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
        node.body = this.flowParseObjectType({
          allowStatic: false,
          allowExact: false,
          allowSpread: false,
          allowProto: false,
          allowInexact: false
        });
        return this.finishNode(node, "InterfaceTypeAnnotation");
      }
      flowParseObjectPropertyKey() {
        return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(true);
      }
      flowParseObjectTypeIndexer(node, isStatic, variance) {
        node.static = isStatic;
        if (this.lookahead().type === 14) {
          node.id = this.flowParseObjectPropertyKey();
          node.key = this.flowParseTypeInitialiser();
        } else {
          node.id = null;
          node.key = this.flowParseType();
        }
        this.expect(3);
        node.value = this.flowParseTypeInitialiser();
        node.variance = variance;
        return this.finishNode(node, "ObjectTypeIndexer");
      }
      flowParseObjectTypeInternalSlot(node, isStatic) {
        node.static = isStatic;
        node.id = this.flowParseObjectPropertyKey();
        this.expect(3);
        this.expect(3);
        if (this.match(47) || this.match(10)) {
          node.method = true;
          node.optional = false;
          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
        } else {
          node.method = false;
          if (this.eat(17)) {
            node.optional = true;
          }
          node.value = this.flowParseTypeInitialiser();
        }
        return this.finishNode(node, "ObjectTypeInternalSlot");
      }
      flowParseObjectTypeMethodish(node) {
        node.params = [];
        node.rest = null;
        node.typeParameters = null;
        node.this = null;
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        this.expect(10);
        if (this.match(78)) {
          node.this = this.flowParseFunctionTypeParam(true);
          node.this.name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          node.params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          node.rest = this.flowParseFunctionTypeParam(false);
        }
        this.expect(11);
        node.returnType = this.flowParseTypeInitialiser();
        return this.finishNode(node, "FunctionTypeAnnotation");
      }
      flowParseObjectTypeCallProperty(node, isStatic) {
        const valueNode = this.startNode();
        node.static = isStatic;
        node.value = this.flowParseObjectTypeMethodish(valueNode);
        return this.finishNode(node, "ObjectTypeCallProperty");
      }
      flowParseObjectType({
        allowStatic,
        allowExact,
        allowSpread,
        allowProto,
        allowInexact
      }) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const nodeStart = this.startNode();
        nodeStart.callProperties = [];
        nodeStart.properties = [];
        nodeStart.indexers = [];
        nodeStart.internalSlots = [];
        let endDelim;
        let exact;
        let inexact = false;
        if (allowExact && this.match(6)) {
          this.expect(6);
          endDelim = 9;
          exact = true;
        } else {
          this.expect(5);
          endDelim = 8;
          exact = false;
        }
        nodeStart.exact = exact;
        while (!this.match(endDelim)) {
          let isStatic = false;
          let protoStartLoc = null;
          let inexactStartLoc = null;
          const node = this.startNode();
          if (allowProto && this.isContextual(118)) {
            const lookahead = this.lookahead();
            if (lookahead.type !== 14 && lookahead.type !== 17) {
              this.next();
              protoStartLoc = this.state.startLoc;
              allowStatic = false;
            }
          }
          if (allowStatic && this.isContextual(106)) {
            const lookahead = this.lookahead();
            if (lookahead.type !== 14 && lookahead.type !== 17) {
              this.next();
              isStatic = true;
            }
          }
          const variance = this.flowParseVariance();
          if (this.eat(0)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (this.eat(0)) {
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
            } else {
              nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
            }
          } else if (this.match(10) || this.match(47)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
          } else {
            let kind = "init";
            if (this.isContextual(99) || this.isContextual(104)) {
              const lookahead = this.lookahead();
              if (tokenIsLiteralPropertyName(lookahead.type)) {
                kind = this.state.value;
                this.next();
              }
            }
            const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
            if (propOrInexact === null) {
              inexact = true;
              inexactStartLoc = this.state.lastTokStartLoc;
            } else {
              nodeStart.properties.push(propOrInexact);
            }
          }
          this.flowObjectTypeSemicolon();
          if (inexactStartLoc && !this.match(8) && !this.match(9)) {
            this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);
          }
        }
        this.expect(endDelim);
        if (allowSpread) {
          nodeStart.inexact = inexact;
        }
        const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
        this.state.inType = oldInType;
        return out;
      }
      flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
        if (this.eat(21)) {
          const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
          if (isInexactToken) {
            if (!allowSpread) {
              this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);
            } else if (!allowInexact) {
              this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);
            }
            if (variance) {
              this.raise(FlowErrors.InexactVariance, variance);
            }
            return null;
          }
          if (!allowSpread) {
            this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);
          }
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc);
          }
          if (variance) {
            this.raise(FlowErrors.SpreadVariance, variance);
          }
          node.argument = this.flowParseType();
          return this.finishNode(node, "ObjectTypeSpreadProperty");
        } else {
          node.key = this.flowParseObjectPropertyKey();
          node.static = isStatic;
          node.proto = protoStartLoc != null;
          node.kind = kind;
          let optional = false;
          if (this.match(47) || this.match(10)) {
            node.method = true;
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
            if (kind === "get" || kind === "set") {
              this.flowCheckGetterSetterParams(node);
            }
            if (!allowSpread && node.key.name === "constructor" && node.value.this) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this);
            }
          } else {
            if (kind !== "init") this.unexpected();
            node.method = false;
            if (this.eat(17)) {
              optional = true;
            }
            node.value = this.flowParseTypeInitialiser();
            node.variance = variance;
          }
          node.optional = optional;
          return this.finishNode(node, "ObjectTypeProperty");
        }
      }
      flowCheckGetterSetterParams(property4) {
        const paramCount = property4.kind === "get" ? 0 : 1;
        const length2 = property4.value.params.length + (property4.value.rest ? 1 : 0);
        if (property4.value.this) {
          this.raise(property4.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property4.value.this);
        }
        if (length2 !== paramCount) {
          this.raise(property4.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, property4);
        }
        if (property4.kind === "set" && property4.value.rest) {
          this.raise(Errors.BadSetterRestParameter, property4);
        }
      }
      flowObjectTypeSemicolon() {
        if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
          this.unexpected();
        }
      }
      flowParseQualifiedTypeIdentifier(startLoc, id) {
        startLoc != null ? startLoc : startLoc = this.state.startLoc;
        let node = id || this.flowParseRestrictedIdentifier(true);
        while (this.eat(16)) {
          const node2 = this.startNodeAt(startLoc);
          node2.qualification = node;
          node2.id = this.flowParseRestrictedIdentifier(true);
          node = this.finishNode(node2, "QualifiedTypeIdentifier");
        }
        return node;
      }
      flowParseGenericType(startLoc, id) {
        const node = this.startNodeAt(startLoc);
        node.typeParameters = null;
        node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        }
        return this.finishNode(node, "GenericTypeAnnotation");
      }
      flowParseTypeofType() {
        const node = this.startNode();
        this.expect(87);
        node.argument = this.flowParsePrimaryType();
        return this.finishNode(node, "TypeofTypeAnnotation");
      }
      flowParseTupleType() {
        const node = this.startNode();
        node.types = [];
        this.expect(0);
        while (this.state.pos < this.length && !this.match(3)) {
          node.types.push(this.flowParseType());
          if (this.match(3)) break;
          this.expect(12);
        }
        this.expect(3);
        return this.finishNode(node, "TupleTypeAnnotation");
      }
      flowParseFunctionTypeParam(first) {
        let name50 = null;
        let optional = false;
        let typeAnnotation = null;
        const node = this.startNode();
        const lh = this.lookahead();
        const isThis = this.state.type === 78;
        if (lh.type === 14 || lh.type === 17) {
          if (isThis && !first) {
            this.raise(FlowErrors.ThisParamMustBeFirst, node);
          }
          name50 = this.parseIdentifier(isThis);
          if (this.eat(17)) {
            optional = true;
            if (isThis) {
              this.raise(FlowErrors.ThisParamMayNotBeOptional, node);
            }
          }
          typeAnnotation = this.flowParseTypeInitialiser();
        } else {
          typeAnnotation = this.flowParseType();
        }
        node.name = name50;
        node.optional = optional;
        node.typeAnnotation = typeAnnotation;
        return this.finishNode(node, "FunctionTypeParam");
      }
      reinterpretTypeAsFunctionTypeParam(type) {
        const node = this.startNodeAt(type.loc.start);
        node.name = null;
        node.optional = false;
        node.typeAnnotation = type;
        return this.finishNode(node, "FunctionTypeParam");
      }
      flowParseFunctionTypeParams(params = []) {
        let rest = null;
        let _this = null;
        if (this.match(78)) {
          _this = this.flowParseFunctionTypeParam(true);
          _this.name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          rest = this.flowParseFunctionTypeParam(false);
        }
        return {
          params,
          rest,
          _this
        };
      }
      flowIdentToTypeAnnotation(startLoc, node, id) {
        switch (id.name) {
          case "any":
            return this.finishNode(node, "AnyTypeAnnotation");
          case "bool":
          case "boolean":
            return this.finishNode(node, "BooleanTypeAnnotation");
          case "mixed":
            return this.finishNode(node, "MixedTypeAnnotation");
          case "empty":
            return this.finishNode(node, "EmptyTypeAnnotation");
          case "number":
            return this.finishNode(node, "NumberTypeAnnotation");
          case "string":
            return this.finishNode(node, "StringTypeAnnotation");
          case "symbol":
            return this.finishNode(node, "SymbolTypeAnnotation");
          default:
            this.checkNotUnderscore(id.name);
            return this.flowParseGenericType(startLoc, id);
        }
      }
      flowParsePrimaryType() {
        const startLoc = this.state.startLoc;
        const node = this.startNode();
        let tmp;
        let type;
        let isGroupedType = false;
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        switch (this.state.type) {
          case 5:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: false,
              allowSpread: true,
              allowProto: false,
              allowInexact: true
            });
          case 6:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: true,
              allowSpread: true,
              allowProto: false,
              allowInexact: false
            });
          case 0:
            this.state.noAnonFunctionType = false;
            type = this.flowParseTupleType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            return type;
          case 47: {
            const node2 = this.startNode();
            node2.typeParameters = this.flowParseTypeParameterDeclaration();
            this.expect(10);
            tmp = this.flowParseFunctionTypeParams();
            node2.params = tmp.params;
            node2.rest = tmp.rest;
            node2.this = tmp._this;
            this.expect(11);
            this.expect(19);
            node2.returnType = this.flowParseType();
            return this.finishNode(node2, "FunctionTypeAnnotation");
          }
          case 10: {
            const node2 = this.startNode();
            this.next();
            if (!this.match(11) && !this.match(21)) {
              if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                const token = this.lookahead().type;
                isGroupedType = token !== 17 && token !== 14;
              } else {
                isGroupedType = true;
              }
            }
            if (isGroupedType) {
              this.state.noAnonFunctionType = false;
              type = this.flowParseType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                this.expect(11);
                return type;
              } else {
                this.eat(12);
              }
            }
            if (type) {
              tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
            } else {
              tmp = this.flowParseFunctionTypeParams();
            }
            node2.params = tmp.params;
            node2.rest = tmp.rest;
            node2.this = tmp._this;
            this.expect(11);
            this.expect(19);
            node2.returnType = this.flowParseType();
            node2.typeParameters = null;
            return this.finishNode(node2, "FunctionTypeAnnotation");
          }
          case 134:
            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
          case 85:
          case 86:
            node.value = this.match(85);
            this.next();
            return this.finishNode(node, "BooleanLiteralTypeAnnotation");
          case 53:
            if (this.state.value === "-") {
              this.next();
              if (this.match(135)) {
                return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
              }
              if (this.match(136)) {
                return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
              }
              throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);
            }
            throw this.unexpected();
          case 135:
            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
          case 136:
            return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
          case 88:
            this.next();
            return this.finishNode(node, "VoidTypeAnnotation");
          case 84:
            this.next();
            return this.finishNode(node, "NullLiteralTypeAnnotation");
          case 78:
            this.next();
            return this.finishNode(node, "ThisTypeAnnotation");
          case 55:
            this.next();
            return this.finishNode(node, "ExistsTypeAnnotation");
          case 87:
            return this.flowParseTypeofType();
          default:
            if (tokenIsKeyword(this.state.type)) {
              const label = tokenLabelName(this.state.type);
              this.next();
              return super.createIdentifier(node, label);
            } else if (tokenIsIdentifier(this.state.type)) {
              if (this.isContextual(129)) {
                return this.flowParseInterfaceType();
              }
              return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
            }
        }
        throw this.unexpected();
      }
      flowParsePostfixType() {
        const startLoc = this.state.startLoc;
        let type = this.flowParsePrimaryType();
        let seenOptionalIndexedAccess = false;
        while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
          const node = this.startNodeAt(startLoc);
          const optional = this.eat(18);
          seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
          this.expect(0);
          if (!optional && this.match(3)) {
            node.elementType = type;
            this.next();
            type = this.finishNode(node, "ArrayTypeAnnotation");
          } else {
            node.objectType = type;
            node.indexType = this.flowParseType();
            this.expect(3);
            if (seenOptionalIndexedAccess) {
              node.optional = optional;
              type = this.finishNode(node, "OptionalIndexedAccessType");
            } else {
              type = this.finishNode(node, "IndexedAccessType");
            }
          }
        }
        return type;
      }
      flowParsePrefixType() {
        const node = this.startNode();
        if (this.eat(17)) {
          node.typeAnnotation = this.flowParsePrefixType();
          return this.finishNode(node, "NullableTypeAnnotation");
        } else {
          return this.flowParsePostfixType();
        }
      }
      flowParseAnonFunctionWithoutParens() {
        const param = this.flowParsePrefixType();
        if (!this.state.noAnonFunctionType && this.eat(19)) {
          const node = this.startNodeAt(param.loc.start);
          node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
          node.rest = null;
          node.this = null;
          node.returnType = this.flowParseType();
          node.typeParameters = null;
          return this.finishNode(node, "FunctionTypeAnnotation");
        }
        return param;
      }
      flowParseIntersectionType() {
        const node = this.startNode();
        this.eat(45);
        const type = this.flowParseAnonFunctionWithoutParens();
        node.types = [type];
        while (this.eat(45)) {
          node.types.push(this.flowParseAnonFunctionWithoutParens());
        }
        return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
      }
      flowParseUnionType() {
        const node = this.startNode();
        this.eat(43);
        const type = this.flowParseIntersectionType();
        node.types = [type];
        while (this.eat(43)) {
          node.types.push(this.flowParseIntersectionType());
        }
        return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
      }
      flowParseType() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const type = this.flowParseUnionType();
        this.state.inType = oldInType;
        return type;
      }
      flowParseTypeOrImplicitInstantiation() {
        if (this.state.type === 132 && this.state.value === "_") {
          const startLoc = this.state.startLoc;
          const node = this.parseIdentifier();
          return this.flowParseGenericType(startLoc, node);
        } else {
          return this.flowParseType();
        }
      }
      flowParseTypeAnnotation() {
        const node = this.startNode();
        node.typeAnnotation = this.flowParseTypeInitialiser();
        return this.finishNode(node, "TypeAnnotation");
      }
      flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
        const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
        if (this.match(14)) {
          ident.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(ident);
        }
        return ident;
      }
      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
        return node.expression;
      }
      flowParseVariance() {
        let variance = null;
        if (this.match(53)) {
          variance = this.startNode();
          if (this.state.value === "+") {
            variance.kind = "plus";
          } else {
            variance.kind = "minus";
          }
          this.next();
          return this.finishNode(variance, "Variance");
        }
        return variance;
      }
      parseFunctionBody(node, allowExpressionBody, isMethod = false) {
        if (allowExpressionBody) {
          this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
          return;
        }
        super.parseFunctionBody(node, false, isMethod);
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        if (this.match(14)) {
          const typeNode = this.startNode();
          [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
          node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
        }
        return super.parseFunctionBodyAndFinish(node, type, isMethod);
      }
      parseStatementLike(flags) {
        if (this.state.strict && this.isContextual(129)) {
          const lookahead = this.lookahead();
          if (tokenIsKeywordOrIdentifier(lookahead.type)) {
            const node = this.startNode();
            this.next();
            return this.flowParseInterface(node);
          }
        } else if (this.isContextual(126)) {
          const node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }
        const stmt = super.parseStatementLike(flags);
        if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
          this.flowPragma = null;
        }
        return stmt;
      }
      parseExpressionStatement(node, expr, decorators) {
        if (expr.type === "Identifier") {
          if (expr.name === "declare") {
            if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
              return this.flowParseDeclare(node);
            }
          } else if (tokenIsIdentifier(this.state.type)) {
            if (expr.name === "interface") {
              return this.flowParseInterface(node);
            } else if (expr.name === "type") {
              return this.flowParseTypeAlias(node);
            } else if (expr.name === "opaque") {
              return this.flowParseOpaqueType(node, false);
            }
          }
        }
        return super.parseExpressionStatement(node, expr, decorators);
      }
      shouldParseExportDeclaration() {
        const {
          type
        } = this.state;
        if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
          return !this.state.containsEsc;
        }
        return super.shouldParseExportDeclaration();
      }
      isExportDefaultSpecifier() {
        const {
          type
        } = this.state;
        if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
          return this.state.containsEsc;
        }
        return super.isExportDefaultSpecifier();
      }
      parseExportDefaultExpression() {
        if (this.isContextual(126)) {
          const node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }
        return super.parseExportDefaultExpression();
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.match(17)) return expr;
        if (this.state.maybeInArrowParameters) {
          const nextCh = this.lookaheadCharCode();
          if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
            this.setOptionalParametersError(refExpressionErrors);
            return expr;
          }
        }
        this.expect(17);
        const state = this.state.clone();
        const originalNoArrowAt = this.state.noArrowAt;
        const node = this.startNodeAt(startLoc);
        let {
          consequent,
          failed
        } = this.tryParseConditionalConsequent();
        let [valid, invalid] = this.getArrowLikeExpressions(consequent);
        if (failed || invalid.length > 0) {
          const noArrowAt = [...originalNoArrowAt];
          if (invalid.length > 0) {
            this.state = state;
            this.state.noArrowAt = noArrowAt;
            for (let i = 0; i < invalid.length; i++) {
              noArrowAt.push(invalid[i].start);
            }
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
            [valid, invalid] = this.getArrowLikeExpressions(consequent);
          }
          if (failed && valid.length > 1) {
            this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);
          }
          if (failed && valid.length === 1) {
            this.state = state;
            noArrowAt.push(valid[0].start);
            this.state.noArrowAt = noArrowAt;
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
          }
        }
        this.getArrowLikeExpressions(consequent, true);
        this.state.noArrowAt = originalNoArrowAt;
        this.expect(14);
        node.test = expr;
        node.consequent = consequent;
        node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0));
        return this.finishNode(node, "ConditionalExpression");
      }
      tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        const consequent = this.parseMaybeAssignAllowIn();
        const failed = !this.match(14);
        this.state.noArrowParamsConversionAt.pop();
        return {
          consequent,
          failed
        };
      }
      getArrowLikeExpressions(node, disallowInvalid) {
        const stack = [node];
        const arrows = [];
        while (stack.length !== 0) {
          const node2 = stack.pop();
          if (node2.type === "ArrowFunctionExpression" && node2.body.type !== "BlockStatement") {
            if (node2.typeParameters || !node2.returnType) {
              this.finishArrowValidation(node2);
            } else {
              arrows.push(node2);
            }
            stack.push(node2.body);
          } else if (node2.type === "ConditionalExpression") {
            stack.push(node2.consequent);
            stack.push(node2.alternate);
          }
        }
        if (disallowInvalid) {
          arrows.forEach((node2) => this.finishArrowValidation(node2));
          return [arrows, []];
        }
        return partition(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));
      }
      finishArrowValidation(node) {
        var _node$extra;
        this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
        this.scope.enter(514 | 4);
        super.checkParams(node, false, true);
        this.scope.exit();
      }
      forwardNoArrowParamsConversionAt(node, parse54) {
        let result;
        if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          result = parse54();
          this.state.noArrowParamsConversionAt.pop();
        } else {
          result = parse54();
        }
        return result;
      }
      parseParenItem(node, startLoc) {
        const newNode = super.parseParenItem(node, startLoc);
        if (this.eat(17)) {
          newNode.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(14)) {
          const typeCastNode = this.startNodeAt(startLoc);
          typeCastNode.expression = newNode;
          typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TypeCastExpression");
        }
        return newNode;
      }
      assertModuleNodeAllowed(node) {
        if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
          return;
        }
        super.assertModuleNodeAllowed(node);
      }
      parseExportDeclaration(node) {
        if (this.isContextual(130)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          if (this.match(5)) {
            node.specifiers = this.parseExportSpecifiers(true);
            super.parseExportFrom(node);
            return null;
          } else {
            return this.flowParseTypeAlias(declarationNode);
          }
        } else if (this.isContextual(131)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseOpaqueType(declarationNode, false);
        } else if (this.isContextual(129)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseInterface(declarationNode);
        } else if (this.isContextual(126)) {
          node.exportKind = "value";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(declarationNode);
        } else {
          return super.parseExportDeclaration(node);
        }
      }
      eatExportStar(node) {
        if (super.eatExportStar(node)) return true;
        if (this.isContextual(130) && this.lookahead().type === 55) {
          node.exportKind = "type";
          this.next();
          this.next();
          return true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(node) {
        const {
          startLoc
        } = this.state;
        const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
        if (hasNamespace && node.exportKind === "type") {
          this.unexpected(startLoc);
        }
        return hasNamespace;
      }
      parseClassId(node, isStatement, optionalId) {
        super.parseClassId(node, isStatement, optionalId);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
      }
      parseClassMember(classBody, member, state) {
        const {
          startLoc
        } = this.state;
        if (this.isContextual(125)) {
          if (super.parseClassMemberFromModifier(classBody, member)) {
            return;
          }
          member.declare = true;
        }
        super.parseClassMember(classBody, member, state);
        if (member.declare) {
          if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
            this.raise(FlowErrors.DeclareClassElement, startLoc);
          } else if (member.value) {
            this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);
          }
        }
      }
      isIterator(word) {
        return word === "iterator" || word === "asyncIterator";
      }
      readIterator() {
        const word = super.readWord1();
        const fullWord = "@@" + word;
        if (!this.isIterator(word) || !this.state.inType) {
          this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {
            identifierName: fullWord
          });
        }
        this.finishToken(132, fullWord);
      }
      getTokenFromCode(code3) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code3 === 123 && next === 124) {
          this.finishOp(6, 2);
        } else if (this.state.inType && (code3 === 62 || code3 === 60)) {
          this.finishOp(code3 === 62 ? 48 : 47, 1);
        } else if (this.state.inType && code3 === 63) {
          if (next === 46) {
            this.finishOp(18, 2);
          } else {
            this.finishOp(17, 1);
          }
        } else if (isIteratorStart(code3, next, this.input.charCodeAt(this.state.pos + 2))) {
          this.state.pos += 2;
          this.readIterator();
        } else {
          super.getTokenFromCode(code3);
        }
      }
      isAssignable(node, isBinding) {
        if (node.type === "TypeCastExpression") {
          return this.isAssignable(node.expression, isBinding);
        } else {
          return super.isAssignable(node, isBinding);
        }
      }
      toAssignable(node, isLHS = false) {
        if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {
          node.left = this.typeCastToParameter(node.left);
        }
        super.toAssignable(node, isLHS);
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }
        super.toAssignableList(exprList, trailingCommaLoc, isLHS);
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        for (let i = 0; i < exprList.length; i++) {
          var _expr$extra;
          const expr = exprList[i];
          if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
            this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);
          }
        }
        return exprList;
      }
      parseArrayLike(close, isTuple, refExpressionErrors) {
        const node = super.parseArrayLike(close, isTuple, refExpressionErrors);
        if (refExpressionErrors != null && !this.state.maybeInArrowParameters) {
          this.toReferencedList(node.elements);
        }
        return node;
      }
      isValidLVal(type, disallowCallExpression, isParenthesized, binding) {
        return type === "TypeCastExpression" || super.isValidLVal(type, disallowCallExpression, isParenthesized, binding);
      }
      parseClassProperty(node) {
        if (this.match(14)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        if (this.match(14)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassPrivateProperty(node);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(14) || super.isClassProperty();
      }
      isNonstaticConstructor(method) {
        return !this.match(14) && super.isNonstaticConstructor(method);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        if (method.params && isConstructor) {
          const params = method.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, method);
          }
        } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
          const params = method.value.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, method);
          }
        }
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && (this.match(47) || this.match(51))) {
          node.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression();
        }
        if (this.isContextual(113)) {
          this.next();
          const implemented = node.implements = [];
          do {
            const node2 = this.startNode();
            node2.id = this.flowParseRestrictedIdentifier(true);
            if (this.match(47)) {
              node2.typeParameters = this.flowParseTypeParameterInstantiation();
            } else {
              node2.typeParameters = null;
            }
            implemented.push(this.finishNode(node2, "ClassImplements"));
          } while (this.eat(12));
        }
      }
      checkGetterSetterParams(method) {
        super.checkGetterSetterParams(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length > 0) {
          const param = params[0];
          if (this.isThisParam(param) && method.kind === "get") {
            this.raise(FlowErrors.GetterMayNotHaveThisParam, param);
          } else if (this.isThisParam(param)) {
            this.raise(FlowErrors.SetterMayNotHaveThisParam, param);
          }
        }
      }
      parsePropertyNamePrefixOperator(node) {
        node.variance = this.flowParseVariance();
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        if (prop.variance) {
          this.unexpected(prop.variance.loc.start);
        }
        delete prop.variance;
        let typeParameters;
        if (this.match(47) && !isAccessor) {
          typeParameters = this.flowParseTypeParameterDeclaration();
          if (!this.match(10)) this.unexpected();
        }
        const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
        if (typeParameters) {
          (result.value || result).typeParameters = typeParameters;
        }
        return result;
      }
      parseFunctionParamType(param) {
        if (this.eat(17)) {
          if (param.type !== "Identifier") {
            this.raise(FlowErrors.PatternIsOptional, param);
          }
          if (this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamMayNotBeOptional, param);
          }
          param.optional = true;
        }
        if (this.match(14)) {
          param.typeAnnotation = this.flowParseTypeAnnotation();
        } else if (this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamAnnotationRequired, param);
        }
        if (this.match(29) && this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamNoDefault, param);
        }
        this.resetEndLocation(param);
        return param;
      }
      parseMaybeDefault(startLoc, left) {
        const node = super.parseMaybeDefault(startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);
        }
        return node;
      }
      checkImportReflection(node) {
        super.checkImportReflection(node);
        if (node.module && node.importKind !== "value") {
          this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
        }
      }
      parseImportSpecifierLocal(node, specifier, type) {
        specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
        node.specifiers.push(this.finishImportSpecifier(specifier, type));
      }
      isPotentialImportPhase(isExport) {
        if (super.isPotentialImportPhase(isExport)) return true;
        if (this.isContextual(130)) {
          if (!isExport) return true;
          const ch = this.lookaheadCharCode();
          return ch === 123 || ch === 42;
        }
        return !isExport && this.isContextual(87);
      }
      applyImportPhase(node, isExport, phase, loc) {
        super.applyImportPhase(node, isExport, phase, loc);
        if (isExport) {
          if (!phase && this.match(65)) {
            return;
          }
          node.exportKind = phase === "type" ? phase : "value";
        } else {
          if (phase === "type" && this.match(55)) this.unexpected();
          node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
        }
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        const firstIdent = specifier.imported;
        let specifierTypeKind = null;
        if (firstIdent.type === "Identifier") {
          if (firstIdent.name === "type") {
            specifierTypeKind = "type";
          } else if (firstIdent.name === "typeof") {
            specifierTypeKind = "typeof";
          }
        }
        let isBinding = false;
        if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
          const as_ident = this.parseIdentifier(true);
          if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = as_ident;
            specifier.importKind = specifierTypeKind;
            specifier.local = this.cloneIdentifier(as_ident);
          } else {
            specifier.imported = firstIdent;
            specifier.importKind = null;
            specifier.local = this.parseIdentifier();
          }
        } else {
          if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = this.parseIdentifier(true);
            specifier.importKind = specifierTypeKind;
          } else {
            if (importedIsString) {
              throw this.raise(Errors.ImportBindingIsString, specifier, {
                importName: firstIdent.value
              });
            }
            specifier.imported = firstIdent;
            specifier.importKind = null;
          }
          if (this.eatContextual(93)) {
            specifier.local = this.parseIdentifier();
          } else {
            isBinding = true;
            specifier.local = this.cloneIdentifier(specifier.imported);
          }
        }
        const specifierIsTypeImport = hasTypeImportKind(specifier);
        if (isInTypeOnlyImport && specifierIsTypeImport) {
          this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);
        }
        if (isInTypeOnlyImport || specifierIsTypeImport) {
          this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
        }
        if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
          this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
        }
        return this.finishImportSpecifier(specifier, "ImportSpecifier");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 78:
            return this.parseIdentifier(true);
          default:
            return super.parseBindingAtom();
        }
      }
      parseFunctionParams(node, isConstructor) {
        const kind = node.kind;
        if (kind !== "get" && kind !== "set" && this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.parseFunctionParams(node, isConstructor);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (this.match(14)) {
          decl.id.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(decl.id);
        }
      }
      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(14)) {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          node.returnType = this.flowParseTypeAnnotation();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        }
        return super.parseAsyncArrowFromCallExpression(node, call);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx;
        let state = null;
        let jsx2;
        if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
          state = this.state.clone();
          jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!jsx2.error) return jsx2.node;
          const {
            context
          } = this.state;
          const currentContext = context[context.length - 1];
          if (currentContext === types.j_oTag || currentContext === types.j_expr) {
            context.pop();
          }
        }
        if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {
          var _jsx2, _jsx3;
          state = state || this.state.clone();
          let typeParameters;
          const arrow = this.tryParse((abort) => {
            var _arrowExpression$extr;
            typeParameters = this.flowParseTypeParameterDeclaration();
            const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
              const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
              this.resetStartLocationFromNode(result, typeParameters);
              return result;
            });
            if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized) abort();
            const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
            if (expr.type !== "ArrowFunctionExpression") abort();
            expr.typeParameters = typeParameters;
            this.resetStartLocationFromNode(expr, typeParameters);
            return arrowExpression2;
          }, state);
          let arrowExpression = null;
          if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
            if (!arrow.error && !arrow.aborted) {
              if (arrow.node.async) {
                this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);
              }
              return arrow.node;
            }
            arrowExpression = arrow.node;
          }
          if ((_jsx2 = jsx2) != null && _jsx2.node) {
            this.state = jsx2.failState;
            return jsx2.node;
          }
          if (arrowExpression) {
            this.state = arrow.failState;
            return arrowExpression;
          }
          if ((_jsx3 = jsx2) != null && _jsx3.thrown) throw jsx2.error;
          if (arrow.thrown) throw arrow.error;
          throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);
        }
        return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      }
      parseArrow(node) {
        if (this.match(14)) {
          const result = this.tryParse(() => {
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            const typeNode = this.startNode();
            [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (this.canInsertSemicolon()) this.unexpected();
            if (!this.match(19)) this.unexpected();
            return typeNode;
          });
          if (result.thrown) return null;
          if (result.error) this.state = result.failState;
          node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
        }
        return super.parseArrow(node);
      }
      shouldParseArrow(params) {
        return this.match(14) || super.shouldParseArrow(params);
      }
      setArrowFunctionParameters(node, params) {
        if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
          node.params = params;
        } else {
          super.setArrowFunctionParameters(node, params);
        }
      }
      checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        if (isArrowFunction && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
          return;
        }
        for (let i = 0; i < node.params.length; i++) {
          if (this.isThisParam(node.params[i]) && i > 0) {
            this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);
          }
        }
        super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        return super.parseParenAndDistinguishExpression(canBeArrow && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
      }
      parseSubscripts(base, startLoc, noCalls) {
        if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.includes(startLoc.index)) {
          this.next();
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          node.arguments = super.parseCallExpressionArguments();
          base = this.finishNode(node, "CallExpression");
        } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
          const state = this.state.clone();
          const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
          if (!arrow.error && !arrow.aborted) return arrow.node;
          const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);
          if (result.node && !result.error) return result.node;
          if (arrow.node) {
            this.state = arrow.failState;
            return arrow.node;
          }
          if (result.node) {
            this.state = result.failState;
            return result.node;
          }
          throw arrow.error || result.error;
        }
        return super.parseSubscripts(base, startLoc, noCalls);
      }
      parseSubscript(base, startLoc, noCalls, subscriptState) {
        if (this.match(18) && this.isLookaheadToken_lt()) {
          subscriptState.optionalChainMember = true;
          if (noCalls) {
            subscriptState.stop = true;
            return base;
          }
          this.next();
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
          this.expect(10);
          node.arguments = this.parseCallExpressionArguments();
          node.optional = true;
          return this.finishCallExpression(node, true);
        } else if (!noCalls && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          const result = this.tryParse(() => {
            node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
            this.expect(10);
            node.arguments = super.parseCallExpressionArguments();
            if (subscriptState.optionalChainMember) {
              node.optional = false;
            }
            return this.finishCallExpression(node, subscriptState.optionalChainMember);
          });
          if (result.node) {
            if (result.error) this.state = result.failState;
            return result.node;
          }
        }
        return super.parseSubscript(base, startLoc, noCalls, subscriptState);
      }
      parseNewCallee(node) {
        super.parseNewCallee(node);
        let targs = null;
        if (this.shouldParseTypes() && this.match(47)) {
          targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
        }
        node.typeArguments = targs;
      }
      parseAsyncArrowWithTypeParameters(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.parseFunctionParams(node, false);
        if (!this.parseArrow(node)) return;
        return super.parseArrowExpression(node, void 0, true);
      }
      readToken_mult_modulo(code3) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code3 === 42 && next === 47 && this.state.hasFlowComment) {
          this.state.hasFlowComment = false;
          this.state.pos += 2;
          this.nextToken();
          return;
        }
        super.readToken_mult_modulo(code3);
      }
      readToken_pipe_amp(code3) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code3 === 124 && next === 125) {
          this.finishOp(9, 2);
          return;
        }
        super.readToken_pipe_amp(code3);
      }
      parseTopLevel(file, program) {
        const fileNode = super.parseTopLevel(file, program);
        if (this.state.hasFlowComment) {
          this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());
        }
        return fileNode;
      }
      skipBlockComment() {
        if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
          if (this.state.hasFlowComment) {
            throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);
          }
          this.hasFlowCommentCompletion();
          const commentSkip = this.skipFlowComment();
          if (commentSkip) {
            this.state.pos += commentSkip;
            this.state.hasFlowComment = true;
          }
          return;
        }
        return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
      }
      skipFlowComment() {
        const {
          pos
        } = this.state;
        let shiftToFirstNonWhiteSpace = 2;
        while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
          shiftToFirstNonWhiteSpace++;
        }
        const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
        const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
        if (ch2 === 58 && ch3 === 58) {
          return shiftToFirstNonWhiteSpace + 2;
        }
        if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
          return shiftToFirstNonWhiteSpace + 12;
        }
        if (ch2 === 58 && ch3 !== 58) {
          return shiftToFirstNonWhiteSpace;
        }
        return false;
      }
      hasFlowCommentCompletion() {
        const end = this.input.indexOf("*/", this.state.pos);
        if (end === -1) {
          throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
        }
      }
      flowEnumErrorBooleanMemberNotInitialized(loc, {
        enumName,
        memberName
      }) {
        this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {
          memberName,
          enumName
        });
      }
      flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
        return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);
      }
      flowEnumErrorNumberMemberNotInitialized(loc, details) {
        this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);
      }
      flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {
        this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);
      }
      flowEnumMemberInit() {
        const startLoc = this.state.startLoc;
        const endOfInit = () => this.match(12) || this.match(8);
        switch (this.state.type) {
          case 135: {
            const literal = this.parseNumericLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "number",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          case 134: {
            const literal = this.parseStringLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "string",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          case 85:
          case 86: {
            const literal = this.parseBooleanLiteral(this.match(85));
            if (endOfInit()) {
              return {
                type: "boolean",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          default:
            return {
              type: "invalid",
              loc: startLoc
            };
        }
      }
      flowEnumMemberRaw() {
        const loc = this.state.startLoc;
        const id = this.parseIdentifier(true);
        const init = this.eat(29) ? this.flowEnumMemberInit() : {
          type: "none",
          loc
        };
        return {
          id,
          init
        };
      }
      flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
        const {
          explicitType
        } = context;
        if (explicitType === null) {
          return;
        }
        if (explicitType !== expectedType) {
          this.flowEnumErrorInvalidMemberInitializer(loc, context);
        }
      }
      flowEnumMembers({
        enumName,
        explicitType
      }) {
        const seenNames = /* @__PURE__ */ new Set();
        const members = {
          booleanMembers: [],
          numberMembers: [],
          stringMembers: [],
          defaultedMembers: []
        };
        let hasUnknownMembers = false;
        while (!this.match(8)) {
          if (this.eat(21)) {
            hasUnknownMembers = true;
            break;
          }
          const memberNode = this.startNode();
          const {
            id,
            init
          } = this.flowEnumMemberRaw();
          const memberName = id.name;
          if (memberName === "") {
            continue;
          }
          if (/^[a-z]/.test(memberName)) {
            this.raise(FlowErrors.EnumInvalidMemberName, id, {
              memberName,
              suggestion: memberName[0].toUpperCase() + memberName.slice(1),
              enumName
            });
          }
          if (seenNames.has(memberName)) {
            this.raise(FlowErrors.EnumDuplicateMemberName, id, {
              memberName,
              enumName
            });
          }
          seenNames.add(memberName);
          const context = {
            enumName,
            explicitType,
            memberName
          };
          memberNode.id = id;
          switch (init.type) {
            case "boolean": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
              memberNode.init = init.value;
              members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
              break;
            }
            case "number": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
              memberNode.init = init.value;
              members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
              break;
            }
            case "string": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
              memberNode.init = init.value;
              members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
              break;
            }
            case "invalid": {
              throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
            }
            case "none": {
              switch (explicitType) {
                case "boolean":
                  this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                  break;
                case "number":
                  this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                  break;
                default:
                  members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
              }
            }
          }
          if (!this.match(8)) {
            this.expect(12);
          }
        }
        return {
          members,
          hasUnknownMembers
        };
      }
      flowEnumStringMembers(initializedMembers, defaultedMembers, {
        enumName
      }) {
        if (initializedMembers.length === 0) {
          return defaultedMembers;
        } else if (defaultedMembers.length === 0) {
          return initializedMembers;
        } else if (defaultedMembers.length > initializedMembers.length) {
          for (const member of initializedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
              enumName
            });
          }
          return defaultedMembers;
        } else {
          for (const member of defaultedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
              enumName
            });
          }
          return initializedMembers;
        }
      }
      flowEnumParseExplicitType({
        enumName
      }) {
        if (!this.eatContextual(102)) return null;
        if (!tokenIsIdentifier(this.state.type)) {
          throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
            enumName
          });
        }
        const {
          value
        } = this.state;
        this.next();
        if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
          this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {
            enumName,
            invalidEnumType: value
          });
        }
        return value;
      }
      flowEnumBody(node, id) {
        const enumName = id.name;
        const nameLoc = id.loc.start;
        const explicitType = this.flowEnumParseExplicitType({
          enumName
        });
        this.expect(5);
        const {
          members,
          hasUnknownMembers
        } = this.flowEnumMembers({
          enumName,
          explicitType
        });
        node.hasUnknownMembers = hasUnknownMembers;
        switch (explicitType) {
          case "boolean":
            node.explicitType = true;
            node.members = members.booleanMembers;
            this.expect(8);
            return this.finishNode(node, "EnumBooleanBody");
          case "number":
            node.explicitType = true;
            node.members = members.numberMembers;
            this.expect(8);
            return this.finishNode(node, "EnumNumberBody");
          case "string":
            node.explicitType = true;
            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName
            });
            this.expect(8);
            return this.finishNode(node, "EnumStringBody");
          case "symbol":
            node.members = members.defaultedMembers;
            this.expect(8);
            return this.finishNode(node, "EnumSymbolBody");
          default: {
            const empty = () => {
              node.members = [];
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");
            };
            node.explicitType = false;
            const boolsLen = members.booleanMembers.length;
            const numsLen = members.numberMembers.length;
            const strsLen = members.stringMembers.length;
            const defaultedLen = members.defaultedMembers.length;
            if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
              return empty();
            } else if (!boolsLen && !numsLen) {
              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName
              });
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");
            } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node.members = members.booleanMembers;
              this.expect(8);
              return this.finishNode(node, "EnumBooleanBody");
            } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node.members = members.numberMembers;
              this.expect(8);
              return this.finishNode(node, "EnumNumberBody");
            } else {
              this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {
                enumName
              });
              return empty();
            }
          }
        }
      }
      flowParseEnumDeclaration(node) {
        const id = this.parseIdentifier();
        node.id = id;
        node.body = this.flowEnumBody(this.startNode(), id);
        return this.finishNode(node, "EnumDeclaration");
      }
      jsxParseOpeningElementAfterName(node) {
        if (this.shouldParseTypes()) {
          if (this.match(47) || this.match(51)) {
            node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
          }
        }
        return super.jsxParseOpeningElementAfterName(node);
      }
      isLookaheadToken_lt() {
        const next = this.nextTokenStart();
        if (this.input.charCodeAt(next) === 60) {
          const afterNext = this.input.charCodeAt(next + 1);
          return afterNext !== 60 && afterNext !== 61;
        }
        return false;
      }
      reScan_lt_gt() {
        const {
          type
        } = this.state;
        if (type === 47) {
          this.state.pos -= 1;
          this.readToken_lt();
        } else if (type === 48) {
          this.state.pos -= 1;
          this.readToken_gt();
        }
      }
      reScan_lt() {
        const {
          type
        } = this.state;
        if (type === 51) {
          this.state.pos -= 2;
          this.finishOp(47, 1);
          return 47;
        }
        return type;
      }
      maybeUnwrapTypeCastExpression(node) {
        return node.type === "TypeCastExpression" ? node.expression : node;
      }
    };
    var entities = {
      __proto__: null,
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: "",
      iexcl: "",
      cent: "",
      pound: "",
      curren: "",
      yen: "",
      brvbar: "",
      sect: "",
      uml: "",
      copy: "",
      ordf: "",
      laquo: "",
      not: "",
      shy: "",
      reg: "",
      macr: "",
      deg: "",
      plusmn: "",
      sup2: "",
      sup3: "",
      acute: "",
      micro: "",
      para: "",
      middot: "",
      cedil: "",
      sup1: "",
      ordm: "",
      raquo: "",
      frac14: "",
      frac12: "",
      frac34: "",
      iquest: "",
      Agrave: "",
      Aacute: "",
      Acirc: "",
      Atilde: "",
      Auml: "",
      Aring: "",
      AElig: "",
      Ccedil: "",
      Egrave: "",
      Eacute: "",
      Ecirc: "",
      Euml: "",
      Igrave: "",
      Iacute: "",
      Icirc: "",
      Iuml: "",
      ETH: "",
      Ntilde: "",
      Ograve: "",
      Oacute: "",
      Ocirc: "",
      Otilde: "",
      Ouml: "",
      times: "",
      Oslash: "",
      Ugrave: "",
      Uacute: "",
      Ucirc: "",
      Uuml: "",
      Yacute: "",
      THORN: "",
      szlig: "",
      agrave: "",
      aacute: "",
      acirc: "",
      atilde: "",
      auml: "",
      aring: "",
      aelig: "",
      ccedil: "",
      egrave: "",
      eacute: "",
      ecirc: "",
      euml: "",
      igrave: "",
      iacute: "",
      icirc: "",
      iuml: "",
      eth: "",
      ntilde: "",
      ograve: "",
      oacute: "",
      ocirc: "",
      otilde: "",
      ouml: "",
      divide: "",
      oslash: "",
      ugrave: "",
      uacute: "",
      ucirc: "",
      uuml: "",
      yacute: "",
      thorn: "",
      yuml: "",
      OElig: "",
      oelig: "",
      Scaron: "",
      scaron: "",
      Yuml: "",
      fnof: "",
      circ: "",
      tilde: "",
      Alpha: "",
      Beta: "",
      Gamma: "",
      Delta: "",
      Epsilon: "",
      Zeta: "",
      Eta: "",
      Theta: "",
      Iota: "",
      Kappa: "",
      Lambda: "",
      Mu: "",
      Nu: "",
      Xi: "",
      Omicron: "",
      Pi: "",
      Rho: "",
      Sigma: "",
      Tau: "",
      Upsilon: "",
      Phi: "",
      Chi: "",
      Psi: "",
      Omega: "",
      alpha: "",
      beta: "",
      gamma: "",
      delta: "",
      epsilon: "",
      zeta: "",
      eta: "",
      theta: "",
      iota: "",
      kappa: "",
      lambda: "",
      mu: "",
      nu: "",
      xi: "",
      omicron: "",
      pi: "",
      rho: "",
      sigmaf: "",
      sigma: "",
      tau: "",
      upsilon: "",
      phi: "",
      chi: "",
      psi: "",
      omega: "",
      thetasym: "",
      upsih: "",
      piv: "",
      ensp: "",
      emsp: "",
      thinsp: "",
      zwnj: "",
      zwj: "",
      lrm: "",
      rlm: "",
      ndash: "",
      mdash: "",
      lsquo: "",
      rsquo: "",
      sbquo: "",
      ldquo: "",
      rdquo: "",
      bdquo: "",
      dagger: "",
      Dagger: "",
      bull: "",
      hellip: "",
      permil: "",
      prime: "",
      Prime: "",
      lsaquo: "",
      rsaquo: "",
      oline: "",
      frasl: "",
      euro: "",
      image: "",
      weierp: "",
      real: "",
      trade: "",
      alefsym: "",
      larr: "",
      uarr: "",
      rarr: "",
      darr: "",
      harr: "",
      crarr: "",
      lArr: "",
      uArr: "",
      rArr: "",
      dArr: "",
      hArr: "",
      forall: "",
      part: "",
      exist: "",
      empty: "",
      nabla: "",
      isin: "",
      notin: "",
      ni: "",
      prod: "",
      sum: "",
      minus: "",
      lowast: "",
      radic: "",
      prop: "",
      infin: "",
      ang: "",
      and: "",
      or: "",
      cap: "",
      cup: "",
      int: "",
      there4: "",
      sim: "",
      cong: "",
      asymp: "",
      ne: "",
      equiv: "",
      le: "",
      ge: "",
      sub: "",
      sup: "",
      nsub: "",
      sube: "",
      supe: "",
      oplus: "",
      otimes: "",
      perp: "",
      sdot: "",
      lceil: "",
      rceil: "",
      lfloor: "",
      rfloor: "",
      lang: "",
      rang: "",
      loz: "",
      spades: "",
      clubs: "",
      hearts: "",
      diams: ""
    };
    var lineBreak = /\r\n|[\r\n\u2028\u2029]/;
    var lineBreakG = new RegExp(lineBreak.source, "g");
    function isNewLine(code3) {
      switch (code3) {
        case 10:
        case 13:
        case 8232:
        case 8233:
          return true;
        default:
          return false;
      }
    }
    function hasNewLine(input, start, end) {
      for (let i = start; i < end; i++) {
        if (isNewLine(input.charCodeAt(i))) {
          return true;
        }
      }
      return false;
    }
    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
    function isWhitespace(code3) {
      switch (code3) {
        case 9:
        case 11:
        case 12:
        case 32:
        case 160:
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return true;
        default:
          return false;
      }
    }
    var JsxErrors = ParseErrorEnum`jsx`({
      AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
      MissingClosingTagElement: ({
        openingTagName
      }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
      MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
      UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
      UnexpectedToken: ({
        unexpected,
        HTMLEntity
      }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
      UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
      UnterminatedJsxContent: "Unterminated JSX contents.",
      UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
    });
    function isFragment(object) {
      return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
    }
    function getQualifiedJSXName(object) {
      if (object.type === "JSXIdentifier") {
        return object.name;
      }
      if (object.type === "JSXNamespacedName") {
        return object.namespace.name + ":" + object.name.name;
      }
      if (object.type === "JSXMemberExpression") {
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
      }
      throw new Error("Node had unexpected type: " + object.type);
    }
    var jsx = (superClass) => class JSXParserMixin extends superClass {
      jsxReadToken() {
        let out = "";
        let chunkStart = this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);
          }
          const ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 60:
            case 123:
              if (this.state.pos === this.state.start) {
                if (ch === 60 && this.state.canStartJSXElement) {
                  ++this.state.pos;
                  this.finishToken(143);
                } else {
                  super.getTokenFromCode(ch);
                }
                return;
              }
              out += this.input.slice(chunkStart, this.state.pos);
              this.finishToken(142, out);
              return;
            case 38:
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
              break;
            case 62:
            case 125:
            default:
              if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadNewLine(true);
                chunkStart = this.state.pos;
              } else {
                ++this.state.pos;
              }
          }
        }
      }
      jsxReadNewLine(normalizeCRLF) {
        const ch = this.input.charCodeAt(this.state.pos);
        let out;
        ++this.state.pos;
        if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos;
          out = normalizeCRLF ? "\n" : "\r\n";
        } else {
          out = String.fromCharCode(ch);
        }
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        return out;
      }
      jsxReadString(quote) {
        let out = "";
        let chunkStart = ++this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(Errors.UnterminatedString, this.state.startLoc);
          }
          const ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote) break;
          if (ch === 38) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadNewLine(false);
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
        }
        out += this.input.slice(chunkStart, this.state.pos++);
        this.finishToken(134, out);
      }
      jsxReadEntity() {
        const startPos = ++this.state.pos;
        if (this.codePointAtPos(this.state.pos) === 35) {
          ++this.state.pos;
          let radix = 10;
          if (this.codePointAtPos(this.state.pos) === 120) {
            radix = 16;
            ++this.state.pos;
          }
          const codePoint = this.readInt(radix, void 0, false, "bail");
          if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
            ++this.state.pos;
            return String.fromCodePoint(codePoint);
          }
        } else {
          let count = 0;
          let semi = false;
          while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59)) {
            ++this.state.pos;
          }
          if (semi) {
            const desc = this.input.slice(startPos, this.state.pos);
            const entity = entities[desc];
            ++this.state.pos;
            if (entity) {
              return entity;
            }
          }
        }
        this.state.pos = startPos;
        return "&";
      }
      jsxReadWord() {
        let ch;
        const start = this.state.pos;
        do {
          ch = this.input.charCodeAt(++this.state.pos);
        } while (isIdentifierChar(ch) || ch === 45);
        this.finishToken(141, this.input.slice(start, this.state.pos));
      }
      jsxParseIdentifier() {
        const node = this.startNode();
        if (this.match(141)) {
          node.name = this.state.value;
        } else if (tokenIsKeyword(this.state.type)) {
          node.name = tokenLabelName(this.state.type);
        } else {
          this.unexpected();
        }
        this.next();
        return this.finishNode(node, "JSXIdentifier");
      }
      jsxParseNamespacedName() {
        const startLoc = this.state.startLoc;
        const name50 = this.jsxParseIdentifier();
        if (!this.eat(14)) return name50;
        const node = this.startNodeAt(startLoc);
        node.namespace = name50;
        node.name = this.jsxParseIdentifier();
        return this.finishNode(node, "JSXNamespacedName");
      }
      jsxParseElementName() {
        const startLoc = this.state.startLoc;
        let node = this.jsxParseNamespacedName();
        if (node.type === "JSXNamespacedName") {
          return node;
        }
        while (this.eat(16)) {
          const newNode = this.startNodeAt(startLoc);
          newNode.object = node;
          newNode.property = this.jsxParseIdentifier();
          node = this.finishNode(newNode, "JSXMemberExpression");
        }
        return node;
      }
      jsxParseAttributeValue() {
        let node;
        switch (this.state.type) {
          case 5:
            node = this.startNode();
            this.setContext(types.brace);
            this.next();
            node = this.jsxParseExpressionContainer(node, types.j_oTag);
            if (node.expression.type === "JSXEmptyExpression") {
              this.raise(JsxErrors.AttributeIsEmpty, node);
            }
            return node;
          case 143:
          case 134:
            return this.parseExprAtom();
          default:
            throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);
        }
      }
      jsxParseEmptyExpression() {
        const node = this.startNodeAt(this.state.lastTokEndLoc);
        return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
      }
      jsxParseSpreadChild(node) {
        this.next();
        node.expression = this.parseExpression();
        this.setContext(types.j_expr);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node, "JSXSpreadChild");
      }
      jsxParseExpressionContainer(node, previousContext) {
        if (this.match(8)) {
          node.expression = this.jsxParseEmptyExpression();
        } else {
          const expression = this.parseExpression();
          node.expression = expression;
        }
        this.setContext(previousContext);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node, "JSXExpressionContainer");
      }
      jsxParseAttribute() {
        const node = this.startNode();
        if (this.match(5)) {
          this.setContext(types.brace);
          this.next();
          this.expect(21);
          node.argument = this.parseMaybeAssignAllowIn();
          this.setContext(types.j_oTag);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node, "JSXSpreadAttribute");
        }
        node.name = this.jsxParseNamespacedName();
        node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
        return this.finishNode(node, "JSXAttribute");
      }
      jsxParseOpeningElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        if (this.eat(144)) {
          return this.finishNode(node, "JSXOpeningFragment");
        }
        node.name = this.jsxParseElementName();
        return this.jsxParseOpeningElementAfterName(node);
      }
      jsxParseOpeningElementAfterName(node) {
        const attributes = [];
        while (!this.match(56) && !this.match(144)) {
          attributes.push(this.jsxParseAttribute());
        }
        node.attributes = attributes;
        node.selfClosing = this.eat(56);
        this.expect(144);
        return this.finishNode(node, "JSXOpeningElement");
      }
      jsxParseClosingElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        if (this.eat(144)) {
          return this.finishNode(node, "JSXClosingFragment");
        }
        node.name = this.jsxParseElementName();
        this.expect(144);
        return this.finishNode(node, "JSXClosingElement");
      }
      jsxParseElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        const children = [];
        const openingElement = this.jsxParseOpeningElementAt(startLoc);
        let closingElement = null;
        if (!openingElement.selfClosing) {
          contents: for (; ; ) {
            switch (this.state.type) {
              case 143:
                startLoc = this.state.startLoc;
                this.next();
                if (this.eat(56)) {
                  closingElement = this.jsxParseClosingElementAt(startLoc);
                  break contents;
                }
                children.push(this.jsxParseElementAt(startLoc));
                break;
              case 142:
                children.push(this.parseLiteral(this.state.value, "JSXText"));
                break;
              case 5: {
                const node2 = this.startNode();
                this.setContext(types.brace);
                this.next();
                if (this.match(21)) {
                  children.push(this.jsxParseSpreadChild(node2));
                } else {
                  children.push(this.jsxParseExpressionContainer(node2, types.j_expr));
                }
                break;
              }
              default:
                this.unexpected();
            }
          }
          if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
            this.raise(JsxErrors.MissingClosingTagFragment, closingElement);
          } else if (!isFragment(openingElement) && isFragment(closingElement)) {
            this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
              openingTagName: getQualifiedJSXName(openingElement.name)
            });
          } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
                openingTagName: getQualifiedJSXName(openingElement.name)
              });
            }
          }
        }
        if (isFragment(openingElement)) {
          node.openingFragment = openingElement;
          node.closingFragment = closingElement;
        } else {
          node.openingElement = openingElement;
          node.closingElement = closingElement;
        }
        node.children = children;
        if (this.match(47)) {
          throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);
        }
        return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
      }
      jsxParseElement() {
        const startLoc = this.state.startLoc;
        this.next();
        return this.jsxParseElementAt(startLoc);
      }
      setContext(newContext) {
        const {
          context
        } = this.state;
        context[context.length - 1] = newContext;
      }
      parseExprAtom(refExpressionErrors) {
        if (this.match(143)) {
          return this.jsxParseElement();
        } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
          this.replaceToken(143);
          return this.jsxParseElement();
        } else {
          return super.parseExprAtom(refExpressionErrors);
        }
      }
      skipSpace() {
        const curContext = this.curContext();
        if (!curContext.preserveSpace) super.skipSpace();
      }
      getTokenFromCode(code3) {
        const context = this.curContext();
        if (context === types.j_expr) {
          this.jsxReadToken();
          return;
        }
        if (context === types.j_oTag || context === types.j_cTag) {
          if (isIdentifierStart2(code3)) {
            this.jsxReadWord();
            return;
          }
          if (code3 === 62) {
            ++this.state.pos;
            this.finishToken(144);
            return;
          }
          if ((code3 === 34 || code3 === 39) && context === types.j_oTag) {
            this.jsxReadString(code3);
            return;
          }
        }
        if (code3 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
          ++this.state.pos;
          this.finishToken(143);
          return;
        }
        super.getTokenFromCode(code3);
      }
      updateContext(prevType) {
        const {
          context,
          type
        } = this.state;
        if (type === 56 && prevType === 143) {
          context.splice(-2, 2, types.j_cTag);
          this.state.canStartJSXElement = false;
        } else if (type === 143) {
          context.push(types.j_oTag);
        } else if (type === 144) {
          const out = context[context.length - 1];
          if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
            context.pop();
            this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
          } else {
            this.setContext(types.j_expr);
            this.state.canStartJSXElement = true;
          }
        } else {
          this.state.canStartJSXElement = tokenComesBeforeExpression(type);
        }
      }
    };
    var TypeScriptScope = class extends Scope {
      constructor(...args) {
        super(...args);
        this.tsNames = /* @__PURE__ */ new Map();
      }
    };
    var TypeScriptScopeHandler = class extends ScopeHandler {
      constructor(...args) {
        super(...args);
        this.importsStack = [];
      }
      createScope(flags) {
        this.importsStack.push(/* @__PURE__ */ new Set());
        return new TypeScriptScope(flags);
      }
      enter(flags) {
        if (flags === 1024) {
          this.importsStack.push(/* @__PURE__ */ new Set());
        }
        super.enter(flags);
      }
      exit() {
        const flags = super.exit();
        if (flags === 1024) {
          this.importsStack.pop();
        }
        return flags;
      }
      hasImport(name50, allowShadow) {
        const len = this.importsStack.length;
        if (this.importsStack[len - 1].has(name50)) {
          return true;
        }
        if (!allowShadow && len > 1) {
          for (let i = 0; i < len - 1; i++) {
            if (this.importsStack[i].has(name50)) return true;
          }
        }
        return false;
      }
      declareName(name50, bindingType, loc) {
        if (bindingType & 4096) {
          if (this.hasImport(name50, true)) {
            this.parser.raise(Errors.VarRedeclaration, loc, {
              identifierName: name50
            });
          }
          this.importsStack[this.importsStack.length - 1].add(name50);
          return;
        }
        const scope = this.currentScope();
        let type = scope.tsNames.get(name50) || 0;
        if (bindingType & 1024) {
          this.maybeExportDefined(scope, name50);
          scope.tsNames.set(name50, type | 16);
          return;
        }
        super.declareName(name50, bindingType, loc);
        if (bindingType & 2) {
          if (!(bindingType & 1)) {
            this.checkRedeclarationInScope(scope, name50, bindingType, loc);
            this.maybeExportDefined(scope, name50);
          }
          type = type | 1;
        }
        if (bindingType & 256) {
          type = type | 2;
        }
        if (bindingType & 512) {
          type = type | 4;
        }
        if (bindingType & 128) {
          type = type | 8;
        }
        if (type) scope.tsNames.set(name50, type);
      }
      isRedeclaredInScope(scope, name50, bindingType) {
        const type = scope.tsNames.get(name50);
        if ((type & 2) > 0) {
          if (bindingType & 256) {
            const isConst = !!(bindingType & 512);
            const wasConst = (type & 4) > 0;
            return isConst !== wasConst;
          }
          return true;
        }
        if (bindingType & 128 && (type & 8) > 0) {
          if (scope.names.get(name50) & 2) {
            return !!(bindingType & 1);
          } else {
            return false;
          }
        }
        if (bindingType & 2 && (type & 1) > 0) {
          return true;
        }
        return super.isRedeclaredInScope(scope, name50, bindingType);
      }
      checkLocalExport(id) {
        const {
          name: name50
        } = id;
        if (this.hasImport(name50)) return;
        const len = this.scopeStack.length;
        for (let i = len - 1; i >= 0; i--) {
          const scope = this.scopeStack[i];
          const type = scope.tsNames.get(name50);
          if ((type & 1) > 0 || (type & 16) > 0) {
            return;
          }
        }
        super.checkLocalExport(id);
      }
    };
    var ProductionParameterHandler = class {
      constructor() {
        this.stacks = [];
      }
      enter(flags) {
        this.stacks.push(flags);
      }
      exit() {
        this.stacks.pop();
      }
      currentFlags() {
        return this.stacks[this.stacks.length - 1];
      }
      get hasAwait() {
        return (this.currentFlags() & 2) > 0;
      }
      get hasYield() {
        return (this.currentFlags() & 1) > 0;
      }
      get hasReturn() {
        return (this.currentFlags() & 4) > 0;
      }
      get hasIn() {
        return (this.currentFlags() & 8) > 0;
      }
    };
    function functionFlags(isAsync, isGenerator) {
      return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
    }
    var BaseParser = class {
      constructor() {
        this.sawUnambiguousESM = false;
        this.ambiguousScriptDifferentAst = false;
      }
      sourceToOffsetPos(sourcePos) {
        return sourcePos + this.startIndex;
      }
      offsetToSourcePos(offsetPos) {
        return offsetPos - this.startIndex;
      }
      hasPlugin(pluginConfig) {
        if (typeof pluginConfig === "string") {
          return this.plugins.has(pluginConfig);
        } else {
          const [pluginName, pluginOptions] = pluginConfig;
          if (!this.hasPlugin(pluginName)) {
            return false;
          }
          const actualOptions = this.plugins.get(pluginName);
          for (const key of Object.keys(pluginOptions)) {
            if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
              return false;
            }
          }
          return true;
        }
      }
      getPluginOption(plugin, name50) {
        var _this$plugins$get;
        return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name50];
      }
    };
    function setTrailingComments(node, comments) {
      if (node.trailingComments === void 0) {
        node.trailingComments = comments;
      } else {
        node.trailingComments.unshift(...comments);
      }
    }
    function setLeadingComments(node, comments) {
      if (node.leadingComments === void 0) {
        node.leadingComments = comments;
      } else {
        node.leadingComments.unshift(...comments);
      }
    }
    function setInnerComments(node, comments) {
      if (node.innerComments === void 0) {
        node.innerComments = comments;
      } else {
        node.innerComments.unshift(...comments);
      }
    }
    function adjustInnerComments(node, elements, commentWS) {
      let lastElement = null;
      let i = elements.length;
      while (lastElement === null && i > 0) {
        lastElement = elements[--i];
      }
      if (lastElement === null || lastElement.start > commentWS.start) {
        setInnerComments(node, commentWS.comments);
      } else {
        setTrailingComments(lastElement, commentWS.comments);
      }
    }
    var CommentsParser = class extends BaseParser {
      addComment(comment) {
        if (this.filename) comment.loc.filename = this.filename;
        const {
          commentsLen
        } = this.state;
        if (this.comments.length !== commentsLen) {
          this.comments.length = commentsLen;
        }
        this.comments.push(comment);
        this.state.commentsLen++;
      }
      processComment(node) {
        const {
          commentStack
        } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0) return;
        let i = commentStackLength - 1;
        const lastCommentWS = commentStack[i];
        if (lastCommentWS.start === node.end) {
          lastCommentWS.leadingNode = node;
          i--;
        }
        const {
          start: nodeStart
        } = node;
        for (; i >= 0; i--) {
          const commentWS = commentStack[i];
          const commentEnd = commentWS.end;
          if (commentEnd > nodeStart) {
            commentWS.containingNode = node;
            this.finalizeComment(commentWS);
            commentStack.splice(i, 1);
          } else {
            if (commentEnd === nodeStart) {
              commentWS.trailingNode = node;
            }
            break;
          }
        }
      }
      finalizeComment(commentWS) {
        var _node$options;
        const {
          comments
        } = commentWS;
        if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
          if (commentWS.leadingNode !== null) {
            setTrailingComments(commentWS.leadingNode, comments);
          }
          if (commentWS.trailingNode !== null) {
            setLeadingComments(commentWS.trailingNode, comments);
          }
        } else {
          const node = commentWS.containingNode;
          const commentStart = commentWS.start;
          if (this.input.charCodeAt(this.offsetToSourcePos(commentStart) - 1) === 44) {
            switch (node.type) {
              case "ObjectExpression":
              case "ObjectPattern":
                adjustInnerComments(node, node.properties, commentWS);
                break;
              case "CallExpression":
              case "OptionalCallExpression":
                adjustInnerComments(node, node.arguments, commentWS);
                break;
              case "ImportExpression":
                adjustInnerComments(node, [node.source, (_node$options = node.options) != null ? _node$options : null], commentWS);
                break;
              case "FunctionDeclaration":
              case "FunctionExpression":
              case "ArrowFunctionExpression":
              case "ObjectMethod":
              case "ClassMethod":
              case "ClassPrivateMethod":
                adjustInnerComments(node, node.params, commentWS);
                break;
              case "ArrayExpression":
              case "ArrayPattern":
                adjustInnerComments(node, node.elements, commentWS);
                break;
              case "ExportNamedDeclaration":
              case "ImportDeclaration":
                adjustInnerComments(node, node.specifiers, commentWS);
                break;
              case "TSEnumDeclaration":
                adjustInnerComments(node, node.members, commentWS);
                break;
              case "TSEnumBody":
                adjustInnerComments(node, node.members, commentWS);
                break;
              default: {
                if (node.type === "RecordExpression") {
                  adjustInnerComments(node, node.properties, commentWS);
                  break;
                }
                if (node.type === "TupleExpression") {
                  adjustInnerComments(node, node.elements, commentWS);
                  break;
                }
                setInnerComments(node, comments);
              }
            }
          } else {
            setInnerComments(node, comments);
          }
        }
      }
      finalizeRemainingComments() {
        const {
          commentStack
        } = this.state;
        for (let i = commentStack.length - 1; i >= 0; i--) {
          this.finalizeComment(commentStack[i]);
        }
        this.state.commentStack = [];
      }
      resetPreviousNodeTrailingComments(node) {
        const {
          commentStack
        } = this.state;
        const {
          length: length2
        } = commentStack;
        if (length2 === 0) return;
        const commentWS = commentStack[length2 - 1];
        if (commentWS.leadingNode === node) {
          commentWS.leadingNode = null;
        }
      }
      takeSurroundingComments(node, start, end) {
        const {
          commentStack
        } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0) return;
        let i = commentStackLength - 1;
        for (; i >= 0; i--) {
          const commentWS = commentStack[i];
          const commentEnd = commentWS.end;
          const commentStart = commentWS.start;
          if (commentStart === end) {
            commentWS.leadingNode = node;
          } else if (commentEnd === start) {
            commentWS.trailingNode = node;
          } else if (commentEnd < start) {
            break;
          }
        }
      }
    };
    var State = class _State {
      constructor() {
        this.flags = 1024;
        this.startIndex = void 0;
        this.curLine = void 0;
        this.lineStart = void 0;
        this.startLoc = void 0;
        this.endLoc = void 0;
        this.errors = [];
        this.potentialArrowAt = -1;
        this.noArrowAt = [];
        this.noArrowParamsConversionAt = [];
        this.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        this.labels = [];
        this.commentsLen = 0;
        this.commentStack = [];
        this.pos = 0;
        this.type = 140;
        this.value = null;
        this.start = 0;
        this.end = 0;
        this.lastTokEndLoc = null;
        this.lastTokStartLoc = null;
        this.context = [types.brace];
        this.firstInvalidTemplateEscapePos = null;
        this.strictErrors = /* @__PURE__ */ new Map();
        this.tokensLength = 0;
      }
      get strict() {
        return (this.flags & 1) > 0;
      }
      set strict(v) {
        if (v) this.flags |= 1;
        else this.flags &= -2;
      }
      init({
        strictMode,
        sourceType,
        startIndex,
        startLine,
        startColumn
      }) {
        this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
        this.startIndex = startIndex;
        this.curLine = startLine;
        this.lineStart = -startColumn;
        this.startLoc = this.endLoc = new Position(startLine, startColumn, startIndex);
      }
      get maybeInArrowParameters() {
        return (this.flags & 2) > 0;
      }
      set maybeInArrowParameters(v) {
        if (v) this.flags |= 2;
        else this.flags &= -3;
      }
      get inType() {
        return (this.flags & 4) > 0;
      }
      set inType(v) {
        if (v) this.flags |= 4;
        else this.flags &= -5;
      }
      get noAnonFunctionType() {
        return (this.flags & 8) > 0;
      }
      set noAnonFunctionType(v) {
        if (v) this.flags |= 8;
        else this.flags &= -9;
      }
      get hasFlowComment() {
        return (this.flags & 16) > 0;
      }
      set hasFlowComment(v) {
        if (v) this.flags |= 16;
        else this.flags &= -17;
      }
      get isAmbientContext() {
        return (this.flags & 32) > 0;
      }
      set isAmbientContext(v) {
        if (v) this.flags |= 32;
        else this.flags &= -33;
      }
      get inAbstractClass() {
        return (this.flags & 64) > 0;
      }
      set inAbstractClass(v) {
        if (v) this.flags |= 64;
        else this.flags &= -65;
      }
      get inDisallowConditionalTypesContext() {
        return (this.flags & 128) > 0;
      }
      set inDisallowConditionalTypesContext(v) {
        if (v) this.flags |= 128;
        else this.flags &= -129;
      }
      get soloAwait() {
        return (this.flags & 256) > 0;
      }
      set soloAwait(v) {
        if (v) this.flags |= 256;
        else this.flags &= -257;
      }
      get inFSharpPipelineDirectBody() {
        return (this.flags & 512) > 0;
      }
      set inFSharpPipelineDirectBody(v) {
        if (v) this.flags |= 512;
        else this.flags &= -513;
      }
      get canStartJSXElement() {
        return (this.flags & 1024) > 0;
      }
      set canStartJSXElement(v) {
        if (v) this.flags |= 1024;
        else this.flags &= -1025;
      }
      get containsEsc() {
        return (this.flags & 2048) > 0;
      }
      set containsEsc(v) {
        if (v) this.flags |= 2048;
        else this.flags &= -2049;
      }
      get hasTopLevelAwait() {
        return (this.flags & 4096) > 0;
      }
      set hasTopLevelAwait(v) {
        if (v) this.flags |= 4096;
        else this.flags &= -4097;
      }
      curPosition() {
        return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
      }
      clone() {
        const state = new _State();
        state.flags = this.flags;
        state.startIndex = this.startIndex;
        state.curLine = this.curLine;
        state.lineStart = this.lineStart;
        state.startLoc = this.startLoc;
        state.endLoc = this.endLoc;
        state.errors = this.errors.slice();
        state.potentialArrowAt = this.potentialArrowAt;
        state.noArrowAt = this.noArrowAt.slice();
        state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();
        state.topicContext = this.topicContext;
        state.labels = this.labels.slice();
        state.commentsLen = this.commentsLen;
        state.commentStack = this.commentStack.slice();
        state.pos = this.pos;
        state.type = this.type;
        state.value = this.value;
        state.start = this.start;
        state.end = this.end;
        state.lastTokEndLoc = this.lastTokEndLoc;
        state.lastTokStartLoc = this.lastTokStartLoc;
        state.context = this.context.slice();
        state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;
        state.strictErrors = this.strictErrors;
        state.tokensLength = this.tokensLength;
        return state;
      }
    };
    var _isDigit = function isDigit2(code3) {
      return code3 >= 48 && code3 <= 57;
    };
    var forbiddenNumericSeparatorSiblings = {
      decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
      hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
    };
    var isAllowedNumericSeparatorSibling = {
      bin: (ch) => ch === 48 || ch === 49,
      oct: (ch) => ch >= 48 && ch <= 55,
      dec: (ch) => ch >= 48 && ch <= 57,
      hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
    };
    function readStringContents(type, input, pos, lineStart, curLine, errors) {
      const initialPos = pos;
      const initialLineStart = lineStart;
      const initialCurLine = curLine;
      let out = "";
      let firstInvalidLoc = null;
      let chunkStart = pos;
      const {
        length: length2
      } = input;
      for (; ; ) {
        if (pos >= length2) {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
          out += input.slice(chunkStart, pos);
          break;
        }
        const ch = input.charCodeAt(pos);
        if (isStringEnd(type, ch, input, pos)) {
          out += input.slice(chunkStart, pos);
          break;
        }
        if (ch === 92) {
          out += input.slice(chunkStart, pos);
          const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
          if (res.ch === null && !firstInvalidLoc) {
            firstInvalidLoc = {
              pos,
              lineStart,
              curLine
            };
          } else {
            out += res.ch;
          }
          ({
            pos,
            lineStart,
            curLine
          } = res);
          chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
          ++pos;
          ++curLine;
          lineStart = pos;
        } else if (ch === 10 || ch === 13) {
          if (type === "template") {
            out += input.slice(chunkStart, pos) + "\n";
            ++pos;
            if (ch === 13 && input.charCodeAt(pos) === 10) {
              ++pos;
            }
            ++curLine;
            chunkStart = lineStart = pos;
          } else {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
          }
        } else {
          ++pos;
        }
      }
      return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
        containsInvalid: !!firstInvalidLoc
      };
    }
    function isStringEnd(type, ch, input, pos) {
      if (type === "template") {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
      }
      return ch === (type === "double" ? 34 : 39);
    }
    function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
      const throwOnInvalid = !inTemplate;
      pos++;
      const res = (ch2) => ({
        pos,
        ch: ch2,
        lineStart,
        curLine
      });
      const ch = input.charCodeAt(pos++);
      switch (ch) {
        case 110:
          return res("\n");
        case 114:
          return res("\r");
        case 120: {
          let code3;
          ({
            code: code3,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
          return res(code3 === null ? null : String.fromCharCode(code3));
        }
        case 117: {
          let code3;
          ({
            code: code3,
            pos
          } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
          return res(code3 === null ? null : String.fromCodePoint(code3));
        }
        case 116:
          return res("	");
        case 98:
          return res("\b");
        case 118:
          return res("\v");
        case 102:
          return res("\f");
        case 13:
          if (input.charCodeAt(pos) === 10) {
            ++pos;
          }
        case 10:
          lineStart = pos;
          ++curLine;
        case 8232:
        case 8233:
          return res("");
        case 56:
        case 57:
          if (inTemplate) {
            return res(null);
          } else {
            errors.strictNumericEscape(pos - 1, lineStart, curLine);
          }
        default:
          if (ch >= 48 && ch <= 55) {
            const startPos = pos - 1;
            const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
            let octalStr = match[0];
            let octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            pos += octalStr.length - 1;
            const next = input.charCodeAt(pos);
            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return res(null);
              } else {
                errors.strictNumericEscape(startPos, lineStart, curLine);
              }
            }
            return res(String.fromCharCode(octal));
          }
          return res(String.fromCharCode(ch));
      }
    }
    function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
      const initialPos = pos;
      let n2;
      ({
        n: n2,
        pos
      } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
      if (n2 === null) {
        if (throwOnInvalid) {
          errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        } else {
          pos = initialPos - 1;
        }
      }
      return {
        code: n2,
        pos
      };
    }
    function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
      const start = pos;
      const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
      let invalid = false;
      let total = 0;
      for (let i = 0, e2 = len == null ? Infinity : len; i < e2; ++i) {
        const code3 = input.charCodeAt(pos);
        let val;
        if (code3 === 95 && allowNumSeparator !== "bail") {
          const prev = input.charCodeAt(pos - 1);
          const next = input.charCodeAt(pos + 1);
          if (!allowNumSeparator) {
            if (bailOnError) return {
              n: null,
              pos
            };
            errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
          } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
            if (bailOnError) return {
              n: null,
              pos
            };
            errors.unexpectedNumericSeparator(pos, lineStart, curLine);
          }
          ++pos;
          continue;
        }
        if (code3 >= 97) {
          val = code3 - 97 + 10;
        } else if (code3 >= 65) {
          val = code3 - 65 + 10;
        } else if (_isDigit(code3)) {
          val = code3 - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          if (val <= 9 && bailOnError) {
            return {
              n: null,
              pos
            };
          } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
            val = 0;
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }
        ++pos;
        total = total * radix + val;
      }
      if (pos === start || len != null && pos - start !== len || invalid) {
        return {
          n: null,
          pos
        };
      }
      return {
        n: total,
        pos
      };
    }
    function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
      const ch = input.charCodeAt(pos);
      let code3;
      if (ch === 123) {
        ++pos;
        ({
          code: code3,
          pos
        } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        if (code3 !== null && code3 > 1114111) {
          if (throwOnInvalid) {
            errors.invalidCodePoint(pos, lineStart, curLine);
          } else {
            return {
              code: null,
              pos
            };
          }
        }
      } else {
        ({
          code: code3,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
      }
      return {
        code: code3,
        pos
      };
    }
    function buildPosition(pos, lineStart, curLine) {
      return new Position(curLine, pos - lineStart, pos);
    }
    var VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
    var Token = class {
      constructor(state) {
        const startIndex = state.startIndex || 0;
        this.type = state.type;
        this.value = state.value;
        this.start = startIndex + state.start;
        this.end = startIndex + state.end;
        this.loc = new SourceLocation(state.startLoc, state.endLoc);
      }
    };
    var Tokenizer = class extends CommentsParser {
      constructor(options, input) {
        super();
        this.isLookahead = void 0;
        this.tokens = [];
        this.errorHandlers_readInt = {
          invalidDigit: (pos, lineStart, curLine, radix) => {
            if (!(this.optionFlags & 2048)) return false;
            this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {
              radix
            });
            return true;
          },
          numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
          unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
        };
        this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
          invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
          invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
        });
        this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: (pos, lineStart, curLine) => {
            this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));
          },
          unterminated: (pos, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));
          }
        });
        this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
          unterminated: (pos, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));
          }
        });
        this.state = new State();
        this.state.init(options);
        this.input = input;
        this.length = input.length;
        this.comments = [];
        this.isLookahead = false;
      }
      pushToken(token) {
        this.tokens.length = this.state.tokensLength;
        this.tokens.push(token);
        ++this.state.tokensLength;
      }
      next() {
        this.checkKeywordEscapes();
        if (this.optionFlags & 256) {
          this.pushToken(new Token(this.state));
        }
        this.state.lastTokEndLoc = this.state.endLoc;
        this.state.lastTokStartLoc = this.state.startLoc;
        this.nextToken();
      }
      eat(type) {
        if (this.match(type)) {
          this.next();
          return true;
        } else {
          return false;
        }
      }
      match(type) {
        return this.state.type === type;
      }
      createLookaheadState(state) {
        return {
          pos: state.pos,
          value: null,
          type: state.type,
          start: state.start,
          end: state.end,
          context: [this.curContext()],
          inType: state.inType,
          startLoc: state.startLoc,
          lastTokEndLoc: state.lastTokEndLoc,
          curLine: state.curLine,
          lineStart: state.lineStart,
          curPosition: state.curPosition
        };
      }
      lookahead() {
        const old = this.state;
        this.state = this.createLookaheadState(old);
        this.isLookahead = true;
        this.nextToken();
        this.isLookahead = false;
        const curr = this.state;
        this.state = old;
        return curr;
      }
      nextTokenStart() {
        return this.nextTokenStartSince(this.state.pos);
      }
      nextTokenStartSince(pos) {
        skipWhiteSpace.lastIndex = pos;
        return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
      }
      lookaheadCharCode() {
        return this.lookaheadCharCodeSince(this.state.pos);
      }
      lookaheadCharCodeSince(pos) {
        return this.input.charCodeAt(this.nextTokenStartSince(pos));
      }
      nextTokenInLineStart() {
        return this.nextTokenInLineStartSince(this.state.pos);
      }
      nextTokenInLineStartSince(pos) {
        skipWhiteSpaceInLine.lastIndex = pos;
        return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
      }
      lookaheadInLineCharCode() {
        return this.input.charCodeAt(this.nextTokenInLineStart());
      }
      codePointAtPos(pos) {
        let cp = this.input.charCodeAt(pos);
        if ((cp & 64512) === 55296 && ++pos < this.input.length) {
          const trail = this.input.charCodeAt(pos);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        return cp;
      }
      setStrict(strict) {
        this.state.strict = strict;
        if (strict) {
          this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at));
          this.state.strictErrors.clear();
        }
      }
      curContext() {
        return this.state.context[this.state.context.length - 1];
      }
      nextToken() {
        this.skipSpace();
        this.state.start = this.state.pos;
        if (!this.isLookahead) this.state.startLoc = this.state.curPosition();
        if (this.state.pos >= this.length) {
          this.finishToken(140);
          return;
        }
        this.getTokenFromCode(this.codePointAtPos(this.state.pos));
      }
      skipBlockComment(commentEnd) {
        let startLoc;
        if (!this.isLookahead) startLoc = this.state.curPosition();
        const start = this.state.pos;
        const end = this.input.indexOf(commentEnd, start + 2);
        if (end === -1) {
          throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
        }
        this.state.pos = end + commentEnd.length;
        lineBreakG.lastIndex = start + 2;
        while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
          ++this.state.curLine;
          this.state.lineStart = lineBreakG.lastIndex;
        }
        if (this.isLookahead) return;
        const comment = {
          type: "CommentBlock",
          value: this.input.slice(start + 2, end),
          start: this.sourceToOffsetPos(start),
          end: this.sourceToOffsetPos(end + commentEnd.length),
          loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.optionFlags & 256) this.pushToken(comment);
        return comment;
      }
      skipLineComment(startSkip) {
        const start = this.state.pos;
        let startLoc;
        if (!this.isLookahead) startLoc = this.state.curPosition();
        let ch = this.input.charCodeAt(this.state.pos += startSkip);
        if (this.state.pos < this.length) {
          while (!isNewLine(ch) && ++this.state.pos < this.length) {
            ch = this.input.charCodeAt(this.state.pos);
          }
        }
        if (this.isLookahead) return;
        const end = this.state.pos;
        const value = this.input.slice(start + startSkip, end);
        const comment = {
          type: "CommentLine",
          value,
          start: this.sourceToOffsetPos(start),
          end: this.sourceToOffsetPos(end),
          loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.optionFlags & 256) this.pushToken(comment);
        return comment;
      }
      skipSpace() {
        const spaceStart = this.state.pos;
        const comments = this.optionFlags & 4096 ? [] : null;
        loop: while (this.state.pos < this.length) {
          const ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                ++this.state.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos;
              ++this.state.curLine;
              this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  const comment = this.skipBlockComment("*/");
                  if (comment !== void 0) {
                    this.addComment(comment);
                    comments == null || comments.push(comment);
                  }
                  break;
                }
                case 47: {
                  const comment = this.skipLineComment(2);
                  if (comment !== void 0) {
                    this.addComment(comment);
                    comments == null || comments.push(comment);
                  }
                  break;
                }
                default:
                  break loop;
              }
              break;
            default:
              if (isWhitespace(ch)) {
                ++this.state.pos;
              } else if (ch === 45 && !this.inModule && this.optionFlags & 8192) {
                const pos = this.state.pos;
                if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                  const comment = this.skipLineComment(3);
                  if (comment !== void 0) {
                    this.addComment(comment);
                    comments == null || comments.push(comment);
                  }
                } else {
                  break loop;
                }
              } else if (ch === 60 && !this.inModule && this.optionFlags & 8192) {
                const pos = this.state.pos;
                if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                  const comment = this.skipLineComment(4);
                  if (comment !== void 0) {
                    this.addComment(comment);
                    comments == null || comments.push(comment);
                  }
                } else {
                  break loop;
                }
              } else {
                break loop;
              }
          }
        }
        if ((comments == null ? void 0 : comments.length) > 0) {
          const end = this.state.pos;
          const commentWhitespace = {
            start: this.sourceToOffsetPos(spaceStart),
            end: this.sourceToOffsetPos(end),
            comments,
            leadingNode: null,
            trailingNode: null,
            containingNode: null
          };
          this.state.commentStack.push(commentWhitespace);
        }
      }
      finishToken(type, val) {
        this.state.end = this.state.pos;
        this.state.endLoc = this.state.curPosition();
        const prevType = this.state.type;
        this.state.type = type;
        this.state.value = val;
        if (!this.isLookahead) {
          this.updateContext(prevType);
        }
      }
      replaceToken(type) {
        this.state.type = type;
        this.updateContext();
      }
      readToken_numberSign() {
        if (this.state.pos === 0 && this.readToken_interpreter()) {
          return;
        }
        const nextPos = this.state.pos + 1;
        const next = this.codePointAtPos(nextPos);
        if (next >= 48 && next <= 57) {
          throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());
        }
        if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
          this.expectPlugin("recordAndTuple");
          if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
            throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
          }
          this.state.pos += 2;
          if (next === 123) {
            this.finishToken(7);
          } else {
            this.finishToken(1);
          }
        } else if (isIdentifierStart2(next)) {
          ++this.state.pos;
          this.finishToken(139, this.readWord1(next));
        } else if (next === 92) {
          ++this.state.pos;
          this.finishToken(139, this.readWord1());
        } else {
          this.finishOp(27, 1);
        }
      }
      readToken_dot() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next >= 48 && next <= 57) {
          this.readNumber(true);
          return;
        }
        if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
          this.state.pos += 3;
          this.finishToken(21);
        } else {
          ++this.state.pos;
          this.finishToken(16);
        }
      }
      readToken_slash() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(31, 2);
        } else {
          this.finishOp(56, 1);
        }
      }
      readToken_interpreter() {
        if (this.state.pos !== 0 || this.length < 2) return false;
        let ch = this.input.charCodeAt(this.state.pos + 1);
        if (ch !== 33) return false;
        const start = this.state.pos;
        this.state.pos += 1;
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
        const value = this.input.slice(start + 2, this.state.pos);
        this.finishToken(28, value);
        return true;
      }
      readToken_mult_modulo(code3) {
        let type = code3 === 42 ? 55 : 54;
        let width2 = 1;
        let next = this.input.charCodeAt(this.state.pos + 1);
        if (code3 === 42 && next === 42) {
          width2++;
          next = this.input.charCodeAt(this.state.pos + 2);
          type = 57;
        }
        if (next === 61 && !this.state.inType) {
          width2++;
          type = code3 === 37 ? 33 : 30;
        }
        this.finishOp(type, width2);
      }
      readToken_pipe_amp(code3) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code3) {
          if (this.input.charCodeAt(this.state.pos + 2) === 61) {
            this.finishOp(30, 3);
          } else {
            this.finishOp(code3 === 124 ? 41 : 42, 2);
          }
          return;
        }
        if (code3 === 124) {
          if (next === 62) {
            this.finishOp(39, 2);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 125) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            }
            this.state.pos += 2;
            this.finishToken(9);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 93) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            }
            this.state.pos += 2;
            this.finishToken(4);
            return;
          }
        }
        if (next === 61) {
          this.finishOp(30, 2);
          return;
        }
        this.finishOp(code3 === 124 ? 43 : 45, 1);
      }
      readToken_caret() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61 && !this.state.inType) {
          this.finishOp(32, 2);
        } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "^^"
        }])) {
          this.finishOp(37, 2);
          const lookaheadCh = this.input.codePointAt(this.state.pos);
          if (lookaheadCh === 94) {
            this.unexpected();
          }
        } else {
          this.finishOp(44, 1);
        }
      }
      readToken_atSign() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 64 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "@@"
        }])) {
          this.finishOp(38, 2);
        } else {
          this.finishOp(26, 1);
        }
      }
      readToken_plus_min(code3) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code3) {
          this.finishOp(34, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(30, 2);
        } else {
          this.finishOp(53, 1);
        }
      }
      readToken_lt() {
        const {
          pos
        } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 60) {
          if (this.input.charCodeAt(pos + 2) === 61) {
            this.finishOp(30, 3);
            return;
          }
          this.finishOp(51, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(47, 1);
      }
      readToken_gt() {
        const {
          pos
        } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 62) {
          const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(pos + size) === 61) {
            this.finishOp(30, size + 1);
            return;
          }
          this.finishOp(52, size);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(48, 1);
      }
      readToken_eq_excl(code3) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
          return;
        }
        if (code3 === 61 && next === 62) {
          this.state.pos += 2;
          this.finishToken(19);
          return;
        }
        this.finishOp(code3 === 61 ? 29 : 35, 1);
      }
      readToken_question() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        const next2 = this.input.charCodeAt(this.state.pos + 2);
        if (next === 63) {
          if (next2 === 61) {
            this.finishOp(30, 3);
          } else {
            this.finishOp(40, 2);
          }
        } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
          this.state.pos += 2;
          this.finishToken(18);
        } else {
          ++this.state.pos;
          this.finishToken(17);
        }
      }
      getTokenFromCode(code3) {
        switch (code3) {
          case 46:
            this.readToken_dot();
            return;
          case 40:
            ++this.state.pos;
            this.finishToken(10);
            return;
          case 41:
            ++this.state.pos;
            this.finishToken(11);
            return;
          case 59:
            ++this.state.pos;
            this.finishToken(13);
            return;
          case 44:
            ++this.state.pos;
            this.finishToken(12);
            return;
          case 91:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
              }
              this.state.pos += 2;
              this.finishToken(2);
            } else {
              ++this.state.pos;
              this.finishToken(0);
            }
            return;
          case 93:
            ++this.state.pos;
            this.finishToken(3);
            return;
          case 123:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
              }
              this.state.pos += 2;
              this.finishToken(6);
            } else {
              ++this.state.pos;
              this.finishToken(5);
            }
            return;
          case 125:
            ++this.state.pos;
            this.finishToken(8);
            return;
          case 58:
            if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
              this.finishOp(15, 2);
            } else {
              ++this.state.pos;
              this.finishToken(14);
            }
            return;
          case 63:
            this.readToken_question();
            return;
          case 96:
            this.readTemplateToken();
            return;
          case 48: {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }
            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }
            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            this.readNumber(false);
            return;
          case 34:
          case 39:
            this.readString(code3);
            return;
          case 47:
            this.readToken_slash();
            return;
          case 37:
          case 42:
            this.readToken_mult_modulo(code3);
            return;
          case 124:
          case 38:
            this.readToken_pipe_amp(code3);
            return;
          case 94:
            this.readToken_caret();
            return;
          case 43:
          case 45:
            this.readToken_plus_min(code3);
            return;
          case 60:
            this.readToken_lt();
            return;
          case 62:
            this.readToken_gt();
            return;
          case 61:
          case 33:
            this.readToken_eq_excl(code3);
            return;
          case 126:
            this.finishOp(36, 1);
            return;
          case 64:
            this.readToken_atSign();
            return;
          case 35:
            this.readToken_numberSign();
            return;
          case 92:
            this.readWord();
            return;
          default:
            if (isIdentifierStart2(code3)) {
              this.readWord(code3);
              return;
            }
        }
        throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {
          unexpected: String.fromCodePoint(code3)
        });
      }
      finishOp(type, size) {
        const str = this.input.slice(this.state.pos, this.state.pos + size);
        this.state.pos += size;
        this.finishToken(type, str);
      }
      readRegexp() {
        const startLoc = this.state.startLoc;
        const start = this.state.start + 1;
        let escaped, inClass;
        let {
          pos
        } = this.state;
        for (; ; ++pos) {
          if (pos >= this.length) {
            throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
          }
          const ch = this.input.charCodeAt(pos);
          if (isNewLine(ch)) {
            throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
          }
          if (escaped) {
            escaped = false;
          } else {
            if (ch === 91) {
              inClass = true;
            } else if (ch === 93 && inClass) {
              inClass = false;
            } else if (ch === 47 && !inClass) {
              break;
            }
            escaped = ch === 92;
          }
        }
        const content = this.input.slice(start, pos);
        ++pos;
        let mods = "";
        const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
        while (pos < this.length) {
          const cp = this.codePointAtPos(pos);
          const char = String.fromCharCode(cp);
          if (VALID_REGEX_FLAGS.has(cp)) {
            if (cp === 118) {
              if (mods.includes("u")) {
                this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
              }
            } else if (cp === 117) {
              if (mods.includes("v")) {
                this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
              }
            }
            if (mods.includes(char)) {
              this.raise(Errors.DuplicateRegExpFlags, nextPos());
            }
          } else if (isIdentifierChar(cp) || cp === 92) {
            this.raise(Errors.MalformedRegExpFlags, nextPos());
          } else {
            break;
          }
          ++pos;
          mods += char;
        }
        this.state.pos = pos;
        this.finishToken(138, {
          pattern: content,
          flags: mods
        });
      }
      readInt(radix, len, forceLen = false, allowNumSeparator = true) {
        const {
          n: n2,
          pos
        } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
        this.state.pos = pos;
        return n2;
      }
      readRadixNumber(radix) {
        const start = this.state.pos;
        const startLoc = this.state.curPosition();
        let isBigInt = false;
        this.state.pos += 2;
        const val = this.readInt(radix);
        if (val == null) {
          this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {
            radix
          });
        }
        const next = this.input.charCodeAt(this.state.pos);
        if (next === 110) {
          ++this.state.pos;
          isBigInt = true;
        } else if (next === 109) {
          throw this.raise(Errors.InvalidDecimal, startLoc);
        }
        if (isIdentifierStart2(this.codePointAtPos(this.state.pos))) {
          throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
        }
        if (isBigInt) {
          const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
          this.finishToken(136, str);
          return;
        }
        this.finishToken(135, val);
      }
      readNumber(startsWithDot) {
        const start = this.state.pos;
        const startLoc = this.state.curPosition();
        let isFloat = false;
        let isBigInt = false;
        let hasExponent = false;
        let isOctal = false;
        if (!startsWithDot && this.readInt(10) === null) {
          this.raise(Errors.InvalidNumber, this.state.curPosition());
        }
        const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (hasLeadingZero) {
          const integer2 = this.input.slice(start, this.state.pos);
          this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);
          if (!this.state.strict) {
            const underscorePos = integer2.indexOf("_");
            if (underscorePos > 0) {
              this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));
            }
          }
          isOctal = hasLeadingZero && !/[89]/.test(integer2);
        }
        let next = this.input.charCodeAt(this.state.pos);
        if (next === 46 && !isOctal) {
          ++this.state.pos;
          this.readInt(10);
          isFloat = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if ((next === 69 || next === 101) && !isOctal) {
          next = this.input.charCodeAt(++this.state.pos);
          if (next === 43 || next === 45) {
            ++this.state.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(Errors.InvalidOrMissingExponent, startLoc);
          }
          isFloat = true;
          hasExponent = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if (next === 110) {
          if (isFloat || hasLeadingZero) {
            this.raise(Errors.InvalidBigIntLiteral, startLoc);
          }
          ++this.state.pos;
          isBigInt = true;
        }
        if (next === 109) {
          this.expectPlugin("decimal", this.state.curPosition());
          if (hasExponent || hasLeadingZero) {
            this.raise(Errors.InvalidDecimal, startLoc);
          }
          ++this.state.pos;
          var isDecimal = true;
        }
        if (isIdentifierStart2(this.codePointAtPos(this.state.pos))) {
          throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
        }
        const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
        if (isBigInt) {
          this.finishToken(136, str);
          return;
        }
        if (isDecimal) {
          this.finishToken(137, str);
          return;
        }
        const val = isOctal ? parseInt(str, 8) : parseFloat(str);
        this.finishToken(135, val);
      }
      readCodePoint(throwOnInvalid) {
        const {
          code: code3,
          pos
        } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
        this.state.pos = pos;
        return code3;
      }
      readString(quote) {
        const {
          str,
          pos,
          curLine,
          lineStart
        } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        this.finishToken(134, str);
      }
      readTemplateContinuation() {
        if (!this.match(8)) {
          this.unexpected(null, 8);
        }
        this.state.pos--;
        this.readTemplateToken();
      }
      readTemplateToken() {
        const opening = this.input[this.state.pos];
        const {
          str,
          firstInvalidLoc,
          pos,
          curLine,
          lineStart
        } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        if (firstInvalidLoc) {
          this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, this.sourceToOffsetPos(firstInvalidLoc.pos));
        }
        if (this.input.codePointAt(pos) === 96) {
          this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
        } else {
          this.state.pos++;
          this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
        }
      }
      recordStrictModeErrors(toParseError, at) {
        const index = at.index;
        if (this.state.strict && !this.state.strictErrors.has(index)) {
          this.raise(toParseError, at);
        } else {
          this.state.strictErrors.set(index, [toParseError, at]);
        }
      }
      readWord1(firstCode) {
        this.state.containsEsc = false;
        let word = "";
        const start = this.state.pos;
        let chunkStart = this.state.pos;
        if (firstCode !== void 0) {
          this.state.pos += firstCode <= 65535 ? 1 : 2;
        }
        while (this.state.pos < this.length) {
          const ch = this.codePointAtPos(this.state.pos);
          if (isIdentifierChar(ch)) {
            this.state.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.state.containsEsc = true;
            word += this.input.slice(chunkStart, this.state.pos);
            const escStart = this.state.curPosition();
            const identifierCheck = this.state.pos === start ? isIdentifierStart2 : isIdentifierChar;
            if (this.input.charCodeAt(++this.state.pos) !== 117) {
              this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());
              chunkStart = this.state.pos - 1;
              continue;
            }
            ++this.state.pos;
            const esc = this.readCodePoint(true);
            if (esc !== null) {
              if (!identifierCheck(esc)) {
                this.raise(Errors.EscapedCharNotAnIdentifier, escStart);
              }
              word += String.fromCodePoint(esc);
            }
            chunkStart = this.state.pos;
          } else {
            break;
          }
        }
        return word + this.input.slice(chunkStart, this.state.pos);
      }
      readWord(firstCode) {
        const word = this.readWord1(firstCode);
        const type = keywords$1.get(word);
        if (type !== void 0) {
          this.finishToken(type, tokenLabelName(type));
        } else {
          this.finishToken(132, word);
        }
      }
      checkKeywordEscapes() {
        const {
          type
        } = this.state;
        if (tokenIsKeyword(type) && this.state.containsEsc) {
          this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {
            reservedWord: tokenLabelName(type)
          });
        }
      }
      raise(toParseError, at, details = {}) {
        const loc = at instanceof Position ? at : at.loc.start;
        const error = toParseError(loc, details);
        if (!(this.optionFlags & 2048)) throw error;
        if (!this.isLookahead) this.state.errors.push(error);
        return error;
      }
      raiseOverwrite(toParseError, at, details = {}) {
        const loc = at instanceof Position ? at : at.loc.start;
        const pos = loc.index;
        const errors = this.state.errors;
        for (let i = errors.length - 1; i >= 0; i--) {
          const error = errors[i];
          if (error.loc.index === pos) {
            return errors[i] = toParseError(loc, details);
          }
          if (error.loc.index < pos) break;
        }
        return this.raise(toParseError, at, details);
      }
      updateContext(prevType) {
      }
      unexpected(loc, type) {
        throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {
          expected: type ? tokenLabelName(type) : null
        });
      }
      expectPlugin(pluginName, loc) {
        if (this.hasPlugin(pluginName)) {
          return true;
        }
        throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {
          missingPlugin: [pluginName]
        });
      }
      expectOnePlugin(pluginNames) {
        if (!pluginNames.some((name50) => this.hasPlugin(name50))) {
          throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {
            missingPlugin: pluginNames
          });
        }
      }
      errorBuilder(error) {
        return (pos, lineStart, curLine) => {
          this.raise(error, buildPosition(pos, lineStart, curLine));
        };
      }
    };
    var ClassScope = class {
      constructor() {
        this.privateNames = /* @__PURE__ */ new Set();
        this.loneAccessors = /* @__PURE__ */ new Map();
        this.undefinedPrivateNames = /* @__PURE__ */ new Map();
      }
    };
    var ClassScopeHandler = class {
      constructor(parser) {
        this.parser = void 0;
        this.stack = [];
        this.undefinedPrivateNames = /* @__PURE__ */ new Map();
        this.parser = parser;
      }
      current() {
        return this.stack[this.stack.length - 1];
      }
      enter() {
        this.stack.push(new ClassScope());
      }
      exit() {
        const oldClassScope = this.stack.pop();
        const current = this.current();
        for (const [name50, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
          if (current) {
            if (!current.undefinedPrivateNames.has(name50)) {
              current.undefinedPrivateNames.set(name50, loc);
            }
          } else {
            this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
              identifierName: name50
            });
          }
        }
      }
      declarePrivateName(name50, elementType, loc) {
        const {
          privateNames,
          loneAccessors,
          undefinedPrivateNames
        } = this.current();
        let redefined = privateNames.has(name50);
        if (elementType & 3) {
          const accessor = redefined && loneAccessors.get(name50);
          if (accessor) {
            const oldStatic = accessor & 4;
            const newStatic = elementType & 4;
            const oldKind = accessor & 3;
            const newKind = elementType & 3;
            redefined = oldKind === newKind || oldStatic !== newStatic;
            if (!redefined) loneAccessors.delete(name50);
          } else if (!redefined) {
            loneAccessors.set(name50, elementType);
          }
        }
        if (redefined) {
          this.parser.raise(Errors.PrivateNameRedeclaration, loc, {
            identifierName: name50
          });
        }
        privateNames.add(name50);
        undefinedPrivateNames.delete(name50);
      }
      usePrivateName(name50, loc) {
        let classScope;
        for (classScope of this.stack) {
          if (classScope.privateNames.has(name50)) return;
        }
        if (classScope) {
          classScope.undefinedPrivateNames.set(name50, loc);
        } else {
          this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
            identifierName: name50
          });
        }
      }
    };
    var ExpressionScope = class {
      constructor(type = 0) {
        this.type = type;
      }
      canBeArrowParameterDeclaration() {
        return this.type === 2 || this.type === 1;
      }
      isCertainlyParameterDeclaration() {
        return this.type === 3;
      }
    };
    var ArrowHeadParsingScope = class extends ExpressionScope {
      constructor(type) {
        super(type);
        this.declarationErrors = /* @__PURE__ */ new Map();
      }
      recordDeclarationError(ParsingErrorClass, at) {
        const index = at.index;
        this.declarationErrors.set(index, [ParsingErrorClass, at]);
      }
      clearDeclarationError(index) {
        this.declarationErrors.delete(index);
      }
      iterateErrors(iterator) {
        this.declarationErrors.forEach(iterator);
      }
    };
    var ExpressionScopeHandler = class {
      constructor(parser) {
        this.parser = void 0;
        this.stack = [new ExpressionScope()];
        this.parser = parser;
      }
      enter(scope) {
        this.stack.push(scope);
      }
      exit() {
        this.stack.pop();
      }
      recordParameterInitializerError(toParseError, node) {
        const origin = node.loc.start;
        const {
          stack
        } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while (!scope.isCertainlyParameterDeclaration()) {
          if (scope.canBeArrowParameterDeclaration()) {
            scope.recordDeclarationError(toParseError, origin);
          } else {
            return;
          }
          scope = stack[--i];
        }
        this.parser.raise(toParseError, origin);
      }
      recordArrowParameterBindingError(error, node) {
        const {
          stack
        } = this;
        const scope = stack[stack.length - 1];
        const origin = node.loc.start;
        if (scope.isCertainlyParameterDeclaration()) {
          this.parser.raise(error, origin);
        } else if (scope.canBeArrowParameterDeclaration()) {
          scope.recordDeclarationError(error, origin);
        } else {
          return;
        }
      }
      recordAsyncArrowParametersError(at) {
        const {
          stack
        } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while (scope.canBeArrowParameterDeclaration()) {
          if (scope.type === 2) {
            scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);
          }
          scope = stack[--i];
        }
      }
      validateAsPattern() {
        const {
          stack
        } = this;
        const currentScope = stack[stack.length - 1];
        if (!currentScope.canBeArrowParameterDeclaration()) return;
        currentScope.iterateErrors(([toParseError, loc]) => {
          this.parser.raise(toParseError, loc);
          let i = stack.length - 2;
          let scope = stack[i];
          while (scope.canBeArrowParameterDeclaration()) {
            scope.clearDeclarationError(loc.index);
            scope = stack[--i];
          }
        });
      }
    };
    function newParameterDeclarationScope() {
      return new ExpressionScope(3);
    }
    function newArrowHeadScope() {
      return new ArrowHeadParsingScope(1);
    }
    function newAsyncArrowScope() {
      return new ArrowHeadParsingScope(2);
    }
    function newExpressionScope() {
      return new ExpressionScope();
    }
    var UtilParser = class extends Tokenizer {
      addExtra(node, key, value, enumerable = true) {
        if (!node) return;
        let {
          extra
        } = node;
        if (extra == null) {
          extra = {};
          node.extra = extra;
        }
        if (enumerable) {
          extra[key] = value;
        } else {
          Object.defineProperty(extra, key, {
            enumerable,
            value
          });
        }
      }
      isContextual(token) {
        return this.state.type === token && !this.state.containsEsc;
      }
      isUnparsedContextual(nameStart, name50) {
        if (this.input.startsWith(name50, nameStart)) {
          const nextCh = this.input.charCodeAt(nameStart + name50.length);
          return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
        }
        return false;
      }
      isLookaheadContextual(name50) {
        const next = this.nextTokenStart();
        return this.isUnparsedContextual(next, name50);
      }
      eatContextual(token) {
        if (this.isContextual(token)) {
          this.next();
          return true;
        }
        return false;
      }
      expectContextual(token, toParseError) {
        if (!this.eatContextual(token)) {
          if (toParseError != null) {
            throw this.raise(toParseError, this.state.startLoc);
          }
          this.unexpected(null, token);
        }
      }
      canInsertSemicolon() {
        return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
      }
      hasPrecedingLineBreak() {
        return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
      }
      hasFollowingLineBreak() {
        return hasNewLine(this.input, this.state.end, this.nextTokenStart());
      }
      isLineTerminator() {
        return this.eat(13) || this.canInsertSemicolon();
      }
      semicolon(allowAsi = true) {
        if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;
        this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);
      }
      expect(type, loc) {
        if (!this.eat(type)) {
          this.unexpected(loc, type);
        }
      }
      tryParse(fn, oldState = this.state.clone()) {
        const abortSignal = {
          node: null
        };
        try {
          const node = fn((node2 = null) => {
            abortSignal.node = node2;
            throw abortSignal;
          });
          if (this.state.errors.length > oldState.errors.length) {
            const failState = this.state;
            this.state = oldState;
            this.state.tokensLength = failState.tokensLength;
            return {
              node,
              error: failState.errors[oldState.errors.length],
              thrown: false,
              aborted: false,
              failState
            };
          }
          return {
            node,
            error: null,
            thrown: false,
            aborted: false,
            failState: null
          };
        } catch (error) {
          const failState = this.state;
          this.state = oldState;
          if (error instanceof SyntaxError) {
            return {
              node: null,
              error,
              thrown: true,
              aborted: false,
              failState
            };
          }
          if (error === abortSignal) {
            return {
              node: abortSignal.node,
              error: null,
              thrown: false,
              aborted: true,
              failState
            };
          }
          throw error;
        }
      }
      checkExpressionErrors(refExpressionErrors, andThrow) {
        if (!refExpressionErrors) return false;
        const {
          shorthandAssignLoc,
          doubleProtoLoc,
          privateKeyLoc,
          optionalParametersLoc,
          voidPatternLoc
        } = refExpressionErrors;
        const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc || !!voidPatternLoc;
        if (!andThrow) {
          return hasErrors;
        }
        if (shorthandAssignLoc != null) {
          this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
        }
        if (doubleProtoLoc != null) {
          this.raise(Errors.DuplicateProto, doubleProtoLoc);
        }
        if (privateKeyLoc != null) {
          this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
        }
        if (optionalParametersLoc != null) {
          this.unexpected(optionalParametersLoc);
        }
        if (voidPatternLoc != null) {
          this.raise(Errors.InvalidCoverDiscardElement, voidPatternLoc);
        }
      }
      isLiteralPropertyName() {
        return tokenIsLiteralPropertyName(this.state.type);
      }
      isPrivateName(node) {
        return node.type === "PrivateName";
      }
      getPrivateNameSV(node) {
        return node.id.name;
      }
      hasPropertyAsPrivateName(node) {
        return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
      }
      isObjectProperty(node) {
        return node.type === "ObjectProperty";
      }
      isObjectMethod(node) {
        return node.type === "ObjectMethod";
      }
      initializeScopes(inModule = this.options.sourceType === "module") {
        const oldLabels = this.state.labels;
        this.state.labels = [];
        const oldExportedIdentifiers = this.exportedIdentifiers;
        this.exportedIdentifiers = /* @__PURE__ */ new Set();
        const oldInModule = this.inModule;
        this.inModule = inModule;
        const oldScope = this.scope;
        const ScopeHandler2 = this.getScopeHandler();
        this.scope = new ScopeHandler2(this, inModule);
        const oldProdParam = this.prodParam;
        this.prodParam = new ProductionParameterHandler();
        const oldClassScope = this.classScope;
        this.classScope = new ClassScopeHandler(this);
        const oldExpressionScope = this.expressionScope;
        this.expressionScope = new ExpressionScopeHandler(this);
        return () => {
          this.state.labels = oldLabels;
          this.exportedIdentifiers = oldExportedIdentifiers;
          this.inModule = oldInModule;
          this.scope = oldScope;
          this.prodParam = oldProdParam;
          this.classScope = oldClassScope;
          this.expressionScope = oldExpressionScope;
        };
      }
      enterInitialScopes() {
        let paramFlags = 0;
        if (this.inModule || this.optionFlags & 1) {
          paramFlags |= 2;
        }
        if (this.optionFlags & 32) {
          paramFlags |= 1;
        }
        const isCommonJS = !this.inModule && this.options.sourceType === "commonjs";
        if (isCommonJS || this.optionFlags & 2) {
          paramFlags |= 4;
        }
        this.prodParam.enter(paramFlags);
        let scopeFlags = isCommonJS ? 514 : 1;
        if (this.optionFlags & 4) {
          scopeFlags |= 512;
        }
        this.scope.enter(scopeFlags);
      }
      checkDestructuringPrivate(refExpressionErrors) {
        const {
          privateKeyLoc
        } = refExpressionErrors;
        if (privateKeyLoc !== null) {
          this.expectPlugin("destructuringPrivate", privateKeyLoc);
        }
      }
    };
    var ExpressionErrors = class {
      constructor() {
        this.shorthandAssignLoc = null;
        this.doubleProtoLoc = null;
        this.privateKeyLoc = null;
        this.optionalParametersLoc = null;
        this.voidPatternLoc = null;
      }
    };
    var Node = class {
      constructor(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        this.loc = new SourceLocation(loc);
        if ((parser == null ? void 0 : parser.optionFlags) & 128) this.range = [pos, 0];
        if (parser != null && parser.filename) this.loc.filename = parser.filename;
      }
    };
    var NodePrototype = Node.prototype;
    NodePrototype.__clone = function() {
      const newNode = new Node(void 0, this.start, this.loc.start);
      const keys = Object.keys(this);
      for (let i = 0, length2 = keys.length; i < length2; i++) {
        const key = keys[i];
        if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
          newNode[key] = this[key];
        }
      }
      return newNode;
    };
    var NodeUtils = class extends UtilParser {
      startNode() {
        const loc = this.state.startLoc;
        return new Node(this, loc.index, loc);
      }
      startNodeAt(loc) {
        return new Node(this, loc.index, loc);
      }
      startNodeAtNode(type) {
        return this.startNodeAt(type.loc.start);
      }
      finishNode(node, type) {
        return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
      }
      finishNodeAt(node, type, endLoc) {
        node.type = type;
        node.end = endLoc.index;
        node.loc.end = endLoc;
        if (this.optionFlags & 128) node.range[1] = endLoc.index;
        if (this.optionFlags & 4096) {
          this.processComment(node);
        }
        return node;
      }
      resetStartLocation(node, startLoc) {
        node.start = startLoc.index;
        node.loc.start = startLoc;
        if (this.optionFlags & 128) node.range[0] = startLoc.index;
      }
      resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        node.end = endLoc.index;
        node.loc.end = endLoc;
        if (this.optionFlags & 128) node.range[1] = endLoc.index;
      }
      resetStartLocationFromNode(node, locationNode) {
        this.resetStartLocation(node, locationNode.loc.start);
      }
      castNodeTo(node, type) {
        node.type = type;
        return node;
      }
      cloneIdentifier(node) {
        const {
          type,
          start,
          end,
          loc,
          range,
          name: name50
        } = node;
        const cloned = Object.create(NodePrototype);
        cloned.type = type;
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        cloned.name = name50;
        if (node.extra) cloned.extra = node.extra;
        return cloned;
      }
      cloneStringLiteral(node) {
        const {
          type,
          start,
          end,
          loc,
          range,
          extra
        } = node;
        const cloned = Object.create(NodePrototype);
        cloned.type = type;
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        cloned.extra = extra;
        cloned.value = node.value;
        return cloned;
      }
    };
    var unwrapParenthesizedExpression = (node) => {
      return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
    };
    var LValParser = class extends NodeUtils {
      toAssignable(node, isLHS = false) {
        var _node$extra, _node$extra3;
        let parenthesized = void 0;
        if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
          parenthesized = unwrapParenthesizedExpression(node);
          if (isLHS) {
            if (parenthesized.type === "Identifier") {
              this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);
            } else if (parenthesized.type !== "CallExpression" && parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized)) {
              this.raise(Errors.InvalidParenthesizedAssignment, node);
            }
          } else {
            this.raise(Errors.InvalidParenthesizedAssignment, node);
          }
        }
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
          case "VoidPattern":
            break;
          case "ObjectExpression":
            this.castNodeTo(node, "ObjectPattern");
            for (let i = 0, length2 = node.properties.length, last = length2 - 1; i < length2; i++) {
              var _node$extra2;
              const prop = node.properties[i];
              const isLast = i === last;
              this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
              if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
                this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);
              }
            }
            break;
          case "ObjectProperty": {
            const {
              key,
              value
            } = node;
            if (this.isPrivateName(key)) {
              this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }
            this.toAssignable(value, isLHS);
            break;
          }
          case "SpreadElement": {
            throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
          }
          case "ArrayExpression":
            this.castNodeTo(node, "ArrayPattern");
            this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
            break;
          case "AssignmentExpression":
            if (node.operator !== "=") {
              this.raise(Errors.MissingEqInAssignment, node.left.loc.end);
            }
            this.castNodeTo(node, "AssignmentPattern");
            delete node.operator;
            if (node.left.type === "VoidPattern") {
              this.raise(Errors.VoidPatternInitializer, node.left);
            }
            this.toAssignable(node.left, isLHS);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(parenthesized, isLHS);
            break;
        }
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === "ObjectMethod") {
          this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);
        } else if (prop.type === "SpreadElement") {
          this.castNodeTo(prop, "RestElement");
          const arg = prop.argument;
          this.checkToRestConversion(arg, false);
          this.toAssignable(arg, isLHS);
          if (!isLast) {
            this.raise(Errors.RestTrailingComma, prop);
          }
        } else {
          this.toAssignable(prop, isLHS);
        }
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        const end = exprList.length - 1;
        for (let i = 0; i <= end; i++) {
          const elt = exprList[i];
          if (!elt) continue;
          this.toAssignableListItem(exprList, i, isLHS);
          if (elt.type === "RestElement") {
            if (i < end) {
              this.raise(Errors.RestTrailingComma, elt);
            } else if (trailingCommaLoc) {
              this.raise(Errors.RestTrailingComma, trailingCommaLoc);
            }
          }
        }
      }
      toAssignableListItem(exprList, index, isLHS) {
        const node = exprList[index];
        if (node.type === "SpreadElement") {
          this.castNodeTo(node, "RestElement");
          const arg = node.argument;
          this.checkToRestConversion(arg, true);
          this.toAssignable(arg, isLHS);
        } else {
          this.toAssignable(node, isLHS);
        }
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
          case "VoidPattern":
            return true;
          case "ObjectExpression": {
            const last = node.properties.length - 1;
            return node.properties.every((prop, i) => {
              return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
            });
          }
          case "ObjectProperty":
            return this.isAssignable(node.value);
          case "SpreadElement":
            return this.isAssignable(node.argument);
          case "ArrayExpression":
            return node.elements.every((element) => element === null || this.isAssignable(element));
          case "AssignmentExpression":
            return node.operator === "=";
          case "ParenthesizedExpression":
            return this.isAssignable(node.expression);
          case "MemberExpression":
          case "OptionalMemberExpression":
            return !isBinding;
          default:
            return false;
        }
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        return exprList;
      }
      toReferencedListDeep(exprList, isParenthesizedExpr) {
        this.toReferencedList(exprList, isParenthesizedExpr);
        for (const expr of exprList) {
          if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
            this.toReferencedListDeep(expr.elements);
          }
        }
      }
      parseSpread(refExpressionErrors) {
        const node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
        return this.finishNode(node, "SpreadElement");
      }
      parseRestBinding() {
        const node = this.startNode();
        this.next();
        const argument = this.parseBindingAtom();
        if (argument.type === "VoidPattern") {
          this.raise(Errors.UnexpectedVoidPattern, argument);
        }
        node.argument = argument;
        return this.finishNode(node, "RestElement");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 0: {
            const node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(3, 93, 1);
            return this.finishNode(node, "ArrayPattern");
          }
          case 5:
            return this.parseObjectLike(8, true);
          case 88:
            return this.parseVoidPattern(null);
        }
        return this.parseIdentifier();
      }
      parseBindingList(close, closeCharCode, flags) {
        const allowEmpty = flags & 1;
        const elts = [];
        let first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
          }
          if (allowEmpty && this.match(12)) {
            elts.push(null);
          } else if (this.eat(close)) {
            break;
          } else if (this.match(21)) {
            let rest = this.parseRestBinding();
            if (this.hasPlugin("flow") || flags & 2) {
              rest = this.parseFunctionParamType(rest);
            }
            elts.push(rest);
            if (!this.checkCommaAfterRest(closeCharCode)) {
              this.expect(close);
              break;
            }
          } else {
            const decorators = [];
            if (flags & 2) {
              if (this.match(26) && this.hasPlugin("decorators")) {
                this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);
              }
              while (this.match(26)) {
                decorators.push(this.parseDecorator());
              }
            }
            elts.push(this.parseBindingElement(flags, decorators));
          }
        }
        return elts;
      }
      parseBindingRestProperty(prop) {
        this.next();
        if (this.hasPlugin("discardBinding") && this.match(88)) {
          prop.argument = this.parseVoidPattern(null);
          this.raise(Errors.UnexpectedVoidPattern, prop.argument);
        } else {
          prop.argument = this.parseIdentifier();
        }
        this.checkCommaAfterRest(125);
        return this.finishNode(prop, "RestElement");
      }
      parseBindingProperty() {
        const {
          type,
          startLoc
        } = this.state;
        if (type === 21) {
          return this.parseBindingRestProperty(this.startNode());
        }
        const prop = this.startNode();
        if (type === 139) {
          this.expectPlugin("destructuringPrivate", startLoc);
          this.classScope.usePrivateName(this.state.value, startLoc);
          prop.key = this.parsePrivateName();
        } else {
          this.parsePropertyName(prop);
        }
        prop.method = false;
        return this.parseObjPropValue(prop, startLoc, false, false, true, false);
      }
      parseBindingElement(flags, decorators) {
        const left = this.parseMaybeDefault();
        if (this.hasPlugin("flow") || flags & 2) {
          this.parseFunctionParamType(left);
        }
        if (decorators.length) {
          left.decorators = decorators;
          this.resetStartLocationFromNode(left, decorators[0]);
        }
        const elt = this.parseMaybeDefault(left.loc.start, left);
        return elt;
      }
      parseFunctionParamType(param) {
        return param;
      }
      parseMaybeDefault(startLoc, left) {
        startLoc != null ? startLoc : startLoc = this.state.startLoc;
        left = left != null ? left : this.parseBindingAtom();
        if (!this.eat(29)) return left;
        const node = this.startNodeAt(startLoc);
        if (left.type === "VoidPattern") {
          this.raise(Errors.VoidPatternInitializer, left);
        }
        node.left = left;
        node.right = this.parseMaybeAssignAllowIn();
        return this.finishNode(node, "AssignmentPattern");
      }
      isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding) {
        switch (type) {
          case "AssignmentPattern":
            return "left";
          case "RestElement":
            return "argument";
          case "ObjectProperty":
            return "value";
          case "ParenthesizedExpression":
            return "expression";
          case "ArrayPattern":
            return "elements";
          case "ObjectPattern":
            return "properties";
          case "VoidPattern":
            return true;
          case "CallExpression":
            if (!disallowCallExpression && !this.state.strict && this.optionFlags & 8192) {
              return true;
            }
        }
        return false;
      }
      isOptionalMemberExpression(expression) {
        return expression.type === "OptionalMemberExpression";
      }
      checkLVal(expression, ancestor, binding = 64, checkClashes = false, strictModeChanged = false, hasParenthesizedAncestor = false, disallowCallExpression = false) {
        var _expression$extra;
        const type = expression.type;
        if (this.isObjectMethod(expression)) return;
        const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);
        if (isOptionalMemberExpression || type === "MemberExpression") {
          if (isOptionalMemberExpression) {
            this.expectPlugin("optionalChainingAssign", expression.loc.start);
            if (ancestor.type !== "AssignmentExpression") {
              this.raise(Errors.InvalidLhsOptionalChaining, expression, {
                ancestor
              });
            }
          }
          if (binding !== 64) {
            this.raise(Errors.InvalidPropertyBindingPattern, expression);
          }
          return;
        }
        if (type === "Identifier") {
          this.checkIdentifier(expression, binding, strictModeChanged);
          const {
            name: name50
          } = expression;
          if (checkClashes) {
            if (checkClashes.has(name50)) {
              this.raise(Errors.ParamDupe, expression);
            } else {
              checkClashes.add(name50);
            }
          }
          return;
        } else if (type === "VoidPattern" && ancestor.type === "CatchClause") {
          this.raise(Errors.VoidPatternCatchClauseParam, expression);
        }
        const unwrappedExpression = unwrapParenthesizedExpression(expression);
        disallowCallExpression || (disallowCallExpression = unwrappedExpression.type === "CallExpression" && (unwrappedExpression.callee.type === "Import" || unwrappedExpression.callee.type === "Super"));
        const validity = this.isValidLVal(type, disallowCallExpression, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
        if (validity === true) return;
        if (validity === false) {
          const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
          this.raise(ParseErrorClass, expression, {
            ancestor
          });
          return;
        }
        let key, isParenthesizedExpression;
        if (typeof validity === "string") {
          key = validity;
          isParenthesizedExpression = type === "ParenthesizedExpression";
        } else {
          [key, isParenthesizedExpression] = validity;
        }
        const nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" ? {
          type
        } : ancestor;
        const val = expression[key];
        if (Array.isArray(val)) {
          for (const child of val) {
            if (child) {
              this.checkLVal(child, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression, true);
            }
          }
        } else if (val) {
          this.checkLVal(val, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression, disallowCallExpression);
        }
      }
      checkIdentifier(at, bindingType, strictModeChanged = false) {
        if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
          if (bindingType === 64) {
            this.raise(Errors.StrictEvalArguments, at, {
              referenceName: at.name
            });
          } else {
            this.raise(Errors.StrictEvalArgumentsBinding, at, {
              bindingName: at.name
            });
          }
        }
        if (bindingType & 8192 && at.name === "let") {
          this.raise(Errors.LetInLexicalBinding, at);
        }
        if (!(bindingType & 64)) {
          this.declareNameFromIdentifier(at, bindingType);
        }
      }
      declareNameFromIdentifier(identifier, binding) {
        this.scope.declareName(identifier.name, binding, identifier.loc.start);
      }
      checkToRestConversion(node, allowPattern) {
        switch (node.type) {
          case "ParenthesizedExpression":
            this.checkToRestConversion(node.expression, allowPattern);
            break;
          case "Identifier":
          case "MemberExpression":
            break;
          case "ArrayExpression":
          case "ObjectExpression":
            if (allowPattern) break;
          default:
            this.raise(Errors.InvalidRestAssignmentPattern, node);
        }
      }
      checkCommaAfterRest(close) {
        if (!this.match(12)) {
          return false;
        }
        this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);
        return true;
      }
    };
    var keywordAndTSRelationalOperator = /in(?:stanceof)?|as|satisfies/y;
    function nonNull(x) {
      if (x == null) {
        throw new Error(`Unexpected ${x} value.`);
      }
      return x;
    }
    function assert(x) {
      if (!x) {
        throw new Error("Assert fail");
      }
    }
    var TSErrors = ParseErrorEnum`typescript`({
      AbstractMethodHasImplementation: ({
        methodName
      }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
      AbstractPropertyHasInitializer: ({
        propertyName
      }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
      AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
      AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
      AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
      ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
      ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
      ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
      ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
      DeclareAccessor: ({
        kind
      }) => `'declare' is not allowed in ${kind}ters.`,
      DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
      DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
      DuplicateAccessibilityModifier: ({
        modifier
      }) => `Accessibility modifier already seen: '${modifier}'.`,
      DuplicateModifier: ({
        modifier
      }) => `Duplicate modifier: '${modifier}'.`,
      EmptyHeritageClauseType: ({
        token
      }) => `'${token}' list cannot be empty.`,
      EmptyTypeArguments: "Type argument list cannot be empty.",
      EmptyTypeParameters: "Type parameter list cannot be empty.",
      ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
      ImportAliasHasImportType: "An import alias can not use 'import type'.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
      IncompatibleModifiers: ({
        modifiers: modifiers2
      }) => `'${modifiers2[0]}' modifier cannot be used with '${modifiers2[1]}' modifier.`,
      IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
      IndexSignatureHasAccessibility: ({
        modifier
      }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
      IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
      IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
      IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
      InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
      InvalidHeritageClauseType: ({
        token
      }) => `'${token}' list can only include identifiers or qualified-names with optional type arguments.`,
      InvalidModifierOnAwaitUsingDeclaration: (modifier) => `'${modifier}' modifier cannot appear on an await using declaration.`,
      InvalidModifierOnTypeMember: ({
        modifier
      }) => `'${modifier}' modifier cannot appear on a type member.`,
      InvalidModifierOnTypeParameter: ({
        modifier
      }) => `'${modifier}' modifier cannot appear on a type parameter.`,
      InvalidModifierOnTypeParameterPositions: ({
        modifier
      }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
      InvalidModifierOnUsingDeclaration: (modifier) => `'${modifier}' modifier cannot appear on a using declaration.`,
      InvalidModifiersOrder: ({
        orderedModifiers
      }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
      InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
      InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
      MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
      NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
      NonClassMethodPropertyHasAbstractModifier: "'abstract' modifier can only appear on a class, method, or property declaration.",
      OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
      OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
      PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
      PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
      PrivateElementHasAccessibility: ({
        modifier
      }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
      ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
      ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
      ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
      SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
      SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
      SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
      SingleTypeParameterWithoutTrailingComma: ({
        typeParameterName
      }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
      StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
      TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
      TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
      TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
      TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
      UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
      UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
      UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
      UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
      UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
      UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
      UnsupportedSignatureParameterKind: ({
        type
      }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,
      UsingDeclarationInAmbientContext: (kind) => `'${kind}' declarations are not allowed in ambient contexts.`
    });
    function keywordTypeFromName(value) {
      switch (value) {
        case "any":
          return "TSAnyKeyword";
        case "boolean":
          return "TSBooleanKeyword";
        case "bigint":
          return "TSBigIntKeyword";
        case "never":
          return "TSNeverKeyword";
        case "number":
          return "TSNumberKeyword";
        case "object":
          return "TSObjectKeyword";
        case "string":
          return "TSStringKeyword";
        case "symbol":
          return "TSSymbolKeyword";
        case "undefined":
          return "TSUndefinedKeyword";
        case "unknown":
          return "TSUnknownKeyword";
        default:
          return void 0;
      }
    }
    function tsIsAccessModifier(modifier) {
      return modifier === "private" || modifier === "public" || modifier === "protected";
    }
    function tsIsVarianceAnnotations(modifier) {
      return modifier === "in" || modifier === "out";
    }
    var typescript = (superClass) => class TypeScriptParserMixin extends superClass {
      constructor(...args) {
        super(...args);
        this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["in", "out"],
          disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameter
        });
        this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["const"],
          disallowedModifiers: ["in", "out"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        });
        this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["in", "out", "const"],
          disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameter
        });
      }
      getScopeHandler() {
        return TypeScriptScopeHandler;
      }
      tsIsIdentifier() {
        return tokenIsIdentifier(this.state.type);
      }
      tsTokenCanFollowModifier() {
        return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
      }
      tsNextTokenOnSameLineAndCanFollowModifier() {
        this.next();
        if (this.hasPrecedingLineBreak()) {
          return false;
        }
        return this.tsTokenCanFollowModifier();
      }
      tsNextTokenCanFollowModifier() {
        if (this.match(106)) {
          this.next();
          return this.tsTokenCanFollowModifier();
        }
        return this.tsNextTokenOnSameLineAndCanFollowModifier();
      }
      tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock, hasSeenStaticModifier) {
        if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
          return void 0;
        }
        const modifier = this.state.value;
        if (allowedModifiers.includes(modifier)) {
          if (hasSeenStaticModifier && this.match(106)) {
            return void 0;
          }
          if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
            return void 0;
          }
          if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
            return modifier;
          }
        }
        return void 0;
      }
      tsParseModifiers({
        allowedModifiers,
        disallowedModifiers,
        stopOnStartOfClassStaticBlock,
        errorTemplate = TSErrors.InvalidModifierOnTypeMember
      }, modified) {
        const enforceOrder = (loc, modifier, before, after) => {
          if (modifier === before && modified[after]) {
            this.raise(TSErrors.InvalidModifiersOrder, loc, {
              orderedModifiers: [before, after]
            });
          }
        };
        const incompatible = (loc, modifier, mod1, mod2) => {
          if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
            this.raise(TSErrors.IncompatibleModifiers, loc, {
              modifiers: [mod1, mod2]
            });
          }
        };
        for (; ; ) {
          const {
            startLoc
          } = this.state;
          const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock, modified.static);
          if (!modifier) break;
          if (tsIsAccessModifier(modifier)) {
            if (modified.accessibility) {
              this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {
                modifier
              });
            } else {
              enforceOrder(startLoc, modifier, modifier, "override");
              enforceOrder(startLoc, modifier, modifier, "static");
              enforceOrder(startLoc, modifier, modifier, "readonly");
              modified.accessibility = modifier;
            }
          } else if (tsIsVarianceAnnotations(modifier)) {
            if (modified[modifier]) {
              this.raise(TSErrors.DuplicateModifier, startLoc, {
                modifier
              });
            }
            modified[modifier] = true;
            enforceOrder(startLoc, modifier, "in", "out");
          } else {
            if (hasOwnProperty.call(modified, modifier)) {
              this.raise(TSErrors.DuplicateModifier, startLoc, {
                modifier
              });
            } else {
              enforceOrder(startLoc, modifier, "static", "readonly");
              enforceOrder(startLoc, modifier, "static", "override");
              enforceOrder(startLoc, modifier, "override", "readonly");
              enforceOrder(startLoc, modifier, "abstract", "override");
              incompatible(startLoc, modifier, "declare", "override");
              incompatible(startLoc, modifier, "static", "abstract");
            }
            modified[modifier] = true;
          }
          if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
            this.raise(errorTemplate, startLoc, {
              modifier
            });
          }
        }
      }
      tsIsListTerminator(kind) {
        switch (kind) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(8);
          case "HeritageClauseElement":
            return this.match(5);
          case "TupleElementTypes":
            return this.match(3);
          case "TypeParametersOrArguments":
            return this.match(48);
        }
      }
      tsParseList(kind, parseElement) {
        const result = [];
        while (!this.tsIsListTerminator(kind)) {
          result.push(parseElement());
        }
        return result;
      }
      tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
        return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
      }
      tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
        const result = [];
        let trailingCommaPos = -1;
        for (; ; ) {
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          trailingCommaPos = -1;
          const element = parseElement();
          if (element == null) {
            return void 0;
          }
          result.push(element);
          if (this.eat(12)) {
            trailingCommaPos = this.state.lastTokStartLoc.index;
            continue;
          }
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          if (expectSuccess) {
            this.expect(12);
          }
          return void 0;
        }
        if (refTrailingCommaPos) {
          refTrailingCommaPos.value = trailingCommaPos;
        }
        return result;
      }
      tsParseBracketedList(kind, parseElement, bracket3, skipFirstToken, refTrailingCommaPos) {
        if (!skipFirstToken) {
          if (bracket3) {
            this.expect(0);
          } else {
            this.expect(47);
          }
        }
        const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
        if (bracket3) {
          this.expect(3);
        } else {
          this.expect(48);
        }
        return result;
      }
      tsParseImportType() {
        const node = this.startNode();
        this.expect(83);
        this.expect(10);
        if (!this.match(134)) {
          this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);
          node.argument = super.parseExprAtom();
        } else {
          node.argument = this.parseStringLiteral(this.state.value);
        }
        if (this.eat(12)) {
          node.options = this.tsParseImportTypeOptions();
        } else {
          node.options = null;
        }
        this.expect(11);
        if (this.eat(16)) {
          node.qualifier = this.tsParseEntityName(1 | 2);
        }
        if (this.match(47)) {
          node.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSImportType");
      }
      tsParseImportTypeOptions() {
        const node = this.startNode();
        this.expect(5);
        const withProperty = this.startNode();
        if (this.isContextual(76)) {
          withProperty.method = false;
          withProperty.key = this.parseIdentifier(true);
          withProperty.computed = false;
          withProperty.shorthand = false;
        } else {
          this.unexpected(null, 76);
        }
        this.expect(14);
        withProperty.value = this.tsParseImportTypeWithPropertyValue();
        node.properties = [this.finishObjectProperty(withProperty)];
        this.eat(12);
        this.expect(8);
        return this.finishNode(node, "ObjectExpression");
      }
      tsParseImportTypeWithPropertyValue() {
        const node = this.startNode();
        const properties5 = [];
        this.expect(5);
        while (!this.match(8)) {
          const type = this.state.type;
          if (tokenIsIdentifier(type) || type === 134) {
            properties5.push(super.parsePropertyDefinition(null));
          } else {
            this.unexpected();
          }
          this.eat(12);
        }
        node.properties = properties5;
        this.next();
        return this.finishNode(node, "ObjectExpression");
      }
      tsParseEntityName(flags) {
        let entity;
        if (flags & 1 && this.match(78)) {
          if (flags & 2) {
            entity = this.parseIdentifier(true);
          } else {
            const node = this.startNode();
            this.next();
            entity = this.finishNode(node, "ThisExpression");
          }
        } else {
          entity = this.parseIdentifier(!!(flags & 1));
        }
        while (this.eat(16)) {
          const node = this.startNodeAtNode(entity);
          node.left = entity;
          node.right = this.parseIdentifier(!!(flags & 1));
          entity = this.finishNode(node, "TSQualifiedName");
        }
        return entity;
      }
      tsParseTypeReference() {
        const node = this.startNode();
        node.typeName = this.tsParseEntityName(1);
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
          node.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSTypeReference");
      }
      tsParseThisTypePredicate(lhs) {
        this.next();
        const node = this.startNodeAtNode(lhs);
        node.parameterName = lhs;
        node.typeAnnotation = this.tsParseTypeAnnotation(false);
        node.asserts = false;
        return this.finishNode(node, "TSTypePredicate");
      }
      tsParseThisTypeNode() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "TSThisType");
      }
      tsParseTypeQuery() {
        const node = this.startNode();
        this.expect(87);
        if (this.match(83)) {
          node.exprName = this.tsParseImportType();
        } else {
          node.exprName = this.tsParseEntityName(1 | 2);
        }
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
          node.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSTypeQuery");
      }
      tsParseTypeParameter(parseModifiers) {
        const node = this.startNode();
        parseModifiers(node);
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsEatThenParseType(81);
        node.default = this.tsEatThenParseType(29);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsTryParseTypeParameters(parseModifiers) {
        if (this.match(47)) {
          return this.tsParseTypeParameters(parseModifiers);
        }
      }
      tsParseTypeParameters(parseModifiers) {
        const node = this.startNode();
        if (this.match(47) || this.match(143)) {
          this.next();
        } else {
          this.unexpected();
        }
        const refTrailingCommaPos = {
          value: -1
        };
        node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
        if (node.params.length === 0) {
          this.raise(TSErrors.EmptyTypeParameters, node);
        }
        if (refTrailingCommaPos.value !== -1) {
          this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
        }
        return this.finishNode(node, "TSTypeParameterDeclaration");
      }
      tsFillSignature(returnToken, signature) {
        const returnTokenRequired = returnToken === 19;
        const paramsKey = "parameters";
        const returnTypeKey = "typeAnnotation";
        signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        this.expect(10);
        signature[paramsKey] = this.tsParseBindingListForSignature();
        if (returnTokenRequired) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
      }
      tsParseBindingListForSignature() {
        const list = super.parseBindingList(11, 41, 2);
        for (const pattern of list) {
          const {
            type
          } = pattern;
          if (type === "AssignmentPattern" || type === "TSParameterProperty") {
            this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {
              type
            });
          }
        }
        return list;
      }
      tsParseTypeMemberSemicolon() {
        if (!this.eat(12) && !this.isLineTerminator()) {
          this.expect(13);
        }
      }
      tsParseSignatureMember(kind, node) {
        this.tsFillSignature(14, node);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, kind);
      }
      tsIsUnambiguouslyIndexSignature() {
        this.next();
        if (tokenIsIdentifier(this.state.type)) {
          this.next();
          return this.match(14);
        }
        return false;
      }
      tsTryParseIndexSignature(node) {
        if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
          return;
        }
        this.expect(0);
        const id = this.parseIdentifier();
        id.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id);
        this.expect(3);
        node.parameters = [id];
        const type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, "TSIndexSignature");
      }
      tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(17)) node.optional = true;
        if (this.match(10) || this.match(47)) {
          if (readonly) {
            this.raise(TSErrors.ReadonlyForMethodSignature, node);
          }
          const method = node;
          if (method.kind && this.match(47)) {
            this.raise(TSErrors.AccessorCannotHaveTypeParameters, this.state.curPosition());
          }
          this.tsFillSignature(14, method);
          this.tsParseTypeMemberSemicolon();
          const paramsKey = "parameters";
          const returnTypeKey = "typeAnnotation";
          if (method.kind === "get") {
            if (method[paramsKey].length > 0) {
              this.raise(Errors.BadGetterArity, this.state.curPosition());
              if (this.isThisParam(method[paramsKey][0])) {
                this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
              }
            }
          } else if (method.kind === "set") {
            if (method[paramsKey].length !== 1) {
              this.raise(Errors.BadSetterArity, this.state.curPosition());
            } else {
              const firstParameter = method[paramsKey][0];
              if (this.isThisParam(firstParameter)) {
                this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
              }
              if (firstParameter.type === "Identifier" && firstParameter.optional) {
                this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter, this.state.curPosition());
              }
              if (firstParameter.type === "RestElement") {
                this.raise(TSErrors.SetAccessorCannotHaveRestParameter, this.state.curPosition());
              }
            }
            if (method[returnTypeKey]) {
              this.raise(TSErrors.SetAccessorCannotHaveReturnType, method[returnTypeKey]);
            }
          } else {
            method.kind = "method";
          }
          return this.finishNode(method, "TSMethodSignature");
        } else {
          const property4 = node;
          if (readonly) property4.readonly = true;
          const type = this.tsTryParseTypeAnnotation();
          if (type) property4.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(property4, "TSPropertySignature");
        }
      }
      tsParseTypeMember() {
        const node = this.startNode();
        if (this.match(10) || this.match(47)) {
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
        }
        if (this.match(77)) {
          const id = this.startNode();
          this.next();
          if (this.match(10) || this.match(47)) {
            return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
          } else {
            node.key = this.createIdentifier(id, "new");
            return this.tsParsePropertyOrMethodSignature(node, false);
          }
        }
        this.tsParseModifiers({
          allowedModifiers: ["readonly"],
          disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
        }, node);
        const idx = this.tsTryParseIndexSignature(node);
        if (idx) {
          return idx;
        }
        super.parsePropertyName(node);
        if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
          node.kind = node.key.name;
          super.parsePropertyName(node);
          if (!this.match(10) && !this.match(47)) {
            this.unexpected(null, 10);
          }
        }
        return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
      }
      tsParseTypeLiteral() {
        const node = this.startNode();
        node.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node, "TSTypeLiteral");
      }
      tsParseObjectTypeMembers() {
        this.expect(5);
        const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        this.expect(8);
        return members;
      }
      tsIsStartOfMappedType() {
        this.next();
        if (this.eat(53)) {
          return this.isContextual(122);
        }
        if (this.isContextual(122)) {
          this.next();
        }
        if (!this.match(0)) {
          return false;
        }
        this.next();
        if (!this.tsIsIdentifier()) {
          return false;
        }
        this.next();
        return this.match(58);
      }
      tsParseMappedType() {
        const node = this.startNode();
        this.expect(5);
        if (this.match(53)) {
          node.readonly = this.state.value;
          this.next();
          this.expectContextual(122);
        } else if (this.eatContextual(122)) {
          node.readonly = true;
        }
        this.expect(0);
        const typeParameter = this.startNode();
        typeParameter.name = this.tsParseTypeParameterName();
        typeParameter.constraint = this.tsExpectThenParseType(58);
        node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
        this.expect(3);
        if (this.match(53)) {
          node.optional = this.state.value;
          this.next();
          this.expect(17);
        } else if (this.eat(17)) {
          node.optional = true;
        }
        node.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(8);
        return this.finishNode(node, "TSMappedType");
      }
      tsParseTupleType() {
        const node = this.startNode();
        node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
        let seenOptionalElement = false;
        node.elementTypes.forEach((elementNode) => {
          const {
            type
          } = elementNode;
          if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
            this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);
          }
          seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
        });
        return this.finishNode(node, "TSTupleType");
      }
      tsParseTupleElementType() {
        const restStartLoc = this.state.startLoc;
        const rest = this.eat(21);
        const {
          startLoc
        } = this.state;
        let labeled;
        let label;
        let optional;
        let type;
        const isWord = tokenIsKeywordOrIdentifier(this.state.type);
        const chAfterWord = isWord ? this.lookaheadCharCode() : null;
        if (chAfterWord === 58) {
          labeled = true;
          optional = false;
          label = this.parseIdentifier(true);
          this.expect(14);
          type = this.tsParseType();
        } else if (chAfterWord === 63) {
          optional = true;
          const wordName = this.state.value;
          const typeOrLabel = this.tsParseNonArrayType();
          if (this.lookaheadCharCode() === 58) {
            labeled = true;
            label = this.createIdentifier(this.startNodeAt(startLoc), wordName);
            this.expect(17);
            this.expect(14);
            type = this.tsParseType();
          } else {
            labeled = false;
            type = typeOrLabel;
            this.expect(17);
          }
        } else {
          type = this.tsParseType();
          optional = this.eat(17);
          labeled = this.eat(14);
        }
        if (labeled) {
          let labeledNode;
          if (label) {
            labeledNode = this.startNodeAt(startLoc);
            labeledNode.optional = optional;
            labeledNode.label = label;
            labeledNode.elementType = type;
            if (this.eat(17)) {
              labeledNode.optional = true;
              this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);
            }
          } else {
            labeledNode = this.startNodeAt(startLoc);
            labeledNode.optional = optional;
            this.raise(TSErrors.InvalidTupleMemberLabel, type);
            labeledNode.label = type;
            labeledNode.elementType = this.tsParseType();
          }
          type = this.finishNode(labeledNode, "TSNamedTupleMember");
        } else if (optional) {
          const optionalTypeNode = this.startNodeAt(startLoc);
          optionalTypeNode.typeAnnotation = type;
          type = this.finishNode(optionalTypeNode, "TSOptionalType");
        }
        if (rest) {
          const restNode = this.startNodeAt(restStartLoc);
          restNode.typeAnnotation = type;
          type = this.finishNode(restNode, "TSRestType");
        }
        return type;
      }
      tsParseParenthesizedType() {
        const node = this.startNode();
        this.expect(10);
        node.typeAnnotation = this.tsParseType();
        this.expect(11);
        return this.finishNode(node, "TSParenthesizedType");
      }
      tsParseFunctionOrConstructorType(type, abstract) {
        const node = this.startNode();
        if (type === "TSConstructorType") {
          node.abstract = !!abstract;
          if (abstract) this.next();
          this.next();
        }
        this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));
        return this.finishNode(node, type);
      }
      tsParseLiteralTypeNode() {
        const node = this.startNode();
        switch (this.state.type) {
          case 135:
          case 136:
          case 134:
          case 85:
          case 86:
            node.literal = super.parseExprAtom();
            break;
          default:
            this.unexpected();
        }
        return this.finishNode(node, "TSLiteralType");
      }
      tsParseTemplateLiteralType() {
        const node = this.startNode();
        node.literal = super.parseTemplate(false);
        return this.finishNode(node, "TSLiteralType");
      }
      parseTemplateSubstitution() {
        if (this.state.inType) return this.tsParseType();
        return super.parseTemplateSubstitution();
      }
      tsParseThisTypeOrThisTypePredicate() {
        const thisKeyword = this.tsParseThisTypeNode();
        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
          return this.tsParseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      }
      tsParseNonArrayType() {
        switch (this.state.type) {
          case 134:
          case 135:
          case 136:
          case 85:
          case 86:
            return this.tsParseLiteralTypeNode();
          case 53:
            if (this.state.value === "-") {
              const node = this.startNode();
              const nextToken = this.lookahead();
              if (nextToken.type !== 135 && nextToken.type !== 136) {
                this.unexpected();
              }
              node.literal = this.parseMaybeUnary();
              return this.finishNode(node, "TSLiteralType");
            }
            break;
          case 78:
            return this.tsParseThisTypeOrThisTypePredicate();
          case 87:
            return this.tsParseTypeQuery();
          case 83:
            return this.tsParseImportType();
          case 5:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
          case 0:
            return this.tsParseTupleType();
          case 10:
            return this.tsParseParenthesizedType();
          case 25:
          case 24:
            return this.tsParseTemplateLiteralType();
          default: {
            const {
              type
            } = this.state;
            if (tokenIsIdentifier(type) || type === 88 || type === 84) {
              const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
              if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                const node = this.startNode();
                this.next();
                return this.finishNode(node, nodeType);
              }
              return this.tsParseTypeReference();
            }
          }
        }
        throw this.unexpected();
      }
      tsParseArrayTypeOrHigher() {
        const {
          startLoc
        } = this.state;
        let type = this.tsParseNonArrayType();
        while (!this.hasPrecedingLineBreak() && this.eat(0)) {
          if (this.match(3)) {
            const node = this.startNodeAt(startLoc);
            node.elementType = type;
            this.expect(3);
            type = this.finishNode(node, "TSArrayType");
          } else {
            const node = this.startNodeAt(startLoc);
            node.objectType = type;
            node.indexType = this.tsParseType();
            this.expect(3);
            type = this.finishNode(node, "TSIndexedAccessType");
          }
        }
        return type;
      }
      tsParseTypeOperator() {
        const node = this.startNode();
        const operator = this.state.value;
        this.next();
        node.operator = operator;
        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
        if (operator === "readonly") {
          this.tsCheckTypeAnnotationForReadOnly(node);
        }
        return this.finishNode(node, "TSTypeOperator");
      }
      tsCheckTypeAnnotationForReadOnly(node) {
        switch (node.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;
          default:
            this.raise(TSErrors.UnexpectedReadonly, node);
        }
      }
      tsParseInferType() {
        const node = this.startNode();
        this.expectContextual(115);
        const typeParameter = this.startNode();
        typeParameter.name = this.tsParseTypeParameterName();
        typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
        node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        return this.finishNode(node, "TSInferType");
      }
      tsParseConstraintForInferType() {
        if (this.eat(81)) {
          const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
          if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
            return constraint;
          }
        }
      }
      tsParseTypeOperatorOrHigher() {
        const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
        return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
      }
      tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        const node = this.startNode();
        const hasLeadingOperator = this.eat(operator);
        const types2 = [];
        do {
          types2.push(parseConstituentType());
        } while (this.eat(operator));
        if (types2.length === 1 && !hasLeadingOperator) {
          return types2[0];
        }
        node.types = types2;
        return this.finishNode(node, kind);
      }
      tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
      }
      tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
      }
      tsIsStartOfFunctionType() {
        if (this.match(47)) {
          return true;
        }
        return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      }
      tsSkipParameterStart() {
        if (tokenIsIdentifier(this.state.type) || this.match(78)) {
          this.next();
          return true;
        }
        if (this.match(5)) {
          const {
            errors
          } = this.state;
          const previousErrorCount = errors.length;
          try {
            this.parseObjectLike(8, true);
            return errors.length === previousErrorCount;
          } catch (_unused) {
            return false;
          }
        }
        if (this.match(0)) {
          this.next();
          const {
            errors
          } = this.state;
          const previousErrorCount = errors.length;
          try {
            super.parseBindingList(3, 93, 1);
            return errors.length === previousErrorCount;
          } catch (_unused2) {
            return false;
          }
        }
        return false;
      }
      tsIsUnambiguouslyStartOfFunctionType() {
        this.next();
        if (this.match(11) || this.match(21)) {
          return true;
        }
        if (this.tsSkipParameterStart()) {
          if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
            return true;
          }
          if (this.match(11)) {
            this.next();
            if (this.match(19)) {
              return true;
            }
          }
        }
        return false;
      }
      tsParseTypeOrTypePredicateAnnotation(returnToken) {
        return this.tsInType(() => {
          const t = this.startNode();
          this.expect(returnToken);
          const node = this.startNode();
          const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
          if (asserts && this.match(78)) {
            let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
            if (thisTypePredicate.type === "TSThisType") {
              node.parameterName = thisTypePredicate;
              node.asserts = true;
              node.typeAnnotation = null;
              thisTypePredicate = this.finishNode(node, "TSTypePredicate");
            } else {
              this.resetStartLocationFromNode(thisTypePredicate, node);
              thisTypePredicate.asserts = true;
            }
            t.typeAnnotation = thisTypePredicate;
            return this.finishNode(t, "TSTypeAnnotation");
          }
          const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
          if (!typePredicateVariable) {
            if (!asserts) {
              return this.tsParseTypeAnnotation(false, t);
            }
            node.parameterName = this.parseIdentifier();
            node.asserts = asserts;
            node.typeAnnotation = null;
            t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
            return this.finishNode(t, "TSTypeAnnotation");
          }
          const type = this.tsParseTypeAnnotation(false);
          node.parameterName = typePredicateVariable;
          node.typeAnnotation = type;
          node.asserts = asserts;
          t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
          return this.finishNode(t, "TSTypeAnnotation");
        });
      }
      tsTryParseTypeOrTypePredicateAnnotation() {
        if (this.match(14)) {
          return this.tsParseTypeOrTypePredicateAnnotation(14);
        }
      }
      tsTryParseTypeAnnotation() {
        if (this.match(14)) {
          return this.tsParseTypeAnnotation();
        }
      }
      tsTryParseType() {
        return this.tsEatThenParseType(14);
      }
      tsParseTypePredicatePrefix() {
        const id = this.parseIdentifier();
        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
          this.next();
          return id;
        }
      }
      tsParseTypePredicateAsserts() {
        if (this.state.type !== 109) {
          return false;
        }
        const containsEsc = this.state.containsEsc;
        this.next();
        if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
          return false;
        }
        if (containsEsc) {
          this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
            reservedWord: "asserts"
          });
        }
        return true;
      }
      tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
        this.tsInType(() => {
          if (eatColon) this.expect(14);
          t.typeAnnotation = this.tsParseType();
        });
        return this.finishNode(t, "TSTypeAnnotation");
      }
      tsParseType() {
        assert(this.state.inType);
        const type = this.tsParseNonConditionalType();
        if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
          return type;
        }
        const node = this.startNodeAtNode(type);
        node.checkType = type;
        node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
        this.expect(17);
        node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        this.expect(14);
        node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        return this.finishNode(node, "TSConditionalType");
      }
      isAbstractConstructorSignature() {
        return this.isContextual(124) && this.isLookaheadContextual("new");
      }
      tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
          return this.tsParseFunctionOrConstructorType("TSFunctionType");
        }
        if (this.match(77)) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType");
        } else if (this.isAbstractConstructorSignature()) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
        }
        return this.tsParseUnionTypeOrHigher();
      }
      tsParseTypeAssertion() {
        if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);
        }
        const node = this.startNode();
        node.typeAnnotation = this.tsInType(() => {
          this.next();
          return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
        });
        this.expect(48);
        node.expression = this.parseMaybeUnary();
        return this.finishNode(node, "TSTypeAssertion");
      }
      tsParseHeritageClause(token) {
        const originalStartLoc = this.state.startLoc;
        const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
          const node = this.startNode();
          node.expression = this.tsParseEntityName(1 | 2);
          if (this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSExpressionWithTypeArguments");
        });
        if (!delimitedList.length) {
          this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {
            token
          });
        }
        return delimitedList;
      }
      tsParseInterfaceDeclaration(node, properties5 = {}) {
        if (this.hasFollowingLineBreak()) return null;
        this.expectContextual(129);
        if (properties5.declare) node.declare = true;
        if (tokenIsIdentifier(this.state.type)) {
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, 130);
        } else {
          node.id = null;
          this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);
        }
        node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        if (this.eat(81)) {
          node.extends = this.tsParseHeritageClause("extends");
        }
        const body = this.startNode();
        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node.body = this.finishNode(body, "TSInterfaceBody");
        return this.finishNode(node, "TSInterfaceDeclaration");
      }
      tsParseTypeAliasDeclaration(node) {
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, 2);
        node.typeAnnotation = this.tsInType(() => {
          node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
          this.expect(29);
          if (this.isContextual(114) && this.lookaheadCharCode() !== 46) {
            const node2 = this.startNode();
            this.next();
            return this.finishNode(node2, "TSIntrinsicKeyword");
          }
          return this.tsParseType();
        });
        this.semicolon();
        return this.finishNode(node, "TSTypeAliasDeclaration");
      }
      tsInTopLevelContext(cb) {
        if (this.curContext() !== types.brace) {
          const oldContext = this.state.context;
          this.state.context = [oldContext[0]];
          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        } else {
          return cb();
        }
      }
      tsInType(cb) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        try {
          return cb();
        } finally {
          this.state.inType = oldInType;
        }
      }
      tsInDisallowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = true;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsInAllowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = false;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsEatThenParseType(token) {
        if (this.match(token)) {
          return this.tsNextThenParseType();
        }
      }
      tsExpectThenParseType(token) {
        return this.tsInType(() => {
          this.expect(token);
          return this.tsParseType();
        });
      }
      tsNextThenParseType() {
        return this.tsInType(() => {
          this.next();
          return this.tsParseType();
        });
      }
      tsParseEnumMember() {
        const node = this.startNode();
        node.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
        if (this.eat(29)) {
          node.initializer = super.parseMaybeAssignAllowIn();
        }
        return this.finishNode(node, "TSEnumMember");
      }
      tsParseEnumDeclaration(node, properties5 = {}) {
        if (properties5.const) node.const = true;
        if (properties5.declare) node.declare = true;
        this.expectContextual(126);
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, node.const ? 8971 : 8459);
        this.expect(5);
        node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(8);
        return this.finishNode(node, "TSEnumDeclaration");
      }
      tsParseEnumBody() {
        const node = this.startNode();
        this.expect(5);
        node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(8);
        return this.finishNode(node, "TSEnumBody");
      }
      tsParseModuleBlock() {
        const node = this.startNode();
        this.scope.enter(0);
        this.expect(5);
        super.parseBlockOrModuleBlockBody(node.body = [], void 0, true, 8);
        this.scope.exit();
        return this.finishNode(node, "TSModuleBlock");
      }
      tsParseModuleOrNamespaceDeclaration(node, nested = false) {
        node.id = this.parseIdentifier();
        if (!nested) {
          this.checkIdentifier(node.id, 1024);
        }
        if (this.eat(16)) {
          const inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, true);
          node.body = inner;
        } else {
          this.scope.enter(1024);
          this.prodParam.enter(0);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseAmbientExternalModuleDeclaration(node) {
        if (this.isContextual(112)) {
          node.kind = "global";
          node.global = true;
          node.id = this.parseIdentifier();
        } else if (this.match(134)) {
          node.kind = "module";
          node.id = super.parseStringLiteral(this.state.value);
        } else {
          this.unexpected();
        }
        if (this.match(5)) {
          this.scope.enter(1024);
          this.prodParam.enter(0);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {
        node.isExport = isExport || false;
        node.id = maybeDefaultIdentifier || this.parseIdentifier();
        this.checkIdentifier(node.id, 4096);
        this.expect(29);
        const moduleReference = this.tsParseModuleReference();
        if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
          this.raise(TSErrors.ImportAliasHasImportType, moduleReference);
        }
        node.moduleReference = moduleReference;
        this.semicolon();
        return this.finishNode(node, "TSImportEqualsDeclaration");
      }
      tsIsExternalModuleReference() {
        return this.isContextual(119) && this.lookaheadCharCode() === 40;
      }
      tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
      }
      tsParseExternalModuleReference() {
        const node = this.startNode();
        this.expectContextual(119);
        this.expect(10);
        if (!this.match(134)) {
          this.unexpected();
        }
        node.expression = super.parseExprAtom();
        this.expect(11);
        this.sawUnambiguousESM = true;
        return this.finishNode(node, "TSExternalModuleReference");
      }
      tsLookAhead(f) {
        const state = this.state.clone();
        const res = f();
        this.state = state;
        return res;
      }
      tsTryParseAndCatch(f) {
        const result = this.tryParse((abort) => f() || abort());
        if (result.aborted || !result.node) return;
        if (result.error) this.state = result.failState;
        return result.node;
      }
      tsTryParse(f) {
        const state = this.state.clone();
        const result = f();
        if (result !== void 0 && result !== false) {
          return result;
        }
        this.state = state;
      }
      tsTryParseDeclare(node) {
        if (this.isLineTerminator()) {
          return;
        }
        const startType = this.state.type;
        return this.tsInAmbientContext(() => {
          switch (startType) {
            case 68:
              node.declare = true;
              return super.parseFunctionStatement(node, false, false);
            case 80:
              node.declare = true;
              return this.parseClass(node, true, false);
            case 126:
              return this.tsParseEnumDeclaration(node, {
                declare: true
              });
            case 112:
              return this.tsParseAmbientExternalModuleDeclaration(node);
            case 100:
              if (this.state.containsEsc) {
                return;
              }
            case 75:
            case 74:
              if (!this.match(75) || !this.isLookaheadContextual("enum")) {
                node.declare = true;
                return this.parseVarStatement(node, this.state.value, true);
              }
              this.expect(75);
              return this.tsParseEnumDeclaration(node, {
                const: true,
                declare: true
              });
            case 107:
              if (this.isUsing()) {
                this.raise(TSErrors.InvalidModifierOnUsingDeclaration, this.state.startLoc, "declare");
                node.declare = true;
                return this.parseVarStatement(node, "using", true);
              }
              break;
            case 96:
              if (this.isAwaitUsing()) {
                this.raise(TSErrors.InvalidModifierOnAwaitUsingDeclaration, this.state.startLoc, "declare");
                node.declare = true;
                this.next();
                return this.parseVarStatement(node, "await using", true);
              }
              break;
            case 129: {
              const result = this.tsParseInterfaceDeclaration(node, {
                declare: true
              });
              if (result) return result;
            }
            default:
              if (tokenIsIdentifier(startType)) {
                return this.tsParseDeclaration(node, this.state.type, true, null);
              }
          }
        });
      }
      tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.type, true, null);
      }
      tsParseDeclaration(node, type, next, decorators) {
        switch (type) {
          case 124:
            if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
              return this.tsParseAbstractDeclaration(node, decorators);
            }
            break;
          case 127:
            if (this.tsCheckLineTerminator(next)) {
              if (this.match(134)) {
                return this.tsParseAmbientExternalModuleDeclaration(node);
              } else if (tokenIsIdentifier(this.state.type)) {
                node.kind = "module";
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }
            }
            break;
          case 128:
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              node.kind = "namespace";
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }
            break;
          case 130:
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              return this.tsParseTypeAliasDeclaration(node);
            }
            break;
        }
      }
      tsCheckLineTerminator(next) {
        if (next) {
          if (this.hasFollowingLineBreak()) return false;
          this.next();
          return true;
        }
        return !this.isLineTerminator();
      }
      tsTryParseGenericAsyncArrowFunction(startLoc) {
        if (!this.match(47)) return;
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = true;
        const res = this.tsTryParseAndCatch(() => {
          const node = this.startNodeAt(startLoc);
          node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          super.parseFunctionParams(node);
          node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
          this.expect(19);
          return node;
        });
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        if (!res) return;
        return super.parseArrowExpression(res, null, true);
      }
      tsParseTypeArgumentsInExpression() {
        if (this.reScan_lt() !== 47) return;
        return this.tsParseTypeArguments();
      }
      tsParseTypeArguments() {
        const node = this.startNode();
        node.params = this.tsInType(() => this.tsInTopLevelContext(() => {
          this.expect(47);
          return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
        }));
        if (node.params.length === 0) {
          this.raise(TSErrors.EmptyTypeArguments, node);
        } else if (!this.state.inType && this.curContext() === types.brace) {
          this.reScan_lt_gt();
        }
        this.expect(48);
        return this.finishNode(node, "TSTypeParameterInstantiation");
      }
      tsIsDeclarationStart() {
        return tokenIsTSDeclarationStart(this.state.type);
      }
      isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart()) return false;
        return super.isExportDefaultSpecifier();
      }
      parseBindingElement(flags, decorators) {
        const startLoc = decorators.length ? decorators[0].loc.start : this.state.startLoc;
        const modified = {};
        this.tsParseModifiers({
          allowedModifiers: ["public", "private", "protected", "override", "readonly"]
        }, modified);
        const accessibility2 = modified.accessibility;
        const override = modified.override;
        const readonly = modified.readonly;
        if (!(flags & 4) && (accessibility2 || readonly || override)) {
          this.raise(TSErrors.UnexpectedParameterModifier, startLoc);
        }
        const left = this.parseMaybeDefault();
        if (flags & 2) {
          this.parseFunctionParamType(left);
        }
        const elt = this.parseMaybeDefault(left.loc.start, left);
        if (accessibility2 || readonly || override) {
          const pp = this.startNodeAt(startLoc);
          if (decorators.length) {
            pp.decorators = decorators;
          }
          if (accessibility2) pp.accessibility = accessibility2;
          if (readonly) pp.readonly = readonly;
          if (override) pp.override = override;
          if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
            this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);
          }
          pp.parameter = elt;
          return this.finishNode(pp, "TSParameterProperty");
        }
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      }
      isSimpleParameter(node) {
        return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
      }
      tsDisallowOptionalPattern(node) {
        for (const param of node.params) {
          if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) {
            this.raise(TSErrors.PatternIsOptional, param);
          }
        }
      }
      setArrowFunctionParameters(node, params, trailingCommaLoc) {
        super.setArrowFunctionParameters(node, params, trailingCommaLoc);
        this.tsDisallowOptionalPattern(node);
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        if (this.match(14)) {
          node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
        }
        const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
        if (bodilessType && !this.match(5) && this.isLineTerminator()) {
          return this.finishNode(node, bodilessType);
        }
        if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
          this.raise(TSErrors.DeclareFunctionHasImplementation, node);
          if (node.declare) {
            return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
          }
        }
        this.tsDisallowOptionalPattern(node);
        return super.parseFunctionBodyAndFinish(node, type, isMethod);
      }
      registerFunctionStatementId(node) {
        if (!node.body && node.id) {
          this.checkIdentifier(node.id, 1024);
        } else {
          super.registerFunctionStatementId(node);
        }
      }
      tsCheckForInvalidTypeCasts(items) {
        items.forEach((node) => {
          if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
            this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);
          }
        });
      }
      toReferencedList(exprList, isInParens) {
        this.tsCheckForInvalidTypeCasts(exprList);
        return exprList;
      }
      parseArrayLike(close, isTuple, refExpressionErrors) {
        const node = super.parseArrayLike(close, isTuple, refExpressionErrors);
        if (node.type === "ArrayExpression") {
          this.tsCheckForInvalidTypeCasts(node.elements);
        }
        return node;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        if (!this.hasPrecedingLineBreak() && this.match(35)) {
          this.state.canStartJSXElement = false;
          this.next();
          const nonNullExpression = this.startNodeAt(startLoc);
          nonNullExpression.expression = base;
          return this.finishNode(nonNullExpression, "TSNonNullExpression");
        }
        let isOptionalCall = false;
        if (this.match(18) && this.lookaheadCharCode() === 60) {
          if (noCalls) {
            state.stop = true;
            return base;
          }
          state.optionalChainMember = isOptionalCall = true;
          this.next();
        }
        if (this.match(47) || this.match(51)) {
          let missingParenErrorLoc;
          const result = this.tsTryParseAndCatch(() => {
            if (!noCalls && this.atPossibleAsyncArrow(base)) {
              const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
              if (asyncArrowFn) {
                state.stop = true;
                return asyncArrowFn;
              }
            }
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            if (!typeArguments) return;
            if (isOptionalCall && !this.match(10)) {
              missingParenErrorLoc = this.state.curPosition();
              return;
            }
            if (tokenIsTemplate(this.state.type)) {
              const result2 = super.parseTaggedTemplateExpression(base, startLoc, state);
              result2.typeParameters = typeArguments;
              return result2;
            }
            if (!noCalls && this.eat(10)) {
              const node2 = this.startNodeAt(startLoc);
              node2.callee = base;
              node2.arguments = this.parseCallExpressionArguments();
              this.tsCheckForInvalidTypeCasts(node2.arguments);
              node2.typeParameters = typeArguments;
              if (state.optionalChainMember) {
                node2.optional = isOptionalCall;
              }
              return this.finishCallExpression(node2, state.optionalChainMember);
            }
            const tokenType2 = this.state.type;
            if (tokenType2 === 48 || tokenType2 === 52 || tokenType2 !== 10 && tokenCanStartExpression(tokenType2) && !this.hasPrecedingLineBreak()) {
              return;
            }
            const node = this.startNodeAt(startLoc);
            node.expression = base;
            node.typeParameters = typeArguments;
            return this.finishNode(node, "TSInstantiationExpression");
          });
          if (missingParenErrorLoc) {
            this.unexpected(missingParenErrorLoc, 10);
          }
          if (result) {
            if (result.type === "TSInstantiationExpression") {
              if (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) {
                this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);
              }
              if (!this.match(16) && !this.match(18)) {
                result.expression = super.stopParseSubscript(base, state);
              }
            }
            return result;
          }
        }
        return super.parseSubscript(base, startLoc, noCalls, state);
      }
      parseNewCallee(node) {
        var _callee$extra;
        super.parseNewCallee(node);
        const {
          callee
        } = node;
        if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
          node.typeParameters = callee.typeParameters;
          node.callee = callee.expression;
        }
      }
      parseExprOp(left, leftStartLoc, minPrec) {
        let isSatisfies;
        if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
          const node = this.startNodeAt(leftStartLoc);
          node.expression = left;
          node.typeAnnotation = this.tsInType(() => {
            this.next();
            if (this.match(75)) {
              if (isSatisfies) {
                this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {
                  keyword: "const"
                });
              }
              return this.tsParseTypeReference();
            }
            return this.tsParseType();
          });
          this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
          this.reScan_lt_gt();
          return this.parseExprOp(node, leftStartLoc, minPrec);
        }
        return super.parseExprOp(left, leftStartLoc, minPrec);
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (!this.state.isAmbientContext) {
          super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
        }
      }
      checkImportReflection(node) {
        super.checkImportReflection(node);
        if (node.module && node.importKind !== "value") {
          this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
        }
      }
      checkDuplicateExports() {
      }
      isPotentialImportPhase(isExport) {
        if (super.isPotentialImportPhase(isExport)) return true;
        if (this.isContextual(130)) {
          const ch = this.lookaheadCharCode();
          return isExport ? ch === 123 || ch === 42 : ch !== 61;
        }
        return !isExport && this.isContextual(87);
      }
      applyImportPhase(node, isExport, phase, loc) {
        super.applyImportPhase(node, isExport, phase, loc);
        if (isExport) {
          node.exportKind = phase === "type" ? "type" : "value";
        } else {
          node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
        }
      }
      parseImport(node) {
        if (this.match(134)) {
          node.importKind = "value";
          return super.parseImport(node);
        }
        let importNode;
        if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
          node.importKind = "value";
          return this.tsParseImportEqualsDeclaration(node);
        } else if (this.isContextual(130)) {
          const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
          if (this.lookaheadCharCode() === 61) {
            return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
          } else {
            importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);
          }
        } else {
          importNode = super.parseImport(node);
        }
        if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
          this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);
        }
        return importNode;
      }
      parseExport(node, decorators) {
        if (this.match(83)) {
          const nodeImportEquals = node;
          this.next();
          let maybeDefaultIdentifier = null;
          if (this.isContextual(130) && this.isPotentialImportPhase(false)) {
            maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, false);
          } else {
            nodeImportEquals.importKind = "value";
          }
          const declaration = this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, true);
          return declaration;
        } else if (this.eat(29)) {
          const assign = node;
          assign.expression = super.parseExpression();
          this.semicolon();
          this.sawUnambiguousESM = true;
          return this.finishNode(assign, "TSExportAssignment");
        } else if (this.eatContextual(93)) {
          const decl = node;
          this.expectContextual(128);
          decl.id = this.parseIdentifier();
          this.semicolon();
          return this.finishNode(decl, "TSNamespaceExportDeclaration");
        } else {
          return super.parseExport(node, decorators);
        }
      }
      isAbstractClass() {
        return this.isContextual(124) && this.isLookaheadContextual("class");
      }
      parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          const cls = this.startNode();
          this.next();
          cls.abstract = true;
          return this.parseClass(cls, true, true);
        }
        if (this.match(129)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return super.parseExportDefaultExpression();
      }
      parseVarStatement(node, kind, allowMissingInitializer = false) {
        const {
          isAmbientContext
        } = this.state;
        const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
        if (!isAmbientContext) return declaration;
        if (!node.declare && (kind === "using" || kind === "await using")) {
          this.raiseOverwrite(TSErrors.UsingDeclarationInAmbientContext, node, kind);
          return declaration;
        }
        for (const {
          id,
          init
        } of declaration.declarations) {
          if (!init) continue;
          if (kind === "var" || kind === "let" || !!id.typeAnnotation) {
            this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);
          } else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) {
            this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);
          }
        }
        return declaration;
      }
      parseStatementContent(flags, decorators) {
        if (!this.state.containsEsc) {
          switch (this.state.type) {
            case 75: {
              if (this.isLookaheadContextual("enum")) {
                const node = this.startNode();
                this.expect(75);
                return this.tsParseEnumDeclaration(node, {
                  const: true
                });
              }
              break;
            }
            case 124:
            case 125: {
              if (this.nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine()) {
                const token = this.state.type;
                const node = this.startNode();
                this.next();
                const declaration = token === 125 ? this.tsTryParseDeclare(node) : this.tsParseAbstractDeclaration(node, decorators);
                if (declaration) {
                  if (token === 125) {
                    declaration.declare = true;
                  }
                  return declaration;
                } else {
                  node.expression = this.createIdentifier(this.startNodeAt(node.loc.start), token === 125 ? "declare" : "abstract");
                  this.semicolon(false);
                  return this.finishNode(node, "ExpressionStatement");
                }
              }
              break;
            }
            case 126:
              return this.tsParseEnumDeclaration(this.startNode());
            case 112: {
              const nextCh = this.lookaheadCharCode();
              if (nextCh === 123) {
                const node = this.startNode();
                return this.tsParseAmbientExternalModuleDeclaration(node);
              }
              break;
            }
            case 129: {
              const result = this.tsParseInterfaceDeclaration(this.startNode());
              if (result) return result;
              break;
            }
            case 127: {
              if (this.nextTokenIsIdentifierOrStringLiteralOnSameLine()) {
                const node = this.startNode();
                this.next();
                return this.tsParseDeclaration(node, 127, false, decorators);
              }
              break;
            }
            case 128: {
              if (this.nextTokenIsIdentifierOnSameLine()) {
                const node = this.startNode();
                this.next();
                return this.tsParseDeclaration(node, 128, false, decorators);
              }
              break;
            }
            case 130: {
              if (this.nextTokenIsIdentifierOnSameLine()) {
                const node = this.startNode();
                this.next();
                return this.tsParseTypeAliasDeclaration(node);
              }
              break;
            }
          }
        }
        return super.parseStatementContent(flags, decorators);
      }
      parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      }
      tsHasSomeModifiers(member, modifiers2) {
        return modifiers2.some((modifier) => {
          if (tsIsAccessModifier(modifier)) {
            return member.accessibility === modifier;
          }
          return !!member[modifier];
        });
      }
      tsIsStartOfStaticBlocks() {
        return this.isContextual(106) && this.lookaheadCharCode() === 123;
      }
      parseClassMember(classBody, member, state) {
        const modifiers2 = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
        this.tsParseModifiers({
          allowedModifiers: modifiers2,
          disallowedModifiers: ["in", "out"],
          stopOnStartOfClassStaticBlock: true,
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        }, member);
        const callParseClassMemberWithIsStatic = () => {
          if (this.tsIsStartOfStaticBlocks()) {
            this.next();
            this.next();
            if (this.tsHasSomeModifiers(member, modifiers2)) {
              this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());
            }
            super.parseClassStaticBlock(classBody, member);
          } else {
            this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
          }
        };
        if (member.declare) {
          this.tsInAmbientContext(callParseClassMemberWithIsStatic);
        } else {
          callParseClassMemberWithIsStatic();
        }
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const idx = this.tsTryParseIndexSignature(member);
        if (idx) {
          classBody.body.push(idx);
          if (member.abstract) {
            this.raise(TSErrors.IndexSignatureHasAbstract, member);
          }
          if (member.accessibility) {
            this.raise(TSErrors.IndexSignatureHasAccessibility, member, {
              modifier: member.accessibility
            });
          }
          if (member.declare) {
            this.raise(TSErrors.IndexSignatureHasDeclare, member);
          }
          if (member.override) {
            this.raise(TSErrors.IndexSignatureHasOverride, member);
          }
          return;
        }
        if (!this.state.inAbstractClass && member.abstract) {
          this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);
        }
        if (member.override) {
          if (!state.hadSuperClass) {
            this.raise(TSErrors.OverrideNotInSubClass, member);
          }
        }
        super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parsePostMemberNameModifiers(methodOrProp) {
        const optional = this.eat(17);
        if (optional) methodOrProp.optional = true;
        if (methodOrProp.readonly && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);
        }
        if (methodOrProp.declare && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);
        }
      }
      shouldParseExportDeclaration() {
        if (this.tsIsDeclarationStart()) return true;
        return super.shouldParseExportDeclaration();
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.match(17)) return expr;
        if (this.state.maybeInArrowParameters) {
          const nextCh = this.lookaheadCharCode();
          if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
            this.setOptionalParametersError(refExpressionErrors);
            return expr;
          }
        }
        return super.parseConditional(expr, startLoc, refExpressionErrors);
      }
      parseParenItem(node, startLoc) {
        const newNode = super.parseParenItem(node, startLoc);
        if (this.eat(17)) {
          newNode.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(14)) {
          const typeCastNode = this.startNodeAt(startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TSTypeCastExpression");
        }
        return node;
      }
      parseExportDeclaration(node) {
        if (!this.state.isAmbientContext && this.isContextual(125)) {
          return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
        }
        const startLoc = this.state.startLoc;
        const isDeclare = this.eatContextual(125);
        if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {
          throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
        }
        const isIdentifier = tokenIsIdentifier(this.state.type);
        const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
        if (!declaration) return null;
        if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
          node.exportKind = "type";
        }
        if (isDeclare && declaration.type !== "TSImportEqualsDeclaration") {
          this.resetStartLocation(declaration, startLoc);
          declaration.declare = true;
        }
        return declaration;
      }
      parseClassId(node, isStatement, optionalId, bindingType) {
        if ((!isStatement || optionalId) && this.isContextual(113)) {
          return;
        }
        super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        if (typeParameters) node.typeParameters = typeParameters;
      }
      parseClassPropertyAnnotation(node) {
        if (!node.optional) {
          if (this.eat(35)) {
            node.definite = true;
          } else if (this.eat(17)) {
            node.optional = true;
          }
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
      }
      parseClassProperty(node) {
        this.parseClassPropertyAnnotation(node);
        if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
          this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);
        }
        if (node.abstract && this.match(29)) {
          const {
            key
          } = node;
          this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {
            propertyName: key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`
          });
        }
        return super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        if (node.abstract) {
          this.raise(TSErrors.PrivateElementHasAbstract, node);
        }
        if (node.accessibility) {
          this.raise(TSErrors.PrivateElementHasAccessibility, node, {
            modifier: node.accessibility
          });
        }
        this.parseClassPropertyAnnotation(node);
        return super.parseClassPrivateProperty(node);
      }
      parseClassAccessorProperty(node) {
        this.parseClassPropertyAnnotation(node);
        if (node.optional) {
          this.raise(TSErrors.AccessorCannotBeOptional, node);
        }
        return super.parseClassAccessorProperty(node);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters && isConstructor) {
          this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);
        }
        const {
          declare = false,
          kind
        } = method;
        if (declare && (kind === "get" || kind === "set")) {
          this.raise(TSErrors.DeclareAccessor, method, {
            kind
          });
        }
        if (typeParameters) method.typeParameters = typeParameters;
        super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) method.typeParameters = typeParameters;
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      declareClassPrivateMethodInScope(node, kind) {
        if (node.type === "TSDeclareMethod") return;
        if (node.type === "MethodDefinition" && node.value.body == null) {
          return;
        }
        super.declareClassPrivateMethodInScope(node, kind);
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && (this.match(47) || this.match(51))) {
          node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
        }
        if (this.eatContextual(113)) {
          node.implements = this.tsParseHeritageClause("implements");
        }
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) prop.typeParameters = typeParameters;
        return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
      }
      parseFunctionParams(node, isConstructor) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) node.typeParameters = typeParameters;
        super.parseFunctionParams(node, isConstructor);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
          decl.definite = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          decl.id.typeAnnotation = type;
          this.resetEndLocation(decl.id);
        }
      }
      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(14)) {
          node.returnType = this.tsParseTypeAnnotation();
        }
        return super.parseAsyncArrowFromCallExpression(node, call);
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
        let state;
        let jsx2;
        let typeCast;
        if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
          state = this.state.clone();
          jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!jsx2.error) return jsx2.node;
          const {
            context
          } = this.state;
          const currentContext = context[context.length - 1];
          if (currentContext === types.j_oTag || currentContext === types.j_expr) {
            context.pop();
          }
        }
        if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
          return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        }
        if (!state || state === this.state) state = this.state.clone();
        let typeParameters;
        const arrow = this.tryParse((abort) => {
          var _expr$extra, _typeParameters;
          typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
          if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
            abort();
          }
          if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
            this.resetStartLocationFromNode(expr, typeParameters);
          }
          expr.typeParameters = typeParameters;
          return expr;
        }, state);
        if (!arrow.error && !arrow.aborted) {
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if (!jsx2) {
          assert(!this.hasPlugin("jsx"));
          typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!typeCast.error) return typeCast.node;
        }
        if ((_jsx2 = jsx2) != null && _jsx2.node) {
          this.state = jsx2.failState;
          return jsx2.node;
        }
        if (arrow.node) {
          this.state = arrow.failState;
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if ((_typeCast = typeCast) != null && _typeCast.node) {
          this.state = typeCast.failState;
          return typeCast.node;
        }
        throw ((_jsx3 = jsx2) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);
      }
      reportReservedArrowTypeParam(node) {
        var _node$extra2;
        if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra2 = node.extra) != null && _node$extra2.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedArrowTypeParam, node);
        }
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        if (!this.hasPlugin("jsx") && this.match(47)) {
          return this.tsParseTypeAssertion();
        }
        return super.parseMaybeUnary(refExpressionErrors, sawUnary);
      }
      parseArrow(node) {
        if (this.match(14)) {
          const result = this.tryParse((abort) => {
            const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
            if (this.canInsertSemicolon() || !this.match(19)) abort();
            return returnType;
          });
          if (result.aborted) return;
          if (!result.thrown) {
            if (result.error) this.state = result.failState;
            node.returnType = result.node;
          }
        }
        return super.parseArrow(node);
      }
      parseFunctionParamType(param) {
        if (this.eat(17)) {
          param.optional = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) param.typeAnnotation = type;
        this.resetEndLocation(param);
        return param;
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "TSTypeCastExpression":
            return this.isAssignable(node.expression, isBinding);
          case "TSParameterProperty":
            return true;
          default:
            return super.isAssignable(node, isBinding);
        }
      }
      toAssignable(node, isLHS = false) {
        switch (node.type) {
          case "ParenthesizedExpression":
            this.toAssignableParenthesizedExpression(node, isLHS);
            break;
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            if (isLHS) {
              this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);
            } else {
              this.raise(TSErrors.UnexpectedTypeCastInParameter, node);
            }
            this.toAssignable(node.expression, isLHS);
            break;
          case "AssignmentExpression":
            if (!isLHS && node.left.type === "TSTypeCastExpression") {
              node.left = this.typeCastToParameter(node.left);
            }
          default:
            super.toAssignable(node, isLHS);
        }
      }
      toAssignableParenthesizedExpression(node, isLHS) {
        switch (node.expression.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
          case "ParenthesizedExpression":
            this.toAssignable(node.expression, isLHS);
            break;
          default:
            super.toAssignable(node, isLHS);
        }
      }
      checkToRestConversion(node, allowPattern) {
        switch (node.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSTypeAssertion":
          case "TSNonNullExpression":
            this.checkToRestConversion(node.expression, false);
            break;
          default:
            super.checkToRestConversion(node, allowPattern);
        }
      }
      isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding) {
        switch (type) {
          case "TSTypeCastExpression":
            return true;
          case "TSParameterProperty":
            return "parameter";
          case "TSNonNullExpression":
            return "expression";
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSTypeAssertion":
            return (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true];
          default:
            return super.isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding);
        }
      }
      parseBindingAtom() {
        if (this.state.type === 78) {
          return this.parseIdentifier(true);
        }
        return super.parseBindingAtom();
      }
      parseMaybeDecoratorArguments(expr, startLoc) {
        if (this.match(47) || this.match(51)) {
          const typeArguments = this.tsParseTypeArgumentsInExpression();
          if (this.match(10)) {
            const call = super.parseMaybeDecoratorArguments(expr, startLoc);
            call.typeParameters = typeArguments;
            return call;
          }
          this.unexpected(null, 10);
        }
        return super.parseMaybeDecoratorArguments(expr, startLoc);
      }
      checkCommaAfterRest(close) {
        if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
          this.next();
          return false;
        }
        return super.checkCommaAfterRest(close);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(35) || this.match(14) || super.isClassProperty();
      }
      parseMaybeDefault(startLoc, left) {
        const node = super.parseMaybeDefault(startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);
        }
        return node;
      }
      getTokenFromCode(code3) {
        if (this.state.inType) {
          if (code3 === 62) {
            this.finishOp(48, 1);
            return;
          }
          if (code3 === 60) {
            this.finishOp(47, 1);
            return;
          }
        }
        super.getTokenFromCode(code3);
      }
      reScan_lt_gt() {
        const {
          type
        } = this.state;
        if (type === 47) {
          this.state.pos -= 1;
          this.readToken_lt();
        } else if (type === 48) {
          this.state.pos -= 1;
          this.readToken_gt();
        }
      }
      reScan_lt() {
        const {
          type
        } = this.state;
        if (type === 51) {
          this.state.pos -= 2;
          this.finishOp(47, 1);
          return 47;
        }
        return type;
      }
      toAssignableListItem(exprList, index, isLHS) {
        const node = exprList[index];
        if (node.type === "TSTypeCastExpression") {
          exprList[index] = this.typeCastToParameter(node);
        }
        super.toAssignableListItem(exprList, index, isLHS);
      }
      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
        return node.expression;
      }
      shouldParseArrow(params) {
        if (this.match(14)) {
          return params.every((expr) => this.isAssignable(expr, true));
        }
        return super.shouldParseArrow(params);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      canHaveLeadingDecorator() {
        return super.canHaveLeadingDecorator() || this.isAbstractClass();
      }
      jsxParseOpeningElementAfterName(node) {
        if (this.match(47) || this.match(51)) {
          const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
          if (typeArguments) {
            node.typeParameters = typeArguments;
          }
        }
        return super.jsxParseOpeningElementAfterName(node);
      }
      getGetterSetterExpectedParamCount(method) {
        const baseCount = super.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        const firstParam = params[0];
        const hasContextParam = firstParam && this.isThisParam(firstParam);
        return hasContextParam ? baseCount + 1 : baseCount;
      }
      parseCatchClauseParam() {
        const param = super.parseCatchClauseParam();
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          param.typeAnnotation = type;
          this.resetEndLocation(param);
        }
        return param;
      }
      tsInAmbientContext(cb) {
        const {
          isAmbientContext: oldIsAmbientContext,
          strict: oldStrict
        } = this.state;
        this.state.isAmbientContext = true;
        this.state.strict = false;
        try {
          return cb();
        } finally {
          this.state.isAmbientContext = oldIsAmbientContext;
          this.state.strict = oldStrict;
        }
      }
      parseClass(node, isStatement, optionalId) {
        const oldInAbstractClass = this.state.inAbstractClass;
        this.state.inAbstractClass = !!node.abstract;
        try {
          return super.parseClass(node, isStatement, optionalId);
        } finally {
          this.state.inAbstractClass = oldInAbstractClass;
        }
      }
      tsParseAbstractDeclaration(node, decorators) {
        if (this.match(80)) {
          node.abstract = true;
          return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
        } else if (this.isContextual(129)) {
          if (!this.hasFollowingLineBreak()) {
            node.abstract = true;
            this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifier, node);
            return this.tsParseInterfaceDeclaration(node);
          } else {
            return null;
          }
        }
        throw this.unexpected(null, 80);
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
        const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        if (method.abstract || method.type === "TSAbstractMethodDefinition") {
          const hasEstreePlugin = this.hasPlugin("estree");
          const methodFn = hasEstreePlugin ? method.value : method;
          if (methodFn.body) {
            const {
              key
            } = method;
            this.raise(TSErrors.AbstractMethodHasImplementation, method, {
              methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`
            });
          }
        }
        return method;
      }
      tsParseTypeParameterName() {
        const typeName = this.parseIdentifier();
        return typeName.name;
      }
      shouldParseAsAmbientContext() {
        return !!this.getPluginOption("typescript", "dts");
      }
      parse() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.parse();
      }
      getExpression() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.getExpression();
      }
      parseExportSpecifier(node, isString2, isInTypeExport, isMaybeTypeOnly) {
        if (!isString2 && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
          return this.finishNode(node, "ExportSpecifier");
        }
        node.exportKind = "value";
        return super.parseExportSpecifier(node, isString2, isInTypeExport, isMaybeTypeOnly);
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (!importedIsString && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
          return this.finishNode(specifier, "ImportSpecifier");
        }
        specifier.importKind = "value";
        return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);
      }
      parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
        const leftOfAsKey = isImport ? "imported" : "local";
        const rightOfAsKey = isImport ? "local" : "exported";
        let leftOfAs = node[leftOfAsKey];
        let rightOfAs;
        let hasTypeSpecifier = false;
        let canParseAsKeyword = true;
        const loc = leftOfAs.loc.start;
        if (this.isContextual(93)) {
          const firstAs = this.parseIdentifier();
          if (this.isContextual(93)) {
            const secondAs = this.parseIdentifier();
            if (tokenIsKeywordOrIdentifier(this.state.type)) {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
              rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
              canParseAsKeyword = false;
            } else {
              rightOfAs = secondAs;
              canParseAsKeyword = false;
            }
          } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            canParseAsKeyword = false;
            rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
          } else {
            hasTypeSpecifier = true;
            leftOfAs = firstAs;
          }
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          hasTypeSpecifier = true;
          if (isImport) {
            leftOfAs = this.parseIdentifier(true);
            if (!this.isContextual(93)) {
              this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
            }
          } else {
            leftOfAs = this.parseModuleExportName();
          }
        }
        if (hasTypeSpecifier && isInTypeOnlyImportExport) {
          this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);
        }
        node[leftOfAsKey] = leftOfAs;
        node[rightOfAsKey] = rightOfAs;
        const kindKey = isImport ? "importKind" : "exportKind";
        node[kindKey] = hasTypeSpecifier ? "type" : "value";
        if (canParseAsKeyword && this.eatContextual(93)) {
          node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
        }
        if (!node[rightOfAsKey]) {
          node[rightOfAsKey] = this.cloneIdentifier(node[leftOfAsKey]);
        }
        if (isImport) {
          this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
        }
      }
      fillOptionalPropertiesForTSESLint(node) {
        var _node$directive, _node$decorators, _node$optional, _node$typeAnnotation, _node$accessibility, _node$decorators2, _node$override, _node$readonly, _node$static, _node$declare, _node$returnType, _node$typeParameters, _node$optional2, _node$optional3, _node$accessibility2, _node$readonly2, _node$static2, _node$declare2, _node$definite, _node$readonly3, _node$typeAnnotation2, _node$accessibility3, _node$decorators3, _node$override2, _node$optional4, _node$id, _node$abstract, _node$declare3, _node$decorators4, _node$implements, _node$superTypeArgume, _node$typeParameters2, _node$declare4, _node$definite2, _node$const, _node$declare5, _node$computed, _node$qualifier, _node$options, _node$declare6, _node$extends, _node$optional5, _node$readonly4, _node$declare7, _node$global, _node$const2, _node$in, _node$out;
        switch (node.type) {
          case "ExpressionStatement":
            (_node$directive = node.directive) != null ? _node$directive : node.directive = void 0;
            return;
          case "RestElement":
            node.value = void 0;
          case "Identifier":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "ObjectPattern":
            (_node$decorators = node.decorators) != null ? _node$decorators : node.decorators = [];
            (_node$optional = node.optional) != null ? _node$optional : node.optional = false;
            (_node$typeAnnotation = node.typeAnnotation) != null ? _node$typeAnnotation : node.typeAnnotation = void 0;
            return;
          case "TSParameterProperty":
            (_node$accessibility = node.accessibility) != null ? _node$accessibility : node.accessibility = void 0;
            (_node$decorators2 = node.decorators) != null ? _node$decorators2 : node.decorators = [];
            (_node$override = node.override) != null ? _node$override : node.override = false;
            (_node$readonly = node.readonly) != null ? _node$readonly : node.readonly = false;
            (_node$static = node.static) != null ? _node$static : node.static = false;
            return;
          case "TSEmptyBodyFunctionExpression":
            node.body = null;
          case "TSDeclareFunction":
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ClassMethod":
          case "ClassPrivateMethod":
            (_node$declare = node.declare) != null ? _node$declare : node.declare = false;
            (_node$returnType = node.returnType) != null ? _node$returnType : node.returnType = void 0;
            (_node$typeParameters = node.typeParameters) != null ? _node$typeParameters : node.typeParameters = void 0;
            return;
          case "Property":
            (_node$optional2 = node.optional) != null ? _node$optional2 : node.optional = false;
            return;
          case "TSMethodSignature":
          case "TSPropertySignature":
            (_node$optional3 = node.optional) != null ? _node$optional3 : node.optional = false;
          case "TSIndexSignature":
            (_node$accessibility2 = node.accessibility) != null ? _node$accessibility2 : node.accessibility = void 0;
            (_node$readonly2 = node.readonly) != null ? _node$readonly2 : node.readonly = false;
            (_node$static2 = node.static) != null ? _node$static2 : node.static = false;
            return;
          case "TSAbstractPropertyDefinition":
          case "PropertyDefinition":
          case "TSAbstractAccessorProperty":
          case "AccessorProperty":
            (_node$declare2 = node.declare) != null ? _node$declare2 : node.declare = false;
            (_node$definite = node.definite) != null ? _node$definite : node.definite = false;
            (_node$readonly3 = node.readonly) != null ? _node$readonly3 : node.readonly = false;
            (_node$typeAnnotation2 = node.typeAnnotation) != null ? _node$typeAnnotation2 : node.typeAnnotation = void 0;
          case "TSAbstractMethodDefinition":
          case "MethodDefinition":
            (_node$accessibility3 = node.accessibility) != null ? _node$accessibility3 : node.accessibility = void 0;
            (_node$decorators3 = node.decorators) != null ? _node$decorators3 : node.decorators = [];
            (_node$override2 = node.override) != null ? _node$override2 : node.override = false;
            (_node$optional4 = node.optional) != null ? _node$optional4 : node.optional = false;
            return;
          case "ClassExpression":
            (_node$id = node.id) != null ? _node$id : node.id = null;
          case "ClassDeclaration":
            (_node$abstract = node.abstract) != null ? _node$abstract : node.abstract = false;
            (_node$declare3 = node.declare) != null ? _node$declare3 : node.declare = false;
            (_node$decorators4 = node.decorators) != null ? _node$decorators4 : node.decorators = [];
            (_node$implements = node.implements) != null ? _node$implements : node.implements = [];
            (_node$superTypeArgume = node.superTypeArguments) != null ? _node$superTypeArgume : node.superTypeArguments = void 0;
            (_node$typeParameters2 = node.typeParameters) != null ? _node$typeParameters2 : node.typeParameters = void 0;
            return;
          case "TSTypeAliasDeclaration":
          case "VariableDeclaration":
            (_node$declare4 = node.declare) != null ? _node$declare4 : node.declare = false;
            return;
          case "VariableDeclarator":
            (_node$definite2 = node.definite) != null ? _node$definite2 : node.definite = false;
            return;
          case "TSEnumDeclaration":
            (_node$const = node.const) != null ? _node$const : node.const = false;
            (_node$declare5 = node.declare) != null ? _node$declare5 : node.declare = false;
            return;
          case "TSEnumMember":
            (_node$computed = node.computed) != null ? _node$computed : node.computed = false;
            return;
          case "TSImportType":
            (_node$qualifier = node.qualifier) != null ? _node$qualifier : node.qualifier = null;
            (_node$options = node.options) != null ? _node$options : node.options = null;
            return;
          case "TSInterfaceDeclaration":
            (_node$declare6 = node.declare) != null ? _node$declare6 : node.declare = false;
            (_node$extends = node.extends) != null ? _node$extends : node.extends = [];
            return;
          case "TSMappedType":
            (_node$optional5 = node.optional) != null ? _node$optional5 : node.optional = false;
            (_node$readonly4 = node.readonly) != null ? _node$readonly4 : node.readonly = void 0;
            return;
          case "TSModuleDeclaration":
            (_node$declare7 = node.declare) != null ? _node$declare7 : node.declare = false;
            (_node$global = node.global) != null ? _node$global : node.global = node.kind === "global";
            return;
          case "TSTypeParameter":
            (_node$const2 = node.const) != null ? _node$const2 : node.const = false;
            (_node$in = node.in) != null ? _node$in : node.in = false;
            (_node$out = node.out) != null ? _node$out : node.out = false;
            return;
        }
      }
      chStartsBindingIdentifierAndNotRelationalOperator(ch, pos) {
        if (isIdentifierStart2(ch)) {
          keywordAndTSRelationalOperator.lastIndex = pos;
          if (keywordAndTSRelationalOperator.test(this.input)) {
            const endCh = this.codePointAtPos(keywordAndTSRelationalOperator.lastIndex);
            if (!isIdentifierChar(endCh) && endCh !== 92) {
              return false;
            }
          }
          return true;
        } else if (ch === 92) {
          return true;
        } else {
          return false;
        }
      }
      nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine() {
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        return this.chStartsBindingIdentifierAndNotRelationalOperator(nextCh, next);
      }
      nextTokenIsIdentifierOrStringLiteralOnSameLine() {
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        return this.chStartsBindingIdentifier(nextCh, next) || nextCh === 34 || nextCh === 39;
      }
    };
    function isPossiblyLiteralEnum(expression) {
      if (expression.type !== "MemberExpression") return false;
      const {
        computed,
        property: property4
      } = expression;
      if (computed && property4.type !== "StringLiteral" && (property4.type !== "TemplateLiteral" || property4.expressions.length > 0)) {
        return false;
      }
      return isUncomputedMemberExpressionChain(expression.object);
    }
    function isValidAmbientConstInitializer(expression, estree2) {
      var _expression$extra;
      const {
        type
      } = expression;
      if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {
        return false;
      }
      if (estree2) {
        if (type === "Literal") {
          const {
            value
          } = expression;
          if (typeof value === "string" || typeof value === "boolean") {
            return true;
          }
        }
      } else {
        if (type === "StringLiteral" || type === "BooleanLiteral") {
          return true;
        }
      }
      if (isNumber(expression, estree2) || isNegativeNumber(expression, estree2)) {
        return true;
      }
      if (type === "TemplateLiteral" && expression.expressions.length === 0) {
        return true;
      }
      if (isPossiblyLiteralEnum(expression)) {
        return true;
      }
      return false;
    }
    function isNumber(expression, estree2) {
      if (estree2) {
        return expression.type === "Literal" && (typeof expression.value === "number" || "bigint" in expression);
      }
      return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
    }
    function isNegativeNumber(expression, estree2) {
      if (expression.type === "UnaryExpression") {
        const {
          operator,
          argument
        } = expression;
        if (operator === "-" && isNumber(argument, estree2)) {
          return true;
        }
      }
      return false;
    }
    function isUncomputedMemberExpressionChain(expression) {
      if (expression.type === "Identifier") return true;
      if (expression.type !== "MemberExpression" || expression.computed) {
        return false;
      }
      return isUncomputedMemberExpressionChain(expression.object);
    }
    var PlaceholderErrors = ParseErrorEnum`placeholders`({
      ClassNameIsRequired: "A class name is required.",
      UnexpectedSpace: "Unexpected space in placeholder."
    });
    var placeholders3 = (superClass) => class PlaceholdersParserMixin extends superClass {
      parsePlaceholder(expectedNode) {
        if (this.match(133)) {
          const node = this.startNode();
          this.next();
          this.assertNoSpace();
          node.name = super.parseIdentifier(true);
          this.assertNoSpace();
          this.expect(133);
          return this.finishPlaceholder(node, expectedNode);
        }
      }
      finishPlaceholder(node, expectedNode) {
        let placeholder = node;
        if (!placeholder.expectedNode || !placeholder.type) {
          placeholder = this.finishNode(placeholder, "Placeholder");
        }
        placeholder.expectedNode = expectedNode;
        return placeholder;
      }
      getTokenFromCode(code3) {
        if (code3 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
          this.finishOp(133, 2);
        } else {
          super.getTokenFromCode(code3);
        }
      }
      parseExprAtom(refExpressionErrors) {
        return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
      }
      parseIdentifier(liberal) {
        return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (word !== void 0) {
          super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
        }
      }
      cloneIdentifier(node) {
        const cloned = super.cloneIdentifier(node);
        if (cloned.type === "Placeholder") {
          cloned.expectedNode = node.expectedNode;
        }
        return cloned;
      }
      cloneStringLiteral(node) {
        if (node.type === "Placeholder") {
          return this.cloneIdentifier(node);
        }
        return super.cloneStringLiteral(node);
      }
      parseBindingAtom() {
        return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
      }
      isValidLVal(type, disallowCallExpression, isParenthesized, binding) {
        return type === "Placeholder" || super.isValidLVal(type, disallowCallExpression, isParenthesized, binding);
      }
      toAssignable(node, isLHS) {
        if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
          node.expectedNode = "Pattern";
        } else {
          super.toAssignable(node, isLHS);
        }
      }
      chStartsBindingIdentifier(ch, pos) {
        if (super.chStartsBindingIdentifier(ch, pos)) {
          return true;
        }
        const next = this.nextTokenStart();
        if (this.input.charCodeAt(next) === 37 && this.input.charCodeAt(next + 1) === 37) {
          return true;
        }
        return false;
      }
      verifyBreakContinue(node, isBreak) {
        var _node$label;
        if (((_node$label = node.label) == null ? void 0 : _node$label.type) === "Placeholder") return;
        super.verifyBreakContinue(node, isBreak);
      }
      parseExpressionStatement(node, expr) {
        var _expr$extra;
        if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
          return super.parseExpressionStatement(node, expr);
        }
        if (this.match(14)) {
          const stmt = node;
          stmt.label = this.finishPlaceholder(expr, "Identifier");
          this.next();
          stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
          return this.finishNode(stmt, "LabeledStatement");
        }
        this.semicolon();
        const stmtPlaceholder = node;
        stmtPlaceholder.name = expr.name;
        return this.finishPlaceholder(stmtPlaceholder, "Statement");
      }
      parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
        return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
      }
      parseFunctionId(requireId) {
        return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
      }
      parseClass(node, isStatement, optionalId) {
        const type = isStatement ? "ClassDeclaration" : "ClassExpression";
        this.next();
        const oldStrict = this.state.strict;
        const placeholder = this.parsePlaceholder("Identifier");
        if (placeholder) {
          if (this.match(81) || this.match(133) || this.match(5)) {
            node.id = placeholder;
          } else if (optionalId || !isStatement) {
            node.id = null;
            node.body = this.finishPlaceholder(placeholder, "ClassBody");
            return this.finishNode(node, type);
          } else {
            throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);
          }
        } else {
          this.parseClassId(node, isStatement, optionalId);
        }
        super.parseClassSuper(node);
        node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, type);
      }
      parseExport(node, decorators) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return super.parseExport(node, decorators);
        const node2 = node;
        if (!this.isContextual(98) && !this.match(12)) {
          node2.specifiers = [];
          node2.source = null;
          node2.declaration = this.finishPlaceholder(placeholder, "Declaration");
          return this.finishNode(node2, "ExportNamedDeclaration");
        }
        this.expectPlugin("exportDefaultFrom");
        const specifier = this.startNode();
        specifier.exported = placeholder;
        node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return super.parseExport(node2, decorators);
      }
      isExportDefaultSpecifier() {
        if (this.match(65)) {
          const next = this.nextTokenStart();
          if (this.isUnparsedContextual(next, "from")) {
            if (this.input.startsWith(tokenLabelName(133), this.nextTokenStartSince(next + 4))) {
              return true;
            }
          }
        }
        return super.isExportDefaultSpecifier();
      }
      maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
        var _specifiers;
        if ((_specifiers = node.specifiers) != null && _specifiers.length) {
          return true;
        }
        return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
      }
      checkExport(node) {
        const {
          specifiers
        } = node;
        if (specifiers != null && specifiers.length) {
          node.specifiers = specifiers.filter((node2) => node2.exported.type === "Placeholder");
        }
        super.checkExport(node);
        node.specifiers = specifiers;
      }
      parseImport(node) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return super.parseImport(node);
        node.specifiers = [];
        if (!this.isContextual(98) && !this.match(12)) {
          node.source = this.finishPlaceholder(placeholder, "StringLiteral");
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
        const specifier = this.startNodeAtNode(placeholder);
        specifier.local = placeholder;
        node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
        if (this.eat(12)) {
          const hasStarImport = this.maybeParseStarImportSpecifier(node);
          if (!hasStarImport) this.parseNamedImportSpecifiers(node);
        }
        this.expectContextual(98);
        node.source = this.parseImportSource();
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      }
      parseImportSource() {
        return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
      }
      assertNoSpace() {
        if (this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index)) {
          this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);
        }
      }
    };
    var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
      parseV8Intrinsic() {
        if (this.match(54)) {
          const v8IntrinsicStartLoc = this.state.startLoc;
          const node = this.startNode();
          this.next();
          if (tokenIsIdentifier(this.state.type)) {
            const name50 = this.parseIdentifierName();
            const identifier = this.createIdentifier(node, name50);
            this.castNodeTo(identifier, "V8IntrinsicIdentifier");
            if (this.match(10)) {
              return identifier;
            }
          }
          this.unexpected(v8IntrinsicStartLoc);
        }
      }
      parseExprAtom(refExpressionErrors) {
        return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
      }
    };
    var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
    var TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
    function validatePlugins(pluginsMap) {
      if (pluginsMap.has("decorators")) {
        if (pluginsMap.has("decorators-legacy")) {
          throw new Error("Cannot use the decorators and decorators-legacy plugin together");
        }
        const decoratorsBeforeExport = pluginsMap.get("decorators").decoratorsBeforeExport;
        if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
          throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
        }
        const allowCallParenthesized = pluginsMap.get("decorators").allowCallParenthesized;
        if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
          throw new Error("'allowCallParenthesized' must be a boolean.");
        }
      }
      if (pluginsMap.has("flow") && pluginsMap.has("typescript")) {
        throw new Error("Cannot combine flow and typescript plugins.");
      }
      if (pluginsMap.has("placeholders") && pluginsMap.has("v8intrinsic")) {
        throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
      }
      if (pluginsMap.has("pipelineOperator")) {
        var _pluginsMap$get2;
        const proposal = pluginsMap.get("pipelineOperator").proposal;
        if (!PIPELINE_PROPOSALS.includes(proposal)) {
          const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
          throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
        }
        if (proposal === "hack") {
          var _pluginsMap$get;
          if (pluginsMap.has("placeholders")) {
            throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
          }
          if (pluginsMap.has("v8intrinsic")) {
            throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
          }
          const topicToken = pluginsMap.get("pipelineOperator").topicToken;
          if (!TOPIC_TOKENS.includes(topicToken)) {
            const tokenList = TOPIC_TOKENS.map((t) => `"${t}"`).join(", ");
            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
          }
          if (topicToken === "#" && ((_pluginsMap$get = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get.syntaxType) === "hash") {
            throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
          }
        } else if (proposal === "smart" && ((_pluginsMap$get2 = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get2.syntaxType) === "hash") {
          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
        }
      }
      if (pluginsMap.has("moduleAttributes")) {
        if (pluginsMap.has("deprecatedImportAssert") || pluginsMap.has("importAssertions")) {
          throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
        }
        const moduleAttributesVersionPluginOption = pluginsMap.get("moduleAttributes").version;
        if (moduleAttributesVersionPluginOption !== "may-2020") {
          throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
        }
      }
      if (pluginsMap.has("importAssertions")) {
        if (pluginsMap.has("deprecatedImportAssert")) {
          throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
        }
      }
      if (pluginsMap.has("deprecatedImportAssert")) ;
      else if (pluginsMap.has("importAttributes") && pluginsMap.get("importAttributes").deprecatedAssertSyntax) {
        pluginsMap.set("deprecatedImportAssert", {});
      }
      if (pluginsMap.has("recordAndTuple")) {
        const syntaxType = pluginsMap.get("recordAndTuple").syntaxType;
        if (syntaxType != null) {
          const RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
          if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType)) {
            throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
          }
        }
      }
      if (pluginsMap.has("asyncDoExpressions") && !pluginsMap.has("doExpressions")) {
        const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
        error.missingPlugins = "doExpressions";
        throw error;
      }
      if (pluginsMap.has("optionalChainingAssign") && pluginsMap.get("optionalChainingAssign").version !== "2023-07") {
        throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
      }
      if (pluginsMap.has("discardBinding") && pluginsMap.get("discardBinding").syntaxType !== "void") {
        throw new Error("The 'discardBinding' plugin requires a 'syntaxType' option. Currently the only supported value is 'void'.");
      }
    }
    var mixinPlugins = {
      estree,
      jsx,
      flow,
      typescript,
      v8intrinsic,
      placeholders: placeholders3
    };
    var mixinPluginNames = Object.keys(mixinPlugins);
    var ExpressionParser = class extends LValParser {
      checkProto(prop, isRecord, sawProto, refExpressionErrors) {
        if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
          return sawProto;
        }
        const key = prop.key;
        const name50 = key.type === "Identifier" ? key.name : key.value;
        if (name50 === "__proto__") {
          if (isRecord) {
            this.raise(Errors.RecordNoProto, key);
            return true;
          }
          if (sawProto) {
            if (refExpressionErrors) {
              if (refExpressionErrors.doubleProtoLoc === null) {
                refExpressionErrors.doubleProtoLoc = key.loc.start;
              }
            } else {
              this.raise(Errors.DuplicateProto, key);
            }
          }
          return true;
        }
        return sawProto;
      }
      shouldExitDescending(expr, potentialArrowAt) {
        return expr.type === "ArrowFunctionExpression" && this.offsetToSourcePos(expr.start) === potentialArrowAt;
      }
      getExpression() {
        this.enterInitialScopes();
        this.nextToken();
        if (this.match(140)) {
          throw this.raise(Errors.ParseExpressionEmptyInput, this.state.startLoc);
        }
        const expr = this.parseExpression();
        if (!this.match(140)) {
          throw this.raise(Errors.ParseExpressionExpectsEOF, this.state.startLoc, {
            unexpected: this.input.codePointAt(this.state.start)
          });
        }
        this.finalizeRemainingComments();
        expr.comments = this.comments;
        expr.errors = this.state.errors;
        if (this.optionFlags & 256) {
          expr.tokens = this.tokens;
        }
        return expr;
      }
      parseExpression(disallowIn, refExpressionErrors) {
        if (disallowIn) {
          return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
        }
        return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
      }
      parseExpressionBase(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const expr = this.parseMaybeAssign(refExpressionErrors);
        if (this.match(12)) {
          const node = this.startNodeAt(startLoc);
          node.expressions = [expr];
          while (this.eat(12)) {
            node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
          }
          this.toReferencedList(node.expressions);
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      }
      parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
        return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
        return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      setOptionalParametersError(refExpressionErrors) {
        refExpressionErrors.optionalParametersLoc = this.state.startLoc;
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        const startLoc = this.state.startLoc;
        const isYield = this.isContextual(108);
        if (isYield) {
          if (this.prodParam.hasYield) {
            this.next();
            let left2 = this.parseYield(startLoc);
            if (afterLeftParse) {
              left2 = afterLeftParse.call(this, left2, startLoc);
            }
            return left2;
          }
        }
        let ownExpressionErrors;
        if (refExpressionErrors) {
          ownExpressionErrors = false;
        } else {
          refExpressionErrors = new ExpressionErrors();
          ownExpressionErrors = true;
        }
        const {
          type
        } = this.state;
        if (type === 10 || tokenIsIdentifier(type)) {
          this.state.potentialArrowAt = this.state.start;
        }
        let left = this.parseMaybeConditional(refExpressionErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startLoc);
        }
        if (tokenIsAssignment(this.state.type)) {
          const node = this.startNodeAt(startLoc);
          const operator = this.state.value;
          node.operator = operator;
          if (this.match(29)) {
            this.toAssignable(left, true);
            node.left = left;
            const startIndex = startLoc.index;
            if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
              refExpressionErrors.doubleProtoLoc = null;
            }
            if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
              refExpressionErrors.shorthandAssignLoc = null;
            }
            if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
              this.checkDestructuringPrivate(refExpressionErrors);
              refExpressionErrors.privateKeyLoc = null;
            }
            if (refExpressionErrors.voidPatternLoc != null && refExpressionErrors.voidPatternLoc.index >= startIndex) {
              refExpressionErrors.voidPatternLoc = null;
            }
          } else {
            node.left = left;
          }
          this.next();
          node.right = this.parseMaybeAssign();
          this.checkLVal(left, this.finishNode(node, "AssignmentExpression"), void 0, void 0, void 0, void 0, operator === "||=" || operator === "&&=" || operator === "??=");
          return node;
        } else if (ownExpressionErrors) {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        if (isYield) {
          const {
            type: type2
          } = this.state;
          const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type2) : tokenCanStartExpression(type2) && !this.match(54);
          if (startsExpr2 && !this.isAmbiguousPrefixOrIdentifier()) {
            this.raiseOverwrite(Errors.YieldNotInGeneratorFunction, startLoc);
            return this.parseYield(startLoc);
          }
        }
        return left;
      }
      parseMaybeConditional(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprOps(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseConditional(expr, startLoc, refExpressionErrors);
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (this.eat(17)) {
          const node = this.startNodeAt(startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssignAllowIn();
          this.expect(14);
          node.alternate = this.parseMaybeAssign();
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      }
      parseMaybeUnaryOrPrivate(refExpressionErrors) {
        return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
      }
      parseExprOps(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseExprOp(expr, startLoc, -1);
      }
      parseExprOp(left, leftStartLoc, minPrec) {
        if (this.isPrivateName(left)) {
          const value = this.getPrivateNameSV(left);
          if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
            this.raise(Errors.PrivateInExpectedIn, left, {
              identifierName: value
            });
          }
          this.classScope.usePrivateName(value, left.loc.start);
        }
        const op = this.state.type;
        if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
          let prec = tokenOperatorPrecedence(op);
          if (prec > minPrec) {
            if (op === 39) {
              this.expectPlugin("pipelineOperator");
              if (this.state.inFSharpPipelineDirectBody) {
                return left;
              }
              this.checkPipelineAtInfixOperator(left, leftStartLoc);
            }
            const node = this.startNodeAt(leftStartLoc);
            node.left = left;
            node.operator = this.state.value;
            const logical = op === 41 || op === 42;
            const coalesce = op === 40;
            if (coalesce) {
              prec = tokenOperatorPrecedence(42);
            }
            this.next();
            if (op === 39 && this.hasPlugin(["pipelineOperator", {
              proposal: "minimal"
            }])) {
              if (this.state.type === 96 && this.prodParam.hasAwait) {
                throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
              }
            }
            node.right = this.parseExprOpRightExpr(op, prec);
            const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
            const nextOp = this.state.type;
            if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
              throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);
            }
            return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
          }
        }
        return left;
      }
      parseExprOpRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        switch (op) {
          case 39:
            switch (this.getPluginOption("pipelineOperator", "proposal")) {
              case "hack":
                return this.withTopicBindingContext(() => {
                  return this.parseHackPipeBody();
                });
              case "fsharp":
                return this.withSoloAwaitPermittingContext(() => {
                  return this.parseFSharpPipelineBody(prec);
                });
            }
            if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108)) {
                  throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);
                }
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
              });
            }
          default:
            return this.parseExprOpBaseRightExpr(op, prec);
        }
      }
      parseExprOpBaseRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
      }
      parseHackPipeBody() {
        var _body$extra;
        const {
          startLoc
        } = this.state;
        const body = this.parseMaybeAssign();
        const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
        if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
          this.raise(Errors.PipeUnparenthesizedBody, startLoc, {
            type: body.type
          });
        }
        if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(Errors.PipeTopicUnused, startLoc);
        }
        return body;
      }
      checkExponentialAfterUnary(node) {
        if (this.match(57)) {
          this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);
        }
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        const startLoc = this.state.startLoc;
        const isAwait = this.isContextual(96);
        if (isAwait && this.recordAwaitIfAllowed()) {
          this.next();
          const expr2 = this.parseAwait(startLoc);
          if (!sawUnary) this.checkExponentialAfterUnary(expr2);
          return expr2;
        }
        const update = this.match(34);
        const node = this.startNode();
        if (tokenIsPrefix(this.state.type)) {
          node.operator = this.state.value;
          node.prefix = true;
          if (this.match(72)) {
            this.expectPlugin("throwExpressions");
          }
          const isDelete = this.match(89);
          this.next();
          node.argument = this.parseMaybeUnary(null, true);
          this.checkExpressionErrors(refExpressionErrors, true);
          if (this.state.strict && isDelete) {
            const arg = node.argument;
            if (arg.type === "Identifier") {
              this.raise(Errors.StrictDelete, node);
            } else if (this.hasPropertyAsPrivateName(arg)) {
              this.raise(Errors.DeletePrivateField, node);
            }
          }
          if (!update) {
            if (!sawUnary) {
              this.checkExponentialAfterUnary(node);
            }
            return this.finishNode(node, "UnaryExpression");
          }
        }
        const expr = this.parseUpdate(node, update, refExpressionErrors);
        if (isAwait) {
          const {
            type
          } = this.state;
          const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
          if (startsExpr2 && !this.isAmbiguousPrefixOrIdentifier()) {
            this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);
            return this.parseAwait(startLoc);
          }
        }
        return expr;
      }
      parseUpdate(node, update, refExpressionErrors) {
        if (update) {
          const updateExpressionNode = node;
          this.checkLVal(updateExpressionNode.argument, this.finishNode(updateExpressionNode, "UpdateExpression"));
          return node;
        }
        const startLoc = this.state.startLoc;
        let expr = this.parseExprSubscripts(refExpressionErrors);
        if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;
        while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
          const node2 = this.startNodeAt(startLoc);
          node2.operator = this.state.value;
          node2.prefix = false;
          node2.argument = expr;
          this.next();
          this.checkLVal(expr, expr = this.finishNode(node2, "UpdateExpression"));
        }
        return expr;
      }
      parseExprSubscripts(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprAtom(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseSubscripts(expr, startLoc);
      }
      parseSubscripts(base, startLoc, noCalls) {
        const state = {
          optionalChainMember: false,
          maybeAsyncArrow: this.atPossibleAsyncArrow(base),
          stop: false
        };
        do {
          base = this.parseSubscript(base, startLoc, noCalls, state);
          state.maybeAsyncArrow = false;
        } while (!state.stop);
        return base;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        const {
          type
        } = this.state;
        if (!noCalls && type === 15) {
          return this.parseBind(base, startLoc, noCalls, state);
        } else if (tokenIsTemplate(type)) {
          return this.parseTaggedTemplateExpression(base, startLoc, state);
        }
        let optional = false;
        if (type === 18) {
          if (noCalls) {
            this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);
            if (this.lookaheadCharCode() === 40) {
              return this.stopParseSubscript(base, state);
            }
          }
          state.optionalChainMember = optional = true;
          this.next();
        }
        if (!noCalls && this.match(10)) {
          return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
        } else {
          const computed = this.eat(0);
          if (computed || optional || this.eat(16)) {
            return this.parseMember(base, startLoc, state, computed, optional);
          } else {
            return this.stopParseSubscript(base, state);
          }
        }
      }
      stopParseSubscript(base, state) {
        state.stop = true;
        return base;
      }
      parseMember(base, startLoc, state, computed, optional) {
        const node = this.startNodeAt(startLoc);
        node.object = base;
        node.computed = computed;
        if (computed) {
          node.property = this.parseExpression();
          this.expect(3);
        } else if (this.match(139)) {
          if (base.type === "Super") {
            this.raise(Errors.SuperPrivateField, startLoc);
          }
          this.classScope.usePrivateName(this.state.value, this.state.startLoc);
          node.property = this.parsePrivateName();
        } else {
          node.property = this.parseIdentifier(true);
        }
        if (state.optionalChainMember) {
          node.optional = optional;
          return this.finishNode(node, "OptionalMemberExpression");
        } else {
          return this.finishNode(node, "MemberExpression");
        }
      }
      parseBind(base, startLoc, noCalls, state) {
        const node = this.startNodeAt(startLoc);
        node.object = base;
        this.next();
        node.callee = this.parseNoCallExpr();
        state.stop = true;
        return this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
      }
      parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        let refExpressionErrors = null;
        this.state.maybeInArrowParameters = true;
        this.next();
        const node = this.startNodeAt(startLoc);
        node.callee = base;
        const {
          maybeAsyncArrow,
          optionalChainMember
        } = state;
        if (maybeAsyncArrow) {
          this.expressionScope.enter(newAsyncArrowScope());
          refExpressionErrors = new ExpressionErrors();
        }
        if (optionalChainMember) {
          node.optional = optional;
        }
        if (optional) {
          node.arguments = this.parseCallExpressionArguments();
        } else {
          node.arguments = this.parseCallExpressionArguments(base.type !== "Super", node, refExpressionErrors);
        }
        let finishedNode = this.finishCallExpression(node, optionalChainMember);
        if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
          state.stop = true;
          this.checkDestructuringPrivate(refExpressionErrors);
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
        } else {
          if (maybeAsyncArrow) {
            this.checkExpressionErrors(refExpressionErrors, true);
            this.expressionScope.exit();
          }
          this.toReferencedArguments(finishedNode);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return finishedNode;
      }
      toReferencedArguments(node, isParenthesizedExpr) {
        this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
      }
      parseTaggedTemplateExpression(base, startLoc, state) {
        const node = this.startNodeAt(startLoc);
        node.tag = base;
        node.quasi = this.parseTemplate(true);
        if (state.optionalChainMember) {
          this.raise(Errors.OptionalChainingNoTemplate, startLoc);
        }
        return this.finishNode(node, "TaggedTemplateExpression");
      }
      atPossibleAsyncArrow(base) {
        return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.offsetToSourcePos(base.start) === this.state.potentialArrowAt;
      }
      finishCallExpression(node, optional) {
        if (node.callee.type === "Import") {
          if (node.arguments.length === 0 || node.arguments.length > 2) {
            this.raise(Errors.ImportCallArity, node);
          } else {
            for (const arg of node.arguments) {
              if (arg.type === "SpreadElement") {
                this.raise(Errors.ImportCallSpreadArgument, arg);
              }
            }
          }
        }
        return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
      }
      parseCallExpressionArguments(allowPlaceholder, nodeForExtra, refExpressionErrors) {
        const elts = [];
        let first = true;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        while (!this.eat(11)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(11)) {
              if (nodeForExtra) {
                this.addTrailingCommaExtraToNode(nodeForExtra);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(11, false, refExpressionErrors, allowPlaceholder));
        }
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return elts;
      }
      shouldParseAsyncArrow() {
        return this.match(19) && !this.canInsertSemicolon();
      }
      parseAsyncArrowFromCallExpression(node, call) {
        var _call$extra;
        this.resetPreviousNodeTrailingComments(call);
        this.expect(19);
        this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
        if (call.innerComments) {
          setInnerComments(node, call.innerComments);
        }
        if (call.callee.trailingComments) {
          setInnerComments(node, call.callee.trailingComments);
        }
        return node;
      }
      parseNoCallExpr() {
        const startLoc = this.state.startLoc;
        return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
      }
      parseExprAtom(refExpressionErrors) {
        let node;
        let decorators = null;
        const {
          type
        } = this.state;
        switch (type) {
          case 79:
            return this.parseSuper();
          case 83:
            node = this.startNode();
            this.next();
            if (this.match(16)) {
              return this.parseImportMetaPropertyOrPhaseCall(node);
            }
            if (this.match(10)) {
              if (this.optionFlags & 512) {
                return this.parseImportCall(node);
              } else {
                return this.finishNode(node, "Import");
              }
            } else {
              this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);
              return this.finishNode(node, "Import");
            }
          case 78:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
          case 90: {
            return this.parseDo(this.startNode(), false);
          }
          case 56:
          case 31: {
            this.readRegexp();
            return this.parseRegExpLiteral(this.state.value);
          }
          case 135:
            return this.parseNumericLiteral(this.state.value);
          case 136:
            return this.parseBigIntLiteral(this.state.value);
          case 134:
            return this.parseStringLiteral(this.state.value);
          case 84:
            return this.parseNullLiteral();
          case 85:
            return this.parseBooleanLiteral(true);
          case 86:
            return this.parseBooleanLiteral(false);
          case 10: {
            const canBeArrow = this.state.potentialArrowAt === this.state.start;
            return this.parseParenAndDistinguishExpression(canBeArrow);
          }
          case 0: {
            return this.parseArrayLike(3, false, refExpressionErrors);
          }
          case 5: {
            return this.parseObjectLike(8, false, false, refExpressionErrors);
          }
          case 68:
            return this.parseFunctionOrFunctionSent();
          case 26:
            decorators = this.parseDecorators();
          case 80:
            return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
          case 77:
            return this.parseNewOrNewTarget();
          case 25:
          case 24:
            return this.parseTemplate(false);
          case 15: {
            node = this.startNode();
            this.next();
            node.object = null;
            const callee = node.callee = this.parseNoCallExpr();
            if (callee.type === "MemberExpression") {
              return this.finishNode(node, "BindExpression");
            } else {
              throw this.raise(Errors.UnsupportedBind, callee);
            }
          }
          case 139: {
            this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {
              identifierName: this.state.value
            });
            return this.parsePrivateName();
          }
          case 33: {
            return this.parseTopicReferenceThenEqualsSign(54, "%");
          }
          case 32: {
            return this.parseTopicReferenceThenEqualsSign(44, "^");
          }
          case 37:
          case 38: {
            return this.parseTopicReference("hack");
          }
          case 44:
          case 54:
          case 27: {
            const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
            if (pipeProposal) {
              return this.parseTopicReference(pipeProposal);
            }
            throw this.unexpected();
          }
          case 47: {
            const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
            if (isIdentifierStart2(lookaheadCh) || lookaheadCh === 62) {
              throw this.expectOnePlugin(["jsx", "flow", "typescript"]);
            }
            throw this.unexpected();
          }
          default:
            if (type === 137) {
              return this.parseDecimalLiteral(this.state.value);
            } else if (type === 2 || type === 1) {
              return this.parseArrayLike(this.state.type === 2 ? 4 : 3, true);
            } else if (type === 6 || type === 7) {
              return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
            }
            if (tokenIsIdentifier(type)) {
              if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {
                return this.parseModuleExpression();
              }
              const canBeArrow = this.state.potentialArrowAt === this.state.start;
              const containsEsc = this.state.containsEsc;
              const id = this.parseIdentifier();
              if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                const {
                  type: type2
                } = this.state;
                if (type2 === 68) {
                  this.resetPreviousNodeTrailingComments(id);
                  this.next();
                  return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
                } else if (tokenIsIdentifier(type2)) {
                  if (this.lookaheadCharCode() === 61) {
                    return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                  } else {
                    return id;
                  }
                } else if (type2 === 90) {
                  this.resetPreviousNodeTrailingComments(id);
                  return this.parseDo(this.startNodeAtNode(id), true);
                }
              }
              if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
                this.next();
                return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
              }
              return id;
            } else {
              throw this.unexpected();
            }
        }
      }
      parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
        const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
        if (pipeProposal) {
          this.state.type = topicTokenType;
          this.state.value = topicTokenValue;
          this.state.pos--;
          this.state.end--;
          this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
          return this.parseTopicReference(pipeProposal);
        }
        throw this.unexpected();
      }
      parseTopicReference(pipeProposal) {
        const node = this.startNode();
        const startLoc = this.state.startLoc;
        const tokenType2 = this.state.type;
        this.next();
        return this.finishTopicReference(node, startLoc, pipeProposal, tokenType2);
      }
      finishTopicReference(node, startLoc, pipeProposal, tokenType2) {
        if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType2)) {
          if (pipeProposal === "hack") {
            if (!this.topicReferenceIsAllowedInCurrentContext()) {
              this.raise(Errors.PipeTopicUnbound, startLoc);
            }
            this.registerTopicReference();
            return this.finishNode(node, "TopicReference");
          } else {
            if (!this.topicReferenceIsAllowedInCurrentContext()) {
              this.raise(Errors.PrimaryTopicNotAllowed, startLoc);
            }
            this.registerTopicReference();
            return this.finishNode(node, "PipelinePrimaryTopicReference");
          }
        } else {
          throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {
            token: tokenLabelName(tokenType2)
          });
        }
      }
      testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType2) {
        switch (pipeProposal) {
          case "hack": {
            return this.hasPlugin(["pipelineOperator", {
              topicToken: tokenLabelName(tokenType2)
            }]);
          }
          case "smart":
            return tokenType2 === 27;
          default:
            throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);
        }
      }
      parseAsyncArrowUnaryFunction(node) {
        this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
        const params = [this.parseIdentifier()];
        this.prodParam.exit();
        if (this.hasPrecedingLineBreak()) {
          this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());
        }
        this.expect(19);
        return this.parseArrowExpression(node, params, true);
      }
      parseDo(node, isAsync) {
        this.expectPlugin("doExpressions");
        if (isAsync) {
          this.expectPlugin("asyncDoExpressions");
        }
        node.async = isAsync;
        this.next();
        const oldLabels = this.state.labels;
        this.state.labels = [];
        if (isAsync) {
          this.prodParam.enter(2);
          node.body = this.parseBlock();
          this.prodParam.exit();
        } else {
          node.body = this.parseBlock();
        }
        this.state.labels = oldLabels;
        return this.finishNode(node, "DoExpression");
      }
      parseSuper() {
        const node = this.startNode();
        this.next();
        if (this.match(10) && !this.scope.allowDirectSuper) {
          if (!(this.optionFlags & 16)) {
            this.raise(Errors.SuperNotAllowed, node);
          }
        } else if (!this.scope.allowSuper) {
          if (!(this.optionFlags & 16)) {
            this.raise(Errors.UnexpectedSuper, node);
          }
        }
        if (!this.match(10) && !this.match(0) && !this.match(16)) {
          this.raise(Errors.UnsupportedSuper, node);
        }
        return this.finishNode(node, "Super");
      }
      parsePrivateName() {
        const node = this.startNode();
        const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
        const name50 = this.state.value;
        this.next();
        node.id = this.createIdentifier(id, name50);
        return this.finishNode(node, "PrivateName");
      }
      parseFunctionOrFunctionSent() {
        const node = this.startNode();
        this.next();
        if (this.prodParam.hasYield && this.match(16)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
          this.next();
          if (this.match(103)) {
            this.expectPlugin("functionSent");
          } else if (!this.hasPlugin("functionSent")) {
            this.unexpected();
          }
          return this.parseMetaProperty(node, meta, "sent");
        }
        return this.parseFunction(node);
      }
      parseMetaProperty(node, meta, propertyName) {
        node.meta = meta;
        const containsEsc = this.state.containsEsc;
        node.property = this.parseIdentifier(true);
        if (node.property.name !== propertyName || containsEsc) {
          this.raise(Errors.UnsupportedMetaProperty, node.property, {
            target: meta.name,
            onlyValidPropertyName: propertyName
          });
        }
        return this.finishNode(node, "MetaProperty");
      }
      parseImportMetaPropertyOrPhaseCall(node) {
        this.next();
        if (this.isContextual(105) || this.isContextual(97)) {
          const isSource = this.isContextual(105);
          this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation");
          this.next();
          node.phase = isSource ? "source" : "defer";
          return this.parseImportCall(node);
        } else {
          const id = this.createIdentifierAt(this.startNodeAtNode(node), "import", this.state.lastTokStartLoc);
          if (this.isContextual(101)) {
            if (!this.inModule) {
              this.raise(Errors.ImportMetaOutsideModule, id);
            }
            this.sawUnambiguousESM = true;
          }
          return this.parseMetaProperty(node, id, "meta");
        }
      }
      parseLiteralAtNode(value, type, node) {
        this.addExtra(node, "rawValue", value);
        this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
        node.value = value;
        this.next();
        return this.finishNode(node, type);
      }
      parseLiteral(value, type) {
        const node = this.startNode();
        return this.parseLiteralAtNode(value, type, node);
      }
      parseStringLiteral(value) {
        return this.parseLiteral(value, "StringLiteral");
      }
      parseNumericLiteral(value) {
        return this.parseLiteral(value, "NumericLiteral");
      }
      parseBigIntLiteral(value) {
        return this.parseLiteral(value, "BigIntLiteral");
      }
      parseDecimalLiteral(value) {
        return this.parseLiteral(value, "DecimalLiteral");
      }
      parseRegExpLiteral(value) {
        const node = this.startNode();
        this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
        node.pattern = value.pattern;
        node.flags = value.flags;
        this.next();
        return this.finishNode(node, "RegExpLiteral");
      }
      parseBooleanLiteral(value) {
        const node = this.startNode();
        node.value = value;
        this.next();
        return this.finishNode(node, "BooleanLiteral");
      }
      parseNullLiteral() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "NullLiteral");
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        const startLoc = this.state.startLoc;
        let val;
        this.next();
        this.expressionScope.enter(newArrowHeadScope());
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.maybeInArrowParameters = true;
        this.state.inFSharpPipelineDirectBody = false;
        const innerStartLoc = this.state.startLoc;
        const exprList = [];
        const refExpressionErrors = new ExpressionErrors();
        let first = true;
        let spreadStartLoc;
        let optionalCommaStartLoc;
        while (!this.match(11)) {
          if (first) {
            first = false;
          } else {
            this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
            if (this.match(11)) {
              optionalCommaStartLoc = this.state.startLoc;
              break;
            }
          }
          if (this.match(21)) {
            const spreadNodeStartLoc = this.state.startLoc;
            spreadStartLoc = this.state.startLoc;
            exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
            if (!this.checkCommaAfterRest(41)) {
              break;
            }
          } else {
            exprList.push(this.parseMaybeAssignAllowInOrVoidPattern(11, refExpressionErrors, this.parseParenItem));
          }
        }
        const innerEndLoc = this.state.lastTokEndLoc;
        this.expect(11);
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let arrowNode = this.startNodeAt(startLoc);
        if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
          this.checkDestructuringPrivate(refExpressionErrors);
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          this.parseArrowExpression(arrowNode, exprList, false);
          return arrowNode;
        }
        this.expressionScope.exit();
        if (!exprList.length) {
          this.unexpected(this.state.lastTokStartLoc);
        }
        if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);
        if (spreadStartLoc) this.unexpected(spreadStartLoc);
        this.checkExpressionErrors(refExpressionErrors, true);
        this.toReferencedListDeep(exprList, true);
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartLoc);
          val.expressions = exprList;
          this.finishNode(val, "SequenceExpression");
          this.resetEndLocation(val, innerEndLoc);
        } else {
          val = exprList[0];
        }
        return this.wrapParenthesis(startLoc, val);
      }
      wrapParenthesis(startLoc, expression) {
        if (!(this.optionFlags & 1024)) {
          this.addExtra(expression, "parenthesized", true);
          this.addExtra(expression, "parenStart", startLoc.index);
          this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
          return expression;
        }
        const parenExpression = this.startNodeAt(startLoc);
        parenExpression.expression = expression;
        return this.finishNode(parenExpression, "ParenthesizedExpression");
      }
      shouldParseArrow(params) {
        return !this.canInsertSemicolon();
      }
      parseArrow(node) {
        if (this.eat(19)) {
          return node;
        }
      }
      parseParenItem(node, startLoc) {
        return node;
      }
      parseNewOrNewTarget() {
        const node = this.startNode();
        this.next();
        if (this.match(16)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
          this.next();
          const metaProp = this.parseMetaProperty(node, meta, "target");
          if (!this.scope.allowNewTarget) {
            this.raise(Errors.UnexpectedNewTarget, metaProp);
          }
          return metaProp;
        }
        return this.parseNew(node);
      }
      parseNew(node) {
        this.parseNewCallee(node);
        if (this.eat(10)) {
          const args = this.parseExprList(11);
          this.toReferencedList(args);
          node.arguments = args;
        } else {
          node.arguments = [];
        }
        return this.finishNode(node, "NewExpression");
      }
      parseNewCallee(node) {
        const isImport = this.match(83);
        const callee = this.parseNoCallExpr();
        node.callee = callee;
        if (isImport && (callee.type === "Import" || callee.type === "ImportExpression")) {
          this.raise(Errors.ImportCallNotNewExpression, callee);
        }
      }
      parseTemplateElement(isTagged) {
        const {
          start,
          startLoc,
          end,
          value
        } = this.state;
        const elemStart = start + 1;
        const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
        if (value === null) {
          if (!isTagged) {
            this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));
          }
        }
        const isTail = this.match(24);
        const endOffset = isTail ? -1 : -2;
        const elemEnd = end + endOffset;
        elem.value = {
          raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
          cooked: value === null ? null : value.slice(1, endOffset)
        };
        elem.tail = isTail;
        this.next();
        const finishedNode = this.finishNode(elem, "TemplateElement");
        this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
        return finishedNode;
      }
      parseTemplate(isTagged) {
        const node = this.startNode();
        let curElt = this.parseTemplateElement(isTagged);
        const quasis = [curElt];
        const substitutions = [];
        while (!curElt.tail) {
          substitutions.push(this.parseTemplateSubstitution());
          this.readTemplateContinuation();
          quasis.push(curElt = this.parseTemplateElement(isTagged));
        }
        node.expressions = substitutions;
        node.quasis = quasis;
        return this.finishNode(node, "TemplateLiteral");
      }
      parseTemplateSubstitution() {
        return this.parseExpression();
      }
      parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
        if (isRecord) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        let sawProto = false;
        let first = true;
        const node = this.startNode();
        node.properties = [];
        this.next();
        while (!this.match(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              this.addTrailingCommaExtraToNode(node);
              break;
            }
          }
          let prop;
          if (isPattern) {
            prop = this.parseBindingProperty();
          } else {
            prop = this.parsePropertyDefinition(refExpressionErrors);
            sawProto = this.checkProto(prop, isRecord, sawProto, refExpressionErrors);
          }
          if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
            this.raise(Errors.InvalidRecordProperty, prop);
          }
          if (prop.shorthand) {
            this.addExtra(prop, "shorthand", true);
          }
          node.properties.push(prop);
        }
        this.next();
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let type = "ObjectExpression";
        if (isPattern) {
          type = "ObjectPattern";
        } else if (isRecord) {
          type = "RecordExpression";
        }
        return this.finishNode(node, type);
      }
      addTrailingCommaExtraToNode(node) {
        this.addExtra(node, "trailingComma", this.state.lastTokStartLoc.index);
        this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
      }
      maybeAsyncOrAccessorProp(prop) {
        return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
      }
      parsePropertyDefinition(refExpressionErrors) {
        let decorators = [];
        if (this.match(26)) {
          if (this.hasPlugin("decorators")) {
            this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);
          }
          while (this.match(26)) {
            decorators.push(this.parseDecorator());
          }
        }
        const prop = this.startNode();
        let isAsync = false;
        let isAccessor = false;
        let startLoc;
        if (this.match(21)) {
          if (decorators.length) this.unexpected();
          return this.parseSpread();
        }
        if (decorators.length) {
          prop.decorators = decorators;
          decorators = [];
        }
        prop.method = false;
        if (refExpressionErrors) {
          startLoc = this.state.startLoc;
        }
        let isGenerator = this.eat(55);
        this.parsePropertyNamePrefixOperator(prop);
        const containsEsc = this.state.containsEsc;
        this.parsePropertyName(prop, refExpressionErrors);
        if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
          const {
            key
          } = prop;
          const keyName = key.name;
          if (keyName === "async" && !this.hasPrecedingLineBreak()) {
            isAsync = true;
            this.resetPreviousNodeTrailingComments(key);
            isGenerator = this.eat(55);
            this.parsePropertyName(prop);
          }
          if (keyName === "get" || keyName === "set") {
            isAccessor = true;
            this.resetPreviousNodeTrailingComments(key);
            prop.kind = keyName;
            if (this.match(55)) {
              isGenerator = true;
              this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {
                kind: keyName
              });
              this.next();
            }
            this.parsePropertyName(prop);
          }
        }
        return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
      }
      getGetterSetterExpectedParamCount(method) {
        return method.kind === "get" ? 0 : 1;
      }
      getObjectOrClassMethodParams(method) {
        return method.params;
      }
      checkGetterSetterParams(method) {
        var _params;
        const paramCount = this.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length !== paramCount) {
          this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, method);
        }
        if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
          this.raise(Errors.BadSetterRestParameter, method);
        }
      }
      parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        if (isAccessor) {
          const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
          this.checkGetterSetterParams(finishedProp);
          return finishedProp;
        }
        if (isAsync || isGenerator || this.match(10)) {
          if (isPattern) this.unexpected();
          prop.kind = "method";
          prop.method = true;
          return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
        }
      }
      parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        prop.shorthand = false;
        if (this.eat(14)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowInOrVoidPattern(8, refExpressionErrors);
          return this.finishObjectProperty(prop);
        }
        if (!prop.computed && prop.key.type === "Identifier") {
          this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));
          } else if (this.match(29)) {
            const shorthandAssignLoc = this.state.startLoc;
            if (refExpressionErrors != null) {
              if (refExpressionErrors.shorthandAssignLoc === null) {
                refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
              }
            } else {
              this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
            }
            prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));
          } else {
            prop.value = this.cloneIdentifier(prop.key);
          }
          prop.shorthand = true;
          return this.finishObjectProperty(prop);
        }
      }
      finishObjectProperty(node) {
        return this.finishNode(node, "ObjectProperty");
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
        if (!node) this.unexpected();
        return node;
      }
      parsePropertyName(prop, refExpressionErrors) {
        if (this.eat(0)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssignAllowIn();
          this.expect(3);
        } else {
          const {
            type,
            value
          } = this.state;
          let key;
          if (tokenIsKeywordOrIdentifier(type)) {
            key = this.parseIdentifier(true);
          } else {
            switch (type) {
              case 135:
                key = this.parseNumericLiteral(value);
                break;
              case 134:
                key = this.parseStringLiteral(value);
                break;
              case 136:
                key = this.parseBigIntLiteral(value);
                break;
              case 139: {
                const privateKeyLoc = this.state.startLoc;
                if (refExpressionErrors != null) {
                  if (refExpressionErrors.privateKeyLoc === null) {
                    refExpressionErrors.privateKeyLoc = privateKeyLoc;
                  }
                } else {
                  this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
                }
                key = this.parsePrivateName();
                break;
              }
              default:
                if (type === 137) {
                  key = this.parseDecimalLiteral(value);
                  break;
                }
                this.unexpected();
            }
          }
          prop.key = key;
          if (type !== 139) {
            prop.computed = false;
          }
        }
      }
      initFunction(node, isAsync) {
        node.id = null;
        node.generator = false;
        node.async = isAsync;
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        this.initFunction(node, isAsync);
        node.generator = isGenerator;
        this.scope.enter(514 | 16 | (inClassScope ? 576 : 0) | (allowDirectSuper ? 32 : 0));
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        this.parseFunctionParams(node, isConstructor);
        const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
        this.prodParam.exit();
        this.scope.exit();
        return finishedNode;
      }
      parseArrayLike(close, isTuple, refExpressionErrors) {
        if (isTuple) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const node = this.startNode();
        this.next();
        node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
      }
      parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
        this.scope.enter(514 | 4);
        let flags = functionFlags(isAsync, false);
        if (!this.match(5) && this.prodParam.hasIn) {
          flags |= 8;
        }
        this.prodParam.enter(flags);
        this.initFunction(node, isAsync);
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        if (params) {
          this.state.maybeInArrowParameters = true;
          this.setArrowFunctionParameters(node, params, trailingCommaLoc);
        }
        this.state.maybeInArrowParameters = false;
        this.parseFunctionBody(node, true);
        this.prodParam.exit();
        this.scope.exit();
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node, "ArrowFunctionExpression");
      }
      setArrowFunctionParameters(node, params, trailingCommaLoc) {
        this.toAssignableList(params, trailingCommaLoc, false);
        node.params = params;
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        this.parseFunctionBody(node, false, isMethod);
        return this.finishNode(node, type);
      }
      parseFunctionBody(node, allowExpression, isMethod = false) {
        const isExpression = allowExpression && !this.match(5);
        this.expressionScope.enter(newExpressionScope());
        if (isExpression) {
          node.body = this.parseMaybeAssign();
          this.checkParams(node, false, allowExpression, false);
        } else {
          const oldStrict = this.state.strict;
          const oldLabels = this.state.labels;
          this.state.labels = [];
          this.prodParam.enter(this.prodParam.currentFlags() | 4);
          node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
            const nonSimple = !this.isSimpleParamList(node.params);
            if (hasStrictModeDirective && nonSimple) {
              this.raise(Errors.IllegalLanguageModeDirective, (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node);
            }
            const strictModeChanged = !oldStrict && this.state.strict;
            this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
            if (this.state.strict && node.id) {
              this.checkIdentifier(node.id, 65, strictModeChanged);
            }
          });
          this.prodParam.exit();
          this.state.labels = oldLabels;
        }
        this.expressionScope.exit();
      }
      isSimpleParameter(node) {
        return node.type === "Identifier";
      }
      isSimpleParamList(params) {
        for (let i = 0, len = params.length; i < len; i++) {
          if (!this.isSimpleParameter(params[i])) return false;
        }
        return true;
      }
      checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();
        const formalParameters = {
          type: "FormalParameters"
        };
        for (const param of node.params) {
          this.checkLVal(param, formalParameters, 5, checkClashes, strictModeChanged);
        }
      }
      parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
        const elts = [];
        let first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              if (nodeForExtra) {
                this.addTrailingCommaExtraToNode(nodeForExtra);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(close, allowEmpty, refExpressionErrors));
        }
        return elts;
      }
      parseExprListItem(close, allowEmpty, refExpressionErrors, allowPlaceholder) {
        let elt;
        if (this.match(12)) {
          if (!allowEmpty) {
            this.raise(Errors.UnexpectedToken, this.state.curPosition(), {
              unexpected: ","
            });
          }
          elt = null;
        } else if (this.match(21)) {
          const spreadNodeStartLoc = this.state.startLoc;
          elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
        } else if (this.match(17)) {
          this.expectPlugin("partialApplication");
          if (!allowPlaceholder) {
            this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);
          }
          const node = this.startNode();
          this.next();
          elt = this.finishNode(node, "ArgumentPlaceholder");
        } else {
          elt = this.parseMaybeAssignAllowInOrVoidPattern(close, refExpressionErrors, this.parseParenItem);
        }
        return elt;
      }
      parseIdentifier(liberal) {
        const node = this.startNode();
        const name50 = this.parseIdentifierName(liberal);
        return this.createIdentifier(node, name50);
      }
      createIdentifier(node, name50) {
        node.name = name50;
        node.loc.identifierName = name50;
        return this.finishNode(node, "Identifier");
      }
      createIdentifierAt(node, name50, endLoc) {
        node.name = name50;
        node.loc.identifierName = name50;
        return this.finishNodeAt(node, "Identifier", endLoc);
      }
      parseIdentifierName(liberal) {
        let name50;
        const {
          startLoc,
          type
        } = this.state;
        if (tokenIsKeywordOrIdentifier(type)) {
          name50 = this.state.value;
        } else {
          this.unexpected();
        }
        const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
        if (liberal) {
          if (tokenIsKeyword2) {
            this.replaceToken(132);
          }
        } else {
          this.checkReservedWord(name50, startLoc, tokenIsKeyword2, false);
        }
        this.next();
        return name50;
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (word.length > 10) {
          return;
        }
        if (!canBeReservedWord(word)) {
          return;
        }
        if (checkKeywords && isKeyword2(word)) {
          this.raise(Errors.UnexpectedKeyword, startLoc, {
            keyword: word
          });
          return;
        }
        const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
        if (reservedTest(word, this.inModule)) {
          this.raise(Errors.UnexpectedReservedWord, startLoc, {
            reservedWord: word
          });
          return;
        } else if (word === "yield") {
          if (this.prodParam.hasYield) {
            this.raise(Errors.YieldBindingIdentifier, startLoc);
            return;
          }
        } else if (word === "await") {
          if (this.prodParam.hasAwait) {
            this.raise(Errors.AwaitBindingIdentifier, startLoc);
            return;
          }
          if (this.scope.inStaticBlock) {
            this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);
            return;
          }
          this.expressionScope.recordAsyncArrowParametersError(startLoc);
        } else if (word === "arguments") {
          if (this.scope.inClassAndNotInNonArrowFunction) {
            this.raise(Errors.ArgumentsInClass, startLoc);
            return;
          }
        }
      }
      recordAwaitIfAllowed() {
        const isAwaitAllowed = this.prodParam.hasAwait;
        if (isAwaitAllowed && !this.scope.inFunction) {
          this.state.hasTopLevelAwait = true;
        }
        return isAwaitAllowed;
      }
      parseAwait(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);
        if (this.eat(55)) {
          this.raise(Errors.ObsoleteAwaitStar, node);
        }
        if (!this.scope.inFunction && !(this.optionFlags & 1)) {
          if (this.isAmbiguousPrefixOrIdentifier()) {
            this.ambiguousScriptDifferentAst = true;
          } else {
            this.sawUnambiguousESM = true;
          }
        }
        if (!this.state.soloAwait) {
          node.argument = this.parseMaybeUnary(null, true);
        }
        return this.finishNode(node, "AwaitExpression");
      }
      isAmbiguousPrefixOrIdentifier() {
        if (this.hasPrecedingLineBreak()) return true;
        const {
          type
        } = this.state;
        return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 138 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
      }
      parseYield(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);
        let delegating = false;
        let argument = null;
        if (!this.hasPrecedingLineBreak()) {
          delegating = this.eat(55);
          switch (this.state.type) {
            case 13:
            case 140:
            case 8:
            case 11:
            case 3:
            case 9:
            case 14:
            case 12:
              if (!delegating) break;
            default:
              argument = this.parseMaybeAssign();
          }
        }
        node.delegate = delegating;
        node.argument = argument;
        return this.finishNode(node, "YieldExpression");
      }
      parseImportCall(node) {
        this.next();
        node.source = this.parseMaybeAssignAllowIn();
        node.options = null;
        if (this.eat(12)) {
          if (!this.match(11)) {
            node.options = this.parseMaybeAssignAllowIn();
            if (this.eat(12)) {
              this.addTrailingCommaExtraToNode(node.options);
              if (!this.match(11)) {
                do {
                  this.parseMaybeAssignAllowIn();
                } while (this.eat(12) && !this.match(11));
                this.raise(Errors.ImportCallArity, node);
              }
            }
          } else {
            this.addTrailingCommaExtraToNode(node.source);
          }
        }
        this.expect(11);
        return this.finishNode(node, "ImportExpression");
      }
      checkPipelineAtInfixOperator(left, leftStartLoc) {
        if (this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }])) {
          if (left.type === "SequenceExpression") {
            this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);
          }
        }
      }
      parseSmartPipelineBodyInStyle(childExpr, startLoc) {
        if (this.isSimpleReference(childExpr)) {
          const bodyNode = this.startNodeAt(startLoc);
          bodyNode.callee = childExpr;
          return this.finishNode(bodyNode, "PipelineBareFunction");
        } else {
          const bodyNode = this.startNodeAt(startLoc);
          this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
          bodyNode.expression = childExpr;
          return this.finishNode(bodyNode, "PipelineTopicExpression");
        }
      }
      isSimpleReference(expression) {
        switch (expression.type) {
          case "MemberExpression":
            return !expression.computed && this.isSimpleReference(expression.object);
          case "Identifier":
            return true;
          default:
            return false;
        }
      }
      checkSmartPipeTopicBodyEarlyErrors(startLoc) {
        if (this.match(19)) {
          throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);
        }
        if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(Errors.PipelineTopicUnused, startLoc);
        }
      }
      withTopicBindingContext(callback) {
        const outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 1,
          maxTopicIndex: null
        };
        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      }
      withSmartMixTopicForbiddingContext(callback) {
        if (this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }])) {
          const outerContextTopicState = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
          };
          try {
            return callback();
          } finally {
            this.state.topicContext = outerContextTopicState;
          }
        } else {
          return callback();
        }
      }
      withSoloAwaitPermittingContext(callback) {
        const outerContextSoloAwaitState = this.state.soloAwait;
        this.state.soloAwait = true;
        try {
          return callback();
        } finally {
          this.state.soloAwait = outerContextSoloAwaitState;
        }
      }
      allowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToSet = 8 & ~flags;
        if (prodParamToSet) {
          this.prodParam.enter(flags | 8);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      disallowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToClear = 8 & flags;
        if (prodParamToClear) {
          this.prodParam.enter(flags & ~8);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      registerTopicReference() {
        this.state.topicContext.maxTopicIndex = 0;
      }
      topicReferenceIsAllowedInCurrentContext() {
        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
      }
      topicReferenceWasUsedInCurrentContext() {
        return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
      }
      parseFSharpPipelineBody(prec) {
        const startLoc = this.state.startLoc;
        this.state.potentialArrowAt = this.state.start;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = true;
        const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return ret;
      }
      parseModuleExpression() {
        this.expectPlugin("moduleBlocks");
        const node = this.startNode();
        this.next();
        if (!this.match(5)) {
          this.unexpected(null, 5);
        }
        const program = this.startNodeAt(this.state.endLoc);
        this.next();
        const revertScopes = this.initializeScopes(true);
        this.enterInitialScopes();
        try {
          node.body = this.parseProgram(program, 8, "module");
        } finally {
          revertScopes();
        }
        return this.finishNode(node, "ModuleExpression");
      }
      parseVoidPattern(refExpressionErrors) {
        this.expectPlugin("discardBinding");
        const node = this.startNode();
        if (refExpressionErrors != null) {
          refExpressionErrors.voidPatternLoc = this.state.startLoc;
        }
        this.next();
        return this.finishNode(node, "VoidPattern");
      }
      parseMaybeAssignAllowInOrVoidPattern(close, refExpressionErrors, afterLeftParse) {
        if (refExpressionErrors != null && this.match(88)) {
          const nextCode = this.lookaheadCharCode();
          if (nextCode === 44 || nextCode === (close === 3 ? 93 : close === 8 ? 125 : 41) || nextCode === 61) {
            return this.parseMaybeDefault(this.state.startLoc, this.parseVoidPattern(refExpressionErrors));
          }
        }
        return this.parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse);
      }
      parsePropertyNamePrefixOperator(prop) {
      }
    };
    var loopLabel = {
      kind: 1
    };
    var switchLabel = {
      kind: 2
    };
    var loneSurrogate = /[\uD800-\uDFFF]/u;
    var keywordRelationalOperator = /in(?:stanceof)?/y;
    function babel7CompatTokens(tokens, input, startIndex) {
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        const {
          type
        } = token;
        if (typeof type === "number") {
          if (type === 139) {
            const {
              loc,
              start,
              value,
              end
            } = token;
            const hashEndPos = start + 1;
            const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
            tokens.splice(i, 1, new Token({
              type: getExportedToken(27),
              value: "#",
              start,
              end: hashEndPos,
              startLoc: loc.start,
              endLoc: hashEndLoc
            }), new Token({
              type: getExportedToken(132),
              value,
              start: hashEndPos,
              end,
              startLoc: hashEndLoc,
              endLoc: loc.end
            }));
            i++;
            continue;
          }
          if (tokenIsTemplate(type)) {
            const {
              loc,
              start,
              value,
              end
            } = token;
            const backquoteEnd = start + 1;
            const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
            let startToken;
            if (input.charCodeAt(start - startIndex) === 96) {
              startToken = new Token({
                type: getExportedToken(22),
                value: "`",
                start,
                end: backquoteEnd,
                startLoc: loc.start,
                endLoc: backquoteEndLoc
              });
            } else {
              startToken = new Token({
                type: getExportedToken(8),
                value: "}",
                start,
                end: backquoteEnd,
                startLoc: loc.start,
                endLoc: backquoteEndLoc
              });
            }
            let templateValue, templateElementEnd, templateElementEndLoc, endToken;
            if (type === 24) {
              templateElementEnd = end - 1;
              templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
              templateValue = value === null ? null : value.slice(1, -1);
              endToken = new Token({
                type: getExportedToken(22),
                value: "`",
                start: templateElementEnd,
                end,
                startLoc: templateElementEndLoc,
                endLoc: loc.end
              });
            } else {
              templateElementEnd = end - 2;
              templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
              templateValue = value === null ? null : value.slice(1, -2);
              endToken = new Token({
                type: getExportedToken(23),
                value: "${",
                start: templateElementEnd,
                end,
                startLoc: templateElementEndLoc,
                endLoc: loc.end
              });
            }
            tokens.splice(i, 1, startToken, new Token({
              type: getExportedToken(20),
              value: templateValue,
              start: backquoteEnd,
              end: templateElementEnd,
              startLoc: backquoteEndLoc,
              endLoc: templateElementEndLoc
            }), endToken);
            i += 2;
            continue;
          }
          token.type = getExportedToken(type);
        }
      }
      return tokens;
    }
    var StatementParser = class extends ExpressionParser {
      parseTopLevel(file, program) {
        file.program = this.parseProgram(program, 140, this.options.sourceType === "module" ? "module" : "script");
        file.comments = this.comments;
        if (this.optionFlags & 256) {
          file.tokens = babel7CompatTokens(this.tokens, this.input, this.startIndex);
        }
        return this.finishNode(file, "File");
      }
      parseProgram(program, end, sourceType) {
        program.sourceType = sourceType;
        program.interpreter = this.parseInterpreterDirective();
        this.parseBlockBody(program, true, true, end);
        if (this.inModule) {
          if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0) {
            for (const [localName, at] of Array.from(this.scope.undefinedExports)) {
              this.raise(Errors.ModuleExportUndefined, at, {
                localName
              });
            }
          }
          this.addExtra(program, "topLevelAwait", this.state.hasTopLevelAwait);
        }
        let finishedProgram;
        if (end === 140) {
          finishedProgram = this.finishNode(program, "Program");
        } else {
          finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
        }
        return finishedProgram;
      }
      stmtToDirective(stmt) {
        const directive = this.castNodeTo(stmt, "Directive");
        const directiveLiteral = this.castNodeTo(stmt.expression, "DirectiveLiteral");
        const expressionValue = directiveLiteral.value;
        const raw = this.input.slice(this.offsetToSourcePos(directiveLiteral.start), this.offsetToSourcePos(directiveLiteral.end));
        const val = directiveLiteral.value = raw.slice(1, -1);
        this.addExtra(directiveLiteral, "raw", raw);
        this.addExtra(directiveLiteral, "rawValue", val);
        this.addExtra(directiveLiteral, "expressionValue", expressionValue);
        directive.value = directiveLiteral;
        delete stmt.expression;
        return directive;
      }
      parseInterpreterDirective() {
        if (!this.match(28)) {
          return null;
        }
        const node = this.startNode();
        node.value = this.state.value;
        this.next();
        return this.finishNode(node, "InterpreterDirective");
      }
      isLet() {
        if (!this.isContextual(100)) {
          return false;
        }
        return this.hasFollowingBindingAtom();
      }
      isUsing() {
        if (!this.isContextual(107)) {
          return false;
        }
        return this.nextTokenIsIdentifierOnSameLine();
      }
      isForUsing() {
        if (!this.isContextual(107)) {
          return false;
        }
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        if (this.isUnparsedContextual(next, "of")) {
          const nextCharAfterOf = this.lookaheadCharCodeSince(next + 2);
          if (nextCharAfterOf !== 61 && nextCharAfterOf !== 58 && nextCharAfterOf !== 59) {
            return false;
          }
        }
        if (this.chStartsBindingIdentifier(nextCh, next) || this.isUnparsedContextual(next, "void")) {
          return true;
        }
        return false;
      }
      nextTokenIsIdentifierOnSameLine() {
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        return this.chStartsBindingIdentifier(nextCh, next);
      }
      isAwaitUsing() {
        if (!this.isContextual(96)) {
          return false;
        }
        let next = this.nextTokenInLineStart();
        if (this.isUnparsedContextual(next, "using")) {
          next = this.nextTokenInLineStartSince(next + 5);
          const nextCh = this.codePointAtPos(next);
          if (this.chStartsBindingIdentifier(nextCh, next)) {
            return true;
          }
        }
        return false;
      }
      chStartsBindingIdentifier(ch, pos) {
        if (isIdentifierStart2(ch)) {
          keywordRelationalOperator.lastIndex = pos;
          if (keywordRelationalOperator.test(this.input)) {
            const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
            if (!isIdentifierChar(endCh) && endCh !== 92) {
              return false;
            }
          }
          return true;
        } else if (ch === 92) {
          return true;
        } else {
          return false;
        }
      }
      chStartsBindingPattern(ch) {
        return ch === 91 || ch === 123;
      }
      hasFollowingBindingAtom() {
        const next = this.nextTokenStart();
        const nextCh = this.codePointAtPos(next);
        return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
      }
      hasInLineFollowingBindingIdentifierOrBrace() {
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);
      }
      allowsUsing() {
        return (this.scope.inModule || !this.scope.inTopLevel) && !this.scope.inBareCaseStatement;
      }
      parseModuleItem() {
        return this.parseStatementLike(1 | 2 | 4 | 8);
      }
      parseStatementListItem() {
        return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
      }
      parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {
        let flags = 0;
        if (this.options.annexB && !this.state.strict) {
          flags |= 4;
          if (allowLabeledFunction) {
            flags |= 8;
          }
        }
        return this.parseStatementLike(flags);
      }
      parseStatement() {
        return this.parseStatementLike(0);
      }
      parseStatementLike(flags) {
        let decorators = null;
        if (this.match(26)) {
          decorators = this.parseDecorators(true);
        }
        return this.parseStatementContent(flags, decorators);
      }
      parseStatementContent(flags, decorators) {
        const startType = this.state.type;
        const node = this.startNode();
        const allowDeclaration = !!(flags & 2);
        const allowFunctionDeclaration = !!(flags & 4);
        const topLevel = flags & 1;
        switch (startType) {
          case 60:
            return this.parseBreakContinueStatement(node, true);
          case 63:
            return this.parseBreakContinueStatement(node, false);
          case 64:
            return this.parseDebuggerStatement(node);
          case 90:
            return this.parseDoWhileStatement(node);
          case 91:
            return this.parseForStatement(node);
          case 68:
            if (this.lookaheadCharCode() === 46) break;
            if (!allowFunctionDeclaration) {
              this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);
            }
            return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
          case 80:
            if (!allowDeclaration) this.unexpected();
            return this.parseClass(this.maybeTakeDecorators(decorators, node), true);
          case 69:
            return this.parseIfStatement(node);
          case 70:
            return this.parseReturnStatement(node);
          case 71:
            return this.parseSwitchStatement(node);
          case 72:
            return this.parseThrowStatement(node);
          case 73:
            return this.parseTryStatement(node);
          case 96:
            if (this.isAwaitUsing()) {
              if (!this.allowsUsing()) {
                this.raise(Errors.UnexpectedUsingDeclaration, node);
              } else if (!allowDeclaration) {
                this.raise(Errors.UnexpectedLexicalDeclaration, node);
              } else if (!this.recordAwaitIfAllowed()) {
                this.raise(Errors.AwaitUsingNotInAsyncContext, node);
              }
              this.next();
              return this.parseVarStatement(node, "await using");
            }
            break;
          case 107:
            if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) {
              break;
            }
            if (!this.allowsUsing()) {
              this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);
            } else if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
            }
            return this.parseVarStatement(node, "using");
          case 100: {
            if (this.state.containsEsc) {
              break;
            }
            const next = this.nextTokenStart();
            const nextCh = this.codePointAtPos(next);
            if (nextCh !== 91) {
              if (!allowDeclaration && this.hasFollowingLineBreak()) break;
              if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
                break;
              }
            }
          }
          case 75: {
            if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
            }
          }
          case 74: {
            const kind = this.state.value;
            return this.parseVarStatement(node, kind);
          }
          case 92:
            return this.parseWhileStatement(node);
          case 76:
            return this.parseWithStatement(node);
          case 5:
            return this.parseBlock();
          case 13:
            return this.parseEmptyStatement(node);
          case 83: {
            const nextTokenCharCode = this.lookaheadCharCode();
            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
              break;
            }
          }
          case 82: {
            if (!(this.optionFlags & 8) && !topLevel) {
              this.raise(Errors.UnexpectedImportExport, this.state.startLoc);
            }
            this.next();
            let result;
            if (startType === 83) {
              result = this.parseImport(node);
            } else {
              result = this.parseExport(node, decorators);
            }
            this.assertModuleNodeAllowed(result);
            return result;
          }
          default: {
            if (this.isAsyncFunction()) {
              if (!allowDeclaration) {
                this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);
              }
              this.next();
              return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
            }
          }
        }
        const maybeName = this.state.value;
        const expr = this.parseExpression();
        if (tokenIsIdentifier(startType) && expr.type === "Identifier" && this.eat(14)) {
          return this.parseLabeledStatement(node, maybeName, expr, flags);
        } else {
          return this.parseExpressionStatement(node, expr, decorators);
        }
      }
      assertModuleNodeAllowed(node) {
        if (!(this.optionFlags & 8) && !this.inModule) {
          this.raise(Errors.ImportOutsideModule, node);
        }
      }
      decoratorsEnabledBeforeExport() {
        if (this.hasPlugin("decorators-legacy")) return true;
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
      }
      maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
        if (maybeDecorators) {
          var _classNode$decorators;
          if ((_classNode$decorators = classNode.decorators) != null && _classNode$decorators.length) {
            if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
              this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);
            }
            classNode.decorators.unshift(...maybeDecorators);
          } else {
            classNode.decorators = maybeDecorators;
          }
          this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
          if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);
        }
        return classNode;
      }
      canHaveLeadingDecorator() {
        return this.match(80);
      }
      parseDecorators(allowExport) {
        const decorators = [];
        do {
          decorators.push(this.parseDecorator());
        } while (this.match(26));
        if (this.match(82)) {
          if (!allowExport) {
            this.unexpected();
          }
          if (!this.decoratorsEnabledBeforeExport()) {
            this.raise(Errors.DecoratorExportClass, this.state.startLoc);
          }
        } else if (!this.canHaveLeadingDecorator()) {
          throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);
        }
        return decorators;
      }
      parseDecorator() {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);
        const node = this.startNode();
        this.next();
        if (this.hasPlugin("decorators")) {
          const startLoc = this.state.startLoc;
          let expr;
          if (this.match(10)) {
            const startLoc2 = this.state.startLoc;
            this.next();
            expr = this.parseExpression();
            this.expect(11);
            expr = this.wrapParenthesis(startLoc2, expr);
            const paramsStartLoc = this.state.startLoc;
            node.expression = this.parseMaybeDecoratorArguments(expr, startLoc2);
            if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node.expression !== expr) {
              this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);
            }
          } else {
            expr = this.parseIdentifier(false);
            while (this.eat(16)) {
              const node2 = this.startNodeAt(startLoc);
              node2.object = expr;
              if (this.match(139)) {
                this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                node2.property = this.parsePrivateName();
              } else {
                node2.property = this.parseIdentifier(true);
              }
              node2.computed = false;
              expr = this.finishNode(node2, "MemberExpression");
            }
            node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);
          }
        } else {
          node.expression = this.parseExprSubscripts();
        }
        return this.finishNode(node, "Decorator");
      }
      parseMaybeDecoratorArguments(expr, startLoc) {
        if (this.eat(10)) {
          const node = this.startNodeAt(startLoc);
          node.callee = expr;
          node.arguments = this.parseCallExpressionArguments();
          this.toReferencedList(node.arguments);
          return this.finishNode(node, "CallExpression");
        }
        return expr;
      }
      parseBreakContinueStatement(node, isBreak) {
        this.next();
        if (this.isLineTerminator()) {
          node.label = null;
        } else {
          node.label = this.parseIdentifier();
          this.semicolon();
        }
        this.verifyBreakContinue(node, isBreak);
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      }
      verifyBreakContinue(node, isBreak) {
        let i;
        for (i = 0; i < this.state.labels.length; ++i) {
          const lab = this.state.labels[i];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === 1)) {
              break;
            }
            if (node.label && isBreak) break;
          }
        }
        if (i === this.state.labels.length) {
          const type = isBreak ? "BreakStatement" : "ContinueStatement";
          this.raise(Errors.IllegalBreakContinue, node, {
            type
          });
        }
      }
      parseDebuggerStatement(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      }
      parseHeaderExpression() {
        this.expect(10);
        const val = this.parseExpression();
        this.expect(11);
        return val;
      }
      parseDoWhileStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.state.labels.pop();
        this.expect(92);
        node.test = this.parseHeaderExpression();
        this.eat(13);
        return this.finishNode(node, "DoWhileStatement");
      }
      parseForStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        let awaitAt = null;
        if (this.isContextual(96) && this.recordAwaitIfAllowed()) {
          awaitAt = this.state.startLoc;
          this.next();
        }
        this.scope.enter(0);
        this.expect(10);
        if (this.match(13)) {
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        const startsWithLet = this.isContextual(100);
        {
          const startsWithAwaitUsing = this.isAwaitUsing();
          const starsWithUsingDeclaration = startsWithAwaitUsing || this.isForUsing();
          const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
          if (this.match(74) || this.match(75) || isLetOrUsing) {
            const initNode = this.startNode();
            let kind;
            if (startsWithAwaitUsing) {
              kind = "await using";
              if (!this.recordAwaitIfAllowed()) {
                this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);
              }
              this.next();
            } else {
              kind = this.state.value;
            }
            this.next();
            this.parseVar(initNode, true, kind);
            const init2 = this.finishNode(initNode, "VariableDeclaration");
            const isForIn = this.match(58);
            if (isForIn && starsWithUsingDeclaration) {
              this.raise(Errors.ForInUsing, init2);
            }
            if ((isForIn || this.isContextual(102)) && init2.declarations.length === 1) {
              return this.parseForIn(node, init2, awaitAt);
            }
            if (awaitAt !== null) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node, init2);
          }
        }
        const startsWithAsync = this.isContextual(95);
        const refExpressionErrors = new ExpressionErrors();
        const init = this.parseExpression(true, refExpressionErrors);
        const isForOf = this.isContextual(102);
        if (isForOf) {
          if (startsWithLet) {
            this.raise(Errors.ForOfLet, init);
          }
          if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
            this.raise(Errors.ForOfAsync, init);
          }
        }
        if (isForOf || this.match(58)) {
          this.checkDestructuringPrivate(refExpressionErrors);
          this.toAssignable(init, true);
          const type = isForOf ? "ForOfStatement" : "ForInStatement";
          this.checkLVal(init, {
            type
          });
          return this.parseForIn(node, init, awaitAt);
        } else {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        if (awaitAt !== null) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      }
      parseFunctionStatement(node, isAsync, isHangingDeclaration) {
        this.next();
        return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
      }
      parseIfStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
        node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
        return this.finishNode(node, "IfStatement");
      }
      parseReturnStatement(node) {
        if (!this.prodParam.hasReturn) {
          this.raise(Errors.IllegalReturn, this.state.startLoc);
        }
        this.next();
        if (this.isLineTerminator()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      }
      parseSwitchStatement(node) {
        this.next();
        node.discriminant = this.parseHeaderExpression();
        const cases = node.cases = [];
        this.expect(5);
        this.state.labels.push(switchLabel);
        this.scope.enter(256);
        let cur;
        for (let sawDefault; !this.match(8); ) {
          if (this.match(61) || this.match(65)) {
            const isCase = this.match(61);
            if (cur) this.finishNode(cur, "SwitchCase");
            cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(14);
          } else {
            if (cur) {
              cur.consequent.push(this.parseStatementListItem());
            } else {
              this.unexpected();
            }
          }
        }
        this.scope.exit();
        if (cur) this.finishNode(cur, "SwitchCase");
        this.next();
        this.state.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      }
      parseThrowStatement(node) {
        this.next();
        if (this.hasPrecedingLineBreak()) {
          this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      }
      parseCatchClauseParam() {
        const param = this.parseBindingAtom();
        this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0);
        this.checkLVal(param, {
          type: "CatchClause"
        }, 9);
        return param;
      }
      parseTryStatement(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.match(62)) {
          const clause = this.startNode();
          this.next();
          if (this.match(10)) {
            this.expect(10);
            clause.param = this.parseCatchClauseParam();
            this.expect(11);
          } else {
            clause.param = null;
            this.scope.enter(0);
          }
          clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
          this.scope.exit();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(67) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(Errors.NoCatchOrFinally, node);
        }
        return this.finishNode(node, "TryStatement");
      }
      parseVarStatement(node, kind, allowMissingInitializer = false) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      }
      parseWhileStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.state.labels.pop();
        return this.finishNode(node, "WhileStatement");
      }
      parseWithStatement(node) {
        if (this.state.strict) {
          this.raise(Errors.StrictWith, this.state.startLoc);
        }
        this.next();
        node.object = this.parseHeaderExpression();
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        return this.finishNode(node, "WithStatement");
      }
      parseEmptyStatement(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      }
      parseLabeledStatement(node, maybeName, expr, flags) {
        for (const label of this.state.labels) {
          if (label.name === maybeName) {
            this.raise(Errors.LabelRedeclaration, expr, {
              labelName: maybeName
            });
          }
        }
        const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;
        for (let i = this.state.labels.length - 1; i >= 0; i--) {
          const label = this.state.labels[i];
          if (label.statementStart === node.start) {
            label.statementStart = this.sourceToOffsetPos(this.state.start);
            label.kind = kind;
          } else {
            break;
          }
        }
        this.state.labels.push({
          name: maybeName,
          kind,
          statementStart: this.sourceToOffsetPos(this.state.start)
        });
        node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
        this.state.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      }
      parseExpressionStatement(node, expr, decorators) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      }
      parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
        const node = this.startNode();
        if (allowDirectives) {
          this.state.strictErrors.clear();
        }
        this.expect(5);
        if (createNewLexicalScope) {
          this.scope.enter(0);
        }
        this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
        if (createNewLexicalScope) {
          this.scope.exit();
        }
        return this.finishNode(node, "BlockStatement");
      }
      isValidDirective(stmt) {
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
      }
      parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        const body = node.body = [];
        const directives = node.directives = [];
        this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
      }
      parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
        const oldStrict = this.state.strict;
        let hasStrictModeDirective = false;
        let parsedNonDirective = false;
        while (!this.match(end)) {
          const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
          if (directives && !parsedNonDirective) {
            if (this.isValidDirective(stmt)) {
              const directive = this.stmtToDirective(stmt);
              directives.push(directive);
              if (!hasStrictModeDirective && directive.value.value === "use strict") {
                hasStrictModeDirective = true;
                this.setStrict(true);
              }
              continue;
            }
            parsedNonDirective = true;
            this.state.strictErrors.clear();
          }
          body.push(stmt);
        }
        afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);
        if (!oldStrict) {
          this.setStrict(false);
        }
        this.next();
      }
      parseFor(node, init) {
        node.init = init;
        this.semicolon(false);
        node.test = this.match(13) ? null : this.parseExpression();
        this.semicolon(false);
        node.update = this.match(11) ? null : this.parseExpression();
        this.expect(11);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, "ForStatement");
      }
      parseForIn(node, init, awaitAt) {
        const isForIn = this.match(58);
        this.next();
        if (isForIn) {
          if (awaitAt !== null) this.unexpected(awaitAt);
        } else {
          node.await = awaitAt !== null;
        }
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(Errors.ForInOfLoopInitializer, init, {
            type: isForIn ? "ForInStatement" : "ForOfStatement"
          });
        }
        if (init.type === "AssignmentPattern") {
          this.raise(Errors.InvalidLhs, init, {
            ancestor: {
              type: "ForStatement"
            }
          });
        }
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
        this.expect(11);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      }
      parseVar(node, isFor, kind, allowMissingInitializer = false) {
        const declarations = node.declarations = [];
        node.kind = kind;
        for (; ; ) {
          const decl = this.startNode();
          this.parseVarId(decl, kind);
          decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
          if (decl.init === null && !allowMissingInitializer) {
            if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102)))) {
              this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                kind: "destructuring"
              });
            } else if ((kind === "const" || kind === "using" || kind === "await using") && !(this.match(58) || this.isContextual(102))) {
              this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                kind
              });
            }
          }
          declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(12)) break;
        }
        return node;
      }
      parseVarId(decl, kind) {
        const id = this.parseBindingAtom();
        if (kind === "using" || kind === "await using") {
          if (id.type === "ArrayPattern" || id.type === "ObjectPattern") {
            this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start);
          }
        } else {
          if (id.type === "VoidPattern") {
            this.raise(Errors.UnexpectedVoidPattern, id.loc.start);
          }
        }
        this.checkLVal(id, {
          type: "VariableDeclarator"
        }, kind === "var" ? 5 : 8201);
        decl.id = id;
      }
      parseAsyncFunctionExpression(node) {
        return this.parseFunction(node, 8);
      }
      parseFunction(node, flags = 0) {
        const hangingDeclaration = flags & 2;
        const isDeclaration = !!(flags & 1);
        const requireId = isDeclaration && !(flags & 4);
        const isAsync = !!(flags & 8);
        this.initFunction(node, isAsync);
        if (this.match(55)) {
          if (hangingDeclaration) {
            this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);
          }
          this.next();
          node.generator = true;
        }
        if (isDeclaration) {
          node.id = this.parseFunctionId(requireId);
        }
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = false;
        this.scope.enter(514);
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        if (!isDeclaration) {
          node.id = this.parseFunctionId();
        }
        this.parseFunctionParams(node, false);
        this.withSmartMixTopicForbiddingContext(() => {
          this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
        });
        this.prodParam.exit();
        this.scope.exit();
        if (isDeclaration && !hangingDeclaration) {
          this.registerFunctionStatementId(node);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return node;
      }
      parseFunctionId(requireId) {
        return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
      }
      parseFunctionParams(node, isConstructor) {
        this.expect(10);
        this.expressionScope.enter(newParameterDeclarationScope());
        node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));
        this.expressionScope.exit();
      }
      registerFunctionStatementId(node) {
        if (!node.id) return;
        this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);
      }
      parseClass(node, isStatement, optionalId) {
        this.next();
        const oldStrict = this.state.strict;
        this.state.strict = true;
        this.parseClassId(node, isStatement, optionalId);
        this.parseClassSuper(node);
        node.body = this.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      }
      isClassProperty() {
        return this.match(29) || this.match(13) || this.match(8);
      }
      isClassMethod() {
        return this.match(10);
      }
      nameIsConstructor(key) {
        return key.type === "Identifier" && key.name === "constructor" || key.type === "StringLiteral" && key.value === "constructor";
      }
      isNonstaticConstructor(method) {
        return !method.computed && !method.static && this.nameIsConstructor(method.key);
      }
      parseClassBody(hadSuperClass, oldStrict) {
        this.classScope.enter();
        const state = {
          hadConstructor: false,
          hadSuperClass
        };
        let decorators = [];
        const classBody = this.startNode();
        classBody.body = [];
        this.expect(5);
        this.withSmartMixTopicForbiddingContext(() => {
          while (!this.match(8)) {
            if (this.eat(13)) {
              if (decorators.length > 0) {
                throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);
              }
              continue;
            }
            if (this.match(26)) {
              decorators.push(this.parseDecorator());
              continue;
            }
            const member = this.startNode();
            if (decorators.length) {
              member.decorators = decorators;
              this.resetStartLocationFromNode(member, decorators[0]);
              decorators = [];
            }
            this.parseClassMember(classBody, member, state);
            if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
              this.raise(Errors.DecoratorConstructor, member);
            }
          }
        });
        this.state.strict = oldStrict;
        this.next();
        if (decorators.length) {
          throw this.raise(Errors.TrailingDecorator, this.state.startLoc);
        }
        this.classScope.exit();
        return this.finishNode(classBody, "ClassBody");
      }
      parseClassMemberFromModifier(classBody, member) {
        const key = this.parseIdentifier(true);
        if (this.isClassMethod()) {
          const method = member;
          method.kind = "method";
          method.computed = false;
          method.key = key;
          method.static = false;
          this.pushClassMethod(classBody, method, false, false, false, false);
          return true;
        } else if (this.isClassProperty()) {
          const prop = member;
          prop.computed = false;
          prop.key = key;
          prop.static = false;
          classBody.body.push(this.parseClassProperty(prop));
          return true;
        }
        this.resetPreviousNodeTrailingComments(key);
        return false;
      }
      parseClassMember(classBody, member, state) {
        const isStatic = this.isContextual(106);
        if (isStatic) {
          if (this.parseClassMemberFromModifier(classBody, member)) {
            return;
          }
          if (this.eat(5)) {
            this.parseClassStaticBlock(classBody, member);
            return;
          }
        }
        this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const publicMethod = member;
        const privateMethod = member;
        const publicProp = member;
        const privateProp = member;
        const accessorProp = member;
        const method = publicMethod;
        const publicMember = publicMethod;
        member.static = isStatic;
        this.parsePropertyNamePrefixOperator(member);
        if (this.eat(55)) {
          method.kind = "method";
          const isPrivateName = this.match(139);
          this.parseClassElementName(method);
          this.parsePostMemberNameModifiers(method);
          if (isPrivateName) {
            this.pushClassPrivateMethod(classBody, privateMethod, true, false);
            return;
          }
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(Errors.ConstructorIsGenerator, publicMethod.key);
          }
          this.pushClassMethod(classBody, publicMethod, true, false, false, false);
          return;
        }
        const isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type);
        const key = this.parseClassElementName(member);
        const maybeContextualKw = isContextual ? key.name : null;
        const isPrivate = this.isPrivateName(key);
        const maybeQuestionTokenStartLoc = this.state.startLoc;
        this.parsePostMemberNameModifiers(publicMember);
        if (this.isClassMethod()) {
          method.kind = "method";
          if (isPrivate) {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
            return;
          }
          const isConstructor = this.isNonstaticConstructor(publicMethod);
          let allowsDirectSuper = false;
          if (isConstructor) {
            publicMethod.kind = "constructor";
            if (state.hadConstructor && !this.hasPlugin("typescript")) {
              this.raise(Errors.DuplicateConstructor, key);
            }
            if (isConstructor && this.hasPlugin("typescript") && member.override) {
              this.raise(Errors.OverrideOnConstructor, key);
            }
            state.hadConstructor = true;
            allowsDirectSuper = state.hadSuperClass;
          }
          this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
        } else if (this.isClassProperty()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else if (maybeContextualKw === "async" && !this.isLineTerminator()) {
          this.resetPreviousNodeTrailingComments(key);
          const isGenerator = this.eat(55);
          if (publicMember.optional) {
            this.unexpected(maybeQuestionTokenStartLoc);
          }
          method.kind = "method";
          const isPrivate2 = this.match(139);
          this.parseClassElementName(method);
          this.parsePostMemberNameModifiers(publicMember);
          if (isPrivate2) {
            this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsAsync, publicMethod.key);
            }
            this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
          }
        } else if ((maybeContextualKw === "get" || maybeContextualKw === "set") && !(this.match(55) && this.isLineTerminator())) {
          this.resetPreviousNodeTrailingComments(key);
          method.kind = maybeContextualKw;
          const isPrivate2 = this.match(139);
          this.parseClassElementName(publicMethod);
          if (isPrivate2) {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsAccessor, publicMethod.key);
            }
            this.pushClassMethod(classBody, publicMethod, false, false, false, false);
          }
          this.checkGetterSetterParams(publicMethod);
        } else if (maybeContextualKw === "accessor" && !this.isLineTerminator()) {
          this.expectPlugin("decoratorAutoAccessors");
          this.resetPreviousNodeTrailingComments(key);
          const isPrivate2 = this.match(139);
          this.parseClassElementName(publicProp);
          this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
        } else if (this.isLineTerminator()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else {
          this.unexpected();
        }
      }
      parseClassElementName(member) {
        const {
          type,
          value
        } = this.state;
        if ((type === 132 || type === 134) && member.static && value === "prototype") {
          this.raise(Errors.StaticPrototype, this.state.startLoc);
        }
        if (type === 139) {
          if (value === "constructor") {
            this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);
          }
          const key = this.parsePrivateName();
          member.key = key;
          return key;
        }
        this.parsePropertyName(member);
        return member.key;
      }
      parseClassStaticBlock(classBody, member) {
        var _member$decorators;
        this.scope.enter(576 | 128 | 16);
        const oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(0);
        const body = member.body = [];
        this.parseBlockOrModuleBlockBody(body, void 0, false, 8);
        this.prodParam.exit();
        this.scope.exit();
        this.state.labels = oldLabels;
        classBody.body.push(this.finishNode(member, "StaticBlock"));
        if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
          this.raise(Errors.DecoratorStaticBlock, member);
        }
      }
      pushClassProperty(classBody, prop) {
        if (!prop.computed && this.nameIsConstructor(prop.key)) {
          this.raise(Errors.ConstructorClassField, prop.key);
        }
        classBody.body.push(this.parseClassProperty(prop));
      }
      pushClassPrivateProperty(classBody, prop) {
        const node = this.parseClassPrivateProperty(prop);
        classBody.body.push(node);
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
      }
      pushClassAccessorProperty(classBody, prop, isPrivate) {
        if (!isPrivate && !prop.computed && this.nameIsConstructor(prop.key)) {
          this.raise(Errors.ConstructorClassField, prop.key);
        }
        const node = this.parseClassAccessorProperty(prop);
        classBody.body.push(node);
        if (isPrivate) {
          this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
        }
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
        classBody.body.push(node);
        const kind = node.kind === "get" ? node.static ? 6 : 2 : node.kind === "set" ? node.static ? 5 : 1 : 0;
        this.declareClassPrivateMethodInScope(node, kind);
      }
      declareClassPrivateMethodInScope(node, kind) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
      }
      parsePostMemberNameModifiers(methodOrProp) {
      }
      parseClassPrivateProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassPrivateProperty");
      }
      parseClassProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassProperty");
      }
      parseClassAccessorProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassAccessorProperty");
      }
      parseInitializer(node) {
        this.scope.enter(576 | 16);
        this.expressionScope.enter(newExpressionScope());
        this.prodParam.enter(0);
        node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
        this.expressionScope.exit();
        this.prodParam.exit();
        this.scope.exit();
      }
      parseClassId(node, isStatement, optionalId, bindingType = 8331) {
        if (tokenIsIdentifier(this.state.type)) {
          node.id = this.parseIdentifier();
          if (isStatement) {
            this.declareNameFromIdentifier(node.id, bindingType);
          }
        } else {
          if (optionalId || !isStatement) {
            node.id = null;
          } else {
            throw this.raise(Errors.MissingClassName, this.state.startLoc);
          }
        }
      }
      parseClassSuper(node) {
        node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
      }
      parseExport(node, decorators) {
        const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);
        const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
        const parseAfterDefault = !hasDefault || this.eat(12);
        const hasStar = parseAfterDefault && this.eatExportStar(node);
        const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
        const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
        const isFromRequired = hasDefault || hasStar;
        if (hasStar && !hasNamespace) {
          if (hasDefault) this.unexpected();
          if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          this.parseExportFrom(node, true);
          this.sawUnambiguousESM = true;
          return this.finishNode(node, "ExportAllDeclaration");
        }
        const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
        if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
          this.unexpected(null, 5);
        }
        if (hasNamespace && parseAfterNamespace) {
          this.unexpected(null, 98);
        }
        let hasDeclaration;
        if (isFromRequired || hasSpecifiers) {
          hasDeclaration = false;
          if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          this.parseExportFrom(node, isFromRequired);
        } else {
          hasDeclaration = this.maybeParseExportDeclaration(node);
        }
        if (isFromRequired || hasSpecifiers || hasDeclaration) {
          var _node2$declaration;
          const node2 = node;
          this.checkExport(node2, true, false, !!node2.source);
          if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration") {
            this.maybeTakeDecorators(decorators, node2.declaration, node2);
          } else if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          this.sawUnambiguousESM = true;
          return this.finishNode(node2, "ExportNamedDeclaration");
        }
        if (this.eat(65)) {
          const node2 = node;
          const decl = this.parseExportDefaultExpression();
          node2.declaration = decl;
          if (decl.type === "ClassDeclaration") {
            this.maybeTakeDecorators(decorators, decl, node2);
          } else if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          this.checkExport(node2, true, true);
          this.sawUnambiguousESM = true;
          return this.finishNode(node2, "ExportDefaultDeclaration");
        }
        throw this.unexpected(null, 5);
      }
      eatExportStar(node) {
        return this.eat(55);
      }
      maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
          this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);
          const id = maybeDefaultIdentifier || this.parseIdentifier(true);
          const specifier = this.startNodeAtNode(id);
          specifier.exported = id;
          node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
          return true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(node) {
        if (this.isContextual(93)) {
          var _ref, _ref$specifiers;
          (_ref$specifiers = (_ref = node).specifiers) != null ? _ref$specifiers : _ref.specifiers = [];
          const specifier = this.startNodeAt(this.state.lastTokStartLoc);
          this.next();
          specifier.exported = this.parseModuleExportName();
          node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
          return true;
        }
        return false;
      }
      maybeParseExportNamedSpecifiers(node) {
        if (this.match(5)) {
          const node2 = node;
          if (!node2.specifiers) node2.specifiers = [];
          const isTypeExport = node2.exportKind === "type";
          node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
          node2.source = null;
          if (this.hasPlugin("importAssertions")) {
            node2.assertions = [];
          } else {
            node2.attributes = [];
          }
          node2.declaration = null;
          return true;
        }
        return false;
      }
      maybeParseExportDeclaration(node) {
        if (this.shouldParseExportDeclaration()) {
          node.specifiers = [];
          node.source = null;
          if (this.hasPlugin("importAssertions")) {
            node.assertions = [];
          } else {
            node.attributes = [];
          }
          node.declaration = this.parseExportDeclaration(node);
          return true;
        }
        return false;
      }
      isAsyncFunction() {
        if (!this.isContextual(95)) return false;
        const next = this.nextTokenInLineStart();
        return this.isUnparsedContextual(next, "function");
      }
      parseExportDefaultExpression() {
        const expr = this.startNode();
        if (this.match(68)) {
          this.next();
          return this.parseFunction(expr, 1 | 4);
        } else if (this.isAsyncFunction()) {
          this.next();
          this.next();
          return this.parseFunction(expr, 1 | 4 | 8);
        }
        if (this.match(80)) {
          return this.parseClass(expr, true, true);
        }
        if (this.match(26)) {
          if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
            this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
          }
          return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
        }
        if (this.match(75) || this.match(74) || this.isLet() || this.isUsing() || this.isAwaitUsing()) {
          throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);
        }
        const res = this.parseMaybeAssignAllowIn();
        this.semicolon();
        return res;
      }
      parseExportDeclaration(node) {
        if (this.match(80)) {
          const node2 = this.parseClass(this.startNode(), true, false);
          return node2;
        }
        return this.parseStatementListItem();
      }
      isExportDefaultSpecifier() {
        const {
          type
        } = this.state;
        if (tokenIsIdentifier(type)) {
          if (type === 95 && !this.state.containsEsc || type === 100) {
            return false;
          }
          if ((type === 130 || type === 129) && !this.state.containsEsc) {
            const next2 = this.nextTokenStart();
            const nextChar = this.input.charCodeAt(next2);
            if (nextChar === 123 || this.chStartsBindingIdentifier(nextChar, next2) && !this.input.startsWith("from", next2)) {
              this.expectOnePlugin(["flow", "typescript"]);
              return false;
            }
          }
        } else if (!this.match(65)) {
          return false;
        }
        const next = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next, "from");
        if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
          return true;
        }
        if (this.match(65) && hasFrom) {
          const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
          return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        return false;
      }
      parseExportFrom(node, expect) {
        if (this.eatContextual(98)) {
          node.source = this.parseImportSource();
          this.checkExport(node);
          this.maybeParseImportAttributes(node);
          this.checkJSONModuleImport(node);
        } else if (expect) {
          this.unexpected();
        }
        this.semicolon();
      }
      shouldParseExportDeclaration() {
        const {
          type
        } = this.state;
        if (type === 26) {
          this.expectOnePlugin(["decorators", "decorators-legacy"]);
          if (this.hasPlugin("decorators")) {
            if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
              this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
            }
            return true;
          }
        }
        if (this.isUsing()) {
          this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
          return true;
        }
        if (this.isAwaitUsing()) {
          this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
          return true;
        }
        return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
      }
      checkExport(node, checkNames, isDefault, isFrom) {
        if (checkNames) {
          var _node$specifiers;
          if (isDefault) {
            this.checkDuplicateExports(node, "default");
            if (this.hasPlugin("exportDefaultFrom")) {
              var _declaration$extra;
              const declaration = node.declaration;
              if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
                this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);
              }
            }
          } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
            for (const specifier of node.specifiers) {
              const {
                exported
              } = specifier;
              const exportName = exported.type === "Identifier" ? exported.name : exported.value;
              this.checkDuplicateExports(specifier, exportName);
              if (!isFrom && specifier.local) {
                const {
                  local
                } = specifier;
                if (local.type !== "Identifier") {
                  this.raise(Errors.ExportBindingIsString, specifier, {
                    localName: local.value,
                    exportName
                  });
                } else {
                  this.checkReservedWord(local.name, local.loc.start, true, false);
                  this.scope.checkLocalExport(local);
                }
              }
            }
          } else if (node.declaration) {
            const decl = node.declaration;
            if (decl.type === "FunctionDeclaration" || decl.type === "ClassDeclaration") {
              const {
                id
              } = decl;
              if (!id) throw new Error("Assertion failure");
              this.checkDuplicateExports(node, id.name);
            } else if (decl.type === "VariableDeclaration") {
              for (const declaration of decl.declarations) {
                this.checkDeclaration(declaration.id);
              }
            }
          }
        }
      }
      checkDeclaration(node) {
        if (node.type === "Identifier") {
          this.checkDuplicateExports(node, node.name);
        } else if (node.type === "ObjectPattern") {
          for (const prop of node.properties) {
            this.checkDeclaration(prop);
          }
        } else if (node.type === "ArrayPattern") {
          for (const elem of node.elements) {
            if (elem) {
              this.checkDeclaration(elem);
            }
          }
        } else if (node.type === "ObjectProperty") {
          this.checkDeclaration(node.value);
        } else if (node.type === "RestElement") {
          this.checkDeclaration(node.argument);
        } else if (node.type === "AssignmentPattern") {
          this.checkDeclaration(node.left);
        }
      }
      checkDuplicateExports(node, exportName) {
        if (this.exportedIdentifiers.has(exportName)) {
          if (exportName === "default") {
            this.raise(Errors.DuplicateDefaultExport, node);
          } else {
            this.raise(Errors.DuplicateExport, node, {
              exportName
            });
          }
        }
        this.exportedIdentifiers.add(exportName);
      }
      parseExportSpecifiers(isInTypeExport) {
        const nodes = [];
        let first = true;
        this.expect(5);
        while (!this.eat(8)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.eat(8)) break;
          }
          const isMaybeTypeOnly = this.isContextual(130);
          const isString2 = this.match(134);
          const node = this.startNode();
          node.local = this.parseModuleExportName();
          nodes.push(this.parseExportSpecifier(node, isString2, isInTypeExport, isMaybeTypeOnly));
        }
        return nodes;
      }
      parseExportSpecifier(node, isString2, isInTypeExport, isMaybeTypeOnly) {
        if (this.eatContextual(93)) {
          node.exported = this.parseModuleExportName();
        } else if (isString2) {
          node.exported = this.cloneStringLiteral(node.local);
        } else if (!node.exported) {
          node.exported = this.cloneIdentifier(node.local);
        }
        return this.finishNode(node, "ExportSpecifier");
      }
      parseModuleExportName() {
        if (this.match(134)) {
          const result = this.parseStringLiteral(this.state.value);
          const surrogate = loneSurrogate.exec(result.value);
          if (surrogate) {
            this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {
              surrogateCharCode: surrogate[0].charCodeAt(0)
            });
          }
          return result;
        }
        return this.parseIdentifier(true);
      }
      isJSONModuleImport(node) {
        if (node.assertions != null) {
          return node.assertions.some(({
            key,
            value
          }) => {
            return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
          });
        }
        return false;
      }
      checkImportReflection(node) {
        const {
          specifiers
        } = node;
        const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
        if (node.phase === "source") {
          if (singleBindingType !== "ImportDefaultSpecifier") {
            this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);
          }
        } else if (node.phase === "defer") {
          if (singleBindingType !== "ImportNamespaceSpecifier") {
            this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);
          }
        } else if (node.module) {
          var _node$assertions;
          if (singleBindingType !== "ImportDefaultSpecifier") {
            this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);
          }
          if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {
            this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);
          }
        }
      }
      checkJSONModuleImport(node) {
        if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
          const {
            specifiers
          } = node;
          if (specifiers != null) {
            const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
              let imported;
              if (specifier.type === "ExportSpecifier") {
                imported = specifier.local;
              } else if (specifier.type === "ImportSpecifier") {
                imported = specifier.imported;
              }
              if (imported !== void 0) {
                return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
              }
            });
            if (nonDefaultNamedSpecifier !== void 0) {
              this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);
            }
          }
        }
      }
      isPotentialImportPhase(isExport) {
        if (isExport) return false;
        return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
      }
      applyImportPhase(node, isExport, phase, loc) {
        if (isExport) {
          return;
        }
        if (phase === "module") {
          this.expectPlugin("importReflection", loc);
          node.module = true;
        } else if (this.hasPlugin("importReflection")) {
          node.module = false;
        }
        if (phase === "source") {
          this.expectPlugin("sourcePhaseImports", loc);
          node.phase = "source";
        } else if (phase === "defer") {
          this.expectPlugin("deferredImportEvaluation", loc);
          node.phase = "defer";
        } else if (this.hasPlugin("sourcePhaseImports")) {
          node.phase = null;
        }
      }
      parseMaybeImportPhase(node, isExport) {
        if (!this.isPotentialImportPhase(isExport)) {
          this.applyImportPhase(node, isExport, null);
          return null;
        }
        const phaseIdentifier = this.startNode();
        const phaseIdentifierName = this.parseIdentifierName(true);
        const {
          type
        } = this.state;
        const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
        if (isImportPhase) {
          this.applyImportPhase(node, isExport, phaseIdentifierName, phaseIdentifier.loc.start);
          return null;
        } else {
          this.applyImportPhase(node, isExport, null);
          return this.createIdentifier(phaseIdentifier, phaseIdentifierName);
        }
      }
      isPrecedingIdImportPhase(phase) {
        const {
          type
        } = this.state;
        return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
      }
      parseImport(node) {
        if (this.match(134)) {
          return this.parseImportSourceAndAttributes(node);
        }
        return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));
      }
      parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
        node.specifiers = [];
        const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);
        const parseNext = !hasDefault || this.eat(12);
        const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
        this.expectContextual(98);
        return this.parseImportSourceAndAttributes(node);
      }
      parseImportSourceAndAttributes(node) {
        var _node$specifiers2;
        (_node$specifiers2 = node.specifiers) != null ? _node$specifiers2 : node.specifiers = [];
        node.source = this.parseImportSource();
        this.maybeParseImportAttributes(node);
        this.checkImportReflection(node);
        this.checkJSONModuleImport(node);
        this.semicolon();
        this.sawUnambiguousESM = true;
        return this.finishNode(node, "ImportDeclaration");
      }
      parseImportSource() {
        if (!this.match(134)) this.unexpected();
        return this.parseExprAtom();
      }
      parseImportSpecifierLocal(node, specifier, type) {
        specifier.local = this.parseIdentifier();
        node.specifiers.push(this.finishImportSpecifier(specifier, type));
      }
      finishImportSpecifier(specifier, type, bindingType = 8201) {
        this.checkLVal(specifier.local, {
          type
        }, bindingType);
        return this.finishNode(specifier, type);
      }
      parseImportAttributes() {
        this.expect(5);
        const attrs = [];
        const attrNames = /* @__PURE__ */ new Set();
        do {
          if (this.match(8)) {
            break;
          }
          const node = this.startNode();
          const keyName = this.state.value;
          if (attrNames.has(keyName)) {
            this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
              key: keyName
            });
          }
          attrNames.add(keyName);
          if (this.match(134)) {
            node.key = this.parseStringLiteral(keyName);
          } else {
            node.key = this.parseIdentifier(true);
          }
          this.expect(14);
          if (!this.match(134)) {
            throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
          }
          node.value = this.parseStringLiteral(this.state.value);
          attrs.push(this.finishNode(node, "ImportAttribute"));
        } while (this.eat(12));
        this.expect(8);
        return attrs;
      }
      parseModuleAttributes() {
        const attrs = [];
        const attributes = /* @__PURE__ */ new Set();
        do {
          const node = this.startNode();
          node.key = this.parseIdentifier(true);
          if (node.key.name !== "type") {
            this.raise(Errors.ModuleAttributeDifferentFromType, node.key);
          }
          if (attributes.has(node.key.name)) {
            this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {
              key: node.key.name
            });
          }
          attributes.add(node.key.name);
          this.expect(14);
          if (!this.match(134)) {
            throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
          }
          node.value = this.parseStringLiteral(this.state.value);
          attrs.push(this.finishNode(node, "ImportAttribute"));
        } while (this.eat(12));
        return attrs;
      }
      maybeParseImportAttributes(node) {
        let attributes;
        var useWith = false;
        if (this.match(76)) {
          if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
            return;
          }
          this.next();
          if (this.hasPlugin("moduleAttributes")) {
            attributes = this.parseModuleAttributes();
            this.addExtra(node, "deprecatedWithLegacySyntax", true);
          } else {
            attributes = this.parseImportAttributes();
          }
          useWith = true;
        } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
          if (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importAssertions")) {
            this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);
          }
          if (!this.hasPlugin("importAssertions")) {
            this.addExtra(node, "deprecatedAssertSyntax", true);
          }
          this.next();
          attributes = this.parseImportAttributes();
        } else {
          attributes = [];
        }
        if (!useWith && this.hasPlugin("importAssertions")) {
          node.assertions = attributes;
        } else {
          node.attributes = attributes;
        }
      }
      maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier) {
          const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
          specifier.local = maybeDefaultIdentifier;
          node.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));
          return true;
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
          return true;
        }
        return false;
      }
      maybeParseStarImportSpecifier(node) {
        if (this.match(55)) {
          const specifier = this.startNode();
          this.next();
          this.expectContextual(93);
          this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
          return true;
        }
        return false;
      }
      parseNamedImportSpecifiers(node) {
        let first = true;
        this.expect(5);
        while (!this.eat(8)) {
          if (first) {
            first = false;
          } else {
            if (this.eat(14)) {
              throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);
            }
            this.expect(12);
            if (this.eat(8)) break;
          }
          const specifier = this.startNode();
          const importedIsString = this.match(134);
          const isMaybeTypeOnly = this.isContextual(130);
          specifier.imported = this.parseModuleExportName();
          const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, void 0);
          node.specifiers.push(importSpecifier);
        }
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (this.eatContextual(93)) {
          specifier.local = this.parseIdentifier();
        } else {
          const {
            imported
          } = specifier;
          if (importedIsString) {
            throw this.raise(Errors.ImportBindingIsString, specifier, {
              importName: imported.value
            });
          }
          this.checkReservedWord(imported.name, specifier.loc.start, true, true);
          if (!specifier.local) {
            specifier.local = this.cloneIdentifier(imported);
          }
        }
        return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
      }
      isThisParam(param) {
        return param.type === "Identifier" && param.name === "this";
      }
    };
    var Parser = class extends StatementParser {
      constructor(options, input, pluginsMap) {
        const normalizedOptions = getOptions(options);
        super(normalizedOptions, input);
        this.options = normalizedOptions;
        this.initializeScopes();
        this.plugins = pluginsMap;
        this.filename = normalizedOptions.sourceFilename;
        this.startIndex = normalizedOptions.startIndex;
        let optionFlags = 0;
        if (normalizedOptions.allowAwaitOutsideFunction) {
          optionFlags |= 1;
        }
        if (normalizedOptions.allowReturnOutsideFunction) {
          optionFlags |= 2;
        }
        if (normalizedOptions.allowImportExportEverywhere) {
          optionFlags |= 8;
        }
        if (normalizedOptions.allowSuperOutsideMethod) {
          optionFlags |= 16;
        }
        if (normalizedOptions.allowUndeclaredExports) {
          optionFlags |= 64;
        }
        if (normalizedOptions.allowNewTargetOutsideFunction) {
          optionFlags |= 4;
        }
        if (normalizedOptions.allowYieldOutsideFunction) {
          optionFlags |= 32;
        }
        if (normalizedOptions.ranges) {
          optionFlags |= 128;
        }
        if (normalizedOptions.tokens) {
          optionFlags |= 256;
        }
        if (normalizedOptions.createImportExpressions) {
          optionFlags |= 512;
        }
        if (normalizedOptions.createParenthesizedExpressions) {
          optionFlags |= 1024;
        }
        if (normalizedOptions.errorRecovery) {
          optionFlags |= 2048;
        }
        if (normalizedOptions.attachComment) {
          optionFlags |= 4096;
        }
        if (normalizedOptions.annexB) {
          optionFlags |= 8192;
        }
        this.optionFlags = optionFlags;
      }
      getScopeHandler() {
        return ScopeHandler;
      }
      parse() {
        this.enterInitialScopes();
        const file = this.startNode();
        const program = this.startNode();
        this.nextToken();
        file.errors = null;
        const result = this.parseTopLevel(file, program);
        result.errors = this.state.errors;
        result.comments.length = this.state.commentsLen;
        return result;
      }
    };
    function parse53(input, options) {
      var _options;
      if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
        options = Object.assign({}, options);
        try {
          options.sourceType = "module";
          const parser = getParser(options, input);
          const ast = parser.parse();
          if (parser.sawUnambiguousESM) {
            return ast;
          }
          if (parser.ambiguousScriptDifferentAst) {
            try {
              options.sourceType = "script";
              return getParser(options, input).parse();
            } catch (_unused) {
            }
          } else {
            ast.program.sourceType = "script";
          }
          return ast;
        } catch (moduleError) {
          try {
            options.sourceType = "script";
            return getParser(options, input).parse();
          } catch (_unused2) {
          }
          throw moduleError;
        }
      } else {
        return getParser(options, input).parse();
      }
    }
    function parseExpression(input, options) {
      const parser = getParser(options, input);
      if (parser.options.strictMode) {
        parser.state.strict = true;
      }
      return parser.getExpression();
    }
    function generateExportedTokenTypes(internalTokenTypes) {
      const tokenTypes3 = {};
      for (const typeName of Object.keys(internalTokenTypes)) {
        tokenTypes3[typeName] = getExportedToken(internalTokenTypes[typeName]);
      }
      return tokenTypes3;
    }
    var tokTypes = generateExportedTokenTypes(tt);
    function getParser(options, input) {
      let cls = Parser;
      const pluginsMap = /* @__PURE__ */ new Map();
      if (options != null && options.plugins) {
        for (const plugin of options.plugins) {
          let name50, opts;
          if (typeof plugin === "string") {
            name50 = plugin;
          } else {
            [name50, opts] = plugin;
          }
          if (!pluginsMap.has(name50)) {
            pluginsMap.set(name50, opts || {});
          }
        }
        validatePlugins(pluginsMap);
        cls = getParserClass(pluginsMap);
      }
      return new cls(options, input, pluginsMap);
    }
    var parserClassCache = /* @__PURE__ */ new Map();
    function getParserClass(pluginsMap) {
      const pluginList = [];
      for (const name50 of mixinPluginNames) {
        if (pluginsMap.has(name50)) {
          pluginList.push(name50);
        }
      }
      const key = pluginList.join("|");
      let cls = parserClassCache.get(key);
      if (!cls) {
        cls = Parser;
        for (const plugin of pluginList) {
          cls = mixinPlugins[plugin](cls);
        }
        parserClassCache.set(key, cls);
      }
      return cls;
    }
    exports.parse = parse53;
    exports.parseExpression = parseExpression;
    exports.tokTypes = tokTypes;
  }
});

// node_modules/@babel/template/lib/parse.js
var require_parse = __commonJS({
  "node_modules/@babel/template/lib/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = parseAndBuildMetadata;
    var _t = require_lib4();
    var _parser = require_lib7();
    var _codeFrame = require_lib6();
    var {
      isCallExpression,
      isExpressionStatement,
      isFunction,
      isIdentifier,
      isJSXIdentifier,
      isNewExpression,
      isPlaceholder,
      isStatement,
      isStringLiteral,
      removePropertiesDeep,
      traverse: traverse2
    } = _t;
    var PATTERN = /^[_$A-Z0-9]+$/;
    function parseAndBuildMetadata(formatter, code2, opts) {
      const {
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders
      } = opts;
      const ast = parseWithCodeFrame(code2, opts.parser, syntacticPlaceholders);
      removePropertiesDeep(ast, {
        preserveComments
      });
      formatter.validate(ast);
      const state = {
        syntactic: {
          placeholders: [],
          placeholderNames: /* @__PURE__ */ new Set()
        },
        legacy: {
          placeholders: [],
          placeholderNames: /* @__PURE__ */ new Set()
        },
        placeholderWhitelist,
        placeholderPattern,
        syntacticPlaceholders
      };
      traverse2(ast, placeholderVisitorHandler, state);
      return Object.assign({
        ast
      }, state.syntactic.placeholders.length ? state.syntactic : state.legacy);
    }
    function placeholderVisitorHandler(node, ancestors, state) {
      var _state$placeholderWhi;
      let name50;
      let hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;
      if (isPlaceholder(node)) {
        if (state.syntacticPlaceholders === false) {
          throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
        }
        name50 = node.name.name;
        hasSyntacticPlaceholders = true;
      } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {
        return;
      } else if (isIdentifier(node) || isJSXIdentifier(node)) {
        name50 = node.name;
      } else if (isStringLiteral(node)) {
        name50 = node.value;
      } else {
        return;
      }
      if (hasSyntacticPlaceholders && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
        throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
      }
      if (!hasSyntacticPlaceholders && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name50)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name50))) {
        return;
      }
      ancestors = ancestors.slice();
      const {
        node: parent,
        key
      } = ancestors[ancestors.length - 1];
      let type;
      if (isStringLiteral(node) || isPlaceholder(node, {
        expectedNode: "StringLiteral"
      })) {
        type = "string";
      } else if (isNewExpression(parent) && key === "arguments" || isCallExpression(parent) && key === "arguments" || isFunction(parent) && key === "params") {
        type = "param";
      } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {
        type = "statement";
        ancestors = ancestors.slice(0, -1);
      } else if (isStatement(node) && isPlaceholder(node)) {
        type = "statement";
      } else {
        type = "other";
      }
      const {
        placeholders: placeholders3,
        placeholderNames
      } = !hasSyntacticPlaceholders ? state.legacy : state.syntactic;
      placeholders3.push({
        name: name50,
        type,
        resolve: (ast) => resolveAncestors(ast, ancestors),
        isDuplicate: placeholderNames.has(name50)
      });
      placeholderNames.add(name50);
    }
    function resolveAncestors(ast, ancestors) {
      let parent = ast;
      for (let i = 0; i < ancestors.length - 1; i++) {
        const {
          key: key2,
          index: index2
        } = ancestors[i];
        if (index2 === void 0) {
          parent = parent[key2];
        } else {
          parent = parent[key2][index2];
        }
      }
      const {
        key,
        index
      } = ancestors[ancestors.length - 1];
      return {
        parent,
        key,
        index
      };
    }
    function parseWithCodeFrame(code2, parserOpts, syntacticPlaceholders) {
      const plugins = (parserOpts.plugins || []).slice();
      if (syntacticPlaceholders !== false) {
        plugins.push("placeholders");
      }
      parserOpts = Object.assign({
        allowAwaitOutsideFunction: true,
        allowReturnOutsideFunction: true,
        allowNewTargetOutsideFunction: true,
        allowSuperOutsideMethod: true,
        allowYieldOutsideFunction: true,
        sourceType: "module"
      }, parserOpts, {
        plugins
      });
      try {
        return (0, _parser.parse)(code2, parserOpts);
      } catch (err) {
        const loc = err.loc;
        if (loc) {
          err.message += "\n" + (0, _codeFrame.codeFrameColumns)(code2, {
            start: loc
          });
          err.code = "BABEL_TEMPLATE_PARSE_ERROR";
        }
        throw err;
      }
    }
  }
});

// node_modules/@babel/template/lib/populate.js
var require_populate = __commonJS({
  "node_modules/@babel/template/lib/populate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = populatePlaceholders;
    var _t = require_lib4();
    var {
      blockStatement,
      cloneNode,
      emptyStatement,
      expressionStatement,
      identifier,
      isStatement,
      isStringLiteral,
      stringLiteral,
      validate
    } = _t;
    function populatePlaceholders(metadata, replacements) {
      const ast = cloneNode(metadata.ast);
      if (replacements) {
        metadata.placeholders.forEach((placeholder) => {
          if (!hasOwnProperty.call(replacements, placeholder.name)) {
            const placeholderName = placeholder.name;
            throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`);
          }
        });
        Object.keys(replacements).forEach((key) => {
          if (!metadata.placeholderNames.has(key)) {
            throw new Error(`Unknown substitution "${key}" given`);
          }
        });
      }
      metadata.placeholders.slice().reverse().forEach((placeholder) => {
        try {
          var _ref;
          applyReplacement(placeholder, ast, (_ref = replacements && replacements[placeholder.name]) != null ? _ref : null);
        } catch (e2) {
          e2.message = `@babel/template placeholder "${placeholder.name}": ${e2.message}`;
          throw e2;
        }
      });
      return ast;
    }
    function applyReplacement(placeholder, ast, replacement) {
      if (placeholder.isDuplicate) {
        if (Array.isArray(replacement)) {
          replacement = replacement.map((node) => cloneNode(node));
        } else if (typeof replacement === "object") {
          replacement = cloneNode(replacement);
        }
      }
      const {
        parent,
        key,
        index
      } = placeholder.resolve(ast);
      if (placeholder.type === "string") {
        if (typeof replacement === "string") {
          replacement = stringLiteral(replacement);
        }
        if (!replacement || !isStringLiteral(replacement)) {
          throw new Error("Expected string substitution");
        }
      } else if (placeholder.type === "statement") {
        if (index === void 0) {
          if (!replacement) {
            replacement = emptyStatement();
          } else if (Array.isArray(replacement)) {
            replacement = blockStatement(replacement);
          } else if (typeof replacement === "string") {
            replacement = expressionStatement(identifier(replacement));
          } else if (!isStatement(replacement)) {
            replacement = expressionStatement(replacement);
          }
        } else {
          if (replacement && !Array.isArray(replacement)) {
            if (typeof replacement === "string") {
              replacement = identifier(replacement);
            }
            if (!isStatement(replacement)) {
              replacement = expressionStatement(replacement);
            }
          }
        }
      } else if (placeholder.type === "param") {
        if (typeof replacement === "string") {
          replacement = identifier(replacement);
        }
        if (index === void 0) throw new Error("Assertion failure.");
      } else {
        if (typeof replacement === "string") {
          replacement = identifier(replacement);
        }
        if (Array.isArray(replacement)) {
          throw new Error("Cannot replace single expression with an array.");
        }
      }
      function set(parent2, key2, value) {
        const node = parent2[key2];
        parent2[key2] = value;
        if (node.type === "Identifier" || node.type === "Placeholder") {
          if (node.typeAnnotation) {
            value.typeAnnotation = node.typeAnnotation;
          }
          if (node.optional) {
            value.optional = node.optional;
          }
          if (node.decorators) {
            value.decorators = node.decorators;
          }
        }
      }
      if (index === void 0) {
        validate(parent, key, replacement);
        set(parent, key, replacement);
      } else {
        const items = parent[key].slice();
        if (placeholder.type === "statement" || placeholder.type === "param") {
          if (replacement == null) {
            items.splice(index, 1);
          } else if (Array.isArray(replacement)) {
            items.splice(index, 1, ...replacement);
          } else {
            set(items, index, replacement);
          }
        } else {
          set(items, index, replacement);
        }
        validate(parent, key, items);
        parent[key] = items;
      }
    }
  }
});

// node_modules/@babel/template/lib/string.js
var require_string = __commonJS({
  "node_modules/@babel/template/lib/string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = stringTemplate;
    var _options = require_options();
    var _parse = require_parse();
    var _populate = require_populate();
    function stringTemplate(formatter, code2, opts) {
      code2 = formatter.code(code2);
      let metadata;
      return (arg) => {
        const replacements = (0, _options.normalizeReplacements)(arg);
        if (!metadata) metadata = (0, _parse.default)(formatter, code2, opts);
        return formatter.unwrap((0, _populate.default)(metadata, replacements));
      };
    }
  }
});

// node_modules/@babel/template/lib/literal.js
var require_literal = __commonJS({
  "node_modules/@babel/template/lib/literal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = literalTemplate;
    var _options = require_options();
    var _parse = require_parse();
    var _populate = require_populate();
    function literalTemplate(formatter, tpl, opts) {
      const {
        metadata,
        names
      } = buildLiteralData(formatter, tpl, opts);
      return (arg) => {
        const defaultReplacements = {};
        arg.forEach((replacement, i) => {
          defaultReplacements[names[i]] = replacement;
        });
        return (arg2) => {
          const replacements = (0, _options.normalizeReplacements)(arg2);
          if (replacements) {
            Object.keys(replacements).forEach((key) => {
              if (hasOwnProperty.call(defaultReplacements, key)) {
                throw new Error("Unexpected replacement overlap.");
              }
            });
          }
          return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
        };
      };
    }
    function buildLiteralData(formatter, tpl, opts) {
      let prefix = "BABEL_TPL$";
      const raw = tpl.join("");
      do {
        prefix = "$$" + prefix;
      } while (raw.includes(prefix));
      const {
        names,
        code: code2
      } = buildTemplateCode(tpl, prefix);
      const metadata = (0, _parse.default)(formatter, formatter.code(code2), {
        parser: opts.parser,
        placeholderWhitelist: new Set(names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
        placeholderPattern: opts.placeholderPattern,
        preserveComments: opts.preserveComments,
        syntacticPlaceholders: opts.syntacticPlaceholders
      });
      return {
        metadata,
        names
      };
    }
    function buildTemplateCode(tpl, prefix) {
      const names = [];
      let code2 = tpl[0];
      for (let i = 1; i < tpl.length; i++) {
        const value = `${prefix}${i - 1}`;
        names.push(value);
        code2 += value + tpl[i];
      }
      return {
        names,
        code: code2
      };
    }
  }
});

// node_modules/@babel/template/lib/builder.js
var require_builder = __commonJS({
  "node_modules/@babel/template/lib/builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = createTemplateBuilder;
    var _options = require_options();
    var _string = require_string();
    var _literal = require_literal();
    var NO_PLACEHOLDER = (0, _options.validate)({
      placeholderPattern: false
    });
    function createTemplateBuilder(formatter, defaultOpts) {
      const templateFnCache = /* @__PURE__ */ new WeakMap();
      const templateAstCache = /* @__PURE__ */ new WeakMap();
      const cachedOpts = defaultOpts || (0, _options.validate)(null);
      return Object.assign((tpl, ...args) => {
        if (typeof tpl === "string") {
          if (args.length > 1) throw new Error("Unexpected extra params.");
          return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));
        } else if (Array.isArray(tpl)) {
          let builder = templateFnCache.get(tpl);
          if (!builder) {
            builder = (0, _literal.default)(formatter, tpl, cachedOpts);
            templateFnCache.set(tpl, builder);
          }
          return extendedTrace(builder(args));
        } else if (typeof tpl === "object" && tpl) {
          if (args.length > 0) throw new Error("Unexpected extra params.");
          return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
        }
        throw new Error(`Unexpected template param ${typeof tpl}`);
      }, {
        ast: (tpl, ...args) => {
          if (typeof tpl === "string") {
            if (args.length > 1) throw new Error("Unexpected extra params.");
            return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();
          } else if (Array.isArray(tpl)) {
            let builder = templateAstCache.get(tpl);
            if (!builder) {
              builder = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER));
              templateAstCache.set(tpl, builder);
            }
            return builder(args)();
          }
          throw new Error(`Unexpected template param ${typeof tpl}`);
        }
      });
    }
    function extendedTrace(fn) {
      let rootStack = "";
      try {
        throw new Error();
      } catch (error) {
        if (error.stack) {
          rootStack = error.stack.split("\n").slice(3).join("\n");
        }
      }
      return (arg) => {
        try {
          return fn(arg);
        } catch (err) {
          err.stack += `
    =============
${rootStack}`;
          throw err;
        }
      };
    }
  }
});

// node_modules/@babel/template/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/@babel/template/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.statements = exports.statement = exports.smart = exports.program = exports.expression = exports.default = void 0;
    var formatters = require_formatters();
    var _builder = require_builder();
    var smart = exports.smart = (0, _builder.default)(formatters.smart);
    var statement = exports.statement = (0, _builder.default)(formatters.statement);
    var statements = exports.statements = (0, _builder.default)(formatters.statements);
    var expression = exports.expression = (0, _builder.default)(formatters.expression);
    var program = exports.program = (0, _builder.default)(formatters.program);
    var _default = exports.default = Object.assign(smart.bind(void 0), {
      smart,
      statement,
      statements,
      expression,
      program,
      ast: smart.ast
    });
  }
});

// node_modules/@babel/traverse/lib/path/conversion.js
var require_conversion = __commonJS({
  "node_modules/@babel/traverse/lib/path/conversion.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.arrowFunctionToExpression = arrowFunctionToExpression;
    exports.ensureBlock = ensureBlock;
    exports.ensureFunctionName = ensureFunctionName;
    exports.splitExportDeclaration = splitExportDeclaration;
    exports.toComputedKey = toComputedKey;
    exports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
    var _t = require_lib4();
    var _template = require_lib8();
    var _visitors = require_visitors();
    var _context = require_context2();
    var {
      arrowFunctionExpression,
      assignmentExpression,
      binaryExpression,
      blockStatement,
      callExpression,
      conditionalExpression,
      expressionStatement,
      identifier,
      isIdentifier,
      jsxIdentifier,
      logicalExpression,
      LOGICAL_OPERATORS,
      memberExpression,
      metaProperty,
      numericLiteral,
      objectExpression,
      restElement,
      returnStatement,
      sequenceExpression,
      spreadElement,
      stringLiteral,
      super: _super,
      thisExpression,
      toExpression,
      unaryExpression,
      toBindingIdentifierName,
      isFunction,
      isAssignmentPattern,
      isRestElement,
      getFunctionName,
      cloneNode,
      variableDeclaration,
      variableDeclarator,
      exportNamedDeclaration,
      exportSpecifier,
      inherits
    } = _t;
    function toComputedKey() {
      let key;
      if (this.isMemberExpression()) {
        key = this.node.property;
      } else if (this.isProperty() || this.isMethod()) {
        key = this.node.key;
      } else {
        throw new ReferenceError("todo");
      }
      if (!this.node.computed) {
        if (isIdentifier(key)) key = stringLiteral(key.name);
      }
      return key;
    }
    function ensureBlock() {
      const body = this.get("body");
      const bodyNode = body.node;
      if (Array.isArray(body)) {
        throw new Error("Can't convert array path to a block statement");
      }
      if (!bodyNode) {
        throw new Error("Can't convert node without a body");
      }
      if (body.isBlockStatement()) {
        return bodyNode;
      }
      const statements = [];
      let stringPath = "body";
      let key;
      let listKey;
      if (body.isStatement()) {
        listKey = "body";
        key = 0;
        statements.push(body.node);
      } else {
        stringPath += ".body.0";
        if (this.isFunction()) {
          key = "argument";
          statements.push(returnStatement(body.node));
        } else {
          key = "expression";
          statements.push(expressionStatement(body.node));
        }
      }
      this.node.body = blockStatement(statements);
      const parentPath = this.get(stringPath);
      _context.setup.call(body, parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
      return this.node;
    }
    {
      exports.arrowFunctionToShadowed = function() {
        if (!this.isArrowFunctionExpression()) return;
        this.arrowFunctionToExpression();
      };
    }
    function unwrapFunctionEnvironment() {
      if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
        throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
      }
      hoistFunctionEnvironment(this);
    }
    function setType(path, type) {
      path.node.type = type;
    }
    function arrowFunctionToExpression({
      allowInsertArrow = true,
      allowInsertArrowWithRest = allowInsertArrow,
      noNewArrows = !((_arguments$) => (_arguments$ = arguments[0]) == null ? void 0 : _arguments$.specCompliant)()
    } = {}) {
      if (!this.isArrowFunctionExpression()) {
        throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
      }
      let self2 = this;
      if (!noNewArrows) {
        var _self$ensureFunctionN;
        self2 = (_self$ensureFunctionN = self2.ensureFunctionName(false)) != null ? _self$ensureFunctionN : self2;
      }
      const {
        thisBinding,
        fnPath: fn
      } = hoistFunctionEnvironment(self2, noNewArrows, allowInsertArrow, allowInsertArrowWithRest);
      fn.ensureBlock();
      setType(fn, "FunctionExpression");
      if (!noNewArrows) {
        const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier("arrowCheckId");
        if (checkBinding) {
          fn.parentPath.scope.push({
            id: checkBinding,
            init: objectExpression([])
          });
        }
        fn.get("body").unshiftContainer("body", expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));
        fn.replaceWith(callExpression(memberExpression(fn.node, identifier("bind")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));
        return fn.get("callee.object");
      }
      return fn;
    }
    var getSuperCallsVisitor = (0, _visitors.environmentVisitor)({
      CallExpression(child, {
        allSuperCalls
      }) {
        if (!child.get("callee").isSuper()) return;
        allSuperCalls.push(child);
      }
    });
    function hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true, allowInsertArrowWithRest = true) {
      let arrowParent;
      let thisEnvFn = fnPath.findParent((p) => {
        if (p.isArrowFunctionExpression()) {
          arrowParent != null ? arrowParent : arrowParent = p;
          return false;
        }
        return p.isFunction() || p.isProgram() || p.isClassProperty({
          static: false
        }) || p.isClassPrivateProperty({
          static: false
        });
      });
      const inConstructor = thisEnvFn.isClassMethod({
        kind: "constructor"
      });
      if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {
        if (arrowParent) {
          thisEnvFn = arrowParent;
        } else if (allowInsertArrow) {
          fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));
          thisEnvFn = fnPath.get("callee");
          fnPath = thisEnvFn.get("body");
        } else {
          throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
        }
      }
      const {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      } = getScopeInformation(fnPath);
      if (inConstructor && superCalls.length > 0) {
        if (!allowInsertArrow) {
          throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
        }
        if (!allowInsertArrowWithRest) {
          throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
        }
        const allSuperCalls = [];
        thisEnvFn.traverse(getSuperCallsVisitor, {
          allSuperCalls
        });
        const superBinding = getSuperBinding(thisEnvFn);
        allSuperCalls.forEach((superCall) => {
          const callee = identifier(superBinding);
          callee.loc = superCall.node.callee.loc;
          superCall.get("callee").replaceWith(callee);
        });
      }
      if (argumentsPaths.length > 0) {
        const argumentsBinding = getBinding(thisEnvFn, "arguments", () => {
          const args = () => identifier("arguments");
          if (thisEnvFn.scope.path.isProgram()) {
            return conditionalExpression(binaryExpression("===", unaryExpression("typeof", args()), stringLiteral("undefined")), thisEnvFn.scope.buildUndefinedNode(), args());
          } else {
            return args();
          }
        });
        argumentsPaths.forEach((argumentsChild) => {
          const argsRef = identifier(argumentsBinding);
          argsRef.loc = argumentsChild.node.loc;
          argumentsChild.replaceWith(argsRef);
        });
      }
      if (newTargetPaths.length > 0) {
        const newTargetBinding = getBinding(thisEnvFn, "newtarget", () => metaProperty(identifier("new"), identifier("target")));
        newTargetPaths.forEach((targetChild) => {
          const targetRef = identifier(newTargetBinding);
          targetRef.loc = targetChild.node.loc;
          targetChild.replaceWith(targetRef);
        });
      }
      if (superProps.length > 0) {
        if (!allowInsertArrow) {
          throw superProps[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
        }
        const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);
        flatSuperProps.forEach((superProp) => {
          const key = superProp.node.computed ? "" : superProp.get("property").node.name;
          const superParentPath = superProp.parentPath;
          const isAssignment = superParentPath.isAssignmentExpression({
            left: superProp.node
          });
          const isCall = superParentPath.isCallExpression({
            callee: superProp.node
          });
          const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({
            tag: superProp.node
          });
          const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
          const args = [];
          if (superProp.node.computed) {
            args.push(superProp.get("property").node);
          }
          if (isAssignment) {
            const value = superParentPath.node.right;
            args.push(value);
          }
          const call = callExpression(identifier(superBinding), args);
          if (isCall) {
            superParentPath.unshiftContainer("arguments", thisExpression());
            superProp.replaceWith(memberExpression(call, identifier("call")));
            thisPaths.push(superParentPath.get("arguments.0"));
          } else if (isAssignment) {
            superParentPath.replaceWith(call);
          } else if (isTaggedTemplate) {
            superProp.replaceWith(callExpression(memberExpression(call, identifier("bind"), false), [thisExpression()]));
            thisPaths.push(superProp.get("arguments.0"));
          } else {
            superProp.replaceWith(call);
          }
        });
      }
      let thisBinding;
      if (thisPaths.length > 0 || !noNewArrows) {
        thisBinding = getThisBinding(thisEnvFn, inConstructor);
        if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {
          thisPaths.forEach((thisChild) => {
            const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);
            thisRef.loc = thisChild.node.loc;
            thisChild.replaceWith(thisRef);
          });
          if (!noNewArrows) thisBinding = null;
        }
      }
      return {
        thisBinding,
        fnPath
      };
    }
    function isLogicalOp(op) {
      return LOGICAL_OPERATORS.includes(op);
    }
    function standardizeSuperProperty(superProp) {
      if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
        const assignmentPath = superProp.parentPath;
        const op = assignmentPath.node.operator.slice(0, -1);
        const value = assignmentPath.node.right;
        const isLogicalAssignment = isLogicalOp(op);
        if (superProp.node.computed) {
          const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
          const object = superProp.node.object;
          const property4 = superProp.node.property;
          assignmentPath.get("left").replaceWith(memberExpression(object, assignmentExpression("=", tmp, property4), true));
          assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(tmp.name), true), value));
        } else {
          const object = superProp.node.object;
          const property4 = superProp.node.property;
          assignmentPath.get("left").replaceWith(memberExpression(object, property4));
          assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(property4.name)), value));
        }
        if (isLogicalAssignment) {
          assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));
        } else {
          assignmentPath.node.operator = "=";
        }
        return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
      } else if (superProp.parentPath.isUpdateExpression()) {
        const updateExpr = superProp.parentPath;
        const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
        const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
        const parts = [assignmentExpression("=", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression("=", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];
        if (!superProp.parentPath.node.prefix) {
          parts.push(identifier(tmp.name));
        }
        updateExpr.replaceWith(sequenceExpression(parts));
        const left = updateExpr.get("expressions.0.right");
        const right = updateExpr.get("expressions.1.left");
        return [left, right];
      }
      return [superProp];
      function rightExpression(op, left, right) {
        if (op === "=") {
          return assignmentExpression("=", left, right);
        } else {
          return binaryExpression(op, left, right);
        }
      }
    }
    function hasSuperClass(thisEnvFn) {
      return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
    }
    var assignSuperThisVisitor = (0, _visitors.environmentVisitor)({
      CallExpression(child, {
        supers,
        thisBinding
      }) {
        if (!child.get("callee").isSuper()) return;
        if (supers.has(child.node)) return;
        supers.add(child.node);
        child.replaceWithMultiple([child.node, assignmentExpression("=", identifier(thisBinding), identifier("this"))]);
      }
    });
    function getThisBinding(thisEnvFn, inConstructor) {
      return getBinding(thisEnvFn, "this", (thisBinding) => {
        if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();
        thisEnvFn.traverse(assignSuperThisVisitor, {
          supers: /* @__PURE__ */ new WeakSet(),
          thisBinding
        });
      });
    }
    function getSuperBinding(thisEnvFn) {
      return getBinding(thisEnvFn, "supercall", () => {
        const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
        return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));
      });
    }
    function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
      const op = isAssignment ? "set" : "get";
      return getBinding(thisEnvFn, `superprop_${op}:${propName || ""}`, () => {
        const argsList = [];
        let fnBody;
        if (propName) {
          fnBody = memberExpression(_super(), identifier(propName));
        } else {
          const method = thisEnvFn.scope.generateUidIdentifier("prop");
          argsList.unshift(method);
          fnBody = memberExpression(_super(), identifier(method.name), true);
        }
        if (isAssignment) {
          const valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
          argsList.push(valueIdent);
          fnBody = assignmentExpression("=", fnBody, identifier(valueIdent.name));
        }
        return arrowFunctionExpression(argsList, fnBody);
      });
    }
    function getBinding(thisEnvFn, key, init) {
      const cacheKey = "binding:" + key;
      let data = thisEnvFn.getData(cacheKey);
      if (!data) {
        const id = thisEnvFn.scope.generateUidIdentifier(key);
        data = id.name;
        thisEnvFn.setData(cacheKey, data);
        thisEnvFn.scope.push({
          id,
          init: init(data)
        });
      }
      return data;
    }
    var getScopeInformationVisitor = (0, _visitors.environmentVisitor)({
      ThisExpression(child, {
        thisPaths
      }) {
        thisPaths.push(child);
      },
      JSXIdentifier(child, {
        thisPaths
      }) {
        if (child.node.name !== "this") return;
        if (!child.parentPath.isJSXMemberExpression({
          object: child.node
        }) && !child.parentPath.isJSXOpeningElement({
          name: child.node
        })) {
          return;
        }
        thisPaths.push(child);
      },
      CallExpression(child, {
        superCalls
      }) {
        if (child.get("callee").isSuper()) superCalls.push(child);
      },
      MemberExpression(child, {
        superProps
      }) {
        if (child.get("object").isSuper()) superProps.push(child);
      },
      Identifier(child, {
        argumentsPaths
      }) {
        if (!child.isReferencedIdentifier({
          name: "arguments"
        })) return;
        let curr = child.scope;
        do {
          if (curr.hasOwnBinding("arguments")) {
            curr.rename("arguments");
            return;
          }
          if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {
            break;
          }
        } while (curr = curr.parent);
        argumentsPaths.push(child);
      },
      MetaProperty(child, {
        newTargetPaths
      }) {
        if (!child.get("meta").isIdentifier({
          name: "new"
        })) return;
        if (!child.get("property").isIdentifier({
          name: "target"
        })) return;
        newTargetPaths.push(child);
      }
    });
    function getScopeInformation(fnPath) {
      const thisPaths = [];
      const argumentsPaths = [];
      const newTargetPaths = [];
      const superProps = [];
      const superCalls = [];
      fnPath.traverse(getScopeInformationVisitor, {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      });
      return {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      };
    }
    function splitExportDeclaration() {
      if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {
        throw new Error("Only default and named export declarations can be split.");
      }
      if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0) {
        throw new Error("It doesn't make sense to split exported specifiers.");
      }
      const declaration = this.get("declaration");
      if (this.isExportDefaultDeclaration()) {
        const standaloneDeclaration = declaration.isFunctionDeclaration() || declaration.isClassDeclaration();
        const exportExpr = declaration.isFunctionExpression() || declaration.isClassExpression();
        const scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;
        let id = declaration.node.id;
        let needBindingRegistration = false;
        if (!id) {
          needBindingRegistration = true;
          id = scope.generateUidIdentifier("default");
          if (standaloneDeclaration || exportExpr) {
            declaration.node.id = cloneNode(id);
          }
        } else if (exportExpr && scope.hasBinding(id.name)) {
          needBindingRegistration = true;
          id = scope.generateUidIdentifier(id.name);
        }
        const updatedDeclaration = standaloneDeclaration ? declaration.node : variableDeclaration("var", [variableDeclarator(cloneNode(id), declaration.node)]);
        const updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id), identifier("default"))]);
        this.insertAfter(updatedExportDeclaration);
        this.replaceWith(updatedDeclaration);
        if (needBindingRegistration) {
          scope.registerDeclaration(this);
        }
        return this;
      } else if (this.get("specifiers").length > 0) {
        throw new Error("It doesn't make sense to split exported specifiers.");
      }
      const bindingIdentifiers = declaration.getOuterBindingIdentifiers();
      const specifiers = Object.keys(bindingIdentifiers).map((name50) => {
        return exportSpecifier(identifier(name50), identifier(name50));
      });
      const aliasDeclar = exportNamedDeclaration(null, specifiers);
      this.insertAfter(aliasDeclar);
      this.replaceWith(declaration.node);
      return this;
    }
    var refersOuterBindingVisitor = {
      "ReferencedIdentifier|BindingIdentifier"(path, state) {
        if (path.node.name !== state.name) return;
        state.needsRename = true;
        path.stop();
      },
      Scope(path, state) {
        if (path.scope.hasOwnBinding(state.name)) {
          path.skip();
        }
      }
    };
    function ensureFunctionName(supportUnicodeId) {
      if (this.node.id) return this;
      const res = getFunctionName(this.node, this.parent);
      if (res == null) return this;
      let {
        name: name50
      } = res;
      if (!supportUnicodeId && /[\uD800-\uDFFF]/.test(name50)) {
        return null;
      }
      if (name50.startsWith("get ") || name50.startsWith("set ")) {
        return null;
      }
      name50 = toBindingIdentifierName(name50.replace(/[/ ]/g, "_"));
      const id = identifier(name50);
      inherits(id, res.originalNode);
      const state = {
        needsRename: false,
        name: name50
      };
      const {
        scope
      } = this;
      const binding = scope.getOwnBinding(name50);
      if (binding) {
        if (binding.kind === "param") {
          state.needsRename = true;
        } else {
        }
      } else if (scope.parent.hasBinding(name50) || scope.hasGlobal(name50)) {
        this.traverse(refersOuterBindingVisitor, state);
      }
      if (!state.needsRename) {
        this.node.id = id;
        {
          scope.getProgramParent().references[id.name] = true;
        }
        return this;
      }
      if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
        scope.rename(id.name);
        this.node.id = id;
        {
          scope.getProgramParent().references[id.name] = true;
        }
        return this;
      }
      if (!isFunction(this.node)) return null;
      const key = scope.generateUidIdentifier(id.name);
      const params = [];
      for (let i = 0, len = getFunctionArity(this.node); i < len; i++) {
        params.push(scope.generateUidIdentifier("x"));
      }
      const call = _template.default.expression.ast`
    (function (${key}) {
      function ${id}(${params}) {
        return ${cloneNode(key)}.apply(this, arguments);
      }

      ${cloneNode(id)}.toString = function () {
        return ${cloneNode(key)}.toString();
      }

      return ${cloneNode(id)};
    })(${toExpression(this.node)})
  `;
      return this.replaceWith(call)[0].get("arguments.0");
    }
    function getFunctionArity(node) {
      const count = node.params.findIndex((param) => isAssignmentPattern(param) || isRestElement(param));
      return count === -1 ? node.params.length : count;
    }
  }
});

// node_modules/@babel/traverse/lib/path/introspection.js
var require_introspection = __commonJS({
  "node_modules/@babel/traverse/lib/path/introspection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
    exports._resolve = _resolve;
    exports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
    exports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
    exports.getSource = getSource;
    exports.isCompletionRecord = isCompletionRecord;
    exports.isConstantExpression = isConstantExpression;
    exports.isInStrictMode = isInStrictMode;
    exports.isNodeType = isNodeType;
    exports.isStatementOrBlock = isStatementOrBlock;
    exports.isStatic = isStatic;
    exports.matchesPattern = matchesPattern;
    exports.referencesImport = referencesImport;
    exports.resolve = resolve;
    exports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
    var _t = require_lib4();
    var {
      STATEMENT_OR_BLOCK_KEYS,
      VISITOR_KEYS,
      isBlockStatement,
      isExpression,
      isIdentifier,
      isLiteral,
      isStringLiteral,
      isType: isType2,
      matchesPattern: _matchesPattern
    } = _t;
    function matchesPattern(pattern, allowPartial) {
      return _matchesPattern(this.node, pattern, allowPartial);
    }
    {
      exports.has = function has(key) {
        var _this$node;
        const val = (_this$node = this.node) == null ? void 0 : _this$node[key];
        if (val && Array.isArray(val)) {
          return !!val.length;
        } else {
          return !!val;
        }
      };
    }
    function isStatic() {
      return this.scope.isStatic(this.node);
    }
    {
      exports.is = exports.has;
      exports.isnt = function isnt(key) {
        return !this.has(key);
      };
      exports.equals = function equals(key, value) {
        return this.node[key] === value;
      };
    }
    function isNodeType(type) {
      return isType2(this.type, type);
    }
    function canHaveVariableDeclarationOrExpression() {
      return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
    }
    function canSwapBetweenExpressionAndStatement(replacement) {
      if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
        return false;
      }
      if (this.isExpression()) {
        return isBlockStatement(replacement);
      } else if (this.isBlockStatement()) {
        return isExpression(replacement);
      }
      return false;
    }
    function isCompletionRecord(allowInsideFunction) {
      let path = this;
      let first = true;
      do {
        const {
          type,
          container: container4
        } = path;
        if (!first && (path.isFunction() || type === "StaticBlock")) {
          return !!allowInsideFunction;
        }
        first = false;
        if (Array.isArray(container4) && path.key !== container4.length - 1) {
          return false;
        }
      } while ((path = path.parentPath) && !path.isProgram() && !path.isDoExpression());
      return true;
    }
    function isStatementOrBlock() {
      if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {
        return false;
      } else {
        return STATEMENT_OR_BLOCK_KEYS.includes(this.key);
      }
    }
    function referencesImport(moduleSource, importName) {
      if (!this.isReferencedIdentifier()) {
        if (this.isJSXMemberExpression() && this.node.property.name === importName || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, {
          value: importName
        }) : this.node.property.name === importName)) {
          const object = this.get("object");
          return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");
        }
        return false;
      }
      const binding = this.scope.getBinding(this.node.name);
      if (!binding || binding.kind !== "module") return false;
      const path = binding.path;
      const parent = path.parentPath;
      if (!parent.isImportDeclaration()) return false;
      if (parent.node.source.value === moduleSource) {
        if (!importName) return true;
      } else {
        return false;
      }
      if (path.isImportDefaultSpecifier() && importName === "default") {
        return true;
      }
      if (path.isImportNamespaceSpecifier() && importName === "*") {
        return true;
      }
      if (path.isImportSpecifier() && isIdentifier(path.node.imported, {
        name: importName
      })) {
        return true;
      }
      return false;
    }
    function getSource() {
      const node = this.node;
      if (node.end) {
        const code2 = this.hub.getCode();
        if (code2) return code2.slice(node.start, node.end);
      }
      return "";
    }
    function willIMaybeExecuteBefore(target) {
      return this._guessExecutionStatusRelativeTo(target) !== "after";
    }
    function getOuterFunction(path) {
      return path.isProgram() ? path : (path.parentPath.scope.getFunctionParent() || path.parentPath.scope.getProgramParent()).path;
    }
    function isExecutionUncertain(type, key) {
      switch (type) {
        case "LogicalExpression":
          return key === "right";
        case "ConditionalExpression":
        case "IfStatement":
          return key === "consequent" || key === "alternate";
        case "WhileStatement":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForOfStatement":
          return key === "body";
        case "ForStatement":
          return key === "body" || key === "update";
        case "SwitchStatement":
          return key === "cases";
        case "TryStatement":
          return key === "handler";
        case "AssignmentPattern":
          return key === "right";
        case "OptionalMemberExpression":
          return key === "property";
        case "OptionalCallExpression":
          return key === "arguments";
        default:
          return false;
      }
    }
    function isExecutionUncertainInList(paths, maxIndex) {
      for (let i = 0; i < maxIndex; i++) {
        const path = paths[i];
        if (isExecutionUncertain(path.parent.type, path.parentKey)) {
          return true;
        }
      }
      return false;
    }
    var SYMBOL_CHECKING = Symbol();
    function _guessExecutionStatusRelativeTo(target) {
      return _guessExecutionStatusRelativeToCached(this, target, /* @__PURE__ */ new Map());
    }
    function _guessExecutionStatusRelativeToCached(base, target, cache) {
      const funcParent = {
        this: getOuterFunction(base),
        target: getOuterFunction(target)
      };
      if (funcParent.target.node !== funcParent.this.node) {
        return _guessExecutionStatusRelativeToDifferentFunctionsCached(base, funcParent.target, cache);
      }
      const paths = {
        target: target.getAncestry(),
        this: base.getAncestry()
      };
      if (paths.target.includes(base)) return "after";
      if (paths.this.includes(target)) return "before";
      let commonPath;
      const commonIndex = {
        target: 0,
        this: 0
      };
      while (!commonPath && commonIndex.this < paths.this.length) {
        const path = paths.this[commonIndex.this];
        commonIndex.target = paths.target.indexOf(path);
        if (commonIndex.target >= 0) {
          commonPath = path;
        } else {
          commonIndex.this++;
        }
      }
      if (!commonPath) {
        throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
      }
      if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
        return "unknown";
      }
      const divergence = {
        this: paths.this[commonIndex.this - 1],
        target: paths.target[commonIndex.target - 1]
      };
      if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {
        return divergence.target.key > divergence.this.key ? "before" : "after";
      }
      const keys = VISITOR_KEYS[commonPath.type];
      const keyPosition = {
        this: keys.indexOf(divergence.this.parentKey),
        target: keys.indexOf(divergence.target.parentKey)
      };
      return keyPosition.target > keyPosition.this ? "before" : "after";
    }
    function _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache) {
      if (!target.isFunctionDeclaration()) {
        if (_guessExecutionStatusRelativeToCached(base, target, cache) === "before") {
          return "before";
        }
        return "unknown";
      } else if (target.parentPath.isExportDeclaration()) {
        return "unknown";
      }
      const binding = target.scope.getBinding(target.node.id.name);
      if (!binding.references) return "before";
      const referencePaths = binding.referencePaths;
      let allStatus;
      for (const path of referencePaths) {
        const childOfFunction = !!path.find((path2) => path2.node === target.node);
        if (childOfFunction) continue;
        if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
          return "unknown";
        }
        const status = _guessExecutionStatusRelativeToCached(base, path, cache);
        if (allStatus && allStatus !== status) {
          return "unknown";
        } else {
          allStatus = status;
        }
      }
      return allStatus;
    }
    function _guessExecutionStatusRelativeToDifferentFunctionsCached(base, target, cache) {
      let nodeMap = cache.get(base.node);
      let cached;
      if (!nodeMap) {
        cache.set(base.node, nodeMap = /* @__PURE__ */ new Map());
      } else if (cached = nodeMap.get(target.node)) {
        if (cached === SYMBOL_CHECKING) {
          return "unknown";
        }
        return cached;
      }
      nodeMap.set(target.node, SYMBOL_CHECKING);
      const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache);
      nodeMap.set(target.node, result);
      return result;
    }
    function resolve(dangerous, resolved) {
      return _resolve.call(this, dangerous, resolved) || this;
    }
    function _resolve(dangerous, resolved) {
      var _resolved;
      if ((_resolved = resolved) != null && _resolved.includes(this)) return;
      resolved = resolved || [];
      resolved.push(this);
      if (this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier()) {
          return this.get("init").resolve(dangerous, resolved);
        } else {
        }
      } else if (this.isReferencedIdentifier()) {
        const binding = this.scope.getBinding(this.node.name);
        if (!binding) return;
        if (!binding.constant) return;
        if (binding.kind === "module") return;
        if (binding.path !== this) {
          const ret = binding.path.resolve(dangerous, resolved);
          if (this.find((parent) => parent.node === ret.node)) return;
          return ret;
        }
      } else if (this.isTypeCastExpression()) {
        return this.get("expression").resolve(dangerous, resolved);
      } else if (dangerous && this.isMemberExpression()) {
        const targetKey = this.toComputedKey();
        if (!isLiteral(targetKey)) return;
        const targetName = targetKey.value;
        const target = this.get("object").resolve(dangerous, resolved);
        if (target.isObjectExpression()) {
          const props = target.get("properties");
          for (const prop of props) {
            if (!prop.isProperty()) continue;
            const key = prop.get("key");
            let match = prop.isnt("computed") && key.isIdentifier({
              name: targetName
            });
            match = match || key.isLiteral({
              value: targetName
            });
            if (match) return prop.get("value").resolve(dangerous, resolved);
          }
        } else if (target.isArrayExpression() && !isNaN(+targetName)) {
          const elems = target.get("elements");
          const elem = elems[targetName];
          if (elem) return elem.resolve(dangerous, resolved);
        }
      }
    }
    function isConstantExpression() {
      if (this.isIdentifier()) {
        const binding = this.scope.getBinding(this.node.name);
        if (!binding) return false;
        return binding.constant;
      }
      if (this.isLiteral()) {
        if (this.isRegExpLiteral()) {
          return false;
        }
        if (this.isTemplateLiteral()) {
          return this.get("expressions").every((expression) => expression.isConstantExpression());
        }
        return true;
      }
      if (this.isUnaryExpression()) {
        if (this.node.operator !== "void") {
          return false;
        }
        return this.get("argument").isConstantExpression();
      }
      if (this.isBinaryExpression()) {
        const {
          operator
        } = this.node;
        return operator !== "in" && operator !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
      }
      if (this.isMemberExpression()) {
        return !this.node.computed && this.get("object").isIdentifier({
          name: "Symbol"
        }) && !this.scope.hasBinding("Symbol", {
          noGlobals: true
        });
      }
      if (this.isCallExpression()) {
        return this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding("Symbol", {
          noGlobals: true
        }) && this.get("arguments")[0].isStringLiteral();
      }
      return false;
    }
    function isInStrictMode() {
      const start = this.isProgram() ? this : this.parentPath;
      const strictParent = start.find((path) => {
        if (path.isProgram({
          sourceType: "module"
        })) return true;
        if (path.isClass()) return true;
        if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement()) {
          return false;
        }
        let body;
        if (path.isFunction()) {
          body = path.node.body;
        } else if (path.isProgram()) {
          body = path.node;
        } else {
          return false;
        }
        for (const directive of body.directives) {
          if (directive.value.value === "use strict") {
            return true;
          }
        }
      });
      return !!strictParent;
    }
  }
});

// node_modules/@babel/traverse/lib/path/family.js
var require_family = __commonJS({
  "node_modules/@babel/traverse/lib/path/family.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports._getKey = _getKey;
    exports._getPattern = _getPattern;
    exports.get = get;
    exports.getAllNextSiblings = getAllNextSiblings;
    exports.getAllPrevSiblings = getAllPrevSiblings;
    exports.getAssignmentIdentifiers = getAssignmentIdentifiers;
    exports.getBindingIdentifierPaths = getBindingIdentifierPaths;
    exports.getBindingIdentifiers = getBindingIdentifiers;
    exports.getCompletionRecords = getCompletionRecords;
    exports.getNextSibling = getNextSibling;
    exports.getOpposite = getOpposite;
    exports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;
    exports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
    exports.getPrevSibling = getPrevSibling;
    exports.getSibling = getSibling;
    var _index = require_path();
    var _t = require_lib4();
    var {
      getAssignmentIdentifiers: _getAssignmentIdentifiers,
      getBindingIdentifiers: _getBindingIdentifiers,
      getOuterBindingIdentifiers: _getOuterBindingIdentifiers,
      numericLiteral,
      unaryExpression
    } = _t;
    var NORMAL_COMPLETION = 0;
    var BREAK_COMPLETION = 1;
    function NormalCompletion(path) {
      return {
        type: NORMAL_COMPLETION,
        path
      };
    }
    function BreakCompletion(path) {
      return {
        type: BREAK_COMPLETION,
        path
      };
    }
    function getOpposite() {
      if (this.key === "left") {
        return this.getSibling("right");
      } else if (this.key === "right") {
        return this.getSibling("left");
      }
      return null;
    }
    function addCompletionRecords(path, records, context) {
      if (path) {
        records.push(..._getCompletionRecords(path, context));
      }
      return records;
    }
    function completionRecordForSwitch(cases, records, context) {
      let lastNormalCompletions = [];
      for (let i = 0; i < cases.length; i++) {
        const casePath = cases[i];
        const caseCompletions = _getCompletionRecords(casePath, context);
        const normalCompletions = [];
        const breakCompletions = [];
        for (const c of caseCompletions) {
          if (c.type === NORMAL_COMPLETION) {
            normalCompletions.push(c);
          }
          if (c.type === BREAK_COMPLETION) {
            breakCompletions.push(c);
          }
        }
        if (normalCompletions.length) {
          lastNormalCompletions = normalCompletions;
        }
        records.push(...breakCompletions);
      }
      records.push(...lastNormalCompletions);
      return records;
    }
    function normalCompletionToBreak(completions) {
      completions.forEach((c) => {
        c.type = BREAK_COMPLETION;
      });
    }
    function replaceBreakStatementInBreakCompletion(completions, reachable) {
      completions.forEach((c) => {
        if (c.path.isBreakStatement({
          label: null
        })) {
          if (reachable) {
            c.path.replaceWith(unaryExpression("void", numericLiteral(0)));
          } else {
            c.path.remove();
          }
        }
      });
    }
    function getStatementListCompletion(paths, context) {
      const completions = [];
      if (context.canHaveBreak) {
        let lastNormalCompletions = [];
        for (let i = 0; i < paths.length; i++) {
          const path = paths[i];
          const newContext = Object.assign({}, context, {
            inCaseClause: false
          });
          if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {
            newContext.shouldPopulateBreak = true;
          } else {
            newContext.shouldPopulateBreak = false;
          }
          const statementCompletions = _getCompletionRecords(path, newContext);
          if (statementCompletions.length > 0 && statementCompletions.every((c) => c.type === BREAK_COMPLETION)) {
            if (lastNormalCompletions.length > 0 && statementCompletions.every((c) => c.path.isBreakStatement({
              label: null
            }))) {
              normalCompletionToBreak(lastNormalCompletions);
              completions.push(...lastNormalCompletions);
              if (lastNormalCompletions.some((c) => c.path.isDeclaration())) {
                completions.push(...statementCompletions);
                if (!context.shouldPreserveBreak) {
                  replaceBreakStatementInBreakCompletion(statementCompletions, true);
                }
              }
              if (!context.shouldPreserveBreak) {
                replaceBreakStatementInBreakCompletion(statementCompletions, false);
              }
            } else {
              completions.push(...statementCompletions);
              if (!context.shouldPopulateBreak && !context.shouldPreserveBreak) {
                replaceBreakStatementInBreakCompletion(statementCompletions, true);
              }
            }
            break;
          }
          if (i === paths.length - 1) {
            completions.push(...statementCompletions);
          } else {
            lastNormalCompletions = [];
            for (let i2 = 0; i2 < statementCompletions.length; i2++) {
              const c = statementCompletions[i2];
              if (c.type === BREAK_COMPLETION) {
                completions.push(c);
              }
              if (c.type === NORMAL_COMPLETION) {
                lastNormalCompletions.push(c);
              }
            }
          }
        }
      } else if (paths.length) {
        for (let i = paths.length - 1; i >= 0; i--) {
          const pathCompletions = _getCompletionRecords(paths[i], context);
          if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration() && !pathCompletions[0].path.isEmptyStatement()) {
            completions.push(...pathCompletions);
            break;
          }
        }
      }
      return completions;
    }
    function _getCompletionRecords(path, context) {
      let records = [];
      if (path.isIfStatement()) {
        records = addCompletionRecords(path.get("consequent"), records, context);
        records = addCompletionRecords(path.get("alternate"), records, context);
      } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {
        return addCompletionRecords(path.get("body"), records, context);
      } else if (path.isProgram() || path.isBlockStatement()) {
        return getStatementListCompletion(path.get("body"), context);
      } else if (path.isFunction()) {
        return _getCompletionRecords(path.get("body"), context);
      } else if (path.isTryStatement()) {
        records = addCompletionRecords(path.get("block"), records, context);
        records = addCompletionRecords(path.get("handler"), records, context);
      } else if (path.isCatchClause()) {
        return addCompletionRecords(path.get("body"), records, context);
      } else if (path.isSwitchStatement()) {
        return completionRecordForSwitch(path.get("cases"), records, context);
      } else if (path.isSwitchCase()) {
        return getStatementListCompletion(path.get("consequent"), {
          canHaveBreak: true,
          shouldPopulateBreak: false,
          inCaseClause: true,
          shouldPreserveBreak: context.shouldPreserveBreak
        });
      } else if (path.isBreakStatement()) {
        records.push(BreakCompletion(path));
      } else {
        records.push(NormalCompletion(path));
      }
      return records;
    }
    function getCompletionRecords(shouldPreserveBreak = false) {
      const records = _getCompletionRecords(this, {
        canHaveBreak: false,
        shouldPopulateBreak: false,
        inCaseClause: false,
        shouldPreserveBreak
      });
      return records.map((r) => r.path);
    }
    function getSibling(key) {
      return _index.default.get({
        parentPath: this.parentPath,
        parent: this.parent,
        container: this.container,
        listKey: this.listKey,
        key
      }).setContext(this.context);
    }
    function getPrevSibling() {
      return this.getSibling(this.key - 1);
    }
    function getNextSibling() {
      return this.getSibling(this.key + 1);
    }
    function getAllNextSiblings() {
      let _key = this.key;
      let sibling = this.getSibling(++_key);
      const siblings = [];
      while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(++_key);
      }
      return siblings;
    }
    function getAllPrevSiblings() {
      let _key = this.key;
      let sibling = this.getSibling(--_key);
      const siblings = [];
      while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(--_key);
      }
      return siblings;
    }
    function get(key, context = true) {
      if (context === true) context = this.context;
      const parts = key.split(".");
      if (parts.length === 1) {
        return _getKey.call(this, key, context);
      } else {
        return _getPattern.call(this, parts, context);
      }
    }
    function _getKey(key, context) {
      const node = this.node;
      const container4 = node[key];
      if (Array.isArray(container4)) {
        return container4.map((_, i) => {
          return _index.default.get({
            listKey: key,
            parentPath: this,
            parent: node,
            container: container4,
            key: i
          }).setContext(context);
        });
      } else {
        return _index.default.get({
          parentPath: this,
          parent: node,
          container: node,
          key
        }).setContext(context);
      }
    }
    function _getPattern(parts, context) {
      let path = this;
      for (const part of parts) {
        if (part === ".") {
          path = path.parentPath;
        } else {
          if (Array.isArray(path)) {
            path = path[part];
          } else {
            path = path.get(part, context);
          }
        }
      }
      return path;
    }
    function getAssignmentIdentifiers() {
      return _getAssignmentIdentifiers(this.node);
    }
    function getBindingIdentifiers(duplicates) {
      return _getBindingIdentifiers(this.node, duplicates);
    }
    function getOuterBindingIdentifiers(duplicates) {
      return _getOuterBindingIdentifiers(this.node, duplicates);
    }
    function getBindingIdentifierPaths(duplicates = false, outerOnly = false) {
      const path = this;
      const search = [path];
      const ids = /* @__PURE__ */ Object.create(null);
      while (search.length) {
        const id = search.shift();
        if (!id) continue;
        if (!id.node) continue;
        const keys = _getBindingIdentifiers.keys[id.node.type];
        if (id.isIdentifier()) {
          if (duplicates) {
            const _ids = ids[id.node.name] = ids[id.node.name] || [];
            _ids.push(id);
          } else {
            ids[id.node.name] = id;
          }
          continue;
        }
        if (id.isExportDeclaration()) {
          const declaration = id.get("declaration");
          if (declaration.isDeclaration()) {
            search.push(declaration);
          }
          continue;
        }
        if (outerOnly) {
          if (id.isFunctionDeclaration()) {
            search.push(id.get("id"));
            continue;
          }
          if (id.isFunctionExpression()) {
            continue;
          }
        }
        if (keys) {
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const child = id.get(key);
            if (Array.isArray(child)) {
              search.push(...child);
            } else if (child.node) {
              search.push(child);
            }
          }
        }
      }
      return ids;
    }
    function getOuterBindingIdentifierPaths(duplicates = false) {
      return this.getBindingIdentifierPaths(duplicates, true);
    }
  }
});

// node_modules/@babel/traverse/lib/path/comments.js
var require_comments = __commonJS({
  "node_modules/@babel/traverse/lib/path/comments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.addComment = addComment;
    exports.addComments = addComments;
    exports.shareCommentsWithSiblings = shareCommentsWithSiblings;
    var _t = require_lib4();
    var {
      addComment: _addComment,
      addComments: _addComments
    } = _t;
    function shareCommentsWithSiblings() {
      if (typeof this.key === "string") return;
      const node = this.node;
      if (!node) return;
      const trailing = node.trailingComments;
      const leading2 = node.leadingComments;
      if (!trailing && !leading2) return;
      const prev = this.getSibling(this.key - 1);
      const next = this.getSibling(this.key + 1);
      const hasPrev = Boolean(prev.node);
      const hasNext = Boolean(next.node);
      if (hasPrev) {
        if (leading2) {
          prev.addComments("trailing", removeIfExisting(leading2, prev.node.trailingComments));
        }
        if (trailing && !hasNext) prev.addComments("trailing", trailing);
      }
      if (hasNext) {
        if (trailing) {
          next.addComments("leading", removeIfExisting(trailing, next.node.leadingComments));
        }
        if (leading2 && !hasPrev) next.addComments("leading", leading2);
      }
    }
    function removeIfExisting(list, toRemove) {
      if (!(toRemove != null && toRemove.length)) return list;
      const set = new Set(toRemove);
      return list.filter((el) => {
        return !set.has(el);
      });
    }
    function addComment(type, content, line) {
      _addComment(this.node, type, content, line);
    }
    function addComments(type, comments) {
      _addComments(this.node, type, comments);
    }
  }
});

// node_modules/@babel/traverse/lib/path/index.js
var require_path = __commonJS({
  "node_modules/@babel/traverse/lib/path/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.SHOULD_STOP = exports.SHOULD_SKIP = exports.REMOVED = void 0;
    var virtualTypes = require_virtual_types();
    var _debug = require_browser();
    var _index = require_lib9();
    var _index2 = require_scope();
    var _t = require_lib4();
    var t = _t;
    var cache = require_cache();
    var _generator = require_lib5();
    var NodePath_ancestry = require_ancestry();
    var NodePath_inference = require_inference();
    var NodePath_replacement = require_replacement();
    var NodePath_evaluation = require_evaluation();
    var NodePath_conversion = require_conversion();
    var NodePath_introspection = require_introspection();
    var _context = require_context2();
    var NodePath_context = _context;
    var NodePath_removal = require_removal();
    var NodePath_modification = require_modification();
    var NodePath_family = require_family();
    var NodePath_comments = require_comments();
    var NodePath_virtual_types_validator = require_virtual_types_validator();
    var {
      validate
    } = _t;
    var debug = _debug("babel");
    var REMOVED = exports.REMOVED = 1 << 0;
    var SHOULD_STOP = exports.SHOULD_STOP = 1 << 1;
    var SHOULD_SKIP = exports.SHOULD_SKIP = 1 << 2;
    var NodePath_Final = exports.default = class NodePath {
      constructor(hub, parent) {
        this.contexts = [];
        this.state = null;
        this.opts = null;
        this._traverseFlags = 0;
        this.skipKeys = null;
        this.parentPath = null;
        this.container = null;
        this.listKey = null;
        this.key = null;
        this.node = null;
        this.type = null;
        this._store = null;
        this.parent = parent;
        this.hub = hub;
        this.data = null;
        this.context = null;
        this.scope = null;
      }
      get removed() {
        return (this._traverseFlags & 1) > 0;
      }
      set removed(v) {
        if (v) this._traverseFlags |= 1;
        else this._traverseFlags &= -2;
      }
      get shouldStop() {
        return (this._traverseFlags & 2) > 0;
      }
      set shouldStop(v) {
        if (v) this._traverseFlags |= 2;
        else this._traverseFlags &= -3;
      }
      get shouldSkip() {
        return (this._traverseFlags & 4) > 0;
      }
      set shouldSkip(v) {
        if (v) this._traverseFlags |= 4;
        else this._traverseFlags &= -5;
      }
      static get({
        hub,
        parentPath,
        parent,
        container: container4,
        listKey,
        key
      }) {
        if (!hub && parentPath) {
          hub = parentPath.hub;
        }
        if (!parent) {
          throw new Error("To get a node path the parent needs to exist");
        }
        const targetNode = container4[key];
        const paths = cache.getOrCreateCachedPaths(parent, parentPath);
        let path = paths.get(targetNode);
        if (!path) {
          path = new NodePath(hub, parent);
          if (targetNode) paths.set(targetNode, path);
        }
        _context.setup.call(path, parentPath, container4, listKey, key);
        return path;
      }
      getScope(scope) {
        return this.isScope() ? new _index2.default(this) : scope;
      }
      setData(key, val) {
        if (this.data == null) {
          this.data = /* @__PURE__ */ Object.create(null);
        }
        return this.data[key] = val;
      }
      getData(key, def) {
        if (this.data == null) {
          this.data = /* @__PURE__ */ Object.create(null);
        }
        let val = this.data[key];
        if (val === void 0 && def !== void 0) val = this.data[key] = def;
        return val;
      }
      hasNode() {
        return this.node != null;
      }
      buildCodeFrameError(msg, Error2 = SyntaxError) {
        return this.hub.buildError(this.node, msg, Error2);
      }
      traverse(visitor, state) {
        (0, _index.default)(this.node, visitor, this.scope, state, this);
      }
      set(key, node) {
        validate(this.node, key, node);
        this.node[key] = node;
      }
      getPathLocation() {
        const parts = [];
        let path = this;
        do {
          let key = path.key;
          if (path.inList) key = `${path.listKey}[${key}]`;
          parts.unshift(key);
        } while (path = path.parentPath);
        return parts.join(".");
      }
      debug(message) {
        if (!debug.enabled) return;
        debug(`${this.getPathLocation()} ${this.type}: ${message}`);
      }
      toString() {
        return (0, _generator.default)(this.node).code;
      }
      get inList() {
        return !!this.listKey;
      }
      set inList(inList) {
        if (!inList) {
          this.listKey = null;
        }
      }
      get parentKey() {
        return this.listKey || this.key;
      }
    };
    var methods = {
      findParent: NodePath_ancestry.findParent,
      find: NodePath_ancestry.find,
      getFunctionParent: NodePath_ancestry.getFunctionParent,
      getStatementParent: NodePath_ancestry.getStatementParent,
      getEarliestCommonAncestorFrom: NodePath_ancestry.getEarliestCommonAncestorFrom,
      getDeepestCommonAncestorFrom: NodePath_ancestry.getDeepestCommonAncestorFrom,
      getAncestry: NodePath_ancestry.getAncestry,
      isAncestor: NodePath_ancestry.isAncestor,
      isDescendant: NodePath_ancestry.isDescendant,
      inType: NodePath_ancestry.inType,
      getTypeAnnotation: NodePath_inference.getTypeAnnotation,
      isBaseType: NodePath_inference.isBaseType,
      couldBeBaseType: NodePath_inference.couldBeBaseType,
      baseTypeStrictlyMatches: NodePath_inference.baseTypeStrictlyMatches,
      isGenericType: NodePath_inference.isGenericType,
      replaceWithMultiple: NodePath_replacement.replaceWithMultiple,
      replaceWithSourceString: NodePath_replacement.replaceWithSourceString,
      replaceWith: NodePath_replacement.replaceWith,
      replaceExpressionWithStatements: NodePath_replacement.replaceExpressionWithStatements,
      replaceInline: NodePath_replacement.replaceInline,
      evaluateTruthy: NodePath_evaluation.evaluateTruthy,
      evaluate: NodePath_evaluation.evaluate,
      toComputedKey: NodePath_conversion.toComputedKey,
      ensureBlock: NodePath_conversion.ensureBlock,
      unwrapFunctionEnvironment: NodePath_conversion.unwrapFunctionEnvironment,
      arrowFunctionToExpression: NodePath_conversion.arrowFunctionToExpression,
      splitExportDeclaration: NodePath_conversion.splitExportDeclaration,
      ensureFunctionName: NodePath_conversion.ensureFunctionName,
      matchesPattern: NodePath_introspection.matchesPattern,
      isStatic: NodePath_introspection.isStatic,
      isNodeType: NodePath_introspection.isNodeType,
      canHaveVariableDeclarationOrExpression: NodePath_introspection.canHaveVariableDeclarationOrExpression,
      canSwapBetweenExpressionAndStatement: NodePath_introspection.canSwapBetweenExpressionAndStatement,
      isCompletionRecord: NodePath_introspection.isCompletionRecord,
      isStatementOrBlock: NodePath_introspection.isStatementOrBlock,
      referencesImport: NodePath_introspection.referencesImport,
      getSource: NodePath_introspection.getSource,
      willIMaybeExecuteBefore: NodePath_introspection.willIMaybeExecuteBefore,
      _guessExecutionStatusRelativeTo: NodePath_introspection._guessExecutionStatusRelativeTo,
      resolve: NodePath_introspection.resolve,
      isConstantExpression: NodePath_introspection.isConstantExpression,
      isInStrictMode: NodePath_introspection.isInStrictMode,
      isDenylisted: NodePath_context.isDenylisted,
      visit: NodePath_context.visit,
      skip: NodePath_context.skip,
      skipKey: NodePath_context.skipKey,
      stop: NodePath_context.stop,
      setContext: NodePath_context.setContext,
      requeue: NodePath_context.requeue,
      requeueComputedKeyAndDecorators: NodePath_context.requeueComputedKeyAndDecorators,
      remove: NodePath_removal.remove,
      insertBefore: NodePath_modification.insertBefore,
      insertAfter: NodePath_modification.insertAfter,
      unshiftContainer: NodePath_modification.unshiftContainer,
      pushContainer: NodePath_modification.pushContainer,
      getOpposite: NodePath_family.getOpposite,
      getCompletionRecords: NodePath_family.getCompletionRecords,
      getSibling: NodePath_family.getSibling,
      getPrevSibling: NodePath_family.getPrevSibling,
      getNextSibling: NodePath_family.getNextSibling,
      getAllNextSiblings: NodePath_family.getAllNextSiblings,
      getAllPrevSiblings: NodePath_family.getAllPrevSiblings,
      get: NodePath_family.get,
      getAssignmentIdentifiers: NodePath_family.getAssignmentIdentifiers,
      getBindingIdentifiers: NodePath_family.getBindingIdentifiers,
      getOuterBindingIdentifiers: NodePath_family.getOuterBindingIdentifiers,
      getBindingIdentifierPaths: NodePath_family.getBindingIdentifierPaths,
      getOuterBindingIdentifierPaths: NodePath_family.getOuterBindingIdentifierPaths,
      shareCommentsWithSiblings: NodePath_comments.shareCommentsWithSiblings,
      addComment: NodePath_comments.addComment,
      addComments: NodePath_comments.addComments
    };
    Object.assign(NodePath_Final.prototype, methods);
    {
      NodePath_Final.prototype.arrowFunctionToShadowed = NodePath_conversion[String("arrowFunctionToShadowed")];
      Object.assign(NodePath_Final.prototype, {
        has: NodePath_introspection[String("has")],
        is: NodePath_introspection[String("is")],
        isnt: NodePath_introspection[String("isnt")],
        equals: NodePath_introspection[String("equals")],
        hoist: NodePath_modification[String("hoist")],
        updateSiblingKeys: NodePath_modification.updateSiblingKeys,
        call: NodePath_context.call,
        isBlacklisted: NodePath_context[String("isBlacklisted")],
        setScope: NodePath_context.setScope,
        resync: NodePath_context.resync,
        popContext: NodePath_context.popContext,
        pushContext: NodePath_context.pushContext,
        setup: NodePath_context.setup,
        setKey: NodePath_context.setKey
      });
    }
    {
      NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
      NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
      Object.assign(NodePath_Final.prototype, {
        _getTypeAnnotation: NodePath_inference._getTypeAnnotation,
        _replaceWith: NodePath_replacement._replaceWith,
        _resolve: NodePath_introspection._resolve,
        _call: NodePath_context._call,
        _resyncParent: NodePath_context._resyncParent,
        _resyncKey: NodePath_context._resyncKey,
        _resyncList: NodePath_context._resyncList,
        _resyncRemoved: NodePath_context._resyncRemoved,
        _getQueueContexts: NodePath_context._getQueueContexts,
        _removeFromScope: NodePath_removal._removeFromScope,
        _callRemovalHooks: NodePath_removal._callRemovalHooks,
        _remove: NodePath_removal._remove,
        _markRemoved: NodePath_removal._markRemoved,
        _assertUnremoved: NodePath_removal._assertUnremoved,
        _containerInsert: NodePath_modification._containerInsert,
        _containerInsertBefore: NodePath_modification._containerInsertBefore,
        _containerInsertAfter: NodePath_modification._containerInsertAfter,
        _verifyNodeList: NodePath_modification._verifyNodeList,
        _getKey: NodePath_family._getKey,
        _getPattern: NodePath_family._getPattern
      });
    }
    for (const type of t.TYPES) {
      const typeKey = `is${type}`;
      const fn = t[typeKey];
      NodePath_Final.prototype[typeKey] = function(opts) {
        return fn(this.node, opts);
      };
      NodePath_Final.prototype[`assert${type}`] = function(opts) {
        if (!fn(this.node, opts)) {
          throw new TypeError(`Expected node path of type ${type}`);
        }
      };
    }
    Object.assign(NodePath_Final.prototype, NodePath_virtual_types_validator);
    for (const type of Object.keys(virtualTypes)) {
      if (type[0] === "_") continue;
      if (!t.TYPES.includes(type)) t.TYPES.push(type);
    }
  }
});

// node_modules/@babel/traverse/lib/context.js
var require_context = __commonJS({
  "node_modules/@babel/traverse/lib/context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = require_path();
    var _t = require_lib4();
    var _context = require_context2();
    var {
      VISITOR_KEYS
    } = _t;
    var TraversalContext = class {
      constructor(scope, opts, state, parentPath) {
        this.queue = null;
        this.priorityQueue = null;
        this.parentPath = parentPath;
        this.scope = scope;
        this.state = state;
        this.opts = opts;
      }
      shouldVisit(node) {
        const opts = this.opts;
        if (opts.enter || opts.exit) return true;
        if (opts[node.type]) return true;
        const keys = VISITOR_KEYS[node.type];
        if (!(keys != null && keys.length)) return false;
        for (const key of keys) {
          if (node[key]) {
            return true;
          }
        }
        return false;
      }
      create(node, container4, key, listKey) {
        return _index.default.get({
          parentPath: this.parentPath,
          parent: node,
          container: container4,
          key,
          listKey
        });
      }
      maybeQueue(path, notPriority) {
        if (this.queue) {
          if (notPriority) {
            this.queue.push(path);
          } else {
            this.priorityQueue.push(path);
          }
        }
      }
      visitMultiple(container4, parent, listKey) {
        if (container4.length === 0) return false;
        const queue = [];
        for (let key = 0; key < container4.length; key++) {
          const node = container4[key];
          if (node && this.shouldVisit(node)) {
            queue.push(this.create(parent, container4, key, listKey));
          }
        }
        return this.visitQueue(queue);
      }
      visitSingle(node, key) {
        if (this.shouldVisit(node[key])) {
          return this.visitQueue([this.create(node, node, key)]);
        } else {
          return false;
        }
      }
      visitQueue(queue) {
        this.queue = queue;
        this.priorityQueue = [];
        const visited = /* @__PURE__ */ new WeakSet();
        let stop = false;
        let visitIndex = 0;
        for (; visitIndex < queue.length; ) {
          const path = queue[visitIndex];
          visitIndex++;
          _context.resync.call(path);
          if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
            _context.pushContext.call(path, this);
          }
          if (path.key === null) continue;
          const {
            node
          } = path;
          if (visited.has(node)) continue;
          if (node) visited.add(node);
          if (path.visit()) {
            stop = true;
            break;
          }
          if (this.priorityQueue.length) {
            stop = this.visitQueue(this.priorityQueue);
            this.priorityQueue = [];
            this.queue = queue;
            if (stop) break;
          }
        }
        for (let i = 0; i < visitIndex; i++) {
          _context.popContext.call(queue[i]);
        }
        this.queue = null;
        return stop;
      }
      visit(node, key) {
        const nodes = node[key];
        if (!nodes) return false;
        if (Array.isArray(nodes)) {
          return this.visitMultiple(nodes, node, key);
        } else {
          return this.visitSingle(node, key);
        }
      }
    };
    exports.default = TraversalContext;
  }
});

// node_modules/@babel/traverse/lib/traverse-node.js
var require_traverse_node = __commonJS({
  "node_modules/@babel/traverse/lib/traverse-node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.traverseNode = traverseNode;
    var _context = require_context();
    var _index = require_path();
    var _t = require_lib4();
    var _context2 = require_context2();
    var {
      VISITOR_KEYS
    } = _t;
    function traverseNode(node, opts, scope, state, path, skipKeys, visitSelf) {
      ;
      const keys = VISITOR_KEYS[node.type];
      if (!keys) return false;
      const context = new _context.default(scope, opts, state, path);
      if (visitSelf) {
        if (skipKeys != null && skipKeys[path.parentKey]) return false;
        return context.visitQueue([path]);
      }
      for (const key of keys) {
        if (skipKeys != null && skipKeys[key]) continue;
        if (context.visit(node, key)) {
          return true;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/traverse/lib/path/context.js
var require_context2 = __commonJS({
  "node_modules/@babel/traverse/lib/path/context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports._call = _call;
    exports._getQueueContexts = _getQueueContexts;
    exports._resyncKey = _resyncKey;
    exports._resyncList = _resyncList;
    exports._resyncParent = _resyncParent;
    exports._resyncRemoved = _resyncRemoved;
    exports.call = call;
    exports.isDenylisted = isDenylisted;
    exports.popContext = popContext;
    exports.pushContext = pushContext;
    exports.requeue = requeue;
    exports.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators;
    exports.resync = resync;
    exports.setContext = setContext;
    exports.setKey = setKey;
    exports.setScope = setScope;
    exports.setup = setup;
    exports.skip = skip;
    exports.skipKey = skipKey;
    exports.stop = stop;
    exports.visit = visit;
    var _traverseNode = require_traverse_node();
    var _index = require_path();
    var _removal = require_removal();
    var t = require_lib4();
    function call(key) {
      const opts = this.opts;
      this.debug(key);
      if (this.node) {
        if (_call.call(this, opts[key])) return true;
      }
      if (this.node) {
        var _opts$this$node$type;
        return _call.call(this, (_opts$this$node$type = opts[this.node.type]) == null ? void 0 : _opts$this$node$type[key]);
      }
      return false;
    }
    function _call(fns2) {
      if (!fns2) return false;
      for (const fn of fns2) {
        if (!fn) continue;
        const node = this.node;
        if (!node) return true;
        const ret = fn.call(this.state, this, this.state);
        if (ret && typeof ret === "object" && typeof ret.then === "function") {
          throw new Error(`You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`);
        }
        if (ret) {
          throw new Error(`Unexpected return value from visitor method ${fn}`);
        }
        if (this.node !== node) return true;
        if (this._traverseFlags > 0) return true;
      }
      return false;
    }
    function isDenylisted() {
      var _this$opts$denylist;
      const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;
      return denylist == null ? void 0 : denylist.includes(this.node.type);
    }
    {
      exports.isBlacklisted = isDenylisted;
    }
    function restoreContext(path, context) {
      if (path.context !== context) {
        path.context = context;
        path.state = context.state;
        path.opts = context.opts;
      }
    }
    function visit() {
      var _this$opts$shouldSkip, _this$opts;
      if (!this.node) {
        return false;
      }
      if (this.isDenylisted()) {
        return false;
      }
      if ((_this$opts$shouldSkip = (_this$opts = this.opts).shouldSkip) != null && _this$opts$shouldSkip.call(_this$opts, this)) {
        return false;
      }
      const currentContext = this.context;
      if (this.shouldSkip || call.call(this, "enter")) {
        this.debug("Skip...");
        return this.shouldStop;
      }
      restoreContext(this, currentContext);
      this.debug("Recursing into...");
      this.shouldStop = (0, _traverseNode.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
      restoreContext(this, currentContext);
      call.call(this, "exit");
      return this.shouldStop;
    }
    function skip() {
      this.shouldSkip = true;
    }
    function skipKey(key) {
      if (this.skipKeys == null) {
        this.skipKeys = {};
      }
      this.skipKeys[key] = true;
    }
    function stop() {
      this._traverseFlags |= _index.SHOULD_SKIP | _index.SHOULD_STOP;
    }
    function setScope() {
      var _this$opts2, _this$scope;
      if ((_this$opts2 = this.opts) != null && _this$opts2.noScope) return;
      let path = this.parentPath;
      if ((this.key === "key" || this.listKey === "decorators") && path.isMethod() || this.key === "discriminant" && path.isSwitchStatement()) {
        path = path.parentPath;
      }
      let target;
      while (path && !target) {
        var _path$opts;
        if ((_path$opts = path.opts) != null && _path$opts.noScope) return;
        target = path.scope;
        path = path.parentPath;
      }
      this.scope = this.getScope(target);
      (_this$scope = this.scope) == null || _this$scope.init();
    }
    function setContext(context) {
      if (this.skipKeys != null) {
        this.skipKeys = {};
      }
      this._traverseFlags = 0;
      if (context) {
        this.context = context;
        this.state = context.state;
        this.opts = context.opts;
      }
      setScope.call(this);
      return this;
    }
    function resync() {
      if (this.removed) return;
      _resyncParent.call(this);
      _resyncList.call(this);
      _resyncKey.call(this);
    }
    function _resyncParent() {
      if (this.parentPath) {
        this.parent = this.parentPath.node;
      }
    }
    function _resyncKey() {
      if (!this.container) return;
      if (this.node === this.container[this.key]) {
        return;
      }
      if (Array.isArray(this.container)) {
        for (let i = 0; i < this.container.length; i++) {
          if (this.container[i] === this.node) {
            setKey.call(this, i);
            return;
          }
        }
      } else {
        for (const key of Object.keys(this.container)) {
          if (this.container[key] === this.node) {
            setKey.call(this, key);
            return;
          }
        }
      }
      this.key = null;
    }
    function _resyncList() {
      if (!this.parent || !this.inList) return;
      const newContainer = this.parent[this.listKey];
      if (this.container === newContainer) return;
      this.container = newContainer || null;
    }
    function _resyncRemoved() {
      if (this.key == null || !this.container || this.container[this.key] !== this.node) {
        _removal._markRemoved.call(this);
      }
    }
    function popContext() {
      this.contexts.pop();
      if (this.contexts.length > 0) {
        this.setContext(this.contexts[this.contexts.length - 1]);
      } else {
        this.setContext(void 0);
      }
    }
    function pushContext(context) {
      this.contexts.push(context);
      this.setContext(context);
    }
    function setup(parentPath, container4, listKey, key) {
      this.listKey = listKey;
      this.container = container4;
      this.parentPath = parentPath || this.parentPath;
      setKey.call(this, key);
    }
    function setKey(key) {
      var _this$node;
      this.key = key;
      this.node = this.container[this.key];
      this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;
    }
    function requeue(pathToQueue = this) {
      if (pathToQueue.removed) return;
      ;
      const contexts = this.contexts;
      for (const context of contexts) {
        context.maybeQueue(pathToQueue);
      }
    }
    function requeueComputedKeyAndDecorators() {
      const {
        context,
        node
      } = this;
      if (!t.isPrivate(node) && node.computed) {
        context.maybeQueue(this.get("key"));
      }
      if (node.decorators) {
        for (const decorator of this.get("decorators")) {
          context.maybeQueue(decorator);
        }
      }
    }
    function _getQueueContexts() {
      let path = this;
      let contexts = this.contexts;
      while (!contexts.length) {
        path = path.parentPath;
        if (!path) break;
        contexts = path.contexts;
      }
      return contexts;
    }
  }
});

// node_modules/@babel/traverse/lib/hub.js
var require_hub = __commonJS({
  "node_modules/@babel/traverse/lib/hub.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var Hub = class {
      getCode() {
      }
      getScope() {
      }
      addHelper() {
        throw new Error("Helpers are not supported by the default hub.");
      }
      buildError(node, msg, Error2 = TypeError) {
        return new Error2(msg);
      }
    };
    exports.default = Hub;
  }
});

// node_modules/@babel/traverse/lib/index.js
var require_lib9 = __commonJS({
  "node_modules/@babel/traverse/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Hub", {
      enumerable: true,
      get: function() {
        return _hub.default;
      }
    });
    Object.defineProperty(exports, "NodePath", {
      enumerable: true,
      get: function() {
        return _index.default;
      }
    });
    Object.defineProperty(exports, "Scope", {
      enumerable: true,
      get: function() {
        return _index2.default;
      }
    });
    exports.visitors = exports.default = void 0;
    require_context2();
    var visitors = require_visitors();
    exports.visitors = visitors;
    var _t = require_lib4();
    var cache = require_cache();
    var _traverseNode = require_traverse_node();
    var _index = require_path();
    var _index2 = require_scope();
    var _hub = require_hub();
    var {
      VISITOR_KEYS,
      removeProperties,
      traverseFast
    } = _t;
    function traverse2(parent, opts = {}, scope, state, parentPath, visitSelf) {
      if (!parent) return;
      if (!opts.noScope && !scope) {
        if (parent.type !== "Program" && parent.type !== "File") {
          throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${parent.type} node without passing scope and parentPath.`);
        }
      }
      if (!parentPath && visitSelf) {
        throw new Error("visitSelf can only be used when providing a NodePath.");
      }
      if (!VISITOR_KEYS[parent.type]) {
        return;
      }
      visitors.explode(opts);
      (0, _traverseNode.traverseNode)(parent, opts, scope, state, parentPath, null, visitSelf);
    }
    var _default = exports.default = traverse2;
    traverse2.visitors = visitors;
    traverse2.verify = visitors.verify;
    traverse2.explode = visitors.explode;
    traverse2.cheap = function(node, enter) {
      traverseFast(node, enter);
      return;
    };
    traverse2.node = function(node, opts, scope, state, path, skipKeys) {
      (0, _traverseNode.traverseNode)(node, opts, scope, state, path, skipKeys);
    };
    traverse2.clearNode = function(node, opts) {
      removeProperties(node, opts);
    };
    traverse2.removeProperties = function(tree, opts) {
      traverseFast(tree, traverse2.clearNode, opts);
      return tree;
    };
    traverse2.hasType = function(tree, type, denylistTypes) {
      if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;
      if (tree.type === type) return true;
      return traverseFast(tree, function(node) {
        if (denylistTypes != null && denylistTypes.includes(node.type)) {
          return traverseFast.skip;
        }
        if (node.type === type) {
          return traverseFast.stop;
        }
      });
    };
    traverse2.cache = cache;
  }
});

// node_modules/source-map-js/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map-js/lib/base64.js"(exports) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number4) {
      if (0 <= number4 && number4 < intToCharMap.length) {
        return intToCharMap[number4];
      }
      throw new TypeError("Must be between 0 and 63: " + number4);
    };
    exports.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero2 = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero2 <= charCode && charCode <= nine) {
        return charCode - zero2 + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map-js/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map-js/lib/base64-vlq.js"(exports) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift2 = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift2);
        shift2 += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map-js/lib/util.js
var require_util2 = __commonJS({
  "node_modules/source-map-js/lib/util.js"(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;
    var MAX_CACHED_INPUTS = 32;
    function lruMemoize(f) {
      var cache = [];
      return function(input) {
        for (var i = 0; i < cache.length; i++) {
          if (cache[i].input === input) {
            var temp = cache[0];
            cache[0] = cache[i];
            cache[i] = temp;
            return cache[0].result;
          }
        }
        var result = f(input);
        cache.unshift({
          input,
          result
        });
        if (cache.length > MAX_CACHED_INPUTS) {
          cache.pop();
        }
        return result;
      };
    }
    var normalize = lruMemoize(function normalize2(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = [];
      var start = 0;
      var i = 0;
      while (true) {
        start = i;
        i = path.indexOf("/", start);
        if (i === -1) {
          parts.push(path.slice(start));
          break;
        } else {
          parts.push(path.slice(start, i));
          while (i < path.length && path[i] === "/") {
            i++;
          }
        }
      }
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    });
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length2 = s.length;
      if (length2 < 9) {
        return false;
      }
      if (s.charCodeAt(length2 - 1) !== 95 || s.charCodeAt(length2 - 2) !== 95 || s.charCodeAt(length2 - 3) !== 111 || s.charCodeAt(length2 - 4) !== 116 || s.charCodeAt(length2 - 5) !== 111 || s.charCodeAt(length2 - 6) !== 114 || s.charCodeAt(length2 - 7) !== 112 || s.charCodeAt(length2 - 8) !== 95 || s.charCodeAt(length2 - 9) !== 95) {
        return false;
      }
      for (var i = length2 - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
      var cmp;
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map-js/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map-js/lib/array-set.js"(exports) {
    var util = require_util2();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});

// node_modules/source-map-js/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map-js/lib/mapping-list.js"(exports) {
    var util = require_util2();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports.MappingList = MappingList;
  }
});

// node_modules/source-map-js/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map-js/lib/source-map-generator.js"(exports) {
    var base64VLQ = require_base64_vlq();
    var util = require_util2();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator2(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._ignoreInvalidMapping = util.getArg(aArgs, "ignoreInvalidMapping", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator2.prototype._version = 3;
    SourceMapGenerator2.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator2(Object.assign(generatorOps || {}, {
        file: aSourceMapConsumer.file,
        sourceRoot
      }));
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator2.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name50 = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        if (this._validateMapping(generated, original, source, name50) === false) {
          return;
        }
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name50 != null) {
        name50 = String(name50);
        if (!this._names.has(name50)) {
          this._names.add(name50);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name: name50
      });
    };
    SourceMapGenerator2.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator2.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name50 = mapping.name;
        if (name50 != null && !newNames.has(name50)) {
          newNames.add(name50);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator2.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        var message = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
        if (this._ignoreInvalidMapping) {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(message);
          }
          return false;
        } else {
          throw new Error(message);
        }
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        var message = "Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        });
        if (this._ignoreInvalidMapping) {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(message);
          }
          return false;
        } else {
          throw new Error(message);
        }
      }
    };
    SourceMapGenerator2.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator2.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator2.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator2.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator2;
  }
});

// node_modules/@unocss/core/dist/index.mjs
var LAYER_DEFAULT = "default";
var LAYER_PREFLIGHTS = "preflights";
var LAYER_SHORTCUTS = "shortcuts";
var LAYER_IMPORTS = "imports";
var DEFAULT_LAYERS = {
  [LAYER_IMPORTS]: -200,
  [LAYER_PREFLIGHTS]: -100,
  [LAYER_SHORTCUTS]: -10,
  [LAYER_DEFAULT]: 0
};
var defaultSplitRE = /[\\:]?[\s'"`;{}]+/g;
var splitWithVariantGroupRE = /([\\:]?[\s"'`;<>]|:\(|\)"|\)\s)/g;
function splitCode(code2) {
  return code2.split(defaultSplitRE);
}
var extractorSplit = {
  name: "@unocss/core/extractor-split",
  order: 0,
  extract({ code: code2 }) {
    return splitCode(code2);
  }
};
function toArray(value = []) {
  return Array.isArray(value) ? value : [value];
}
function uniq(value) {
  return Array.from(new Set(value));
}
function uniqueBy(array, equalFn) {
  return array.reduce((acc, cur) => {
    if (acc.findIndex((item) => equalFn(cur, item)) === -1) acc.push(cur);
    return acc;
  }, []);
}
function isString(s) {
  return typeof s === "string";
}
var CountableSet = class extends Set {
  constructor(values) {
    super();
    this._map = /* @__PURE__ */ new Map();
    if (values) for (const key of values) this.add(key);
  }
  add(key) {
    this._map.set(key, (this._map.get(key) ?? 0) + 1);
    return super.add(key);
  }
  delete(key) {
    if (!this._map.has(key)) return false;
    this._map.delete(key);
    return super.delete(key);
  }
  clear() {
    this._map.clear();
    super.clear();
  }
  getCount(key) {
    return this._map.get(key) ?? 0;
  }
  setCount(key, count) {
    this._map.set(key, count);
    return super.add(key);
  }
};
function isCountableSet(value) {
  return value instanceof CountableSet;
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function escapeSelector(str) {
  const length2 = str.length;
  let index = -1;
  let codeUnit;
  let result = "";
  const firstCodeUnit = str.charCodeAt(0);
  while (++index < length2) {
    codeUnit = str.charCodeAt(index);
    if (codeUnit === 0) {
      result += "";
      continue;
    }
    if (codeUnit === 37) {
      result += "\\%";
      continue;
    }
    if (codeUnit === 44) {
      result += "\\,";
      continue;
    }
    if (codeUnit >= 1 && codeUnit <= 31 || codeUnit === 127 || index === 0 && codeUnit >= 48 && codeUnit <= 57 || index === 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit === 45) {
      result += `\\${codeUnit.toString(16)} `;
      continue;
    }
    if (index === 0 && length2 === 1 && codeUnit === 45) {
      result += `\\${str.charAt(index)}`;
      continue;
    }
    if (codeUnit >= 128 || codeUnit === 45 || codeUnit === 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
      result += str.charAt(index);
      continue;
    }
    result += `\\${str.charAt(index)}`;
  }
  return result;
}
var e = escapeSelector;
function createNanoEvents() {
  return {
    events: {},
    emit(event, ...args) {
      (this.events[event] || []).forEach((i) => i(...args));
    },
    on(event, cb) {
      (this.events[event] = this.events[event] || []).push(cb);
      return () => this.events[event] = (this.events[event] || []).filter((i) => i !== cb);
    }
  };
}
var attributifyRE = /^\[(.+?)~?="(.*)"\]$/;
var cssIdRE = /\.(css|postcss|sass|scss|less|stylus|styl)($|\?)/;
var validateFilterRE = /[\w\u00A0-\uFFFF%-?]/;
function isAttributifySelector(selector2) {
  return selector2.match(attributifyRE);
}
function isValidSelector(selector2 = "") {
  return validateFilterRE.test(selector2);
}
function normalizeVariant(variant) {
  return typeof variant === "function" ? { match: variant } : variant;
}
function isRawUtil(util) {
  return util.length === 3;
}
function notNull(value) {
  return value != null;
}
function noop() {
}
function withLayer(layer, rules4) {
  rules4.forEach((r) => {
    if (!r[2]) r[2] = { layer };
    else r[2].layer = layer;
  });
  return rules4;
}
var TwoKeyMap = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  get(key1, key2) {
    const m2 = this._map.get(key1);
    if (m2) return m2.get(key2);
  }
  getFallback(key1, key2, fallback) {
    let m2 = this._map.get(key1);
    if (!m2) {
      m2 = /* @__PURE__ */ new Map();
      this._map.set(key1, m2);
    }
    if (!m2.has(key2)) m2.set(key2, fallback);
    return m2.get(key2);
  }
  set(key1, key2, value) {
    let m2 = this._map.get(key1);
    if (!m2) {
      m2 = /* @__PURE__ */ new Map();
      this._map.set(key1, m2);
    }
    m2.set(key2, value);
    return this;
  }
  has(key1, key2) {
    var _a;
    return (_a = this._map.get(key1)) == null ? void 0 : _a.has(key2);
  }
  delete(key1, key2) {
    var _a;
    return ((_a = this._map.get(key1)) == null ? void 0 : _a.delete(key2)) || false;
  }
  deleteTop(key1) {
    return this._map.delete(key1);
  }
  map(fn) {
    return Array.from(this._map.entries()).flatMap(([k1, m2]) => Array.from(m2.entries()).map(([k2, v]) => {
      return fn(v, k1, k2);
    }));
  }
};
var BetterMap = class extends Map {
  getFallback(key, fallback) {
    const v = this.get(key);
    if (v === void 0) {
      this.set(key, fallback);
      return fallback;
    }
    return v;
  }
  map(mapFn) {
    const result = [];
    this.forEach((v, k) => {
      result.push(mapFn(v, k));
    });
    return result;
  }
  flatMap(mapFn) {
    const result = [];
    this.forEach((v, k) => {
      result.push(...mapFn(v, k));
    });
    return result;
  }
};
function normalizeCSSEntries(obj) {
  if (isString(obj)) return obj;
  return (!Array.isArray(obj) ? Object.entries(obj) : obj).filter((i) => i[1] != null);
}
function normalizeCSSValues(obj) {
  if (Array.isArray(obj)) if (obj.find((i) => !Array.isArray(i) || Array.isArray(i[0]))) return obj.map((i) => normalizeCSSEntries(i));
  else return [obj];
  else return [normalizeCSSEntries(obj)];
}
function clearIdenticalEntries(entry) {
  return entry.filter(([k, v], idx) => {
    if (k.startsWith("$$")) return false;
    for (let i = idx - 1; i >= 0; i--) if (entry[i][0] === k && entry[i][1] === v) return false;
    return true;
  });
}
var VirtualKey = "__virtual_key__";
function entriesToCss(arr) {
  if (arr == null) return "";
  return clearIdenticalEntries(arr).map(([key, value]) => value != null && typeof value !== "function" ? key !== VirtualKey ? `${key}:${value};` : value : void 0).filter(Boolean).join("");
}
function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
function mergeDeep(original, patch, mergeArray = false) {
  const o = original;
  const p = patch;
  if (Array.isArray(p)) if (mergeArray && Array.isArray(p)) return [...o, ...p];
  else return [...p];
  const output = { ...o };
  if (isObject(o) && isObject(p)) Object.keys(p).forEach((key) => {
    if (isObject(o[key]) && isObject(p[key]) || Array.isArray(o[key]) && Array.isArray(p[key])) output[key] = mergeDeep(o[key], p[key], mergeArray);
    else Object.assign(output, { [key]: p[key] });
  });
  return output;
}
function clone(val) {
  let k, out, tmp;
  if (Array.isArray(val)) {
    out = Array.from({ length: k = val.length });
    while (k--) out[k] = (tmp = val[k]) && typeof tmp === "object" ? clone(tmp) : tmp;
    return out;
  }
  if (Object.prototype.toString.call(val) === "[object Object]") {
    out = {};
    for (k in val) if (k === "__proto__") Object.defineProperty(out, k, {
      value: clone(val[k]),
      configurable: true,
      enumerable: true,
      writable: true
    });
    else out[k] = (tmp = val[k]) && typeof tmp === "object" ? clone(tmp) : tmp;
    return out;
  }
  return val;
}
function isStaticRule(rule) {
  return isString(rule[0]);
}
function isStaticShortcut(sc) {
  return isString(sc[0]);
}
var regexCache = {};
function makeRegexClassGroup(separators = ["-", ":"]) {
  const key = separators.join("|");
  if (!regexCache[key]) regexCache[key] = new RegExp(`((?:[!@<~\\w+:_-]|\\[&?>?:?\\S*\\])+?)(${key})\\(((?:[~!<>\\w\\s:/\\\\,%#.$?-]|\\[[^\\]]*?\\])+?)\\)(?!\\s*?=>)`, "gm");
  regexCache[key].lastIndex = 0;
  return regexCache[key];
}
function parseVariantGroup(str, separators = ["-", ":"], depth = 5) {
  const regexClassGroup = makeRegexClassGroup(separators);
  let hasChanged;
  let content = str.toString();
  const prefixes = /* @__PURE__ */ new Set();
  const groupsByOffset = /* @__PURE__ */ new Map();
  do {
    hasChanged = false;
    content = content.replace(regexClassGroup, (from, pre, sep, body, groupOffset) => {
      var _a;
      if (!separators.includes(sep)) return from;
      hasChanged = true;
      prefixes.add(pre + sep);
      const bodyOffset = groupOffset + pre.length + sep.length + 1;
      const group = {
        length: from.length,
        items: []
      };
      groupsByOffset.set(groupOffset, group);
      for (const itemMatch of [...body.matchAll(/\S+/g)]) {
        const itemOffset = bodyOffset + itemMatch.index;
        let innerItems = (_a = groupsByOffset.get(itemOffset)) == null ? void 0 : _a.items;
        if (innerItems) groupsByOffset.delete(itemOffset);
        else innerItems = [{
          offset: itemOffset,
          length: itemMatch[0].length,
          className: itemMatch[0]
        }];
        for (const item of innerItems) {
          item.className = item.className === "~" ? pre : item.className.replace(/^(!?)(.*)/, `$1${pre}${sep}$2`);
          group.items.push(item);
        }
      }
      return "$".repeat(from.length);
    });
    depth -= 1;
  } while (hasChanged && depth);
  let expanded;
  if (typeof str === "string") {
    expanded = "";
    let prevOffset = 0;
    for (const [offset, group] of groupsByOffset) {
      expanded += str.slice(prevOffset, offset);
      expanded += group.items.map((item) => item.className).join(" ");
      prevOffset = offset + group.length;
    }
    expanded += str.slice(prevOffset);
  } else {
    expanded = str;
    for (const [offset, group] of groupsByOffset) expanded.overwrite(offset, offset + group.length, group.items.map((item) => item.className).join(" "));
  }
  return {
    prefixes: Array.from(prefixes),
    hasChanged,
    groupsByOffset,
    get expanded() {
      return expanded.toString();
    }
  };
}
function collapseVariantGroup(str, prefixes) {
  const collection = /* @__PURE__ */ new Map();
  const sortedPrefix = prefixes.sort((a, b) => b.length - a.length);
  return str.split(/\s+/g).map((part) => {
    const prefix = sortedPrefix.find((prefix$1) => part.startsWith(prefix$1));
    if (!prefix) return part;
    const body = part.slice(prefix.length);
    if (collection.has(prefix)) {
      collection.get(prefix).push(body);
      return null;
    } else {
      const items = [body];
      collection.set(prefix, items);
      return {
        prefix,
        items
      };
    }
  }).filter(notNull).map((i) => {
    if (typeof i === "string") return i;
    return `${i.prefix}(${i.items.join(" ")})`;
  }).join(" ");
}
function expandVariantGroup(str, separators = ["-", ":"], depth = 5) {
  const res = parseVariantGroup(str, separators, depth);
  return typeof str === "string" ? res.expanded : str;
}
var warned = /* @__PURE__ */ new Set();
function warnOnce(msg) {
  if (warned.has(msg)) return;
  console.warn("[unocss]", msg);
  warned.add(msg);
}
function resolveShortcuts(shortcuts3) {
  return toArray(shortcuts3).flatMap((s) => {
    if (Array.isArray(s)) return [s];
    return Object.entries(s);
  });
}
var __RESOLVED = "_uno_resolved";
async function resolvePreset(presetInput) {
  var _a;
  let preset = typeof presetInput === "function" ? await presetInput() : await presetInput;
  if (__RESOLVED in preset) return preset;
  preset = { ...preset };
  Object.defineProperty(preset, __RESOLVED, {
    value: true,
    enumerable: false
  });
  const shortcuts3 = preset.shortcuts ? resolveShortcuts(preset.shortcuts) : void 0;
  preset.shortcuts = shortcuts3;
  if (preset.prefix || preset.layer) {
    const apply = (i) => {
      if (!i[2]) i[2] = {};
      const meta = i[2];
      if (meta.prefix == null && preset.prefix) meta.prefix = toArray(preset.prefix);
      if (meta.layer == null && preset.layer) meta.layer = preset.layer;
    };
    shortcuts3 == null ? void 0 : shortcuts3.forEach(apply);
    (_a = preset.rules) == null ? void 0 : _a.forEach(apply);
  }
  return preset;
}
async function resolvePresets(preset) {
  const root = await resolvePreset(preset);
  if (!root.presets) return [root];
  return [root, ...(await Promise.all((root.presets || []).flatMap(toArray).flatMap(resolvePresets))).flat()];
}
function mergeContentOptions(optionsArray) {
  var _a, _b;
  if (optionsArray.length === 0) return {};
  const pipelineIncludes = [];
  const pipelineExcludes = [];
  let pipelineDisabled = false;
  const filesystem = [];
  const inline = [];
  for (const options of optionsArray) {
    if (options.pipeline === false) {
      pipelineDisabled = true;
      break;
    } else {
      if ((_a = options.pipeline) == null ? void 0 : _a.include) pipelineIncludes.push(options.pipeline.include);
      if ((_b = options.pipeline) == null ? void 0 : _b.exclude) pipelineExcludes.push(options.pipeline.exclude);
    }
    if (options.filesystem) filesystem.push(options.filesystem);
    if (options.inline) inline.push(options.inline);
  }
  const mergedContent = { pipeline: pipelineDisabled ? false : {
    include: uniq(mergeFilterPatterns(...pipelineIncludes)),
    exclude: uniq(mergeFilterPatterns(...pipelineExcludes))
  } };
  if (filesystem.length) mergedContent.filesystem = uniq(filesystem.flat());
  if (inline.length) mergedContent.inline = uniq(inline.flat());
  return mergedContent;
}
async function resolveConfig(userConfig = {}, defaults2 = {}) {
  var _a, _b;
  const config = Object.assign({}, defaults2, userConfig);
  const rawPresets = uniqueBy((await Promise.all((config.presets || []).flatMap(toArray).flatMap(resolvePresets))).flat(), (a, b) => a.name === b.name);
  const sortedPresets = [
    ...rawPresets.filter((p) => p.enforce === "pre"),
    ...rawPresets.filter((p) => !p.enforce),
    ...rawPresets.filter((p) => p.enforce === "post")
  ];
  const sources = [...sortedPresets, config];
  const sourcesReversed = [...sources].reverse();
  const layers = Object.assign({}, DEFAULT_LAYERS, ...sources.map((i) => i.layers));
  function getMerged(key) {
    return uniq(sources.flatMap((p) => toArray(p[key] || [])));
  }
  const extractors = getMerged("extractors");
  let extractorDefault = (_a = sourcesReversed.find((i) => i.extractorDefault !== void 0)) == null ? void 0 : _a.extractorDefault;
  if (extractorDefault === void 0) extractorDefault = extractorSplit;
  if (extractorDefault && !extractors.includes(extractorDefault)) extractors.unshift(extractorDefault);
  extractors.sort((a, b) => (a.order || 0) - (b.order || 0));
  const rules4 = getMerged("rules");
  const rulesSize = rules4.length;
  const rulesStaticMap = {};
  const rulesDynamic = [];
  for (const [index, rule] of rules4.entries()) {
    const meta = rule[2] ?? (rule[2] = {});
    meta.__index = index;
    if (isStaticRule(rule)) toArray(meta.prefix ?? "").forEach((prefix) => {
      rulesStaticMap[prefix + rule[0]] = rule;
    });
    else rulesDynamic.unshift(rule);
  }
  const autocomplete = {
    templates: uniq(sources.flatMap((p) => {
      var _a2;
      return toArray((_a2 = p.autocomplete) == null ? void 0 : _a2.templates);
    })),
    extractors: sources.flatMap((p) => {
      var _a2;
      return toArray((_a2 = p.autocomplete) == null ? void 0 : _a2.extractors);
    }).sort((a, b) => (a.order || 0) - (b.order || 0)),
    shorthands: mergeAutocompleteShorthands(sources.map((p) => {
      var _a2;
      return ((_a2 = p.autocomplete) == null ? void 0 : _a2.shorthands) || {};
    }))
  };
  let separators = getMerged("separators");
  if (!separators.length) separators = [":", "-"];
  const content = mergeContentOptions(getMerged("content"));
  const resolved = {
    mergeSelectors: true,
    warn: true,
    sortLayers: (layers$1) => layers$1,
    ...config,
    blocklist: getMerged("blocklist"),
    presets: sortedPresets,
    envMode: config.envMode || "build",
    shortcutsLayer: config.shortcutsLayer || "shortcuts",
    layers,
    theme: mergeThemes(sources.map((p) => p.theme)),
    rules: rules4,
    rulesSize,
    rulesDynamic,
    rulesStaticMap,
    preprocess: getMerged("preprocess"),
    postprocess: getMerged("postprocess"),
    preflights: getMerged("preflights"),
    autocomplete,
    variants: getMerged("variants").map(normalizeVariant).sort((a, b) => (a.order || 0) - (b.order || 0)),
    shortcuts: resolveShortcuts(getMerged("shortcuts")).reverse(),
    extractors,
    safelist: getMerged("safelist"),
    separators,
    details: config.details ?? config.envMode === "dev",
    content,
    transformers: uniqueBy(getMerged("transformers"), (a, b) => a.name === b.name)
  };
  const extendThemes = getMerged("extendTheme");
  for (const extendTheme of extendThemes) resolved.theme = extendTheme(resolved.theme, resolved) || resolved.theme;
  for (const p of sources) (_b = p == null ? void 0 : p.configResolved) == null ? void 0 : _b.call(p, resolved);
  return resolved;
}
function mergeConfigs(configs) {
  const maybeArrays = [
    "shortcuts",
    "preprocess",
    "postprocess"
  ];
  return configs.map((config) => Object.entries(config).reduce((acc, [key, value]) => ({
    ...acc,
    [key]: maybeArrays.includes(key) ? toArray(value) : value
  }), {})).reduce(({ theme: themeA, content: contentA, ...a }, { theme: themeB, content: contentB, ...b }) => {
    const c = mergeDeep(a, b, true);
    if (themeA || themeB) c.theme = mergeThemes([themeA, themeB]);
    if (contentA || contentB) c.content = mergeContentOptions([contentA || {}, contentB || {}]);
    return c;
  }, {});
}
function mergeThemes(themes) {
  return themes.map((theme4) => theme4 ? clone(theme4) : {}).reduce((a, b) => mergeDeep(a, b), {});
}
function mergeAutocompleteShorthands(shorthands3) {
  return shorthands3.reduce((a, b) => {
    const rs = {};
    for (const key in b) {
      const value = b[key];
      if (Array.isArray(value)) rs[key] = `(${value.join("|")})`;
      else rs[key] = value;
    }
    return {
      ...a,
      ...rs
    };
  }, {});
}
function mergeFilterPatterns(...filterPatterns) {
  return filterPatterns.flatMap(flatternFilterPattern);
}
function flatternFilterPattern(pattern) {
  return Array.isArray(pattern) ? pattern : pattern ? [pattern] : [];
}
function definePreset(preset) {
  return preset;
}
var version = "66.6.0";
var symbols = {
  shortcutsNoMerge: "$$symbol-shortcut-no-merge",
  noMerge: "$$symbol-no-merge",
  variants: "$$symbol-variants",
  parent: "$$symbol-parent",
  selector: "$$symbol-selector",
  layer: "$$symbol-layer",
  sort: "$$symbol-sort",
  body: "$$symbol-body"
};
var UnoGeneratorInternal = class UnoGeneratorInternal2 {
  constructor(userConfig = {}, defaults2 = {}) {
    this.userConfig = userConfig;
    this.defaults = defaults2;
    this.version = version;
    this.events = createNanoEvents();
    this.config = void 0;
    this.cache = /* @__PURE__ */ new Map();
    this.blocked = /* @__PURE__ */ new Set();
    this.parentOrders = /* @__PURE__ */ new Map();
    this.activatedRules = /* @__PURE__ */ new Set();
    this.resolveCSSResult = (raw, result, rule, context) => {
      const entries = normalizeCSSValues(result).filter((i) => i.length);
      if (entries.length) {
        if (this.config.details) context.rules.push(rule);
        context.generator.activatedRules.add(rule);
        const meta = rule[2];
        return entries.map((css) => {
          if (isString(css)) return [
            meta.__index,
            css,
            meta
          ];
          let variants4 = context.variantHandlers;
          let entryMeta = meta;
          for (const entry of css) if (entry[0] === symbols.variants) if (typeof entry[1] === "function") variants4 = entry[1](variants4) || variants4;
          else variants4 = [...toArray(entry[1]), ...variants4];
          else if (entry[0] === symbols.parent) variants4 = [{ parent: entry[1] }, ...variants4];
          else if (entry[0] === symbols.selector) variants4 = [{ selector: entry[1] }, ...variants4];
          else if (entry[0] === symbols.layer) variants4 = [{ layer: entry[1] }, ...variants4];
          else if (entry[0] === symbols.sort) entryMeta = {
            ...entryMeta,
            sort: entry[1]
          };
          else if (entry[0] === symbols.noMerge) entryMeta = {
            ...entryMeta,
            noMerge: entry[1]
          };
          else if (entry[0] === symbols.body) entry[0] = VirtualKey;
          return [
            meta.__index,
            raw,
            css,
            entryMeta,
            variants4
          ];
        });
      }
    };
  }
  static async create(userConfig = {}, defaults2 = {}) {
    const uno = new UnoGeneratorInternal2(userConfig, defaults2);
    uno.config = await resolveConfig(uno.userConfig, uno.defaults);
    uno.events.emit("config", uno.config);
    return uno;
  }
  async setConfig(userConfig, defaults2) {
    if (!userConfig) return;
    if (defaults2) this.defaults = defaults2;
    this.userConfig = userConfig;
    this.blocked.clear();
    this.parentOrders.clear();
    this.activatedRules.clear();
    this.cache.clear();
    this.config = await resolveConfig(userConfig, this.defaults);
    this.events.emit("config", this.config);
  }
  async applyExtractors(code2, id, extracted = /* @__PURE__ */ new Set()) {
    var _a;
    const context = {
      original: code2,
      code: code2,
      id,
      extracted,
      envMode: this.config.envMode
    };
    for (const extractor of this.config.extractors) {
      const result = await ((_a = extractor.extract) == null ? void 0 : _a.call(extractor, context));
      if (!result) continue;
      if (isCountableSet(result) && isCountableSet(extracted)) for (const token of result) extracted.setCount(token, extracted.getCount(token) + result.getCount(token));
      else for (const token of result) extracted.add(token);
    }
    return extracted;
  }
  makeContext(raw, applied) {
    const context = {
      rawSelector: raw,
      currentSelector: applied[1],
      theme: this.config.theme,
      generator: this,
      symbols,
      variantHandlers: applied[2],
      constructCSS: (...args) => this.constructCustomCSS(context, ...args),
      variantMatch: applied
    };
    return context;
  }
  async parseToken(raw, alias) {
    if (this.blocked.has(raw)) return;
    const cacheKey = `${raw}${alias ? ` ${alias}` : ""}`;
    if (this.cache.has(cacheKey)) return this.cache.get(cacheKey);
    const current = this.config.preprocess.reduce((acc, p) => p(acc) ?? acc, raw);
    if (this.isBlocked(current)) {
      this.blocked.add(raw);
      this.cache.set(cacheKey, null);
      return;
    }
    const variantResults = await this.matchVariants(raw, current);
    if (variantResults.every((i) => !i || this.isBlocked(i[1]))) {
      this.blocked.add(raw);
      this.cache.set(cacheKey, null);
      return;
    }
    const handleVariantResult = async (matched) => {
      var _a;
      const context = this.makeContext(raw, [
        alias || matched[0],
        matched[1],
        matched[2],
        matched[3]
      ]);
      if (this.config.details) context.variants = [...matched[3]];
      const expanded = await this.expandShortcut(context.currentSelector, context);
      return expanded ? await this.stringifyShortcuts(context.variantMatch, context, expanded[0], expanded[1]) : (_a = await this.parseUtil(context.variantMatch, context)) == null ? void 0 : _a.flatMap((i) => this.stringifyUtil(i, context)).filter(notNull);
    };
    const result = (await Promise.all(variantResults.map((i) => handleVariantResult(i)))).flat().filter((x) => !!x);
    if (result == null ? void 0 : result.length) {
      this.cache.set(cacheKey, result);
      return result;
    }
    this.cache.set(cacheKey, null);
  }
  async generate(input, options = {}) {
    const { id, scope, preflights: preflights3 = true, safelist = true, minify = false, extendedInfo = false } = options;
    const tokens = isString(input) ? await this.applyExtractors(input, id, extendedInfo ? new CountableSet() : /* @__PURE__ */ new Set()) : Array.isArray(input) ? new Set(input) : input;
    if (safelist) {
      const safelistContext = {
        generator: this,
        theme: this.config.theme
      };
      this.config.safelist.flatMap((s) => typeof s === "function" ? s(safelistContext) : s).forEach((s) => {
        const trimmedS = s.trim();
        if (trimmedS && !tokens.has(trimmedS)) tokens.add(trimmedS);
      });
    }
    const nl = minify ? "" : "\n";
    const layerSet = /* @__PURE__ */ new Set([LAYER_DEFAULT]);
    const matched = extendedInfo ? /* @__PURE__ */ new Map() : /* @__PURE__ */ new Set();
    const sheet = /* @__PURE__ */ new Map();
    let preflightsMap = {};
    const tokenPromises = Array.from(tokens).map(async (raw) => {
      var _a;
      if (matched.has(raw)) return;
      const payload = await this.parseToken(raw);
      if (payload == null) return;
      if (matched instanceof Map) matched.set(raw, {
        data: payload,
        count: isCountableSet(tokens) ? tokens.getCount(raw) : -1
      });
      else matched.add(raw);
      for (const item of payload) {
        const parent = item[3] || "";
        const layer = (_a = item[4]) == null ? void 0 : _a.layer;
        if (!sheet.has(parent)) sheet.set(parent, []);
        sheet.get(parent).push(item);
        if (layer) layerSet.add(layer);
      }
    });
    await Promise.all(tokenPromises);
    await (async () => {
      if (!preflights3) return;
      const preflightContext = {
        generator: this,
        theme: this.config.theme
      };
      const preflightLayerSet = /* @__PURE__ */ new Set([]);
      this.config.preflights.forEach(({ layer = LAYER_PREFLIGHTS }) => {
        layerSet.add(layer);
        preflightLayerSet.add(layer);
      });
      preflightsMap = Object.fromEntries(await Promise.all(Array.from(preflightLayerSet).map(async (layer) => {
        return [layer, (await Promise.all(this.config.preflights.filter((i) => (i.layer || LAYER_PREFLIGHTS) === layer).map(async (i) => await i.getCSS(preflightContext)))).filter(Boolean).join(nl)];
      })));
    })();
    const sortLayers = (layers$1) => this.config.sortLayers(layers$1.sort((a, b) => (this.config.layers[a] ?? 0) - (this.config.layers[b] ?? 0) || a.localeCompare(b)));
    const layers = sortLayers(Array.from(layerSet));
    const layerCache = {};
    const outputCssLayers = this.config.outputToCssLayers;
    const getLayerAlias = (layer) => {
      var _a;
      let alias = layer;
      if (typeof outputCssLayers === "object") alias = (_a = outputCssLayers.cssLayerName) == null ? void 0 : _a.call(outputCssLayers, layer);
      return alias === null ? null : alias ?? layer;
    };
    const getLayer = (layer = LAYER_DEFAULT) => {
      if (layerCache[layer]) return layerCache[layer];
      let css = Array.from(sheet).sort((a, b) => {
        var _a;
        return (this.parentOrders.get(a[0]) ?? 0) - (this.parentOrders.get(b[0]) ?? 0) || ((_a = a[0]) == null ? void 0 : _a.localeCompare(b[0] || "")) || 0;
      }).map(([parent, items]) => {
        const size = items.length;
        const sorted = items.filter((i) => {
          var _a;
          return (((_a = i[4]) == null ? void 0 : _a.layer) || LAYER_DEFAULT) === layer;
        }).sort((a, b) => {
          var _a, _b, _c, _d, _e, _f, _g;
          return a[0] - b[0] || (((_a = a[4]) == null ? void 0 : _a.sort) || 0) - (((_b = b[4]) == null ? void 0 : _b.sort) || 0) || ((_e = (_c = a[5]) == null ? void 0 : _c.currentSelector) == null ? void 0 : _e.localeCompare(((_d = b[5]) == null ? void 0 : _d.currentSelector) ?? "")) || ((_f = a[1]) == null ? void 0 : _f.localeCompare(b[1] || "")) || ((_g = a[2]) == null ? void 0 : _g.localeCompare(b[2] || "")) || 0;
        }).map(([, selector2, body, , meta, , variantNoMerge]) => {
          return [
            [[(selector2 ? applyScope(selector2, scope) : selector2) ?? "", (meta == null ? void 0 : meta.sort) ?? 0]],
            body,
            !!(variantNoMerge ?? (meta == null ? void 0 : meta.noMerge))
          ];
        });
        if (!sorted.length) return void 0;
        const ruleLines = sorted.reverse().map(([selectorSortPair, body, noMerge], idx) => {
          if (!noMerge && this.config.mergeSelectors) for (let i = idx + 1; i < size; i++) {
            const current = sorted[i];
            if (current && !current[2] && (selectorSortPair && current[0] || selectorSortPair == null && current[0] == null) && current[1] === body) {
              if (selectorSortPair && current[0]) current[0].push(...selectorSortPair);
              return null;
            }
          }
          const selectors = selectorSortPair ? uniq(selectorSortPair.sort((a, b) => {
            var _a;
            return a[1] - b[1] || ((_a = a[0]) == null ? void 0 : _a.localeCompare(b[0] || "")) || 0;
          }).map((pair) => pair[0]).filter(Boolean)) : [];
          return selectors.length ? `${selectors.join(`,${nl}`)}{${body}}` : body;
        }).filter(Boolean);
        const rules4 = Array.from(new Set(ruleLines)).reverse().join(nl);
        if (!parent) return rules4;
        const parents = parent.split(" $$ ");
        return `${parents.join("{")}{${nl}${rules4}${nl}${"}".repeat(parents.length)}`;
      }).filter(Boolean).join(nl);
      if (preflights3) css = [preflightsMap[layer], css].filter(Boolean).join(nl);
      let alias;
      if (outputCssLayers && css) {
        alias = getLayerAlias(layer);
        if (alias !== null) css = `@layer ${alias}{${nl}${css}${nl}}`;
      }
      const layerMark = minify ? "" : `/* layer: ${layer}${alias && alias !== layer ? `, alias: ${alias}` : ""} */${nl}`;
      return layerCache[layer] = css ? layerMark + css : "";
    };
    const getLayers = (includes = layers, excludes) => {
      const layers$1 = includes.filter((i) => !(excludes == null ? void 0 : excludes.includes(i)));
      const css = layers$1.map(getLayer).filter(Boolean);
      if (outputCssLayers) {
        let layerNames = layers$1;
        if (typeof outputCssLayers === "object" && outputCssLayers.allLayers) layerNames = sortLayers(Object.keys(this.config.layers));
        if (layerNames.length > 0) css.unshift(`@layer ${layerNames.map(getLayerAlias).filter(notNull).join(", ")};`);
      }
      return css.join(nl);
    };
    const setLayer = async (layer, callback) => {
      const content = await callback(getLayer(layer));
      layerCache[layer] = content;
      return content;
    };
    return {
      get css() {
        return getLayers();
      },
      layers,
      matched,
      getLayers,
      getLayer,
      setLayer
    };
  }
  async matchVariants(raw, current) {
    const context = {
      rawSelector: raw,
      theme: this.config.theme,
      generator: this
    };
    const match = async (result) => {
      let applied = true;
      const [, , handlers, variants4] = result;
      while (applied) {
        applied = false;
        const processed = result[1];
        for (const v of this.config.variants) {
          if (!v.multiPass && variants4.has(v)) continue;
          let handler3 = await v.match(processed, context);
          if (!handler3) continue;
          if (isString(handler3)) {
            if (handler3 === processed) continue;
            handler3 = { matcher: handler3 };
          }
          if (Array.isArray(handler3)) {
            if (!handler3.length) continue;
            if (handler3.length === 1) handler3 = handler3[0];
            else {
              if (v.multiPass) throw new Error("multiPass can not be used together with array return variants");
              const clones = handler3.map((h3) => {
                const _processed = h3.matcher ?? processed;
                const _handlers = [h3, ...handlers];
                const _variants = new Set(variants4);
                _variants.add(v);
                return [
                  result[0],
                  _processed,
                  _handlers,
                  _variants
                ];
              });
              return (await Promise.all(clones.map((c) => match(c)))).flat();
            }
          }
          result[1] = handler3.matcher ?? processed;
          handlers.unshift(handler3);
          variants4.add(v);
          applied = true;
          break;
        }
        if (!applied) break;
        if (handlers.length > 500) throw new Error(`Too many variants applied to "${raw}"`);
      }
      return [result];
    };
    return await match([
      raw,
      current || raw,
      [],
      /* @__PURE__ */ new Set()
    ]);
  }
  applyVariants(parsed, variantHandlers = parsed[4], raw = parsed[1]) {
    const variantContextResult = variantHandlers.slice().sort((a, b) => (a.order || 0) - (b.order || 0)).reduceRight((previous, v) => (input) => {
      var _a, _b;
      const entries = ((_a = v.body) == null ? void 0 : _a.call(v, input.entries)) || input.entries;
      const parents = Array.isArray(v.parent) ? v.parent : [v.parent, void 0];
      const selector2 = (_b = v.selector) == null ? void 0 : _b.call(v, input.selector, entries);
      return (v.handle ?? defaultVariantHandler)({
        ...input,
        entries,
        selector: selector2 || input.selector,
        parent: parents[0] || input.parent,
        parentOrder: parents[1] || input.parentOrder,
        layer: v.layer || input.layer,
        sort: v.sort || input.sort
      }, previous);
    }, (input) => input)({
      prefix: "",
      selector: toEscapedSelector(raw),
      pseudo: "",
      entries: parsed[2]
    });
    const { parent, parentOrder } = variantContextResult;
    if (parent != null && parentOrder != null) this.parentOrders.set(parent, parentOrder);
    const obj = {
      selector: [
        variantContextResult.prefix,
        variantContextResult.selector,
        variantContextResult.pseudo
      ].join(""),
      entries: variantContextResult.entries,
      parent,
      layer: variantContextResult.layer,
      sort: variantContextResult.sort,
      noMerge: variantContextResult.noMerge
    };
    return this.config.postprocess.reduce((utilities, p) => {
      const result = [];
      for (const util of utilities) {
        const processed = p(util);
        if (Array.isArray(processed)) result.push(...processed.filter(notNull));
        else result.push(processed || util);
      }
      return result;
    }, [obj]);
  }
  constructCustomCSS(context, body, overrideSelector) {
    const normalizedBody = normalizeCSSEntries(body);
    if (isString(normalizedBody)) return normalizedBody;
    return this.applyVariants([
      0,
      overrideSelector || context.rawSelector,
      normalizedBody,
      void 0,
      context.variantHandlers
    ]).map(({ selector: selector2, entries, parent }) => {
      const cssBody = `${selector2}{${entriesToCss(entries)}}`;
      if (parent) return `${parent}{${cssBody}}`;
      return cssBody;
    }).join("");
  }
  async parseUtil(input, context, internal = false, shortcutPrefix) {
    const variantResults = isString(input) ? await this.matchVariants(input) : [input];
    const parse53 = async ([raw, processed, variantHandlers]) => {
      var _a;
      if (this.config.details) context.rules = context.rules ?? [];
      const scopeContext = {
        ...context,
        variantHandlers
      };
      const staticMatch = this.config.rulesStaticMap[processed];
      if (staticMatch) {
        if (staticMatch[1] && (internal || !((_a = staticMatch[2]) == null ? void 0 : _a.internal))) return this.resolveCSSResult(raw, staticMatch[1], staticMatch, scopeContext);
      }
      for (const rule of this.config.rulesDynamic) {
        const [matcher, handler3, meta] = rule;
        if ((meta == null ? void 0 : meta.internal) && !internal) continue;
        let unprefixed = processed;
        if (meta == null ? void 0 : meta.prefix) {
          const prefixes = toArray(meta.prefix);
          if (shortcutPrefix) {
            const shortcutPrefixes = toArray(shortcutPrefix);
            if (!prefixes.some((i) => shortcutPrefixes.includes(i))) continue;
          } else {
            const prefix = prefixes.find((i) => processed.startsWith(i));
            if (prefix == null) continue;
            unprefixed = processed.slice(prefix.length);
          }
        }
        const match = unprefixed.match(matcher);
        if (!match) continue;
        let result = await handler3(match, scopeContext);
        if (!result) continue;
        if (typeof result !== "string") {
          if (Symbol.asyncIterator in result) {
            const entries = [];
            for await (const r of result) if (r) entries.push(r);
            result = entries;
          } else if (Symbol.iterator in result && !Array.isArray(result)) result = Array.from(result).filter(notNull);
        }
        const resolvedResult = this.resolveCSSResult(raw, result, rule, scopeContext);
        if (resolvedResult) return resolvedResult;
      }
    };
    const parsed = (await Promise.all(variantResults.map((i) => parse53(i)))).flat().filter((x) => !!x);
    if (!parsed.length) return void 0;
    return parsed;
  }
  stringifyUtil(parsed, context) {
    if (!parsed) return;
    if (isRawUtil(parsed)) return [[
      parsed[0],
      void 0,
      parsed[1],
      void 0,
      parsed[2],
      this.config.details ? context : void 0,
      void 0
    ]];
    const utilities = this.applyVariants(parsed);
    const result = [];
    for (const util of utilities) {
      const { selector: selector2, entries, parent, layer: variantLayer, sort: variantSort, noMerge } = util;
      const body = entriesToCss(entries);
      if (!body) continue;
      const { layer: metaLayer, sort: metaSort, ...meta } = parsed[3] ?? {};
      const ruleMeta = {
        ...meta,
        layer: variantLayer ?? metaLayer,
        sort: variantSort ?? metaSort
      };
      result.push([
        parsed[0],
        selector2,
        body,
        parent,
        ruleMeta,
        this.config.details ? context : void 0,
        noMerge
      ]);
    }
    return result;
  }
  async expandShortcut(input, context, depth = 5) {
    var _a;
    if (depth === 0) return;
    const recordShortcut = this.config.details ? (s) => {
      context.shortcuts = context.shortcuts ?? [];
      context.shortcuts.push(s);
    } : noop;
    let meta;
    let result;
    let stringResult;
    let inlineResult;
    for (const s of this.config.shortcuts) {
      let unprefixed = input;
      if ((_a = s[2]) == null ? void 0 : _a.prefix) {
        const prefix = toArray(s[2].prefix).find((i) => input.startsWith(i));
        if (prefix == null) continue;
        unprefixed = input.slice(prefix.length);
      }
      if (isStaticShortcut(s)) {
        if (s[0] === unprefixed) {
          meta = meta || s[2];
          result = s[1];
          recordShortcut(s);
          break;
        }
      } else {
        const match = unprefixed.match(s[0]);
        if (match) result = s[1](match, context);
        if (result) {
          meta = meta || s[2];
          recordShortcut(s);
          break;
        }
      }
    }
    if (result) {
      stringResult = uniq(toArray(result).filter(isString).map((s) => expandVariantGroup(s.trim()).split(/\s+/g)).flat());
      inlineResult = toArray(result).filter((i) => !isString(i)).map((i) => ({
        handles: [],
        value: i
      }));
    }
    if (!result) {
      const matched = isString(input) ? await this.matchVariants(input) : [input];
      for (const match of matched) {
        const [raw, inputWithoutVariant, handles] = match;
        if (raw !== inputWithoutVariant) {
          const expanded = await this.expandShortcut(inputWithoutVariant, context, depth - 1);
          if (expanded) {
            stringResult = expanded[0].filter(isString).map((item) => raw.replace(inputWithoutVariant, item));
            inlineResult = expanded[0].filter((i) => !isString(i)).map((item) => {
              return {
                handles: [...item.handles, ...handles],
                value: item.value
              };
            });
          }
        }
      }
    }
    if (!(stringResult == null ? void 0 : stringResult.length) && !(inlineResult == null ? void 0 : inlineResult.length)) return;
    return [[await Promise.all(toArray(stringResult).map(async (s) => {
      var _a2;
      return ((_a2 = await this.expandShortcut(s, context, depth - 1)) == null ? void 0 : _a2[0]) || [s];
    })), inlineResult].flat(2).filter((x) => !!x), meta];
  }
  async stringifyShortcuts(parent, context, expanded, meta = { layer: this.config.shortcutsLayer }) {
    var _a;
    const layerMap = new BetterMap();
    const parsed = (await Promise.all(uniq(expanded).map(async (i) => {
      const result = isString(i) ? await this.parseUtil(i, context, true, meta.prefix) : [[
        Number.POSITIVE_INFINITY,
        "{inline}",
        normalizeCSSEntries(i.value),
        void 0,
        i.handles
      ]];
      if (!result && this.config.warn) warnOnce(`unmatched utility "${i}" in shortcut "${parent[1]}"`);
      return result || [];
    }))).flat(1).filter(Boolean).sort((a, b) => a[0] - b[0]);
    const [raw, , parentVariants] = parent;
    const rawStringifiedUtil = [];
    for (const item of parsed) {
      if (isRawUtil(item)) {
        rawStringifiedUtil.push([
          item[0],
          void 0,
          item[1],
          void 0,
          item[2],
          context,
          void 0
        ]);
        continue;
      }
      const isNoMerge = Object.fromEntries(item[2])[symbols.shortcutsNoMerge];
      const variants4 = [...item[4], ...!isNoMerge ? parentVariants : []];
      for (const { selector: selector2, entries, parent: parent$1, sort, noMerge, layer } of this.applyVariants(item, variants4, raw)) layerMap.getFallback(layer ?? meta.layer, new TwoKeyMap()).getFallback(selector2, parent$1, [[], item[0]])[0].push([
        entries,
        !!(noMerge ?? ((_a = item[3]) == null ? void 0 : _a.noMerge)),
        sort ?? 0
      ]);
    }
    return rawStringifiedUtil.concat(layerMap.flatMap((selectorMap, layer) => selectorMap.map(([e$1, index], selector2, joinedParents) => {
      const stringify = (flatten, noMerge, entrySortPair) => {
        const maxSort = Math.max(...entrySortPair.map((e$2) => e$2[1]));
        const entriesList = entrySortPair.map((e$2) => e$2[0]);
        return (flatten ? [entriesList.flat(1)] : entriesList).map((entries) => {
          const body = entriesToCss(entries);
          if (body) return [
            index,
            selector2,
            body,
            joinedParents,
            {
              ...meta,
              noMerge,
              sort: maxSort,
              layer
            },
            context,
            void 0
          ];
        });
      };
      return [[e$1.filter(([, noMerge]) => noMerge).map(([entries, , sort]) => [entries, sort]), true], [e$1.filter(([, noMerge]) => !noMerge).map(([entries, , sort]) => [entries, sort]), false]].map(([e$2, noMerge]) => [...stringify(false, noMerge, e$2.filter(([entries]) => entries.some((entry) => entry[0] === symbols.shortcutsNoMerge))), ...stringify(true, noMerge, e$2.filter(([entries]) => entries.every((entry) => entry[0] !== symbols.shortcutsNoMerge)))]);
    }).flat(2).filter(Boolean)));
  }
  isBlocked(raw) {
    return !raw || this.config.blocklist.map((e$1) => Array.isArray(e$1) ? e$1[0] : e$1).some((e$1) => typeof e$1 === "function" ? e$1(raw) : isString(e$1) ? e$1 === raw : e$1.test(raw));
  }
  getBlocked(raw) {
    const rule = this.config.blocklist.find((e$1) => {
      const v = Array.isArray(e$1) ? e$1[0] : e$1;
      return typeof v === "function" ? v(raw) : isString(v) ? v === raw : v.test(raw);
    });
    return rule ? Array.isArray(rule) ? rule : [rule, void 0] : void 0;
  }
};
var UnoGenerator = class extends UnoGeneratorInternal {
  /**
  * @deprecated `new UnoGenerator` is deprecated, please use `createGenerator()` instead
  */
  constructor(userConfig = {}, defaults2 = {}) {
    super(userConfig, defaults2);
    console.warn("`new UnoGenerator()` is deprecated, please use `createGenerator()` instead");
  }
};
async function createGenerator(config, defaults2) {
  return await UnoGeneratorInternal.create(config, defaults2);
}
var regexScopePlaceholder = /\s\$\$\s+/g;
function hasScopePlaceholder(css) {
  return regexScopePlaceholder.test(css);
}
function applyScope(css, scope) {
  if (hasScopePlaceholder(css)) return css.replace(regexScopePlaceholder, scope ? ` ${scope} ` : " ");
  else return scope ? `${scope} ${css}` : css;
}
var attributifyRe = /^\[(.+?)(~?=)"(.*)"\]$/;
function toEscapedSelector(raw) {
  if (attributifyRe.test(raw)) return raw.replace(attributifyRe, (_, n2, s, i) => `[${e(n2)}${s}"${e(i)}"]`);
  return `.${e(raw)}`;
}
function defaultVariantHandler(input, next) {
  return next(input);
}

// node_modules/@unocss/preset-attributify/dist/index.mjs
var variantsRE = /^(?!.*\[[^:]+:.+\]$)((?:.+:)?!?)(.*)$/;
function variantAttributify(options = {}) {
  const prefix = options.prefix ?? "un-";
  const prefixedOnly = options.prefixedOnly ?? false;
  const trueToNonValued = options.trueToNonValued ?? false;
  let variantsValueRE;
  return {
    name: "attributify",
    match(input, { generator }) {
      var _a, _b;
      const match = isAttributifySelector(input);
      if (!match) return;
      let name50 = match[1];
      if (name50.startsWith(prefix)) name50 = name50.slice(prefix.length);
      else if (prefixedOnly) return;
      const content = match[2];
      const [, variants4 = "", body = content] = content.match(variantsRE) || [];
      if (body === "~" || trueToNonValued && body === "true" || !body) return `${variants4}${name50}`;
      if (variantsValueRE == null) {
        const separators = (_b = (_a = generator == null ? void 0 : generator.config) == null ? void 0 : _a.separators) == null ? void 0 : _b.join("|");
        if (separators) variantsValueRE = new RegExp(`^(.*\\](?:${separators}))(\\[[^\\]]+?\\])$`);
        else variantsValueRE = false;
      }
      if (variantsValueRE) {
        const [, bodyVariant, bracketValue] = content.match(variantsValueRE) || [];
        if (bracketValue) return `${bodyVariant}${variants4}${name50}-${bracketValue}`;
      }
      if (variants4 && body.match(/^[\d.]+$/)) {
        const variantParts = variants4.split(/([^:]*:)/g).filter(Boolean);
        const _body = variantParts.pop() + body;
        const _variants = variantParts.join("");
        return [{ matcher: `${variants4}${name50}-${body}` }, { matcher: `${_variants}${name50}-${_body}` }];
      }
      return `${variants4}${name50}-${body}`;
    }
  };
}
var elementRE$1 = /(<\w[\w:.$-]*\s)((?:'[^>']*'|"[^>"]*"|`[^>`]*`|\{[^>}]*\}|[^>]*?)*)/g;
var valuedAttributeRE$1 = /(\?|(?!\d|-{2}|-\d)[\w\u00A0-\uFFFF-:%]+)(?:=("[^"]*|'[^']*))?/g;
var splitterRE$1 = /[\s'"`;>]+/;
function autocompleteExtractorAttributify(options) {
  return {
    name: "attributify",
    extract: ({ content, cursor }) => {
      const matchedElements = content.matchAll(elementRE$1);
      let attrs;
      let elPos = 0;
      for (const match of matchedElements) {
        const [, prefix, content$1] = match;
        const currentPos$1 = match.index + prefix.length;
        if (cursor > currentPos$1 && cursor <= currentPos$1 + content$1.length) {
          elPos = currentPos$1;
          attrs = content$1;
          break;
        }
      }
      if (!attrs) return null;
      const matchedAttributes = attrs.matchAll(valuedAttributeRE$1);
      let attrsPos = 0;
      let attrName;
      let attrValues;
      for (const match of matchedAttributes) {
        const [matched, name50, rawValues] = match;
        const currentPos$1 = elPos + match.index;
        if (cursor > currentPos$1 && cursor <= currentPos$1 + matched.length) {
          attrsPos = currentPos$1;
          attrName = name50;
          attrValues = rawValues == null ? void 0 : rawValues.slice(1);
          break;
        }
      }
      if (!attrName) return null;
      if (attrName === "class" || attrName === "className" || attrName === ":class") return null;
      const hasPrefix = !!(options == null ? void 0 : options.prefix) && attrName.startsWith(options.prefix);
      if ((options == null ? void 0 : options.prefixedOnly) && !hasPrefix) return null;
      const attrNameWithoutPrefix = hasPrefix ? attrName.slice(options.prefix.length) : attrName;
      if (attrValues === void 0) return {
        extracted: attrNameWithoutPrefix,
        resolveReplacement(suggestion) {
          const startOffset = hasPrefix ? options.prefix.length : 0;
          return {
            start: attrsPos + startOffset,
            end: attrsPos + attrName.length,
            replacement: suggestion
          };
        }
      };
      const attrValuePos = attrsPos + attrName.length + 2;
      let matchSplit = splitterRE$1.exec(attrValues);
      let currentPos = 0;
      let value;
      while (matchSplit) {
        const [matched] = matchSplit;
        if (cursor > attrValuePos + currentPos && cursor <= attrValuePos + currentPos + matchSplit.index) {
          value = attrValues.slice(currentPos, currentPos + matchSplit.index);
          break;
        }
        currentPos += matchSplit.index + matched.length;
        matchSplit = splitterRE$1.exec(attrValues.slice(currentPos));
      }
      if (value === void 0) value = attrValues.slice(currentPos);
      const [, variants4 = "", body] = value.match(variantsRE) || [];
      return {
        extracted: `${variants4}${attrNameWithoutPrefix}-${body}`,
        transformSuggestions(suggestions) {
          return suggestions.filter((v) => v.startsWith(`${variants4}${attrNameWithoutPrefix}-`)).map((v) => variants4 + v.slice(variants4.length + attrNameWithoutPrefix.length + 1));
        },
        resolveReplacement(suggestion) {
          return {
            start: currentPos + attrValuePos,
            end: currentPos + attrValuePos + value.length,
            replacement: variants4 + suggestion.slice(variants4.length + attrNameWithoutPrefix.length + 1)
          };
        }
      };
    }
  };
}
var strippedPrefixes = ["v-bind:", ":"];
var splitterRE = /[\s'"`;]+/g;
var elementRE = /<[^>\s]*\s((?:'[^']*'|"[^"]*"|`[^`]*`|\{[^}]*\}|=>|[^>]*?)*)/g;
var valuedAttributeRE = /(\?|(?!\d|-{2}|-\d)[\w\u00A0-\uFFFF:!%.~<-]+)=?(?:"([^"]*)"|'([^']*)'|\{([^}]*)\})?/g;
var defaultIgnoreAttributes = [
  "placeholder",
  "fill",
  "opacity",
  "stroke-opacity"
];
function extractorAttributify(options) {
  const ignoreAttributes = (options == null ? void 0 : options.ignoreAttributes) ?? defaultIgnoreAttributes;
  const nonValuedAttribute = (options == null ? void 0 : options.nonValuedAttribute) ?? true;
  const trueToNonValued = (options == null ? void 0 : options.trueToNonValued) ?? false;
  return {
    name: "@unocss/preset-attributify/extractor",
    extract({ code: code2 }) {
      return Array.from(code2.matchAll(elementRE)).flatMap((match) => Array.from((match[1] || "").matchAll(valuedAttributeRE))).flatMap(([, name50, ...contents3]) => {
        const content = contents3.filter(Boolean).join("");
        if (ignoreAttributes.includes(name50)) return [];
        for (const prefix of strippedPrefixes) if (name50.startsWith(prefix)) {
          name50 = name50.slice(prefix.length);
          break;
        }
        if (!content) {
          if (isValidSelector(name50) && nonValuedAttribute !== false) {
            const result = [`[${name50}=""]`];
            if (trueToNonValued) result.push(`[${name50}="true"]`);
            return result;
          }
          return [];
        }
        if (["class", "className"].includes(name50)) return content.split(splitterRE).filter(isValidSelector);
        else if (elementRE.test(content)) {
          elementRE.lastIndex = 0;
          return this.extract({ code: content });
        } else {
          if ((options == null ? void 0 : options.prefixedOnly) && options.prefix && !name50.startsWith(options.prefix)) return [];
          return content.split(splitterRE).filter((v) => Boolean(v) && v !== ":").map((v) => `[${name50}~="${v}"]`);
        }
      });
    }
  };
}
var presetAttributify = definePreset((options = {}) => {
  options.strict = options.strict ?? false;
  options.prefix = options.prefix ?? "un-";
  options.prefixedOnly = options.prefixedOnly ?? false;
  options.nonValuedAttribute = options.nonValuedAttribute ?? true;
  options.ignoreAttributes = options.ignoreAttributes ?? defaultIgnoreAttributes;
  return {
    name: "@unocss/preset-attributify",
    enforce: "post",
    variants: [variantAttributify(options)],
    extractors: [extractorAttributify(options)],
    options,
    autocomplete: { extractors: [autocompleteExtractorAttributify(options)] },
    extractorDefault: options.strict ? false : void 0
  };
});
var src_default = presetAttributify;

// node_modules/@iconify/utils/lib/svg/trim.js
function trimSVG(str) {
  return str.replace(/(['"])\s*\n\s*([^>\\/\s])/g, "$1 $2").replace(/(["';{}><])\s*\n\s*/g, "$1").replace(/\s*\n\s*/g, " ").replace(/\s+"/g, '"').replace(/="\s+/g, '="').replace(/(\s)+\/>/g, "/>").trim();
}

// node_modules/@iconify/utils/lib/svg/size.js
var unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
var unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function calculateSize(size, ratio, precision) {
  if (ratio === 1) return size;
  precision = precision || 100;
  if (typeof size === "number") return Math.ceil(size * ratio * precision) / precision;
  if (typeof size !== "string") return size;
  const oldParts = size.split(unitsSplit);
  if (oldParts === null || !oldParts.length) return size;
  const newParts = [];
  let code2 = oldParts.shift();
  let isNumber = unitsTest.test(code2);
  while (true) {
    if (isNumber) {
      const num = parseFloat(code2);
      if (isNaN(num)) newParts.push(code2);
      else newParts.push(Math.ceil(num * ratio * precision) / precision);
    } else newParts.push(code2);
    code2 = oldParts.shift();
    if (code2 === void 0) return newParts.join("");
    isNumber = !isNumber;
  }
}

// node_modules/@iconify/utils/lib/icon/defaults.js
var defaultIconDimensions = Object.freeze({
  left: 0,
  top: 0,
  width: 16,
  height: 16
});
var defaultIconTransformations = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false
});
var defaultIconProps = Object.freeze({
  ...defaultIconDimensions,
  ...defaultIconTransformations
});
var defaultExtendedIconProps = Object.freeze({
  ...defaultIconProps,
  body: "",
  hidden: false
});

// node_modules/@iconify/utils/lib/customisations/defaults.js
var defaultIconSizeCustomisations = Object.freeze({
  width: null,
  height: null
});
var defaultIconCustomisations = Object.freeze({
  ...defaultIconSizeCustomisations,
  ...defaultIconTransformations
});

// node_modules/@iconify/utils/lib/svg/defs.js
function splitSVGDefs(content, tag = "defs") {
  let defs = "";
  const index = content.indexOf("<" + tag);
  while (index >= 0) {
    const start = content.indexOf(">", index);
    const end = content.indexOf("</" + tag);
    if (start === -1 || end === -1) break;
    const endEnd = content.indexOf(">", end);
    if (endEnd === -1) break;
    defs += content.slice(start + 1, end).trim();
    content = content.slice(0, index).trim() + content.slice(endEnd + 1);
  }
  return {
    defs,
    content
  };
}
function mergeDefsAndContent(defs, content) {
  return defs ? "<defs>" + defs + "</defs>" + content : content;
}
function wrapSVGContent(body, start, end) {
  const split = splitSVGDefs(body);
  return mergeDefsAndContent(split.defs, start + split.content + end);
}

// node_modules/@iconify/utils/lib/svg/build.js
var isUnsetKeyword = (value) => value === "unset" || value === "undefined" || value === "none";
function iconToSVG(icon, customisations) {
  const fullIcon = {
    ...defaultIconProps,
    ...icon
  };
  const fullCustomisations = {
    ...defaultIconCustomisations,
    ...customisations
  };
  const box = {
    left: fullIcon.left,
    top: fullIcon.top,
    width: fullIcon.width,
    height: fullIcon.height
  };
  let body = fullIcon.body;
  [fullIcon, fullCustomisations].forEach((props) => {
    const transformations = [];
    const hFlip = props.hFlip;
    const vFlip = props.vFlip;
    let rotation = props.rotate;
    if (hFlip) if (vFlip) rotation += 2;
    else {
      transformations.push("translate(" + (box.width + box.left).toString() + " " + (0 - box.top).toString() + ")");
      transformations.push("scale(-1 1)");
      box.top = box.left = 0;
    }
    else if (vFlip) {
      transformations.push("translate(" + (0 - box.left).toString() + " " + (box.height + box.top).toString() + ")");
      transformations.push("scale(1 -1)");
      box.top = box.left = 0;
    }
    let tempValue;
    if (rotation < 0) rotation -= Math.floor(rotation / 4) * 4;
    rotation = rotation % 4;
    switch (rotation) {
      case 1:
        tempValue = box.height / 2 + box.top;
        transformations.unshift("rotate(90 " + tempValue.toString() + " " + tempValue.toString() + ")");
        break;
      case 2:
        transformations.unshift("rotate(180 " + (box.width / 2 + box.left).toString() + " " + (box.height / 2 + box.top).toString() + ")");
        break;
      case 3:
        tempValue = box.width / 2 + box.left;
        transformations.unshift("rotate(-90 " + tempValue.toString() + " " + tempValue.toString() + ")");
        break;
    }
    if (rotation % 2 === 1) {
      if (box.left !== box.top) {
        tempValue = box.left;
        box.left = box.top;
        box.top = tempValue;
      }
      if (box.width !== box.height) {
        tempValue = box.width;
        box.width = box.height;
        box.height = tempValue;
      }
    }
    if (transformations.length) body = wrapSVGContent(body, '<g transform="' + transformations.join(" ") + '">', "</g>");
  });
  const customisationsWidth = fullCustomisations.width;
  const customisationsHeight = fullCustomisations.height;
  const boxWidth = box.width;
  const boxHeight = box.height;
  let width2;
  let height2;
  if (customisationsWidth === null) {
    height2 = customisationsHeight === null ? "1em" : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
    width2 = calculateSize(height2, boxWidth / boxHeight);
  } else {
    width2 = customisationsWidth === "auto" ? boxWidth : customisationsWidth;
    height2 = customisationsHeight === null ? calculateSize(width2, boxHeight / boxWidth) : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
  }
  const attributes = {};
  const setAttr = (prop, value) => {
    if (!isUnsetKeyword(value)) attributes[prop] = value.toString();
  };
  setAttr("width", width2);
  setAttr("height", height2);
  const viewBox = [
    box.left,
    box.top,
    boxWidth,
    boxHeight
  ];
  attributes.viewBox = viewBox.join(" ");
  return {
    attributes,
    viewBox,
    body
  };
}

// node_modules/@iconify/utils/lib/loader/utils.js
var svgWidthRegex = /\swidth\s*=\s*["']([\w.]+)["']/;
var svgHeightRegex = /\sheight\s*=\s*["']([\w.]+)["']/;
var svgTagRegex = /<svg\s+/;
function configureSvgSize(svg, props, scale) {
  const svgNode = svg.slice(0, svg.indexOf(">"));
  const check = (prop, regex) => {
    const result = regex.exec(svgNode);
    const isSet = result != null;
    const propValue = props[prop];
    if (!propValue && !isUnsetKeyword(propValue)) {
      if (typeof scale === "number") {
        if (scale > 0) props[prop] = calculateSize((result == null ? void 0 : result[1]) ?? "1em", scale);
      } else if (result) props[prop] = result[1];
    }
    return isSet;
  };
  return [check("width", svgWidthRegex), check("height", svgHeightRegex)];
}
async function mergeIconProps(svg, collection, icon, options, propsProvider, afterCustomizations) {
  const { scale, addXmlNs = false } = options ?? {};
  const { additionalProps = {}, iconCustomizer } = (options == null ? void 0 : options.customizations) ?? {};
  const props = await (propsProvider == null ? void 0 : propsProvider()) ?? {};
  await (iconCustomizer == null ? void 0 : iconCustomizer(collection, icon, props));
  Object.keys(additionalProps).forEach((p) => {
    const v = additionalProps[p];
    if (v !== void 0 && v !== null) props[p] = v;
  });
  afterCustomizations == null ? void 0 : afterCustomizations(props);
  const [widthOnSvg, heightOnSvg] = configureSvgSize(svg, props, scale);
  if (addXmlNs) {
    if (!svg.includes("xmlns=") && !props["xmlns"]) props["xmlns"] = "http://www.w3.org/2000/svg";
    if (!svg.includes("xmlns:xlink=") && svg.includes("xlink:") && !props["xmlns:xlink"]) props["xmlns:xlink"] = "http://www.w3.org/1999/xlink";
  }
  const propsToAdd = Object.keys(props).map((p) => p === "width" && widthOnSvg || p === "height" && heightOnSvg ? null : `${p}="${props[p]}"`).filter((p) => p != null);
  if (propsToAdd.length) svg = svg.replace(svgTagRegex, `<svg ${propsToAdd.join(" ")} `);
  if (options) {
    const { defaultStyle, defaultClass } = options;
    if (defaultClass && !svg.includes("class=")) svg = svg.replace(svgTagRegex, `<svg class="${defaultClass}" `);
    if (defaultStyle && !svg.includes("style=")) svg = svg.replace(svgTagRegex, `<svg style="${defaultStyle}" `);
  }
  const usedProps = options == null ? void 0 : options.usedProps;
  if (usedProps) {
    Object.keys(additionalProps).forEach((p) => {
      const v = props[p];
      if (v !== void 0 && v !== null) usedProps[p] = v;
    });
    if (typeof props.width !== "undefined" && props.width !== null) usedProps.width = props.width;
    if (typeof props.height !== "undefined" && props.height !== null) usedProps.height = props.height;
  }
  return svg;
}

// node_modules/@iconify/utils/lib/loader/custom.js
async function getCustomIcon(custom2, collection, icon, options) {
  var _a;
  let result;
  try {
    if (typeof custom2 === "function") result = await custom2(icon);
    else {
      const inline = custom2[icon];
      result = typeof inline === "function" ? await inline() : inline;
    }
  } catch (err) {
    console.warn(`Failed to load custom icon "${icon}" in "${collection}":`, err);
    return;
  }
  if (result) {
    const cleanupIdx = result.indexOf("<svg");
    if (cleanupIdx > 0) result = result.slice(cleanupIdx);
    const { transform: transform3 } = (options == null ? void 0 : options.customizations) ?? {};
    result = typeof transform3 === "function" ? await transform3(result, collection, icon) : result;
    if (!result.startsWith("<svg")) {
      console.warn(`Custom icon "${icon}" in "${collection}" is not a valid SVG`);
      return result;
    }
    return await mergeIconProps(((_a = options == null ? void 0 : options.customizations) == null ? void 0 : _a.trimCustomSvg) === true ? trimSVG(result) : result, collection, icon, options, void 0);
  }
}

// node_modules/@iconify/utils/lib/icon/transformations.js
function mergeIconTransformations(obj1, obj2) {
  const result = {};
  if (!obj1.hFlip !== !obj2.hFlip) result.hFlip = true;
  if (!obj1.vFlip !== !obj2.vFlip) result.vFlip = true;
  const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;
  if (rotate) result.rotate = rotate;
  return result;
}

// node_modules/@iconify/utils/lib/icon/merge.js
function mergeIconData(parent, child) {
  const result = mergeIconTransformations(parent, child);
  for (const key in defaultExtendedIconProps) if (key in defaultIconTransformations) {
    if (key in parent && !(key in result)) result[key] = defaultIconTransformations[key];
  } else if (key in child) result[key] = child[key];
  else if (key in parent) result[key] = parent[key];
  return result;
}

// node_modules/@iconify/utils/lib/icon-set/tree.js
function getIconsTree(data, names) {
  const icons = data.icons;
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  const resolved = /* @__PURE__ */ Object.create(null);
  function resolve(name50) {
    if (icons[name50]) return resolved[name50] = [];
    if (!(name50 in resolved)) {
      resolved[name50] = null;
      const parent = aliases[name50] && aliases[name50].parent;
      const value = parent && resolve(parent);
      if (value) resolved[name50] = [parent].concat(value);
    }
    return resolved[name50];
  }
  (names || Object.keys(icons).concat(Object.keys(aliases))).forEach(resolve);
  return resolved;
}

// node_modules/@iconify/utils/lib/icon-set/get-icon.js
function internalGetIconData(data, name50, tree) {
  const icons = data.icons;
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  let currentProps = {};
  function parse53(name$1) {
    currentProps = mergeIconData(icons[name$1] || aliases[name$1], currentProps);
  }
  parse53(name50);
  tree.forEach(parse53);
  return mergeIconData(data, currentProps);
}
function getIconData(data, name50) {
  if (data.icons[name50]) return internalGetIconData(data, name50, []);
  const tree = getIconsTree(data, [name50])[name50];
  return tree ? internalGetIconData(data, name50, tree) : null;
}

// node_modules/@iconify/utils/lib/loader/modern.js
async function searchForIcon(iconSet, collection, ids, options) {
  let iconData;
  const { customize } = (options == null ? void 0 : options.customizations) ?? {};
  for (const id of ids) {
    iconData = getIconData(iconSet, id);
    if (iconData) {
      let defaultCustomizations = { ...defaultIconCustomisations };
      if (typeof customize === "function") {
        iconData = Object.assign({}, iconData);
        defaultCustomizations = customize(defaultCustomizations, iconData, `${collection}:${id}`) ?? defaultCustomizations;
      }
      const { attributes: { width: width2, height: height2, ...restAttributes }, body } = iconToSVG(iconData, defaultCustomizations);
      const scale = options == null ? void 0 : options.scale;
      return await mergeIconProps(`<svg >${body}</svg>`, collection, id, options, () => {
        return { ...restAttributes };
      }, (props) => {
        const check = (prop, defaultValue) => {
          const propValue = props[prop];
          let value;
          if (!isUnsetKeyword(propValue)) {
            if (propValue) return;
            if (typeof scale === "number") {
              if (scale) value = calculateSize(defaultValue ?? "1em", scale);
            } else value = defaultValue;
          }
          if (!value) delete props[prop];
          else props[prop] = value;
        };
        check("width", width2);
        check("height", height2);
      });
    }
  }
}

// node_modules/@iconify/utils/lib/loader/loader.js
var loadIcon = async (collection, icon, options) => {
  var _a;
  const custom2 = (_a = options == null ? void 0 : options.customCollections) == null ? void 0 : _a[collection];
  if (custom2) if (typeof custom2 === "function") {
    let result;
    try {
      result = await custom2(icon);
    } catch (err) {
      console.warn(`Failed to load custom icon "${icon}" in "${collection}":`, err);
      return;
    }
    if (result) {
      if (typeof result === "string") return await getCustomIcon(() => result, collection, icon, options);
      if ("icons" in result) {
        const ids = [
          icon,
          icon.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
          icon.replace(/([a-z])(\d+)/g, "$1-$2")
        ];
        return await searchForIcon(result, collection, ids, options);
      }
    }
  } else return await getCustomIcon(custom2, collection, icon, options);
};

// node_modules/@iconify/utils/lib/svg/url.js
function encodeSVGforURL(svg) {
  return svg.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}

// node_modules/@iconify/utils/lib/svg/encode-svg-for-css.js
function encodeSvgForCss(svg) {
  let useSvg = svg.startsWith("<svg>") ? svg.replace("<svg>", "<svg >") : svg;
  if (!useSvg.includes(" xmlns:xlink=") && useSvg.includes(" xlink:")) useSvg = useSvg.replace("<svg ", '<svg xmlns:xlink="http://www.w3.org/1999/xlink" ');
  if (!useSvg.includes(" xmlns=")) useSvg = useSvg.replace("<svg ", '<svg xmlns="http://www.w3.org/2000/svg" ');
  return encodeSVGforURL(useSvg);
}

// node_modules/@unocss/preset-icons/dist/core-Cim-HCl5.mjs
function getEnvFlags() {
  const isNode = typeof process !== "undefined" && process.stdout;
  return {
    isNode,
    isVSCode: isNode && !!process.env.VSCODE_CWD,
    isESLint: isNode && !!process.env.ESLINT
  };
}
var collections_default = [
  "academicons",
  "akar-icons",
  "ant-design",
  "arcticons",
  "basil",
  "bi",
  "bitcoin-icons",
  "bpmn",
  "brandico",
  "bubbles",
  "bx",
  "bxl",
  "bxs",
  "bytesize",
  "carbon",
  "catppuccin",
  "cbi",
  "charm",
  "ci",
  "cib",
  "cif",
  "cil",
  "circle-flags",
  "circum",
  "clarity",
  "codex",
  "codicon",
  "covid",
  "cryptocurrency-color",
  "cryptocurrency",
  "cuida",
  "dashicons",
  "devicon-line",
  "devicon-original",
  "devicon-plain",
  "devicon",
  "dinkie-icons",
  "duo-icons",
  "ei",
  "el",
  "emblemicons",
  "emojione-monotone",
  "emojione-v1",
  "emojione",
  "entypo-social",
  "entypo",
  "eos-icons",
  "ep",
  "et",
  "eva",
  "f7",
  "fa-brands",
  "fa-regular",
  "fa-solid",
  "fa",
  "fa6-brands",
  "fa6-regular",
  "fa6-solid",
  "fa7-brands",
  "fa7-regular",
  "fa7-solid",
  "fad",
  "famicons",
  "fe",
  "feather",
  "file-icons",
  "flag",
  "flagpack",
  "flat-color-icons",
  "flat-ui",
  "flowbite",
  "fluent-color",
  "fluent-emoji-flat",
  "fluent-emoji-high-contrast",
  "fluent-emoji",
  "fluent-mdl2",
  "fluent",
  "fontelico",
  "fontisto",
  "formkit",
  "foundation",
  "fxemoji",
  "gala",
  "game-icons",
  "garden",
  "geo",
  "gg",
  "gis",
  "gravity-ui",
  "gridicons",
  "grommet-icons",
  "guidance",
  "healthicons",
  "heroicons-outline",
  "heroicons-solid",
  "heroicons",
  "hugeicons",
  "humbleicons",
  "ic",
  "icomoon-free",
  "icon-park-outline",
  "icon-park-solid",
  "icon-park-twotone",
  "icon-park",
  "iconamoon",
  "iconoir",
  "icons8",
  "il",
  "ion",
  "iwwa",
  "ix",
  "jam",
  "la",
  "lets-icons",
  "line-md",
  "lineicons",
  "logos",
  "ls",
  "lsicon",
  "lucide-lab",
  "lucide",
  "mage",
  "majesticons",
  "maki",
  "map",
  "marketeq",
  "material-icon-theme",
  "material-symbols-light",
  "material-symbols",
  "mdi-light",
  "mdi",
  "medical-icon",
  "memory",
  "meteocons",
  "meteor-icons",
  "mi",
  "mingcute",
  "mono-icons",
  "mynaui",
  "nimbus",
  "nonicons",
  "noto-v1",
  "noto",
  "nrk",
  "octicon",
  "oi",
  "ooui",
  "openmoji",
  "oui",
  "pajamas",
  "pepicons-pencil",
  "pepicons-pop",
  "pepicons-print",
  "pepicons",
  "ph",
  "picon",
  "pixel",
  "pixelarticons",
  "prime",
  "proicons",
  "ps",
  "qlementine-icons",
  "quill",
  "radix-icons",
  "raphael",
  "ri",
  "rivet-icons",
  "roentgen",
  "si-glyph",
  "si",
  "sidekickicons",
  "simple-icons",
  "simple-line-icons",
  "skill-icons",
  "solar",
  "stash",
  "streamline-block",
  "streamline-color",
  "streamline-cyber-color",
  "streamline-cyber",
  "streamline-emojis",
  "streamline-flex-color",
  "streamline-flex",
  "streamline-freehand-color",
  "streamline-freehand",
  "streamline-guidance",
  "streamline-kameleon-color",
  "streamline-logos",
  "streamline-pixel",
  "streamline-plump-color",
  "streamline-plump",
  "streamline-sharp-color",
  "streamline-sharp",
  "streamline-stickies-color",
  "streamline-ultimate-color",
  "streamline-ultimate",
  "streamline",
  "subway",
  "svg-spinners",
  "system-uicons",
  "tabler",
  "tdesign",
  "teenyicons",
  "temaki",
  "token-branded",
  "token",
  "topcoat",
  "twemoji",
  "typcn",
  "uil",
  "uim",
  "uis",
  "uit",
  "uiw",
  "unjs",
  "vaadin",
  "vs",
  "vscode-icons",
  "websymbol",
  "weui",
  "whh",
  "wi",
  "wpf",
  "zmdi",
  "zondicons"
];
var COLLECTION_NAME_PARTS_MAX = 3;
function createPresetIcons(lookupIconLoader) {
  return definePreset((options = {}) => {
    const { scale = 1, mode = "auto", prefix = "i-", warn = false, iconifyCollectionsNames, collections: customCollections, extraProperties = {}, customizations = {}, autoInstall = false, collectionsNodeResolvePath, layer = "icons", unit, processor } = options;
    const flags = getEnvFlags();
    const loaderOptions = {
      addXmlNs: true,
      scale,
      customCollections,
      autoInstall,
      cwd: collectionsNodeResolvePath,
      warn: void 0,
      customizations: {
        ...customizations,
        additionalProps: { ...extraProperties },
        trimCustomSvg: true,
        async iconCustomizer(collection, icon, props) {
          var _a;
          await ((_a = customizations.iconCustomizer) == null ? void 0 : _a.call(customizations, collection, icon, props));
          if (unit) {
            if (!props.width) props.width = `${scale}${unit}`;
            if (!props.height) props.height = `${scale}${unit}`;
          }
        }
      }
    };
    let iconLoader;
    return {
      name: "@unocss/preset-icons",
      enforce: "pre",
      options,
      layers: { icons: -30 },
      api: {
        encodeSvgForCss,
        parseIconWithLoader
      },
      rules: [[
        /^([\w:-]+)(?:\?(mask|bg|auto))?$/,
        async (matcher) => {
          let [full, body, _mode = mode] = matcher;
          iconLoader = iconLoader || await lookupIconLoader(options);
          const usedProps = {};
          const parsed = await parseIconWithLoader(body, iconLoader, {
            ...loaderOptions,
            usedProps
          }, iconifyCollectionsNames);
          if (!parsed) {
            if (warn && !flags.isESLint) warnOnce(`failed to load icon "${full}"`);
            return;
          }
          let cssObject;
          const url = `url("data:image/svg+xml;utf8,${encodeSvgForCss(parsed.svg)}")`;
          if (_mode === "auto") _mode = parsed.svg.includes("currentColor") ? "mask" : "bg";
          if (_mode === "mask") cssObject = {
            "--un-icon": url,
            "-webkit-mask": "var(--un-icon) no-repeat",
            "mask": "var(--un-icon) no-repeat",
            "-webkit-mask-size": "100% 100%",
            "mask-size": "100% 100%",
            "background-color": "currentColor",
            "color": "inherit",
            ...usedProps
          };
          else cssObject = {
            "background": `${url} no-repeat`,
            "background-size": "100% 100%",
            "background-color": "transparent",
            ...usedProps
          };
          processor == null ? void 0 : processor(cssObject, {
            ...parsed,
            icon: parsed.name,
            mode: _mode
          });
          return cssObject;
        },
        {
          layer,
          prefix
        }
      ]]
    };
  });
}
function createCDNFetchLoader(fetcher, cdnBase, cacheMap = /* @__PURE__ */ new Map()) {
  function fetchCollection(name50) {
    if (!collections_default.includes(name50)) return void 0;
    if (!cacheMap.has(name50)) cacheMap.set(name50, fetcher(`${cdnBase}@iconify-json/${name50}/icons.json`));
    return cacheMap.get(name50);
  }
  return async (collection, icon, options) => {
    let result = await loadIcon(collection, icon, options);
    if (result) return result;
    const iconSet = await fetchCollection(collection);
    if (iconSet) result = await searchForIcon(iconSet, collection, [
      icon,
      icon.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
      icon.replace(/([a-z])(\d+)/g, "$1-$2")
    ], options);
    return result;
  };
}
async function parseIconWithLoader(body, loader, options = {}, safeCollectionsNames = []) {
  let collection = "";
  let name50 = "";
  let svg;
  const allCollections = /* @__PURE__ */ new Set([
    ...collections_default,
    ...safeCollectionsNames,
    ...Object.keys(options.customCollections || {})
  ]);
  if (body.includes(":")) {
    [collection, name50] = body.split(":");
    if (!allCollections.has(collection)) return;
    svg = await loader(collection, name50, options);
  } else {
    const parts = body.split(/-/g);
    for (let i = COLLECTION_NAME_PARTS_MAX; i >= 1; i--) {
      collection = parts.slice(0, i).join("-");
      if (!allCollections.has(collection)) continue;
      name50 = parts.slice(i).join("-");
      svg = await loader(collection, name50, options);
      if (svg) break;
    }
  }
  if (!svg) return;
  return {
    collection,
    name: name50,
    svg
  };
}

// node_modules/@unocss/preset-icons/dist/cdn-B-mELdBX.mjs
async function createCDNLoader(cdnBase) {
  const { $fetch } = await import("./dist-HFD2ANBM.js");
  return createCDNFetchLoader($fetch, cdnBase);
}

// node_modules/@iconify/utils/lib/icon-set/validate-basic.js
var optionalPropertyDefaults = {
  provider: "",
  aliases: {},
  not_found: {},
  ...defaultIconDimensions
};

// node_modules/@iconify/utils/lib/icon-set/get-icons.js
var propsToCopy = Object.keys(defaultIconDimensions).concat(["provider"]);

// node_modules/@iconify/utils/lib/colors/keywords.js
var colorKeywords = {
  transparent: { type: "transparent" },
  none: { type: "none" },
  currentcolor: { type: "current" }
};
function add(keyword2, colors3) {
  const type = "rgb";
  const r = colors3[0];
  const length2 = colors3.length;
  colorKeywords[keyword2] = {
    type,
    r,
    g: length2 > 1 ? colors3[1] : r,
    b: length2 > 2 ? colors3[2] : r,
    alpha: length2 > 3 ? colors3[3] : 1
  };
}
add("silver", [192]);
add("gray", [128]);
add("white", [255]);
add("maroon", [
  128,
  0,
  0
]);
add("red", [
  255,
  0,
  0
]);
add("purple", [128, 0]);
add("fuchsia", [255, 0]);
add("green", [0, 128]);
add("lime", [0, 255]);
add("olive", [
  128,
  128,
  0
]);
add("yellow", [
  255,
  255,
  0
]);
add("navy", [
  0,
  0,
  128
]);
add("blue", [
  0,
  0,
  255
]);
add("teal", [
  0,
  128,
  128
]);
add("aqua", [
  0,
  255,
  255
]);
add("aliceblue", [
  240,
  248,
  255
]);
add("antiquewhite", [
  250,
  235,
  215
]);
add("aqua", [
  0,
  255,
  255
]);
add("aquamarine", [
  127,
  255,
  212
]);
add("azure", [
  240,
  255,
  255
]);
add("beige", [
  245,
  245,
  220
]);
add("bisque", [
  255,
  228,
  196
]);
add("black", [0]);
add("blanchedalmond", [
  255,
  235,
  205
]);
add("blue", [
  0,
  0,
  255
]);
add("blueviolet", [
  138,
  43,
  226
]);
add("brown", [
  165,
  42,
  42
]);
add("burlywood", [
  222,
  184,
  135
]);
add("cadetblue", [
  95,
  158,
  160
]);
add("chartreuse", [
  127,
  255,
  0
]);
add("chocolate", [
  210,
  105,
  30
]);
add("coral", [
  255,
  127,
  80
]);
add("cornflowerblue", [
  100,
  149,
  237
]);
add("cornsilk", [
  255,
  248,
  220
]);
add("crimson", [
  220,
  20,
  60
]);
add("cyan", [
  0,
  255,
  255
]);
add("darkblue", [
  0,
  0,
  139
]);
add("darkcyan", [
  0,
  139,
  139
]);
add("darkgoldenrod", [
  184,
  134,
  11
]);
add("darkgray", [169]);
add("darkgreen", [0, 100]);
add("darkgrey", [169]);
add("darkkhaki", [
  189,
  183,
  107
]);
add("darkmagenta", [139, 0]);
add("darkolivegreen", [
  85,
  107,
  47
]);
add("darkorange", [
  255,
  140,
  0
]);
add("darkorchid", [
  153,
  50,
  204
]);
add("darkred", [
  139,
  0,
  0
]);
add("darksalmon", [
  233,
  150,
  122
]);
add("darkseagreen", [143, 188]);
add("darkslateblue", [
  72,
  61,
  139
]);
add("darkslategray", [
  47,
  79,
  79
]);
add("darkslategrey", [
  47,
  79,
  79
]);
add("darkturquoise", [
  0,
  206,
  209
]);
add("darkviolet", [
  148,
  0,
  211
]);
add("deeppink", [
  255,
  20,
  147
]);
add("deepskyblue", [
  0,
  191,
  255
]);
add("dimgray", [105]);
add("dimgrey", [105]);
add("dodgerblue", [
  30,
  144,
  255
]);
add("firebrick", [
  178,
  34,
  34
]);
add("floralwhite", [
  255,
  250,
  240
]);
add("forestgreen", [34, 139]);
add("fuchsia", [255, 0]);
add("gainsboro", [220]);
add("ghostwhite", [
  248,
  248,
  255
]);
add("gold", [
  255,
  215,
  0
]);
add("goldenrod", [
  218,
  165,
  32
]);
add("gray", [128]);
add("green", [0, 128]);
add("greenyellow", [
  173,
  255,
  47
]);
add("grey", [128]);
add("honeydew", [240, 255]);
add("hotpink", [
  255,
  105,
  180
]);
add("indianred", [
  205,
  92,
  92
]);
add("indigo", [
  75,
  0,
  130
]);
add("ivory", [
  255,
  255,
  240
]);
add("khaki", [
  240,
  230,
  140
]);
add("lavender", [
  230,
  230,
  250
]);
add("lavenderblush", [
  255,
  240,
  245
]);
add("lawngreen", [
  124,
  252,
  0
]);
add("lemonchiffon", [
  255,
  250,
  205
]);
add("lightblue", [
  173,
  216,
  230
]);
add("lightcoral", [
  240,
  128,
  128
]);
add("lightcyan", [
  224,
  255,
  255
]);
add("lightgoldenrodyellow", [
  250,
  250,
  210
]);
add("lightgray", [211]);
add("lightgreen", [144, 238]);
add("lightgrey", [211]);
add("lightpink", [
  255,
  182,
  193
]);
add("lightsalmon", [
  255,
  160,
  122
]);
add("lightseagreen", [
  32,
  178,
  170
]);
add("lightskyblue", [
  135,
  206,
  250
]);
add("lightslategray", [
  119,
  136,
  153
]);
add("lightslategrey", [
  119,
  136,
  153
]);
add("lightsteelblue", [
  176,
  196,
  222
]);
add("lightyellow", [
  255,
  255,
  224
]);
add("lime", [0, 255]);
add("limegreen", [50, 205]);
add("linen", [
  250,
  240,
  230
]);
add("magenta", [255, 0]);
add("maroon", [
  128,
  0,
  0
]);
add("mediumaquamarine", [
  102,
  205,
  170
]);
add("mediumblue", [
  0,
  0,
  205
]);
add("mediumorchid", [
  186,
  85,
  211
]);
add("mediumpurple", [
  147,
  112,
  219
]);
add("mediumseagreen", [
  60,
  179,
  113
]);
add("mediumslateblue", [
  123,
  104,
  238
]);
add("mediumspringgreen", [
  0,
  250,
  154
]);
add("mediumturquoise", [
  72,
  209,
  204
]);
add("mediumvioletred", [
  199,
  21,
  133
]);
add("midnightblue", [
  25,
  25,
  112
]);
add("mintcream", [
  245,
  255,
  250
]);
add("mistyrose", [
  255,
  228,
  225
]);
add("moccasin", [
  255,
  228,
  181
]);
add("navajowhite", [
  255,
  222,
  173
]);
add("navy", [
  0,
  0,
  128
]);
add("oldlace", [
  253,
  245,
  230
]);
add("olive", [
  128,
  128,
  0
]);
add("olivedrab", [
  107,
  142,
  35
]);
add("orange", [
  255,
  165,
  0
]);
add("orangered", [
  255,
  69,
  0
]);
add("orchid", [
  218,
  112,
  214
]);
add("palegoldenrod", [
  238,
  232,
  170
]);
add("palegreen", [152, 251]);
add("paleturquoise", [
  175,
  238,
  238
]);
add("palevioletred", [
  219,
  112,
  147
]);
add("papayawhip", [
  255,
  239,
  213
]);
add("peachpuff", [
  255,
  218,
  185
]);
add("peru", [
  205,
  133,
  63
]);
add("pink", [
  255,
  192,
  203
]);
add("plum", [221, 160]);
add("powderblue", [
  176,
  224,
  230
]);
add("purple", [128, 0]);
add("rebeccapurple", [
  102,
  51,
  153
]);
add("red", [
  255,
  0,
  0
]);
add("rosybrown", [
  188,
  143,
  143
]);
add("royalblue", [
  65,
  105,
  225
]);
add("saddlebrown", [
  139,
  69,
  19
]);
add("salmon", [
  250,
  128,
  114
]);
add("sandybrown", [
  244,
  164,
  96
]);
add("seagreen", [
  46,
  139,
  87
]);
add("seashell", [
  255,
  245,
  238
]);
add("sienna", [
  160,
  82,
  45
]);
add("silver", [192]);
add("skyblue", [
  135,
  206,
  235
]);
add("slateblue", [
  106,
  90,
  205
]);
add("slategray", [
  112,
  128,
  144
]);
add("slategrey", [
  112,
  128,
  144
]);
add("snow", [
  255,
  250,
  250
]);
add("springgreen", [
  0,
  255,
  127
]);
add("steelblue", [
  70,
  130,
  180
]);
add("tan", [
  210,
  180,
  140
]);
add("teal", [
  0,
  128,
  128
]);
add("thistle", [216, 191]);
add("tomato", [
  255,
  99,
  71
]);
add("turquoise", [
  64,
  224,
  208
]);
add("violet", [238, 130]);
add("wheat", [
  245,
  222,
  179
]);
add("white", [255]);
add("whitesmoke", [245]);
add("yellow", [
  255,
  255,
  0
]);
add("yellowgreen", [
  154,
  205,
  50
]);

// node_modules/@iconify/utils/lib/css/icons.js
var commonSelector = ".icon--{prefix}";
var iconSelector = ".icon--{prefix}--{name}";
var defaultSelectors = {
  commonSelector,
  iconSelector,
  overrideSelector: commonSelector + iconSelector
};

// node_modules/@iconify/utils/lib/emoji/format.js
var defaultUnicodeOptions = {
  prefix: "",
  separator: "",
  case: "lower",
  format: "utf-32",
  add0: false,
  throwOnError: true
};
var defaultSequenceOptions = {
  ...defaultUnicodeOptions,
  separator: "-"
};

// node_modules/@unocss/preset-icons/dist/browser.mjs
var presetIcons = createPresetIcons(async (options) => {
  const fetcher = options == null ? void 0 : options.customFetch;
  const cdn = options == null ? void 0 : options.cdn;
  if (fetcher && cdn) return createCDNFetchLoader(fetcher, cdn);
  if (cdn) return await createCDNLoader(cdn);
  return loadIcon;
});
var browser_default = presetIcons;

// node_modules/@unocss/preset-mini/dist/chunk-gol_9zmq.mjs
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __exportAll = (all, symbols2) => {
  let target = {};
  for (var name50 in all) {
    __defProp(target, name50, {
      get: all[name50],
      enumerable: true
    });
  }
  if (symbols2) {
    __defProp(target, Symbol.toStringTag, { value: "Module" });
  }
  return target;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (var keys = __getOwnPropNames(from), i = 0, n2 = keys.length, key; i < n2; i++) {
      key = keys[i];
      if (!__hasOwnProp.call(to, key) && key !== except) {
        __defProp(to, key, {
          get: ((k) => from[k]).bind(null, key),
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
      }
    }
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));

// node_modules/@unocss/rule-utils/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  PseudoClassFunctions: () => PseudoClassFunctions,
  PseudoClassFunctionsStr: () => PseudoClassFunctionsStr,
  PseudoClasses: () => PseudoClasses,
  PseudoClassesAndElementsColonStr: () => PseudoClassesAndElementsColonStr,
  PseudoClassesAndElementsStr: () => PseudoClassesAndElementsStr,
  PseudoClassesColon: () => PseudoClassesColon,
  PseudoClassesColonKeys: () => PseudoClassesColonKeys,
  PseudoClassesColonStr: () => PseudoClassesColonStr,
  PseudoClassesKeys: () => PseudoClassesKeys,
  PseudoClassesMulti: () => PseudoClassesMulti,
  PseudoClassesMultiStr: () => PseudoClassesMultiStr,
  PseudoClassesStr: () => PseudoClassesStr,
  alphaPlaceholders: () => alphaPlaceholders,
  alphaPlaceholdersRE: () => alphaPlaceholdersRE,
  calcMaxWidthBySize: () => calcMaxWidthBySize,
  colorOpacityToString: () => colorOpacityToString,
  colorToString: () => colorToString2,
  createPartClasses: () => createPartClasses,
  createPseudoClassFunctions: () => createPseudoClassFunctions,
  createPseudoClassesAndElements: () => createPseudoClassesAndElements,
  createTaggedPseudoClassMatcher: () => createTaggedPseudoClassMatcher,
  createTaggedPseudoClasses: () => createTaggedPseudoClasses,
  createValueHandler: () => createValueHandler,
  cssColorFunctions: () => cssColorFunctions,
  excludedPseudo: () => excludedPseudo,
  getBracket: () => getBracket,
  getStringComponent: () => getStringComponent,
  getStringComponents: () => getStringComponents,
  hasIconFn: () => hasIconFn,
  hasThemeFn: () => hasThemeFn,
  hex2rgba: () => hex2rgba,
  hueInterpolationMethods: () => hueInterpolationMethods,
  iconFnRE: () => iconFnRE,
  isInterpolatedMethod: () => isInterpolatedMethod,
  parseCssColor: () => parseCssColor,
  polarColorSpace: () => polarColorSpace,
  rectangularColorSpace: () => rectangularColorSpace,
  themeFnRE: () => themeFnRE,
  transformThemeFn: () => transformThemeFn,
  transformThemeString: () => transformThemeString,
  variantGetBracket: () => variantGetBracket,
  variantGetParameter: () => variantGetParameter,
  variantMatcher: () => variantMatcher,
  variantParentMatcher: () => variantParentMatcher
});

// node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
var comma = ",".charCodeAt(0);
var semicolon = ";".charCodeAt(0);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i = 0; i < chars.length; i++) {
  const c = chars.charCodeAt(i);
  intToChar[i] = c;
  charToInt[c] = i;
}
function encodeInteger(builder, num, relative) {
  let delta = num - relative;
  delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
  do {
    let clamped = delta & 31;
    delta >>>= 5;
    if (delta > 0) clamped |= 32;
    builder.write(intToChar[clamped]);
  } while (delta > 0);
  return num;
}
var bufLength = 1024 * 16;
var td = typeof TextDecoder !== "undefined" ? new TextDecoder() : typeof Buffer !== "undefined" ? {
  decode(buf) {
    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    return out.toString();
  }
} : {
  decode(buf) {
    let out = "";
    for (let i = 0; i < buf.length; i++) {
      out += String.fromCharCode(buf[i]);
    }
    return out;
  }
};
var StringWriter = class {
  constructor() {
    this.pos = 0;
    this.out = "";
    this.buffer = new Uint8Array(bufLength);
  }
  write(v) {
    const { buffer } = this;
    buffer[this.pos++] = v;
    if (this.pos === bufLength) {
      this.out += td.decode(buffer);
      this.pos = 0;
    }
  }
  flush() {
    const { buffer, out, pos } = this;
    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
  }
};
function encode(decoded) {
  const writer = new StringWriter();
  let sourcesIndex = 0;
  let sourceLine = 0;
  let sourceColumn = 0;
  let namesIndex = 0;
  for (let i = 0; i < decoded.length; i++) {
    const line = decoded[i];
    if (i > 0) writer.write(semicolon);
    if (line.length === 0) continue;
    let genColumn = 0;
    for (let j = 0; j < line.length; j++) {
      const segment = line[j];
      if (j > 0) writer.write(comma);
      genColumn = encodeInteger(writer, segment[0], genColumn);
      if (segment.length === 1) continue;
      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
      sourceLine = encodeInteger(writer, segment[2], sourceLine);
      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
      if (segment.length === 4) continue;
      namesIndex = encodeInteger(writer, segment[4], namesIndex);
    }
  }
  return writer.flush();
}

// node_modules/magic-string/dist/magic-string.es.mjs
var BitSet = class _BitSet {
  constructor(arg) {
    this.bits = arg instanceof _BitSet ? arg.bits.slice() : [];
  }
  add(n2) {
    this.bits[n2 >> 5] |= 1 << (n2 & 31);
  }
  has(n2) {
    return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));
  }
};
var Chunk = class _Chunk {
  constructor(start, end, content) {
    this.start = start;
    this.end = end;
    this.original = content;
    this.intro = "";
    this.outro = "";
    this.content = content;
    this.storeName = false;
    this.edited = false;
    {
      this.previous = null;
      this.next = null;
    }
  }
  appendLeft(content) {
    this.outro += content;
  }
  appendRight(content) {
    this.intro = this.intro + content;
  }
  clone() {
    const chunk = new _Chunk(this.start, this.end, this.original);
    chunk.intro = this.intro;
    chunk.outro = this.outro;
    chunk.content = this.content;
    chunk.storeName = this.storeName;
    chunk.edited = this.edited;
    return chunk;
  }
  contains(index) {
    return this.start < index && index < this.end;
  }
  eachNext(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.next;
    }
  }
  eachPrevious(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.previous;
    }
  }
  edit(content, storeName, contentOnly) {
    this.content = content;
    if (!contentOnly) {
      this.intro = "";
      this.outro = "";
    }
    this.storeName = storeName;
    this.edited = true;
    return this;
  }
  prependLeft(content) {
    this.outro = content + this.outro;
  }
  prependRight(content) {
    this.intro = content + this.intro;
  }
  reset() {
    this.intro = "";
    this.outro = "";
    if (this.edited) {
      this.content = this.original;
      this.storeName = false;
      this.edited = false;
    }
  }
  split(index) {
    const sliceIndex = index - this.start;
    const originalBefore = this.original.slice(0, sliceIndex);
    const originalAfter = this.original.slice(sliceIndex);
    this.original = originalBefore;
    const newChunk = new _Chunk(index, this.end, originalAfter);
    newChunk.outro = this.outro;
    this.outro = "";
    this.end = index;
    if (this.edited) {
      newChunk.edit("", false);
      this.content = "";
    } else {
      this.content = originalBefore;
    }
    newChunk.next = this.next;
    if (newChunk.next) newChunk.next.previous = newChunk;
    newChunk.previous = this;
    this.next = newChunk;
    return newChunk;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(rx) {
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length) return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.start + trimmed.length).edit("", void 0, true);
        if (this.edited) {
          this.edit(trimmed, this.storeName, true);
        }
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length) return true;
    }
  }
  trimStart(rx) {
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length) return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        const newChunk = this.split(this.end - trimmed.length);
        if (this.edited) {
          newChunk.edit(trimmed, this.storeName, true);
        }
        this.edit("", void 0, true);
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length) return true;
    }
  }
};
function getBtoa() {
  if (typeof globalThis !== "undefined" && typeof globalThis.btoa === "function") {
    return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));
  } else if (typeof Buffer === "function") {
    return (str) => Buffer.from(str, "utf-8").toString("base64");
  } else {
    return () => {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
  }
}
var btoa = getBtoa();
var SourceMap = class {
  constructor(properties5) {
    this.version = 3;
    this.file = properties5.file;
    this.sources = properties5.sources;
    this.sourcesContent = properties5.sourcesContent;
    this.names = properties5.names;
    this.mappings = encode(properties5.mappings);
    if (typeof properties5.x_google_ignoreList !== "undefined") {
      this.x_google_ignoreList = properties5.x_google_ignoreList;
    }
    if (typeof properties5.debugId !== "undefined") {
      this.debugId = properties5.debugId;
    }
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + btoa(this.toString());
  }
};
function guessIndent(code2) {
  const lines = code2.split("\n");
  const tabbed = lines.filter((line) => /^\t+/.test(line));
  const spaced = lines.filter((line) => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }
  if (tabbed.length >= spaced.length) {
    return "	";
  }
  const min = spaced.reduce((previous, current) => {
    const numSpaces = /^ +/.exec(current)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min + 1).join(" ");
}
function getRelativePath(from, to) {
  const fromParts = from.split(/[/\\]/);
  const toParts = to.split(/[/\\]/);
  fromParts.pop();
  while (fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  if (fromParts.length) {
    let i = fromParts.length;
    while (i--) fromParts[i] = "..";
  }
  return fromParts.concat(toParts).join("/");
}
var toString = Object.prototype.toString;
function isObject2(thing) {
  return toString.call(thing) === "[object Object]";
}
function getLocator(source) {
  const originalLines = source.split("\n");
  const lineOffsets = [];
  for (let i = 0, pos = 0; i < originalLines.length; i++) {
    lineOffsets.push(pos);
    pos += originalLines[i].length + 1;
  }
  return function locate(index) {
    let i = 0;
    let j = lineOffsets.length;
    while (i < j) {
      const m = i + j >> 1;
      if (index < lineOffsets[m]) {
        j = m;
      } else {
        i = m + 1;
      }
    }
    const line = i - 1;
    const column = index - lineOffsets[line];
    return { line, column };
  };
}
var wordRegex = /\w/;
var Mappings = class {
  constructor(hires) {
    this.hires = hires;
    this.generatedCodeLine = 0;
    this.generatedCodeColumn = 0;
    this.raw = [];
    this.rawSegments = this.raw[this.generatedCodeLine] = [];
    this.pending = null;
  }
  addEdit(sourceIndex, content, loc, nameIndex) {
    if (content.length) {
      const contentLengthMinusOne = content.length - 1;
      let contentLineEnd = content.indexOf("\n", 0);
      let previousContentLineEnd = -1;
      while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
        const segment2 = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (nameIndex >= 0) {
          segment2.push(nameIndex);
        }
        this.rawSegments.push(segment2);
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        previousContentLineEnd = contentLineEnd;
        contentLineEnd = content.indexOf("\n", contentLineEnd + 1);
      }
      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
      if (nameIndex >= 0) {
        segment.push(nameIndex);
      }
      this.rawSegments.push(segment);
      this.advance(content.slice(previousContentLineEnd + 1));
    } else if (this.pending) {
      this.rawSegments.push(this.pending);
      this.advance(content);
    }
    this.pending = null;
  }
  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
    let originalCharIndex = chunk.start;
    let first = true;
    let charInHiresBoundary = false;
    while (originalCharIndex < chunk.end) {
      if (original[originalCharIndex] === "\n") {
        loc.line += 1;
        loc.column = 0;
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        first = true;
        charInHiresBoundary = false;
      } else {
        if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
          const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
          if (this.hires === "boundary") {
            if (wordRegex.test(original[originalCharIndex])) {
              if (!charInHiresBoundary) {
                this.rawSegments.push(segment);
                charInHiresBoundary = true;
              }
            } else {
              this.rawSegments.push(segment);
              charInHiresBoundary = false;
            }
          } else {
            this.rawSegments.push(segment);
          }
        }
        loc.column += 1;
        this.generatedCodeColumn += 1;
        first = false;
      }
      originalCharIndex += 1;
    }
    this.pending = null;
  }
  advance(str) {
    if (!str) return;
    const lines = str.split("\n");
    if (lines.length > 1) {
      for (let i = 0; i < lines.length - 1; i++) {
        this.generatedCodeLine++;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
      }
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += lines[lines.length - 1].length;
  }
};
var n = "\n";
var warned2 = {
  insertLeft: false,
  insertRight: false,
  storeName: false
};
var MagicString = class _MagicString {
  constructor(string, options = {}) {
    const chunk = new Chunk(0, string.length, string);
    Object.defineProperties(this, {
      original: { writable: true, value: string },
      outro: { writable: true, value: "" },
      intro: { writable: true, value: "" },
      firstChunk: { writable: true, value: chunk },
      lastChunk: { writable: true, value: chunk },
      lastSearchedChunk: { writable: true, value: chunk },
      byStart: { writable: true, value: {} },
      byEnd: { writable: true, value: {} },
      filename: { writable: true, value: options.filename },
      indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
      sourcemapLocations: { writable: true, value: new BitSet() },
      storedNames: { writable: true, value: {} },
      indentStr: { writable: true, value: void 0 },
      ignoreList: { writable: true, value: options.ignoreList },
      offset: { writable: true, value: options.offset || 0 }
    });
    this.byStart[0] = chunk;
    this.byEnd[string.length] = chunk;
  }
  addSourcemapLocation(char) {
    this.sourcemapLocations.add(char);
  }
  append(content) {
    if (typeof content !== "string") throw new TypeError("outro content must be a string");
    this.outro += content;
    return this;
  }
  appendLeft(index, content) {
    index = index + this.offset;
    if (typeof content !== "string") throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.appendLeft(content);
    } else {
      this.intro += content;
    }
    return this;
  }
  appendRight(index, content) {
    index = index + this.offset;
    if (typeof content !== "string") throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.appendRight(content);
    } else {
      this.outro += content;
    }
    return this;
  }
  clone() {
    const cloned = new _MagicString(this.original, { filename: this.filename, offset: this.offset });
    let originalChunk = this.firstChunk;
    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
    while (originalChunk) {
      cloned.byStart[clonedChunk.start] = clonedChunk;
      cloned.byEnd[clonedChunk.end] = clonedChunk;
      const nextOriginalChunk = originalChunk.next;
      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
      if (nextClonedChunk) {
        clonedChunk.next = nextClonedChunk;
        nextClonedChunk.previous = clonedChunk;
        clonedChunk = nextClonedChunk;
      }
      originalChunk = nextOriginalChunk;
    }
    cloned.lastChunk = clonedChunk;
    if (this.indentExclusionRanges) {
      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
    }
    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
    cloned.intro = this.intro;
    cloned.outro = this.outro;
    return cloned;
  }
  generateDecodedMap(options) {
    options = options || {};
    const sourceIndex = 0;
    const names = Object.keys(this.storedNames);
    const mappings = new Mappings(options.hires);
    const locate = getLocator(this.original);
    if (this.intro) {
      mappings.advance(this.intro);
    }
    this.firstChunk.eachNext((chunk) => {
      const loc = locate(chunk.start);
      if (chunk.intro.length) mappings.advance(chunk.intro);
      if (chunk.edited) {
        mappings.addEdit(
          sourceIndex,
          chunk.content,
          loc,
          chunk.storeName ? names.indexOf(chunk.original) : -1
        );
      } else {
        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
      }
      if (chunk.outro.length) mappings.advance(chunk.outro);
    });
    if (this.outro) {
      mappings.advance(this.outro);
    }
    return {
      file: options.file ? options.file.split(/[/\\]/).pop() : void 0,
      sources: [
        options.source ? getRelativePath(options.file || "", options.source) : options.file || ""
      ],
      sourcesContent: options.includeContent ? [this.original] : void 0,
      names,
      mappings: mappings.raw,
      x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0
    };
  }
  generateMap(options) {
    return new SourceMap(this.generateDecodedMap(options));
  }
  _ensureindentStr() {
    if (this.indentStr === void 0) {
      this.indentStr = guessIndent(this.original);
    }
  }
  _getRawIndentString() {
    this._ensureindentStr();
    return this.indentStr;
  }
  getIndentString() {
    this._ensureindentStr();
    return this.indentStr === null ? "	" : this.indentStr;
  }
  indent(indentStr, options) {
    const pattern = /^[^\r\n]/gm;
    if (isObject2(indentStr)) {
      options = indentStr;
      indentStr = void 0;
    }
    if (indentStr === void 0) {
      this._ensureindentStr();
      indentStr = this.indentStr || "	";
    }
    if (indentStr === "") return this;
    options = options || {};
    const isExcluded = {};
    if (options.exclude) {
      const exclusions = typeof options.exclude[0] === "number" ? [options.exclude] : options.exclude;
      exclusions.forEach((exclusion) => {
        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
          isExcluded[i] = true;
        }
      });
    }
    let shouldIndentNextCharacter = options.indentStart !== false;
    const replacer = (match) => {
      if (shouldIndentNextCharacter) return `${indentStr}${match}`;
      shouldIndentNextCharacter = true;
      return match;
    };
    this.intro = this.intro.replace(pattern, replacer);
    let charIndex = 0;
    let chunk = this.firstChunk;
    while (chunk) {
      const end = chunk.end;
      if (chunk.edited) {
        if (!isExcluded[charIndex]) {
          chunk.content = chunk.content.replace(pattern, replacer);
          if (chunk.content.length) {
            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
          }
        }
      } else {
        charIndex = chunk.start;
        while (charIndex < end) {
          if (!isExcluded[charIndex]) {
            const char = this.original[charIndex];
            if (char === "\n") {
              shouldIndentNextCharacter = true;
            } else if (char !== "\r" && shouldIndentNextCharacter) {
              shouldIndentNextCharacter = false;
              if (charIndex === chunk.start) {
                chunk.prependRight(indentStr);
              } else {
                this._splitChunk(chunk, charIndex);
                chunk = chunk.next;
                chunk.prependRight(indentStr);
              }
            }
          }
          charIndex += 1;
        }
      }
      charIndex = chunk.end;
      chunk = chunk.next;
    }
    this.outro = this.outro.replace(pattern, replacer);
    return this;
  }
  insert() {
    throw new Error(
      "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
    );
  }
  insertLeft(index, content) {
    if (!warned2.insertLeft) {
      console.warn(
        "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
      );
      warned2.insertLeft = true;
    }
    return this.appendLeft(index, content);
  }
  insertRight(index, content) {
    if (!warned2.insertRight) {
      console.warn(
        "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
      );
      warned2.insertRight = true;
    }
    return this.prependRight(index, content);
  }
  move(start, end, index) {
    start = start + this.offset;
    end = end + this.offset;
    index = index + this.offset;
    if (index >= start && index <= end) throw new Error("Cannot move a selection inside itself");
    this._split(start);
    this._split(end);
    this._split(index);
    const first = this.byStart[start];
    const last = this.byEnd[end];
    const oldLeft = first.previous;
    const oldRight = last.next;
    const newRight = this.byStart[index];
    if (!newRight && last === this.lastChunk) return this;
    const newLeft = newRight ? newRight.previous : this.lastChunk;
    if (oldLeft) oldLeft.next = oldRight;
    if (oldRight) oldRight.previous = oldLeft;
    if (newLeft) newLeft.next = first;
    if (newRight) newRight.previous = last;
    if (!first.previous) this.firstChunk = last.next;
    if (!last.next) {
      this.lastChunk = first.previous;
      this.lastChunk.next = null;
    }
    first.previous = newLeft;
    last.next = newRight || null;
    if (!newLeft) this.firstChunk = first;
    if (!newRight) this.lastChunk = last;
    return this;
  }
  overwrite(start, end, content, options) {
    options = options || {};
    return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });
  }
  update(start, end, content, options) {
    start = start + this.offset;
    end = end + this.offset;
    if (typeof content !== "string") throw new TypeError("replacement content must be a string");
    if (this.original.length !== 0) {
      while (start < 0) start += this.original.length;
      while (end < 0) end += this.original.length;
    }
    if (end > this.original.length) throw new Error("end is out of bounds");
    if (start === end)
      throw new Error(
        "Cannot overwrite a zero-length range  use appendLeft or prependRight instead"
      );
    this._split(start);
    this._split(end);
    if (options === true) {
      if (!warned2.storeName) {
        console.warn(
          "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
        );
        warned2.storeName = true;
      }
      options = { storeName: true };
    }
    const storeName = options !== void 0 ? options.storeName : false;
    const overwrite = options !== void 0 ? options.overwrite : false;
    if (storeName) {
      const original = this.original.slice(start, end);
      Object.defineProperty(this.storedNames, original, {
        writable: true,
        value: true,
        enumerable: true
      });
    }
    const first = this.byStart[start];
    const last = this.byEnd[end];
    if (first) {
      let chunk = first;
      while (chunk !== last) {
        if (chunk.next !== this.byStart[chunk.end]) {
          throw new Error("Cannot overwrite across a split point");
        }
        chunk = chunk.next;
        chunk.edit("", false);
      }
      first.edit(content, storeName, !overwrite);
    } else {
      const newChunk = new Chunk(start, end, "").edit(content, storeName);
      last.next = newChunk;
      newChunk.previous = last;
    }
    return this;
  }
  prepend(content) {
    if (typeof content !== "string") throw new TypeError("outro content must be a string");
    this.intro = content + this.intro;
    return this;
  }
  prependLeft(index, content) {
    index = index + this.offset;
    if (typeof content !== "string") throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.prependLeft(content);
    } else {
      this.intro = content + this.intro;
    }
    return this;
  }
  prependRight(index, content) {
    index = index + this.offset;
    if (typeof content !== "string") throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.prependRight(content);
    } else {
      this.outro = content + this.outro;
    }
    return this;
  }
  remove(start, end) {
    start = start + this.offset;
    end = end + this.offset;
    if (this.original.length !== 0) {
      while (start < 0) start += this.original.length;
      while (end < 0) end += this.original.length;
    }
    if (start === end) return this;
    if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
    if (start > end) throw new Error("end must be greater than start");
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.intro = "";
      chunk.outro = "";
      chunk.edit("");
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  reset(start, end) {
    start = start + this.offset;
    end = end + this.offset;
    if (this.original.length !== 0) {
      while (start < 0) start += this.original.length;
      while (end < 0) end += this.original.length;
    }
    if (start === end) return this;
    if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
    if (start > end) throw new Error("end must be greater than start");
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.reset();
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  lastChar() {
    if (this.outro.length) return this.outro[this.outro.length - 1];
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
      if (chunk.content.length) return chunk.content[chunk.content.length - 1];
      if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
    } while (chunk = chunk.previous);
    if (this.intro.length) return this.intro[this.intro.length - 1];
    return "";
  }
  lastLine() {
    let lineIndex = this.outro.lastIndexOf(n);
    if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
    let lineStr = this.outro;
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length > 0) {
        lineIndex = chunk.outro.lastIndexOf(n);
        if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.outro + lineStr;
      }
      if (chunk.content.length > 0) {
        lineIndex = chunk.content.lastIndexOf(n);
        if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.content + lineStr;
      }
      if (chunk.intro.length > 0) {
        lineIndex = chunk.intro.lastIndexOf(n);
        if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.intro + lineStr;
      }
    } while (chunk = chunk.previous);
    lineIndex = this.intro.lastIndexOf(n);
    if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
    return this.intro + lineStr;
  }
  slice(start = 0, end = this.original.length - this.offset) {
    start = start + this.offset;
    end = end + this.offset;
    if (this.original.length !== 0) {
      while (start < 0) start += this.original.length;
      while (end < 0) end += this.original.length;
    }
    let result = "";
    let chunk = this.firstChunk;
    while (chunk && (chunk.start > start || chunk.end <= start)) {
      if (chunk.start < end && chunk.end >= end) {
        return result;
      }
      chunk = chunk.next;
    }
    if (chunk && chunk.edited && chunk.start !== start)
      throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
    const startChunk = chunk;
    while (chunk) {
      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
        result += chunk.intro;
      }
      const containsEnd = chunk.start < end && chunk.end >= end;
      if (containsEnd && chunk.edited && chunk.end !== end)
        throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
      const sliceStart = startChunk === chunk ? start - chunk.start : 0;
      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
      result += chunk.content.slice(sliceStart, sliceEnd);
      if (chunk.outro && (!containsEnd || chunk.end === end)) {
        result += chunk.outro;
      }
      if (containsEnd) {
        break;
      }
      chunk = chunk.next;
    }
    return result;
  }
  // TODO deprecate this? not really very useful
  snip(start, end) {
    const clone3 = this.clone();
    clone3.remove(0, start);
    clone3.remove(end, clone3.original.length);
    return clone3;
  }
  _split(index) {
    if (this.byStart[index] || this.byEnd[index]) return;
    let chunk = this.lastSearchedChunk;
    let previousChunk = chunk;
    const searchForward = index > chunk.end;
    while (chunk) {
      if (chunk.contains(index)) return this._splitChunk(chunk, index);
      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
      if (chunk === previousChunk) return;
      previousChunk = chunk;
    }
  }
  _splitChunk(chunk, index) {
    if (chunk.edited && chunk.content.length) {
      const loc = getLocator(this.original)(index);
      throw new Error(
        `Cannot split a chunk that has already been edited (${loc.line}:${loc.column}  "${chunk.original}")`
      );
    }
    const newChunk = chunk.split(index);
    this.byEnd[index] = chunk;
    this.byStart[index] = newChunk;
    this.byEnd[newChunk.end] = newChunk;
    if (chunk === this.lastChunk) this.lastChunk = newChunk;
    this.lastSearchedChunk = chunk;
    return true;
  }
  toString() {
    let str = this.intro;
    let chunk = this.firstChunk;
    while (chunk) {
      str += chunk.toString();
      chunk = chunk.next;
    }
    return str + this.outro;
  }
  isEmpty() {
    let chunk = this.firstChunk;
    do {
      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())
        return false;
    } while (chunk = chunk.next);
    return true;
  }
  length() {
    let chunk = this.firstChunk;
    let length2 = 0;
    do {
      length2 += chunk.intro.length + chunk.content.length + chunk.outro.length;
    } while (chunk = chunk.next);
    return length2;
  }
  trimLines() {
    return this.trim("[\\r\\n]");
  }
  trim(charType) {
    return this.trimStart(charType).trimEnd(charType);
  }
  trimEndAborted(charType) {
    const rx = new RegExp((charType || "\\s") + "+$");
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length) return true;
    let chunk = this.lastChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimEnd(rx);
      if (chunk.end !== end) {
        if (this.lastChunk === chunk) {
          this.lastChunk = chunk.next;
        }
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted) return true;
      chunk = chunk.previous;
    } while (chunk);
    return false;
  }
  trimEnd(charType) {
    this.trimEndAborted(charType);
    return this;
  }
  trimStartAborted(charType) {
    const rx = new RegExp("^" + (charType || "\\s") + "+");
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length) return true;
    let chunk = this.firstChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimStart(rx);
      if (chunk.end !== end) {
        if (chunk === this.lastChunk) this.lastChunk = chunk.next;
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted) return true;
      chunk = chunk.next;
    } while (chunk);
    return false;
  }
  trimStart(charType) {
    this.trimStartAborted(charType);
    return this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(searchValue, replacement) {
    function getReplacement(match, str) {
      if (typeof replacement === "string") {
        return replacement.replace(/\$(\$|&|\d+)/g, (_, i) => {
          if (i === "$") return "$";
          if (i === "&") return match[0];
          const num = +i;
          if (num < match.length) return match[+i];
          return `$${i}`;
        });
      } else {
        return replacement(...match, match.index, str, match.groups);
      }
    }
    function matchAll(re, str) {
      let match;
      const matches = [];
      while (match = re.exec(str)) {
        matches.push(match);
      }
      return matches;
    }
    if (searchValue.global) {
      const matches = matchAll(searchValue, this.original);
      matches.forEach((match) => {
        if (match.index != null) {
          const replacement2 = getReplacement(match, this.original);
          if (replacement2 !== match[0]) {
            this.overwrite(match.index, match.index + match[0].length, replacement2);
          }
        }
      });
    } else {
      const match = this.original.match(searchValue);
      if (match && match.index != null) {
        const replacement2 = getReplacement(match, this.original);
        if (replacement2 !== match[0]) {
          this.overwrite(match.index, match.index + match[0].length, replacement2);
        }
      }
    }
    return this;
  }
  _replaceString(string, replacement) {
    const { original } = this;
    const index = original.indexOf(string);
    if (index !== -1) {
      if (typeof replacement === "function") {
        replacement = replacement(string, index, original);
      }
      if (string !== replacement) {
        this.overwrite(index, index + string.length, replacement);
      }
    }
    return this;
  }
  replace(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceString(searchValue, replacement);
    }
    return this._replaceRegexp(searchValue, replacement);
  }
  _replaceAllString(string, replacement) {
    const { original } = this;
    const stringLength = string.length;
    for (let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)) {
      const previous = original.slice(index, index + stringLength);
      let _replacement = replacement;
      if (typeof replacement === "function") {
        _replacement = replacement(previous, index, original);
      }
      if (previous !== _replacement) this.overwrite(index, index + stringLength, _replacement);
    }
    return this;
  }
  replaceAll(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceAllString(searchValue, replacement);
    }
    if (!searchValue.global) {
      throw new TypeError(
        "MagicString.prototype.replaceAll called with a non-global RegExp argument"
      );
    }
    return this._replaceRegexp(searchValue, replacement);
  }
};

// node_modules/@unocss/rule-utils/dist/index.mjs
function getBracket(str, open, close) {
  if (str === "") return;
  const l = str.length;
  let parenthesis = 0;
  let opened = false;
  let openAt = 0;
  for (let i = 0; i < l; i++) switch (str[i]) {
    case open:
      if (!opened) {
        opened = true;
        openAt = i;
      }
      parenthesis++;
      break;
    case close:
      --parenthesis;
      if (parenthesis < 0) return;
      if (parenthesis === 0) return [
        str.slice(openAt, i + 1),
        str.slice(i + 1),
        str.slice(0, openAt)
      ];
      break;
  }
}
function getStringComponent(str, open, close, separators) {
  if (str === "") return;
  if (isString(separators)) separators = [separators];
  if (separators.length === 0) return;
  const l = str.length;
  let parenthesis = 0;
  for (let i = 0; i < l; i++) switch (str[i]) {
    case open:
      parenthesis++;
      break;
    case close:
      if (--parenthesis < 0) return;
      break;
    default:
      for (const separator of separators) {
        const separatorLength = separator.length;
        if (separatorLength && separator === str.slice(i, i + separatorLength) && parenthesis === 0) {
          if (i === 0 || i === l - separatorLength) return;
          return [str.slice(0, i), str.slice(i + separatorLength)];
        }
      }
  }
  return [str, ""];
}
function getStringComponents(str, separators, limit, open = "(", close = ")") {
  limit = limit ?? 10;
  const components = [];
  let i = 0;
  while (str !== "") {
    if (++i > limit) return;
    const componentPair = getStringComponent(str, open, close, separators);
    if (!componentPair) return;
    const [component, rest] = componentPair;
    components.push(component);
    str = rest;
  }
  if (components.length > 0) return components;
}
var cssColorFunctions = [
  "hsl",
  "hsla",
  "hwb",
  "lab",
  "lch",
  "oklab",
  "oklch",
  "rgb",
  "rgba"
];
var rectangularColorSpace = [
  "srgb",
  "srgb-linear",
  "display-p3",
  "a98-rgb",
  "prophoto-rgb",
  "rec2020",
  "lab",
  "oklab",
  "xyz",
  "xyz-d50",
  "xyz-d65"
];
var polarColorSpace = [
  "hsl",
  "hwb",
  "lch",
  "oklch"
];
var hueInterpolationMethods = [
  "shorter",
  "longer",
  "increasing",
  "decreasing"
];
var alphaPlaceholders = ["%alpha", "<alpha-value>"];
var alphaPlaceholdersRE = new RegExp(alphaPlaceholders.map((v) => escapeRegExp(v)).join("|"), "g");
function isInterpolatedMethod(type) {
  if (!type) return false;
  return rectangularColorSpace.some((space) => type.includes(space)) || polarColorSpace.some((space) => type.includes(space)) || hueInterpolationMethods.some((method) => type.includes(method));
}
function hex2rgba(hex = "") {
  const color = parseHexColor(hex);
  if (color != null) {
    const { components, alpha } = color;
    if (alpha == null) return components;
    return [...components, alpha];
  }
}
function parseCssColor(str = "") {
  const color = parseColor(str);
  if (color == null || color === false) return;
  const { type: casedType, components, alpha } = color;
  const type = casedType.toLowerCase();
  if (components.length === 0) return;
  if (cssColorFunctions.includes(type) && ![1, 3].includes(components.length)) return;
  return {
    type,
    components: components.map((c) => typeof c === "string" ? c.trim() : c),
    alpha: typeof alpha === "string" ? alpha.trim() : alpha
  };
}
function colorOpacityToString(color) {
  const alpha = color.alpha ?? 1;
  return typeof alpha === "string" && alphaPlaceholders.includes(alpha) ? 1 : alpha;
}
function colorToString2(color, alphaOverride) {
  if (typeof color === "string") return color.replace(alphaPlaceholdersRE, `${alphaOverride ?? 1}`);
  const { components } = color;
  let { alpha, type } = color;
  alpha = alphaOverride ?? alpha;
  type = type.toLowerCase();
  if (["hsla", "rgba"].includes(type)) return `${type}(${components.join(", ")}${alpha == null ? "" : `, ${alpha}`})`;
  alpha = alpha == null ? "" : ` / ${alpha}`;
  if (cssColorFunctions.includes(type)) return `${type}(${components.join(" ")}${alpha})`;
  return `color(${type} ${components.join(" ")}${alpha})`;
}
function parseColor(str) {
  if (!str) return;
  let color = parseHexColor(str);
  if (color != null) return color;
  color = cssColorKeyword(str);
  if (color != null) return color;
  color = parseCssCommaColorFunction(str);
  if (color != null) return color;
  color = parseCssSpaceColorFunction(str);
  if (color != null) return color;
  color = parseCssColorFunction(str);
  if (color != null) return color;
}
function parseHexColor(str) {
  const [, body] = str.match(/^#([\da-f]+)$/i) || [];
  if (!body) return;
  switch (body.length) {
    case 3:
    case 4: {
      const digits = Array.from(body, (s) => Number.parseInt(s, 16)).map((n2) => n2 << 4 | n2);
      return {
        type: "rgb",
        components: digits.slice(0, 3),
        alpha: body.length === 3 ? void 0 : Math.round(digits[3] / 255 * 100) / 100
      };
    }
    case 6:
    case 8: {
      const value = Number.parseInt(body, 16);
      return {
        type: "rgb",
        components: body.length === 6 ? [
          value >> 16 & 255,
          value >> 8 & 255,
          value & 255
        ] : [
          value >> 24 & 255,
          value >> 16 & 255,
          value >> 8 & 255
        ],
        alpha: body.length === 6 ? void 0 : Math.round((value & 255) / 255 * 100) / 100
      };
    }
  }
}
function cssColorKeyword(str) {
  const color = { rebeccapurple: [
    102,
    51,
    153,
    1
  ] }[str];
  if (color != null) return {
    type: "rgb",
    components: color.slice(0, 3),
    alpha: color[3]
  };
}
function parseCssCommaColorFunction(color) {
  const match = color.match(/^(rgb|rgba|hsl|hsla)\((.+)\)$/i);
  if (!match) return;
  const [, type, componentString] = match;
  const components = getStringComponents(componentString, ",", 5);
  if (components) {
    if ([3, 4].includes(components.length)) return {
      type,
      components: components.slice(0, 3),
      alpha: components[3]
    };
    else if (components.length !== 1) return false;
  }
}
var cssColorFunctionsRe = new RegExp(`^(${cssColorFunctions.join("|")})\\((.+)\\)$`, "i");
function parseCssSpaceColorFunction(color) {
  const match = color.match(cssColorFunctionsRe);
  if (!match) return;
  const [, fn, componentString] = match;
  const parsed = parseCssSpaceColorValues(`${fn} ${componentString}`);
  if (parsed) {
    const { alpha, components: [type, ...components] } = parsed;
    return {
      type,
      components,
      alpha
    };
  }
}
function parseCssColorFunction(color) {
  const match = color.match(/^color\((.+)\)$/);
  if (!match) return;
  const parsed = parseCssSpaceColorValues(match[1]);
  if (parsed) {
    const { alpha, components: [type, ...components] } = parsed;
    return {
      type,
      components,
      alpha
    };
  }
}
function parseCssSpaceColorValues(componentString) {
  const components = getStringComponents(componentString, " ");
  if (!components) return;
  let totalComponents = components.length;
  if (components[totalComponents - 2] === "/") return {
    components: components.slice(0, totalComponents - 2),
    alpha: components[totalComponents - 1]
  };
  if (components[totalComponents - 2] != null && (components[totalComponents - 2].endsWith("/") || components[totalComponents - 1].startsWith("/"))) {
    const removed = components.splice(totalComponents - 2);
    components.push(removed.join(" "));
    --totalComponents;
  }
  const withAlpha = getStringComponents(components[totalComponents - 1], "/", 2);
  if (!withAlpha) return;
  if (withAlpha.length === 1 || withAlpha[withAlpha.length - 1] === "") return { components };
  const alpha = withAlpha.pop();
  components[totalComponents - 1] = withAlpha.join("/");
  return {
    components,
    alpha
  };
}
var themeFnRE = /theme\(\s*(['"])?(.*?)\1?\s*\)/g;
function hasThemeFn(str) {
  return str.includes("theme(") && str.includes(")");
}
function transformThemeFn(code2, theme4, throwOnMissing = true) {
  const matches = Array.from(code2.toString().matchAll(themeFnRE));
  if (!matches.length) return code2;
  const s = new MagicString(code2);
  for (const match of matches) {
    const rawArg = match[2];
    if (!rawArg) throw new Error("theme() expect exact one argument, but got 0");
    const value = transformThemeString(rawArg, theme4, throwOnMissing);
    if (value) s.overwrite(match.index, match.index + match[0].length, value);
  }
  return s.toString();
}
function transformThemeString(code2, theme4, throwOnMissing = true) {
  const [rawKey, alpha] = code2.split("/");
  let value = rawKey.trim().split(".").reduce((t, k) => t === null || t === void 0 ? void 0 : t[k], theme4);
  if (typeof value === "object") value = value.DEFAULT;
  if (typeof value === "string") {
    if (alpha) {
      const color = parseCssColor(value);
      if (color) value = colorToString2(color, alpha);
    }
    return value;
  } else if (throwOnMissing) throw new Error(`theme of "${code2}" did not found`);
}
function calcMaxWidthBySize(size) {
  var _size$match;
  const value = ((_size$match = size.match(/^-?\d+\.?\d*/)) === null || _size$match === void 0 ? void 0 : _size$match[0]) || "";
  const unit = size.slice(value.length);
  if (unit === "px") {
    const maxWidth2 = Number.parseFloat(value) - 0.1;
    return Number.isNaN(maxWidth2) ? size : `${maxWidth2}${unit}`;
  }
  return `calc(${size} - 0.1px)`;
}
function createValueHandler(handlers) {
  const handler3 = function(str, theme4) {
    var _this$__options;
    const s = ((_this$__options = this.__options) === null || _this$__options === void 0 ? void 0 : _this$__options.sequence) || [];
    this.__options.sequence = [];
    for (const n2 of s) {
      const res = handlers[n2](str, theme4);
      if (res != null) return res;
    }
  };
  function addProcessor(that, name50) {
    if (!that.__options) that.__options = { sequence: [] };
    that.__options.sequence.push(name50);
    return that;
  }
  for (const name50 of Object.keys(handlers)) Object.defineProperty(handler3, name50, {
    enumerable: true,
    configurable: true,
    get() {
      return addProcessor(this, name50);
    }
  });
  return handler3;
}
var iconFnRE = /icon\(\s*(['"])?(.*?)\1?\s*\)/g;
function hasIconFn(str) {
  return str.includes("icon(") && str.includes(")");
}
var PseudoPlaceholder = "__pseudo_placeholder__";
var PseudoClasses = Object.fromEntries([
  ["first-letter", "::first-letter"],
  ["first-line", "::first-line"],
  "any-link",
  "link",
  "visited",
  "target",
  ["open", "[open]"],
  "default",
  "checked",
  "indeterminate",
  "placeholder-shown",
  "autofill",
  "optional",
  "required",
  "valid",
  "invalid",
  "user-valid",
  "user-invalid",
  "in-range",
  "out-of-range",
  "read-only",
  "read-write",
  "empty",
  "focus-within",
  "hover",
  "focus",
  "focus-visible",
  "active",
  "enabled",
  "disabled",
  "popover-open",
  "root",
  "empty",
  ["even-of-type", ":nth-of-type(even)"],
  ["even", ":nth-child(even)"],
  ["odd-of-type", ":nth-of-type(odd)"],
  ["odd", ":nth-child(odd)"],
  ["nth", `:nth-child(${PseudoPlaceholder})`],
  ["nth-last", `:nth-last-child(${PseudoPlaceholder})`],
  ["nth-last-of-type", `:nth-last-of-type(${PseudoPlaceholder})`],
  ["nth-of-type", `:nth-of-type(${PseudoPlaceholder})`],
  "first-of-type",
  ["first", ":first-child"],
  "last-of-type",
  ["last", ":last-child"],
  "only-child",
  "only-of-type",
  ["backdrop-element", "::backdrop"],
  ["placeholder", "::placeholder"],
  ["before", "::before"],
  ["after", "::after"],
  ["file", "::file-selector-button"]
].map((key) => Array.isArray(key) ? key : [key, `:${key}`]));
var PseudoClassesKeys = Object.keys(PseudoClasses);
var PseudoClassesColon = Object.fromEntries([["backdrop", "::backdrop"]].map((key) => Array.isArray(key) ? key : [key, `:${key}`]));
var PseudoClassesColonKeys = Object.keys(PseudoClassesColon);
var PseudoClassFunctions = [
  "not",
  "is",
  "where",
  "has"
];
var PseudoClassesMulti = Object.fromEntries([["selection", ["::selection", " *::selection"]], ["marker", ["::marker", " *::marker"]]]);
var PseudoClassesStr = Object.entries(PseudoClasses).filter(([, pseudo]) => !pseudo.startsWith("::")).map(([key]) => key).sort((a, b) => b.length - a.length).join("|");
var PseudoClassesColonStr = Object.entries(PseudoClassesColon).filter(([, pseudo]) => !pseudo.startsWith("::")).map(([key]) => key).sort((a, b) => b.length - a.length).join("|");
var PseudoClassFunctionsStr = PseudoClassFunctions.join("|");
var PseudoClassesMultiStr = Object.keys(PseudoClassesMulti).sort((a, b) => b.length - a.length).join("|");
var excludedPseudo = [
  "::-webkit-resizer",
  "::-webkit-scrollbar",
  "::-webkit-scrollbar-button",
  "::-webkit-scrollbar-corner",
  "::-webkit-scrollbar-thumb",
  "::-webkit-scrollbar-track",
  "::-webkit-scrollbar-track-piece",
  "::file-selector-button"
];
var PseudoClassesAndElementsStr = Object.entries(PseudoClasses).map(([key]) => key).sort((a, b) => b.length - a.length).join("|");
var PseudoClassesAndElementsColonStr = Object.entries(PseudoClassesColon).map(([key]) => key).sort((a, b) => b.length - a.length).join("|");
function createTaggedPseudoClassMatcher(tag, parent, combinator, utils) {
  const { h: h3, variantGetBracket: variantGetBracket$1 } = utils;
  const rawRE = new RegExp(`^(${escapeRegExp(parent)}:)(\\S+)${escapeRegExp(combinator)}\\1`);
  let splitRE;
  let pseudoRE;
  let pseudoColonRE;
  let pseudoVarRE;
  const matchBracket = (input) => {
    var _rest$split;
    const body = variantGetBracket$1(`${tag}-`, input, []);
    if (!body) return;
    const [match, rest] = body;
    const bracketValue = h3.bracket(match);
    if (bracketValue == null) return;
    const label = ((_rest$split = rest.split(splitRE, 1)) === null || _rest$split === void 0 ? void 0 : _rest$split[0]) ?? "";
    const prefix = `${parent}${escapeSelector(label)}`;
    return [
      label,
      input.slice(input.length - (rest.length - label.length - 1)),
      bracketValue.includes("&") ? bracketValue.replace(/&/g, prefix) : `${prefix}${bracketValue}`
    ];
  };
  const matchPseudo = (input) => {
    const match = input.match(pseudoRE) || input.match(pseudoColonRE);
    if (!match) return;
    const [original, fn, pseudoKey] = match;
    const label = match[3] ?? "";
    let pseudo = PseudoClasses[pseudoKey] || PseudoClassesColon[pseudoKey] || `:${pseudoKey}`;
    if (fn) pseudo = `:${fn}(${pseudo})`;
    return [
      label,
      input.slice(original.length),
      `${parent}${escapeSelector(label)}${pseudo}`,
      pseudoKey
    ];
  };
  const matchPseudoVar = (input) => {
    const match = input.match(pseudoVarRE);
    if (!match) return;
    const [original, fn, pseudoValue] = match;
    const label = match[3] ?? "";
    const pseudo = `:${fn}(${pseudoValue})`;
    return [
      label,
      input.slice(original.length),
      `${parent}${escapeSelector(label)}${pseudo}`
    ];
  };
  return {
    name: `pseudo:${tag}`,
    match(input, ctx) {
      if (!(splitRE && pseudoRE && pseudoColonRE)) {
        splitRE = new RegExp(`(?:${ctx.generator.config.separators.join("|")})`);
        pseudoRE = new RegExp(`^${tag}-(?:(?:(${PseudoClassFunctionsStr})-)?(${PseudoClassesStr}))(?:(/[\\w-]+))?(?:${ctx.generator.config.separators.join("|")})`);
        pseudoColonRE = new RegExp(`^${tag}-(?:(?:(${PseudoClassFunctionsStr})-)?(${PseudoClassesColonStr}))(?:(/[\\w-]+))?(?:${ctx.generator.config.separators.filter((x) => x !== "-").join("|")})`);
        pseudoVarRE = new RegExp(`^${tag}-(?:(${PseudoClassFunctionsStr})-)?\\[(.+)\\](?:(/[\\w-]+))?(?:${ctx.generator.config.separators.filter((x) => x !== "-").join("|")})`);
      }
      if (!input.startsWith(tag)) return;
      const result = matchBracket(input) || matchPseudo(input) || matchPseudoVar(input);
      if (!result) return;
      const [_label, matcher, prefix, pseudoName = ""] = result;
      return {
        matcher,
        handle: (input$1, next) => next({
          ...input$1,
          prefix: `${prefix}${combinator}${input$1.prefix}`.replace(rawRE, "$1$2:"),
          sort: PseudoClassesKeys.indexOf(pseudoName) ?? PseudoClassesColonKeys.indexOf(pseudoName)
        })
      };
    },
    multiPass: true
  };
}
function createPseudoClassesAndElements(utils) {
  const { h: h3 } = utils;
  let PseudoClassesAndElementsRE;
  let PseudoClassesAndElementsColonRE;
  let PseudoClassesMultiRE;
  return [{
    name: "pseudo",
    match(input, ctx) {
      if (!(PseudoClassesAndElementsRE && PseudoClassesAndElementsColonRE)) {
        PseudoClassesAndElementsRE = new RegExp(`^(${PseudoClassesAndElementsStr})(?:-(\\d+|\\[(\\w|[+-.])+\\]))?(?:${ctx.generator.config.separators.join("|")})`);
        PseudoClassesAndElementsColonRE = new RegExp(`^(${PseudoClassesAndElementsColonStr})(?:${ctx.generator.config.separators.filter((x) => x !== "-").join("|")})`);
      }
      const match = input.match(PseudoClassesAndElementsRE) || input.match(PseudoClassesAndElementsColonRE);
      if (match) {
        let pseudo = PseudoClasses[match[1]] || PseudoClassesColon[match[1]] || `:${match[1]}`;
        if (match[2]) {
          let anPlusB2;
          if (match[2].startsWith("[") && match[2].endsWith("]")) anPlusB2 = h3.bracket(match[2]);
          else anPlusB2 = match[2];
          if (anPlusB2) pseudo = pseudo.replace(PseudoPlaceholder, anPlusB2);
        }
        let index = PseudoClassesKeys.indexOf(match[1]);
        if (index === -1) index = PseudoClassesColonKeys.indexOf(match[1]);
        if (index === -1) index = void 0;
        return {
          matcher: input.slice(match[0].length),
          handle: (input$1, next) => {
            const selectors = pseudo.includes("::") && !excludedPseudo.includes(pseudo) ? { pseudo: `${input$1.pseudo}${pseudo}` } : { selector: `${input$1.selector}${pseudo}` };
            return next({
              ...input$1,
              ...selectors,
              sort: index,
              noMerge: true
            });
          }
        };
      }
    },
    multiPass: true,
    autocomplete: `(${PseudoClassesAndElementsStr}|${PseudoClassesAndElementsColonStr}):`
  }, {
    name: "pseudo:multi",
    match(input, ctx) {
      if (!PseudoClassesMultiRE) PseudoClassesMultiRE = new RegExp(`^(${PseudoClassesMultiStr})(?:${ctx.generator.config.separators.join("|")})`);
      const match = input.match(PseudoClassesMultiRE);
      if (match) return PseudoClassesMulti[match[1]].map((pseudo) => {
        return {
          matcher: input.slice(match[0].length),
          handle: (input$1, next) => next({
            ...input$1,
            pseudo: `${input$1.pseudo}${pseudo}`
          })
        };
      });
    },
    multiPass: false,
    autocomplete: `(${PseudoClassesMultiStr}):`
  }];
}
function createPseudoClassFunctions(utils) {
  const { getBracket: getBracket$1, h: h3 } = utils;
  let PseudoClassFunctionsRE;
  let PseudoClassColonFunctionsRE;
  let PseudoClassVarFunctionRE;
  return {
    match(input, ctx) {
      if (!(PseudoClassFunctionsRE && PseudoClassColonFunctionsRE)) {
        PseudoClassFunctionsRE = new RegExp(`^(${PseudoClassFunctionsStr})-(${PseudoClassesStr})(?:${ctx.generator.config.separators.join("|")})`);
        PseudoClassColonFunctionsRE = new RegExp(`^(${PseudoClassFunctionsStr})-(${PseudoClassesColonStr})(?:${ctx.generator.config.separators.filter((x) => x !== "-").join("|")})`);
        PseudoClassVarFunctionRE = new RegExp(`^(${PseudoClassFunctionsStr})-(\\[.+\\])(?:${ctx.generator.config.separators.filter((x) => x !== "-").join("|")})`);
      }
      const match = input.match(PseudoClassFunctionsRE) || input.match(PseudoClassColonFunctionsRE) || input.match(PseudoClassVarFunctionRE);
      if (match) {
        const fn = match[1];
        const pseudo = getBracket$1(match[2], "[", "]") ? h3.bracket(match[2]) : PseudoClasses[match[2]] || PseudoClassesColon[match[2]] || `:${match[2]}`;
        return {
          matcher: input.slice(match[0].length),
          selector: (s) => `${s}:${fn}(${pseudo})`
        };
      }
    },
    multiPass: true,
    autocomplete: `(${PseudoClassFunctionsStr})-(${PseudoClassesStr}|${PseudoClassesColonStr}):`
  };
}
function createTaggedPseudoClasses(options, utils) {
  const attributify = !!(options === null || options === void 0 ? void 0 : options.attributifyPseudo);
  let firstPrefix = (options === null || options === void 0 ? void 0 : options.prefix) ?? "";
  firstPrefix = escapeSelector((Array.isArray(firstPrefix) ? firstPrefix : [firstPrefix]).filter(Boolean)[0] ?? "");
  const tagWithPrefix = (tag, combinator) => createTaggedPseudoClassMatcher(tag, attributify ? `[${firstPrefix}${tag}=""]` : `.${firstPrefix}${tag}`, combinator, utils);
  return [
    tagWithPrefix("group", " "),
    tagWithPrefix("peer", "~"),
    tagWithPrefix("parent", ">"),
    tagWithPrefix("previous", "+")
  ];
}
var PartClassesRE = /(part-\[(.+)\]:)(.+)/;
function createPartClasses() {
  return {
    match(input) {
      const match = input.match(PartClassesRE);
      if (match) {
        const part = `part(${match[2]})`;
        return {
          matcher: input.slice(match[1].length),
          selector: (s) => `${s}::${part}`
        };
      }
    },
    multiPass: true
  };
}
function variantMatcher(name50, handler3, options = {}) {
  let re;
  return {
    name: name50,
    match(input, ctx) {
      if (!re) re = new RegExp(`^${escapeRegExp(name50)}(?:${ctx.generator.config.separators.join("|")})`);
      const match = input.match(re);
      if (match) {
        const matcher = input.slice(match[0].length);
        const handlers = toArray(handler3).map((handler$1) => ({
          matcher,
          handle: (input$1, next) => next({
            ...input$1,
            ...handler$1(input$1)
          }),
          ...options
        }));
        return handlers.length === 1 ? handlers[0] : handlers;
      }
    },
    autocomplete: `${name50}:`
  };
}
function variantParentMatcher(name50, parent) {
  let re;
  return {
    name: name50,
    match(input, ctx) {
      if (!re) re = new RegExp(`^${escapeRegExp(name50)}(?:${ctx.generator.config.separators.join("|")})`);
      const match = input.match(re);
      if (match) return {
        matcher: input.slice(match[0].length),
        handle: (input$1, next) => next({
          ...input$1,
          parent: `${input$1.parent ? `${input$1.parent} $$ ` : ""}${parent}`
        })
      };
    },
    autocomplete: `${name50}:`
  };
}
function variantGetBracket(prefix, matcher, separators) {
  if (matcher.startsWith(`${prefix}[`)) {
    const [match, rest] = getBracket(matcher.slice(prefix.length), "[", "]") ?? [];
    if (match && rest) {
      for (const separator of separators) if (rest.startsWith(separator)) return [
        match,
        rest.slice(separator.length),
        separator
      ];
      return [
        match,
        rest,
        ""
      ];
    }
  }
}
function variantGetParameter(prefix, matcher, separators) {
  for (const p of toArray(prefix)) if (matcher.startsWith(p)) {
    const body = variantGetBracket(p, matcher, separators);
    if (body) {
      const [label = "", rest = body[1]] = variantGetParameter("/", body[1], separators) ?? [];
      return [
        body[0],
        rest,
        label
      ];
    }
    for (const separator of separators.filter((x) => x !== "/")) {
      const pos = matcher.indexOf(separator, p.length);
      if (pos !== -1) {
        const labelPos = matcher.indexOf("/", p.length);
        const unlabelled = labelPos === -1 || pos <= labelPos;
        return [
          matcher.slice(p.length, unlabelled ? pos : labelPos),
          matcher.slice(pos + separator.length),
          unlabelled ? "" : matcher.slice(labelPos + 1, pos)
        ];
      }
    }
  }
}

// node_modules/@unocss/preset-mini/dist/utils-DLpYZ57Q.mjs
var directionMap = {
  "l": ["-left"],
  "r": ["-right"],
  "t": ["-top"],
  "b": ["-bottom"],
  "s": ["-inline-start"],
  "e": ["-inline-end"],
  "x": ["-left", "-right"],
  "y": ["-top", "-bottom"],
  "": [""],
  "bs": ["-block-start"],
  "be": ["-block-end"],
  "is": ["-inline-start"],
  "ie": ["-inline-end"],
  "block": ["-block-start", "-block-end"],
  "inline": ["-inline-start", "-inline-end"]
};
var insetMap = {
  ...directionMap,
  s: ["-inset-inline-start"],
  start: ["-inset-inline-start"],
  e: ["-inset-inline-end"],
  end: ["-inset-inline-end"],
  bs: ["-inset-block-start"],
  be: ["-inset-block-end"],
  is: ["-inset-inline-start"],
  ie: ["-inset-inline-end"],
  block: ["-inset-block-start", "-inset-block-end"],
  inline: ["-inset-inline-start", "-inset-inline-end"]
};
var cornerMap = {
  "l": ["-top-left", "-bottom-left"],
  "r": ["-top-right", "-bottom-right"],
  "t": ["-top-left", "-top-right"],
  "b": ["-bottom-left", "-bottom-right"],
  "tl": ["-top-left"],
  "lt": ["-top-left"],
  "tr": ["-top-right"],
  "rt": ["-top-right"],
  "bl": ["-bottom-left"],
  "lb": ["-bottom-left"],
  "br": ["-bottom-right"],
  "rb": ["-bottom-right"],
  "": [""],
  "bs": ["-start-start", "-start-end"],
  "be": ["-end-start", "-end-end"],
  "s": ["-end-start", "-start-start"],
  "is": ["-end-start", "-start-start"],
  "e": ["-start-end", "-end-end"],
  "ie": ["-start-end", "-end-end"],
  "ss": ["-start-start"],
  "bs-is": ["-start-start"],
  "is-bs": ["-start-start"],
  "se": ["-start-end"],
  "bs-ie": ["-start-end"],
  "ie-bs": ["-start-end"],
  "es": ["-end-start"],
  "be-is": ["-end-start"],
  "is-be": ["-end-start"],
  "ee": ["-end-end"],
  "be-ie": ["-end-end"],
  "ie-be": ["-end-end"]
};
var xyzMap = {
  "x": ["-x"],
  "y": ["-y"],
  "z": ["-z"],
  "": ["-x", "-y"]
};
var xyzArray = [
  "x",
  "y",
  "z"
];
var basePositionMap = [
  "top",
  "top center",
  "top left",
  "top right",
  "bottom",
  "bottom center",
  "bottom left",
  "bottom right",
  "left",
  "left center",
  "left top",
  "left bottom",
  "right",
  "right center",
  "right top",
  "right bottom",
  "center",
  "center top",
  "center bottom",
  "center left",
  "center right",
  "center center"
];
var positionMap = Object.assign({}, ...basePositionMap.map((p) => ({ [p.replace(/ /, "-")]: p })), ...basePositionMap.map((p) => ({ [p.replace(/\b(\w)\w+/g, "$1").replace(/ /, "")]: p })));
var globalKeywords = [
  "inherit",
  "initial",
  "revert",
  "revert-layer",
  "unset"
];
var cssMathFnRE = /^(calc|clamp|min|max)\s*\((.+)\)(.*)/;
var cssVarFnRE = /^(var)\s*\((.+)\)(.*)/;
var numberWithUnitRE = /^(-?\d*(?:\.\d+)?)(px|pt|pc|%|r?(?:em|ex|lh|cap|ch|ic)|(?:[sld]?v|cq)(?:[whib]|min|max)|in|cm|mm|rpx)?$/i;
var numberRE = /^(-?\d*(?:\.\d+)?)$/;
var unitOnlyRE = /^(px|[sld]?v[wh])$/i;
var unitOnlyMap = {
  px: 1,
  vw: 100,
  vh: 100,
  svw: 100,
  svh: 100,
  dvw: 100,
  dvh: 100,
  lvh: 100,
  lvw: 100
};
var bracketTypeRe = /^\[(color|image|length|size|position|quoted|string):/i;
var splitComma = /,(?![^()]*\))/g;
var handlers_exports = __exportAll({
  auto: () => auto,
  bracket: () => bracket,
  bracketOfColor: () => bracketOfColor,
  bracketOfLength: () => bracketOfLength,
  bracketOfPosition: () => bracketOfPosition,
  cssvar: () => cssvar,
  degree: () => degree,
  fraction: () => fraction,
  global: () => global2,
  number: () => number,
  numberWithUnit: () => numberWithUnit,
  percent: () => percent,
  position: () => position,
  properties: () => properties,
  px: () => px,
  rem: () => rem,
  time: () => time
});
var cssProps = [
  "color",
  "border-color",
  "background-color",
  "outline-color",
  "text-decoration-color",
  "flex-grow",
  "flex",
  "flex-shrink",
  "caret-color",
  "font",
  "gap",
  "opacity",
  "visibility",
  "z-index",
  "font-weight",
  "zoom",
  "text-shadow",
  "transform",
  "box-shadow",
  "border",
  "background-position",
  "left",
  "right",
  "top",
  "bottom",
  "object-position",
  "max-height",
  "min-height",
  "max-width",
  "min-width",
  "height",
  "width",
  "border-width",
  "margin",
  "padding",
  "outline-width",
  "outline-offset",
  "font-size",
  "line-height",
  "text-indent",
  "vertical-align",
  "border-spacing",
  "letter-spacing",
  "word-spacing",
  "stroke",
  "filter",
  "backdrop-filter",
  "fill",
  "mask",
  "mask-size",
  "mask-border",
  "clip-path",
  "clip",
  "border-radius"
];
function round(n2) {
  return +n2.toFixed(10);
}
function numberWithUnit(str) {
  const match = str.match(numberWithUnitRE);
  if (!match) return;
  const [, n2, unit] = match;
  const num = Number.parseFloat(n2);
  if (unit && !Number.isNaN(num)) return `${round(num)}${unit}`;
}
function auto(str) {
  if (str === "auto" || str === "a") return "auto";
}
function rem(str) {
  if (!str) return;
  if (unitOnlyRE.test(str)) return `${unitOnlyMap[str]}${str}`;
  const match = str.match(numberWithUnitRE);
  if (!match) return;
  const [, n2, unit] = match;
  const num = Number.parseFloat(n2);
  if (!Number.isNaN(num)) {
    if (num === 0) return "0";
    return unit ? `${round(num)}${unit}` : `${round(num / 4)}rem`;
  }
}
function px(str) {
  if (unitOnlyRE.test(str)) return `${unitOnlyMap[str]}${str}`;
  const match = str.match(numberWithUnitRE);
  if (!match) return;
  const [, n2, unit] = match;
  const num = Number.parseFloat(n2);
  if (!Number.isNaN(num)) return unit ? `${round(num)}${unit}` : `${round(num)}px`;
}
function number(str) {
  if (!numberRE.test(str)) return;
  const num = Number.parseFloat(str);
  if (!Number.isNaN(num)) return round(num);
}
function percent(str) {
  if (str.endsWith("%")) str = str.slice(0, -1);
  if (!numberRE.test(str)) return;
  const num = Number.parseFloat(str);
  if (!Number.isNaN(num)) return `${round(num / 100)}`;
}
function fraction(str) {
  if (!str) return;
  if (str === "full") return "100%";
  const [left, right] = str.split("/");
  const num = Number.parseFloat(left) / Number.parseFloat(right);
  if (!Number.isNaN(num)) {
    if (num === 0) return "0";
    return `${round(num * 100)}%`;
  }
}
function bracketWithType(str, requiredType) {
  if (str && str.startsWith("[") && str.endsWith("]")) {
    let base;
    let hintedType;
    const match = str.match(bracketTypeRe);
    if (!match) base = str.slice(1, -1);
    else {
      if (!requiredType) hintedType = match[1];
      base = str.slice(match[0].length, -1);
    }
    if (!base) return;
    if (base === '=""') return;
    if (base.startsWith("--")) base = `var(${base})`;
    let curly = 0;
    for (const i of base) if (i === "[") curly += 1;
    else if (i === "]") {
      curly -= 1;
      if (curly < 0) return;
    }
    if (curly) return;
    switch (hintedType) {
      case "string":
        return base.replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_");
      case "quoted":
        return base.replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_").replace(/(["\\])/g, "\\$1").replace(/^(.+)$/, '"$1"');
    }
    return base.replace(/(url\(.*?\))/g, (v) => v.replace(/_/g, "\\_")).replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_").replace(/(?:calc|clamp|max|min)\((.*)/g, (match$1) => {
      const vars = [];
      return match$1.replace(/var\((--.+?)[,)]/g, (match$2, g1) => {
        vars.push(g1);
        return match$2.replace(g1, "--un-calc");
      }).replace(/(-?\d*\.?\d(?!-\d.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ").replace(/--un-calc/g, () => vars.shift());
    });
  }
}
function bracket(str) {
  return bracketWithType(str);
}
function bracketOfColor(str) {
  return bracketWithType(str, "color");
}
function bracketOfLength(str) {
  return bracketWithType(str, "length");
}
function bracketOfPosition(str) {
  return bracketWithType(str, "position");
}
function cssvar(str) {
  if (/^\$[^\s'"`;{}]/.test(str)) {
    const [name50, defaultValue] = str.slice(1).split(",");
    return `var(--${escapeSelector(name50)}${defaultValue ? `, ${defaultValue}` : ""})`;
  }
}
function time(str) {
  const match = str.match(/^(-?[0-9.]+)(s|ms)?$/i);
  if (!match) return;
  const [, n2, unit] = match;
  const num = Number.parseFloat(n2);
  if (!Number.isNaN(num)) {
    if (num === 0 && !unit) return "0s";
    return unit ? `${round(num)}${unit}` : `${round(num)}ms`;
  }
}
function degree(str) {
  const match = str.match(/^(-?[0-9.]+)(deg|rad|grad|turn)?$/i);
  if (!match) return;
  const [, n2, unit] = match;
  const num = Number.parseFloat(n2);
  if (!Number.isNaN(num)) {
    if (num === 0) return "0deg";
    return unit ? `${round(num)}${unit}` : `${round(num)}deg`;
  }
}
function global2(str) {
  if (globalKeywords.includes(str)) return str;
}
function properties(str) {
  if (str.split(",").every((prop) => cssProps.includes(prop))) return str;
}
function position(str) {
  if ([
    "top",
    "left",
    "right",
    "bottom",
    "center"
  ].includes(str)) return str;
}
var handler = createValueHandler(handlers_exports);
var h = handler;
var CONTROL_MINI_NO_NEGATIVE = "$$mini-no-negative";
function directionSize(propertyPrefix) {
  return ([_, direction, size], { theme: theme4 }) => {
    var _a, _b;
    const v = ((_a = theme4.spacing) == null ? void 0 : _a[size || "DEFAULT"]) ?? h.bracket.cssvar.global.auto.fraction.rem(size);
    if (v != null) return directionMap[direction].map((i) => [`${propertyPrefix}${i}`, v]);
    else if (size == null ? void 0 : size.startsWith("-")) {
      const v$1 = (_b = theme4.spacing) == null ? void 0 : _b[size.slice(1)];
      if (v$1 != null) return directionMap[direction].map((i) => [`${propertyPrefix}${i}`, `calc(${v$1} * -1)`]);
    }
  };
}
function getThemeColorForKey(theme4, colors3, key = "colors") {
  const obj = theme4[key];
  function deepGet(current, path) {
    if (path.length === 0) return current;
    if (!current || typeof current !== "object") return void 0;
    for (let i = path.length; i > 0; i--) {
      const flatKey = path.slice(0, i).join("-");
      const value = current[flatKey.replace(/(-[a-z])/g, (n2) => n2.slice(1).toUpperCase())] ?? current[flatKey];
      if (value != null) {
        if (i === path.length) return value;
        return deepGet(value, path.slice(i));
      }
    }
  }
  return deepGet(obj, colors3);
}
function getThemeColor(theme4, colors3, key) {
  return getThemeColorForKey(theme4, colors3, key) || getThemeColorForKey(theme4, colors3, "colors");
}
function splitShorthand(body, type) {
  const [front, rest] = getStringComponent(body, "[", "]", ["/", ":"]) ?? [];
  if (front != null) {
    const match = (front.match(bracketTypeRe) ?? [])[1];
    if (match == null || match === type) return [front, rest];
  }
}
function parseColor2(body, theme4, key) {
  const split = splitShorthand(body, "color");
  if (!split) return;
  const [main, opacity3] = split;
  const colors3 = main.replace(/([a-z])(\d)/g, "$1-$2").split(/-/g);
  const [name50] = colors3;
  if (!name50) return;
  let color;
  const bracket$1 = h.bracketOfColor(main);
  const bracketOrMain = bracket$1 || main;
  if (h.numberWithUnit(bracketOrMain)) return;
  if (/^#[\da-f]+$/i.test(bracketOrMain)) color = bracketOrMain;
  else if (/^hex-[\da-fA-F]+$/.test(bracketOrMain)) color = `#${bracketOrMain.slice(4)}`;
  else if (main.startsWith("$")) color = h.cssvar(main);
  color = color || bracket$1;
  if (!color) {
    const colorData = getThemeColor(theme4, [main], key);
    if (typeof colorData === "string") color = colorData;
  }
  let no = "DEFAULT";
  if (!color) {
    let keys = colors3;
    let _no;
    const [scale] = colors3.slice(-1);
    if (/^\d+$/.test(scale)) {
      no = _no = scale;
      keys = colors3.slice(0, -1);
    }
    const colorData = getThemeColor(theme4, keys, key);
    if (typeof colorData === "object") color = colorData[_no ?? no];
    else if (typeof colorData === "string" && !_no) color = colorData;
  }
  return {
    opacity: opacity3,
    name: name50,
    no,
    color,
    cssColor: parseCssColor(color),
    alpha: h.bracket.cssvar.percent(opacity3 ?? "")
  };
}
function colorResolver(property4, varName, key, shouldPass) {
  return ([, body], { theme: theme4, generator }) => {
    const data = parseColor2(body ?? "", theme4, key);
    if (!data) return;
    const { alpha, color, cssColor } = data;
    const rawColorComment = generator.config.envMode === "dev" && color ? ` /* ${color} */` : "";
    const css = {};
    if (cssColor) if (alpha != null) css[property4] = colorToString2(cssColor, alpha) + rawColorComment;
    else {
      const opacityVar = `--un-${varName}-opacity`;
      const result = colorToString2(cssColor, `var(${opacityVar})`);
      if (result.includes(opacityVar)) css[opacityVar] = colorOpacityToString(cssColor);
      css[property4] = result + rawColorComment;
    }
    else if (color) if (alpha != null) css[property4] = colorToString2(color, alpha) + rawColorComment;
    else {
      const opacityVar = `--un-${varName}-opacity`;
      const result = colorToString2(color, `var(${opacityVar})`);
      if (result.includes(opacityVar)) css[opacityVar] = 1;
      css[property4] = result + rawColorComment;
    }
    if ((shouldPass == null ? void 0 : shouldPass(css)) !== false) return css;
  };
}
function colorableShadows(shadows, colorVar) {
  const colored = [];
  shadows = toArray(shadows);
  for (let i = 0; i < shadows.length; i++) {
    const components = getStringComponents(shadows[i], " ", 6);
    if (!components || components.length < 3) return shadows;
    let isInset = false;
    const pos = components.indexOf("inset");
    if (pos !== -1) {
      components.splice(pos, 1);
      isInset = true;
    }
    let colorVarValue = "";
    const lastComp = components.at(-1);
    if (parseCssColor(components.at(0))) {
      const color = parseCssColor(components.shift());
      if (color) colorVarValue = `, ${colorToString2(color)}`;
    } else if (parseCssColor(lastComp)) {
      const color = parseCssColor(components.pop());
      if (color) colorVarValue = `, ${colorToString2(color)}`;
    } else if (lastComp && lastComp.startsWith("var(")) colorVarValue = `, ${components.pop()}`;
    colored.push(`${isInset ? "inset " : ""}${components.join(" ")} var(${colorVar}${colorVarValue})`);
  }
  return colored;
}
function hasParseableColor(color, theme4, key) {
  var _a;
  return color != null && !!((_a = parseColor2(color, theme4, key)) == null ? void 0 : _a.color);
}
var reLetters = /[a-z]+/gi;
var resolvedBreakpoints = /* @__PURE__ */ new WeakMap();
function resolveBreakpoints({ theme: theme4, generator }, key = "breakpoints") {
  var _a, _b;
  const breakpoints2 = ((_b = (_a = generator == null ? void 0 : generator.userConfig) == null ? void 0 : _a.theme) == null ? void 0 : _b[key]) || theme4[key];
  if (!breakpoints2) return void 0;
  if (resolvedBreakpoints.has(theme4)) return resolvedBreakpoints.get(theme4);
  const resolved = Object.entries(breakpoints2).sort((a, b) => Number.parseInt(a[1].replace(reLetters, "")) - Number.parseInt(b[1].replace(reLetters, ""))).map(([point, size]) => ({
    point,
    size
  }));
  resolvedBreakpoints.set(theme4, resolved);
  return resolved;
}
function resolveVerticalBreakpoints(context) {
  return resolveBreakpoints(context, "verticalBreakpoints");
}
function makeGlobalStaticRules(prefix, property4) {
  return globalKeywords.map((keyword2) => [`${prefix}-${keyword2}`, { [property4 ?? prefix]: keyword2 }]);
}
function isCSSMathFn(value) {
  return value != null && cssMathFnRE.test(value);
}
function isSize(str) {
  if (str[0] === "[" && str.slice(-1) === "]") str = str.slice(1, -1);
  return cssMathFnRE.test(str) || numberWithUnitRE.test(str);
}
function transformXYZ(d, v, name50) {
  const values = v.split(splitComma);
  if (d || !d && values.length === 1) return xyzMap[d].map((i) => [`--un-${name50}${i}`, v]);
  return values.map((v$1, i) => [`--un-${name50}-${xyzArray[i]}`, v$1]);
}
var _utils_exports = __exportAll({
  CONTROL_MINI_NO_NEGATIVE: () => CONTROL_MINI_NO_NEGATIVE,
  colorResolver: () => colorResolver,
  colorableShadows: () => colorableShadows,
  cornerMap: () => cornerMap,
  cssMathFnRE: () => cssMathFnRE,
  cssVarFnRE: () => cssVarFnRE,
  directionMap: () => directionMap,
  directionSize: () => directionSize,
  globalKeywords: () => globalKeywords,
  h: () => h,
  handler: () => handler,
  hasParseableColor: () => hasParseableColor,
  insetMap: () => insetMap,
  isCSSMathFn: () => isCSSMathFn,
  isSize: () => isSize,
  makeGlobalStaticRules: () => makeGlobalStaticRules,
  parseColor: () => parseColor2,
  positionMap: () => positionMap,
  resolveBreakpoints: () => resolveBreakpoints,
  resolveVerticalBreakpoints: () => resolveVerticalBreakpoints,
  splitShorthand: () => splitShorthand,
  transformXYZ: () => transformXYZ,
  valueHandlers: () => handlers_exports,
  xyzArray: () => xyzArray,
  xyzMap: () => xyzMap
});
__reExport(_utils_exports, dist_exports);
var utils_exports = __exportAll({
  CONTROL_MINI_NO_NEGATIVE: () => CONTROL_MINI_NO_NEGATIVE,
  colorResolver: () => colorResolver,
  colorableShadows: () => colorableShadows,
  cornerMap: () => cornerMap,
  cssMathFnRE: () => cssMathFnRE,
  cssVarFnRE: () => cssVarFnRE,
  directionMap: () => directionMap,
  directionSize: () => directionSize,
  globalKeywords: () => globalKeywords,
  h: () => h,
  handler: () => handler,
  hasParseableColor: () => hasParseableColor,
  insetMap: () => insetMap,
  isCSSMathFn: () => isCSSMathFn,
  isSize: () => isSize,
  makeGlobalStaticRules: () => makeGlobalStaticRules,
  parseColor: () => parseColor2,
  positionMap: () => positionMap,
  resolveBreakpoints: () => resolveBreakpoints,
  resolveVerticalBreakpoints: () => resolveVerticalBreakpoints,
  splitShorthand: () => splitShorthand,
  transformXYZ: () => transformXYZ,
  valueHandlers: () => handlers_exports,
  xyzArray: () => xyzArray,
  xyzMap: () => xyzMap
});
__reExport(utils_exports, _utils_exports);

// node_modules/@unocss/preset-mini/dist/rules-Cc0JK3VG.mjs
var verticalAlignAlias = {
  "mid": "middle",
  "base": "baseline",
  "btm": "bottom",
  "baseline": "baseline",
  "top": "top",
  "start": "top",
  "middle": "middle",
  "bottom": "bottom",
  "end": "bottom",
  "text-top": "text-top",
  "text-bottom": "text-bottom",
  "sub": "sub",
  "super": "super",
  ...Object.fromEntries(globalKeywords.map((x) => [x, x]))
};
var verticalAligns = [[
  /^(?:vertical|align|v)-(.+)$/,
  ([, v]) => ({ "vertical-align": verticalAlignAlias[v] ?? h.bracket.cssvar.numberWithUnit(v) }),
  { autocomplete: [`(vertical|align|v)-(${Object.keys(verticalAlignAlias).join("|")})`, "(vertical|align|v)-<percentage>"] }
]];
var textAlignValues = [
  "center",
  "left",
  "right",
  "justify",
  "start",
  "end"
];
var textAligns = [...textAlignValues.map((v) => [`text-${v}`, { "text-align": v }]), ...[...globalKeywords, ...textAlignValues].map((v) => [`text-align-${v}`, { "text-align": v }])];
var outline = [
  [
    /^outline-(?:width-|size-)?(.+)$/,
    handleWidth$3,
    { autocomplete: "outline-(width|size)-<num>" }
  ],
  [
    /^outline-(?:color-)?(.+)$/,
    handleColorOrWidth$3,
    { autocomplete: "outline-$colors" }
  ],
  [
    /^outline-offset-(.+)$/,
    ([, d], { theme: theme4 }) => {
      var _a;
      return { "outline-offset": ((_a = theme4.lineWidth) == null ? void 0 : _a[d]) ?? h.bracket.cssvar.global.px(d) };
    },
    { autocomplete: "outline-(offset)-<num>" }
  ],
  ["outline", { "outline-style": "solid" }],
  ...[
    "auto",
    "dashed",
    "dotted",
    "double",
    "hidden",
    "solid",
    "groove",
    "ridge",
    "inset",
    "outset",
    ...globalKeywords
  ].map((v) => [`outline-${v}`, { "outline-style": v }]),
  ["outline-none", {
    "outline": "2px solid transparent",
    "outline-offset": "2px"
  }]
];
function handleWidth$3([, b], { theme: theme4 }) {
  var _a;
  return { "outline-width": ((_a = theme4.lineWidth) == null ? void 0 : _a[b]) ?? h.bracket.cssvar.global.px(b) };
}
function handleColorOrWidth$3(match, ctx) {
  if (isCSSMathFn(h.bracket(match[1]))) return handleWidth$3(match, ctx);
  return colorResolver("outline-color", "outline-color", "borderColor")(match, ctx);
}
var appearance = [["appearance-auto", {
  "-webkit-appearance": "auto",
  "appearance": "auto"
}], ["appearance-none", {
  "-webkit-appearance": "none",
  "appearance": "none"
}]];
function willChangeProperty(prop) {
  return h.properties.auto.global(prop) ?? {
    contents: "contents",
    scroll: "scroll-position"
  }[prop];
}
var willChange = [[/^will-change-(.+)/, ([, p]) => ({ "will-change": willChangeProperty(p) })]];
var borderStyles = [
  "solid",
  "dashed",
  "dotted",
  "double",
  "hidden",
  "none",
  "groove",
  "ridge",
  "inset",
  "outset",
  ...globalKeywords
];
var borders = [
  [
    /^(?:border|b)()(?:-(.+))?$/,
    handlerBorderSize,
    { autocomplete: "(border|b)-<directions>" }
  ],
  [/^(?:border|b)-([xy])(?:-(.+))?$/, handlerBorderSize],
  [/^(?:border|b)-([rltbse])(?:-(.+))?$/, handlerBorderSize],
  [/^(?:border|b)-(block|inline)(?:-(.+))?$/, handlerBorderSize],
  [/^(?:border|b)-([bi][se])(?:-(.+))?$/, handlerBorderSize],
  [
    /^(?:border|b)-()(?:width|size)-(.+)$/,
    handlerBorderSize,
    { autocomplete: ["(border|b)-<num>", "(border|b)-<directions>-<num>"] }
  ],
  [/^(?:border|b)-([xy])-(?:width|size)-(.+)$/, handlerBorderSize],
  [/^(?:border|b)-([rltbse])-(?:width|size)-(.+)$/, handlerBorderSize],
  [/^(?:border|b)-(block|inline)-(?:width|size)-(.+)$/, handlerBorderSize],
  [/^(?:border|b)-([bi][se])-(?:width|size)-(.+)$/, handlerBorderSize],
  [
    /^(?:border|b)-()(?:color-)?(.+)$/,
    handlerBorderColorOrSize,
    { autocomplete: ["(border|b)-$colors", "(border|b)-<directions>-$colors"] }
  ],
  [/^(?:border|b)-([xy])-(?:color-)?(.+)$/, handlerBorderColorOrSize],
  [/^(?:border|b)-([rltbse])-(?:color-)?(.+)$/, handlerBorderColorOrSize],
  [/^(?:border|b)-(block|inline)-(?:color-)?(.+)$/, handlerBorderColorOrSize],
  [/^(?:border|b)-([bi][se])-(?:color-)?(.+)$/, handlerBorderColorOrSize],
  [
    /^(?:border|b)-()op(?:acity)?-?(.+)$/,
    handlerBorderOpacity,
    { autocomplete: "(border|b)-(op|opacity)-<percent>" }
  ],
  [/^(?:border|b)-([xy])-op(?:acity)?-?(.+)$/, handlerBorderOpacity],
  [/^(?:border|b)-([rltbse])-op(?:acity)?-?(.+)$/, handlerBorderOpacity],
  [/^(?:border|b)-(block|inline)-op(?:acity)?-?(.+)$/, handlerBorderOpacity],
  [/^(?:border|b)-([bi][se])-op(?:acity)?-?(.+)$/, handlerBorderOpacity],
  [
    /^(?:border-|b-)?(?:rounded|rd)()(?:-(.+))?$/,
    handlerRounded,
    { autocomplete: [
      "(border|b)-(rounded|rd)",
      "(border|b)-(rounded|rd)-$borderRadius",
      "(rounded|rd)",
      "(rounded|rd)-$borderRadius"
    ] }
  ],
  [/^(?:border-|b-)?(?:rounded|rd)-([rltbse])(?:-(.+))?$/, handlerRounded],
  [/^(?:border-|b-)?(?:rounded|rd)-([rltb]{2})(?:-(.+))?$/, handlerRounded],
  [/^(?:border-|b-)?(?:rounded|rd)-([bise][se])(?:-(.+))?$/, handlerRounded],
  [/^(?:border-|b-)?(?:rounded|rd)-([bi][se]-[bi][se])(?:-(.+))?$/, handlerRounded],
  [
    /^(?:border|b)-(?:style-)?()(.+)$/,
    handlerBorderStyle,
    { autocomplete: [
      "(border|b)-style",
      `(border|b)-(${borderStyles.join("|")})`,
      "(border|b)-<directions>-style",
      `(border|b)-<directions>-(${borderStyles.join("|")})`,
      `(border|b)-<directions>-style-(${borderStyles.join("|")})`,
      `(border|b)-style-(${borderStyles.join("|")})`
    ] }
  ],
  [/^(?:border|b)-([xy])-(?:style-)?(.+)$/, handlerBorderStyle],
  [/^(?:border|b)-([rltbse])-(?:style-)?(.+)$/, handlerBorderStyle],
  [/^(?:border|b)-(block|inline)-(?:style-)?(.+)$/, handlerBorderStyle],
  [/^(?:border|b)-([bi][se])-(?:style-)?(.+)$/, handlerBorderStyle]
];
function transformBorderColor(color, alpha, direction) {
  if (alpha != null) return { [`border${direction}-color`]: colorToString2(color, alpha) };
  if (direction === "") {
    const object = {};
    const opacityVar = `--un-border-opacity`;
    const result = colorToString2(color, `var(${opacityVar})`);
    if (result.includes(opacityVar)) object[opacityVar] = typeof color === "string" ? 1 : colorOpacityToString(color);
    object["border-color"] = result;
    return object;
  } else {
    const object = {};
    const opacityVar = "--un-border-opacity";
    const opacityDirectionVar = `--un-border${direction}-opacity`;
    const result = colorToString2(color, `var(${opacityDirectionVar})`);
    if (result.includes(opacityDirectionVar)) {
      object[opacityVar] = typeof color === "string" ? 1 : colorOpacityToString(color);
      object[opacityDirectionVar] = `var(${opacityVar})`;
    }
    object[`border${direction}-color`] = result;
    return object;
  }
}
function borderColorResolver(direction) {
  return ([, body], theme4) => {
    const data = parseColor2(body, theme4, "borderColor");
    if (!data) return;
    const { alpha, color, cssColor } = data;
    if (cssColor) return transformBorderColor(cssColor, alpha, direction);
    else if (color) return transformBorderColor(color, alpha, direction);
  };
}
function handlerBorderSize([, a = "", b], { theme: theme4 }) {
  var _a;
  const v = ((_a = theme4.lineWidth) == null ? void 0 : _a[b || "DEFAULT"]) ?? h.bracket.cssvar.global.px(b || "1");
  if (a in directionMap && v != null) return directionMap[a].map((i) => [`border${i}-width`, v]);
}
function handlerBorderColorOrSize([, a = "", b], ctx) {
  if (a in directionMap) {
    if (isCSSMathFn(h.bracket(b))) return handlerBorderSize([
      "",
      a,
      b
    ], ctx);
    if (hasParseableColor(b, ctx.theme, "borderColor")) return Object.assign({}, ...directionMap[a].map((i) => borderColorResolver(i)(["", b], ctx.theme)));
  }
}
function handlerBorderOpacity([, a = "", opacity$1]) {
  const v = h.bracket.percent.cssvar(opacity$1);
  if (a in directionMap && v != null) return directionMap[a].map((i) => [`--un-border${i}-opacity`, v]);
}
function handlerRounded([, a = "", s], { theme: theme4 }) {
  var _a;
  const v = ((_a = theme4.borderRadius) == null ? void 0 : _a[s || "DEFAULT"]) || h.bracket.cssvar.global.fraction.rem(s || "1");
  if (a in cornerMap && v != null) return cornerMap[a].map((i) => [`border${i}-radius`, v]);
}
function handlerBorderStyle([, a = "", s]) {
  if (borderStyles.includes(s) && a in directionMap) return directionMap[a].map((i) => [`border${i}-style`, s]);
}
var opacity = [[/^op(?:acity)?-?(.+)$/, ([, d]) => ({ opacity: h.bracket.percent.cssvar(d) })]];
var bgUrlRE = /^\[url\(.+\)\]$/;
var bgLengthRE = /^\[(?:length|size):.+\]$/;
var bgPositionRE = /^\[position:.+\]$/;
var bgGradientRE = /^\[(?:linear|conic|radial)-gradient\(.+\)\]$/;
var bgImageRE = /^\[image:.+\]$/;
var bgColors = [[
  /^bg-(.+)$/,
  (...args) => {
    const d = args[0][1];
    if (bgUrlRE.test(d)) return {
      "--un-url": h.bracket(d),
      "background-image": "var(--un-url)"
    };
    if (bgLengthRE.test(d) && h.bracketOfLength(d) != null) return { "background-size": h.bracketOfLength(d).split(" ").map((e2) => h.fraction.auto.px.cssvar(e2) ?? e2).join(" ") };
    if ((isSize(d) || bgPositionRE.test(d)) && h.bracketOfPosition(d) != null) return { "background-position": h.bracketOfPosition(d).split(" ").map((e2) => h.position.fraction.auto.px.cssvar(e2) ?? e2).join(" ") };
    if (bgGradientRE.test(d) || bgImageRE.test(d)) {
      const s = h.bracket(d);
      if (s) {
        const url = s.startsWith("http") ? `url(${s})` : h.cssvar(s);
        return { "background-image": url ?? s };
      }
    }
    return colorResolver("background-color", "bg", "backgroundColor")(...args);
  },
  { autocomplete: "bg-$colors" }
], [
  /^bg-op(?:acity)?-?(.+)$/,
  ([, opacity$1]) => ({ "--un-bg-opacity": h.bracket.percent.cssvar(opacity$1) }),
  { autocomplete: "bg-(op|opacity)-<percent>" }
]];
var colorScheme = [[/^color-scheme-(\w+)$/, ([, v]) => ({ "color-scheme": v })]];
var containerParent = [[/^@container(?:\/(\w+))?(?:-(normal|inline-size|size))?$/, ([, l, v]) => {
  return {
    "container-type": v ?? "inline-size",
    "container-name": l
  };
}]];
var decorationStyles = [
  "solid",
  "double",
  "dotted",
  "dashed",
  "wavy",
  ...globalKeywords
];
var textDecorations = [
  [
    /^(?:decoration-)?(underline|overline|line-through)$/,
    ([, s]) => ({ "text-decoration-line": s }),
    { autocomplete: "decoration-(underline|overline|line-through)" }
  ],
  [
    /^(?:underline|decoration)-(?:size-)?(.+)$/,
    handleWidth$2,
    { autocomplete: "(underline|decoration)-<num>" }
  ],
  [
    /^(?:underline|decoration)-(auto|from-font)$/,
    ([, s]) => ({ "text-decoration-thickness": s }),
    { autocomplete: "(underline|decoration)-(auto|from-font)" }
  ],
  [
    /^(?:underline|decoration)-(.+)$/,
    handleColorOrWidth$2,
    { autocomplete: "(underline|decoration)-$colors" }
  ],
  [
    /^(?:underline|decoration)-op(?:acity)?-?(.+)$/,
    ([, opacity$1]) => ({ "--un-line-opacity": h.bracket.percent.cssvar(opacity$1) }),
    { autocomplete: "(underline|decoration)-(op|opacity)-<percent>" }
  ],
  [
    /^(?:underline|decoration)-offset-(.+)$/,
    ([, s], { theme: theme4 }) => {
      var _a;
      return { "text-underline-offset": ((_a = theme4.lineWidth) == null ? void 0 : _a[s]) ?? h.auto.bracket.cssvar.global.px(s) };
    },
    { autocomplete: "(underline|decoration)-(offset)-<num>" }
  ],
  ...decorationStyles.map((v) => [`underline-${v}`, { "text-decoration-style": v }]),
  ...decorationStyles.map((v) => [`decoration-${v}`, { "text-decoration-style": v }]),
  ["no-underline", { "text-decoration": "none" }],
  ["decoration-none", { "text-decoration": "none" }]
];
function handleWidth$2([, b], { theme: theme4 }) {
  var _a;
  return { "text-decoration-thickness": ((_a = theme4.lineWidth) == null ? void 0 : _a[b]) ?? h.bracket.cssvar.global.px(b) };
}
function handleColorOrWidth$2(match, ctx) {
  if (isCSSMathFn(h.bracket(match[1]))) return handleWidth$2(match, ctx);
  const result = colorResolver("text-decoration-color", "line", "borderColor")(match, ctx);
  if (result) return {
    "-webkit-text-decoration-color": result["text-decoration-color"],
    ...result
  };
}
var flex = [
  ["flex", { display: "flex" }],
  ["inline-flex", { display: "inline-flex" }],
  ["flex-inline", { display: "inline-flex" }],
  [/^flex-(.*)$/, ([, d]) => ({ flex: h.bracket(d) != null ? h.bracket(d).split(" ").map((e2) => h.cssvar.fraction(e2) ?? e2).join(" ") : h.cssvar.fraction(d) })],
  ["flex-1", { flex: "1 1 0%" }],
  ["flex-auto", { flex: "1 1 auto" }],
  ["flex-initial", { flex: "0 1 auto" }],
  ["flex-none", { flex: "none" }],
  [
    /^(?:flex-)?shrink(?:-(.*))?$/,
    ([, d = ""]) => ({ "flex-shrink": h.bracket.cssvar.number(d) ?? 1 }),
    { autocomplete: ["flex-shrink-<num>", "shrink-<num>"] }
  ],
  [
    /^(?:flex-)?grow(?:-(.*))?$/,
    ([, d = ""]) => ({ "flex-grow": h.bracket.cssvar.number(d) ?? 1 }),
    { autocomplete: ["flex-grow-<num>", "grow-<num>"] }
  ],
  [
    /^(?:flex-)?basis-(.+)$/,
    ([, d], { theme: theme4 }) => {
      var _a;
      return { "flex-basis": ((_a = theme4.spacing) == null ? void 0 : _a[d]) ?? h.bracket.cssvar.auto.fraction.rem(d) };
    },
    { autocomplete: ["flex-basis-$spacing", "basis-$spacing"] }
  ],
  ["flex-row", { "flex-direction": "row" }],
  ["flex-row-reverse", { "flex-direction": "row-reverse" }],
  ["flex-col", { "flex-direction": "column" }],
  ["flex-col-reverse", { "flex-direction": "column-reverse" }],
  ["flex-wrap", { "flex-wrap": "wrap" }],
  ["flex-wrap-reverse", { "flex-wrap": "wrap-reverse" }],
  ["flex-nowrap", { "flex-wrap": "nowrap" }]
];
var directions = {
  "": "",
  "x": "column-",
  "y": "row-",
  "col": "column-",
  "row": "row-"
};
function handleGap([, d = "", s], { theme: theme4 }) {
  var _a;
  const v = ((_a = theme4.spacing) == null ? void 0 : _a[s]) ?? h.bracket.cssvar.global.rem(s);
  if (v != null) return { [`${directions[d]}gap`]: v };
}
var gaps = [
  [
    /^(?:flex-|grid-)?gap-?()(.+)$/,
    handleGap,
    { autocomplete: ["gap-$spacing", "gap-<num>"] }
  ],
  [
    /^(?:flex-|grid-)?gap-([xy])-?(.+)$/,
    handleGap,
    { autocomplete: ["gap-(x|y)-$spacing", "gap-(x|y)-<num>"] }
  ],
  [
    /^(?:flex-|grid-)?gap-(col|row)-?(.+)$/,
    handleGap,
    { autocomplete: ["gap-(col|row)-$spacing", "gap-(col|row)-<num>"] }
  ]
];
function rowCol(s) {
  return s.replace("col", "column");
}
function rowColTheme(s) {
  return s[0] === "r" ? "Row" : "Column";
}
function autoDirection(c, theme4, prop) {
  var _a;
  const v = (_a = theme4[`gridAuto${rowColTheme(c)}`]) == null ? void 0 : _a[prop];
  if (v != null) return v;
  switch (prop) {
    case "min":
      return "min-content";
    case "max":
      return "max-content";
    case "fr":
      return "minmax(0,1fr)";
  }
  return h.bracket.cssvar.auto.rem(prop);
}
var grids = [
  ["grid", { display: "grid" }],
  ["inline-grid", { display: "inline-grid" }],
  [/^(?:grid-)?(row|col)-(.+)$/, ([, c, v], { theme: theme4 }) => {
    var _a;
    return { [`grid-${rowCol(c)}`]: ((_a = theme4[`grid${rowColTheme(c)}`]) == null ? void 0 : _a[v]) ?? h.bracket.cssvar.auto(v) };
  }],
  [
    /^(?:grid-)?(row|col)-span-(.+)$/,
    ([, c, s]) => {
      if (s === "full") return { [`grid-${rowCol(c)}`]: "1/-1" };
      const v = h.bracket.number(s);
      if (v != null) return { [`grid-${rowCol(c)}`]: `span ${v}/span ${v}` };
    },
    { autocomplete: "(grid-row|grid-col|row|col)-span-<num>" }
  ],
  [/^(?:grid-)?(row|col)-start-(.+)$/, ([, c, v]) => ({ [`grid-${rowCol(c)}-start`]: h.bracket.cssvar(v) ?? v })],
  [
    /^(?:grid-)?(row|col)-end-(.+)$/,
    ([, c, v]) => ({ [`grid-${rowCol(c)}-end`]: h.bracket.cssvar(v) ?? v }),
    { autocomplete: "(grid-row|grid-col|row|col)-(start|end)-<num>" }
  ],
  [
    /^(?:grid-)?auto-(rows|cols)-(.+)$/,
    ([, c, v], { theme: theme4 }) => ({ [`grid-auto-${rowCol(c)}`]: autoDirection(c, theme4, v) }),
    { autocomplete: "(grid-auto|auto)-(rows|cols)-<num>" }
  ],
  [/^(?:grid-auto-flow|auto-flow|grid-flow)-(.+)$/, ([, v]) => ({ "grid-auto-flow": h.bracket.cssvar(v) })],
  [
    /^(?:grid-auto-flow|auto-flow|grid-flow)-(row|col|dense|row-dense|col-dense)$/,
    ([, v]) => ({ "grid-auto-flow": rowCol(v).replace("-", " ") }),
    { autocomplete: ["(grid-auto-flow|auto-flow|grid-flow)-(row|col|dense|row-dense|col-dense)"] }
  ],
  [/^(?:grid-)?(rows|cols)-(.+)$/, ([, c, v], { theme: theme4 }) => {
    var _a;
    return { [`grid-template-${rowCol(c)}`]: ((_a = theme4[`gridTemplate${rowColTheme(c)}`]) == null ? void 0 : _a[v]) ?? h.bracket.cssvar(v) };
  }],
  [/^(?:grid-)?(rows|cols)-minmax-([\w.-]+)$/, ([, c, d]) => ({ [`grid-template-${rowCol(c)}`]: `repeat(auto-fill,minmax(${d},1fr))` })],
  [
    /^(?:grid-)?(rows|cols)-(\d+)$/,
    ([, c, d]) => ({ [`grid-template-${rowCol(c)}`]: `repeat(${d},minmax(0,1fr))` }),
    { autocomplete: "(grid-rows|grid-cols|rows|cols)-<num>" }
  ],
  [/^grid-area(s)?-(.+)$/, ([, s, v]) => {
    if (s != null) return { "grid-template-areas": h.cssvar(v) ?? v.split("-").map((s$1) => `"${h.bracket(s$1)}"`).join(" ") };
    return { "grid-area": h.bracket.cssvar(v) };
  }],
  ["grid-rows-none", { "grid-template-rows": "none" }],
  ["grid-cols-none", { "grid-template-columns": "none" }],
  ["grid-rows-subgrid", { "grid-template-rows": "subgrid" }],
  ["grid-cols-subgrid", { "grid-template-columns": "subgrid" }]
];
var overflowValues = [
  "auto",
  "hidden",
  "clip",
  "visible",
  "scroll",
  "overlay",
  ...globalKeywords
];
var overflows = [[
  /^(?:overflow|of)-(.+)$/,
  ([, v]) => overflowValues.includes(v) ? { overflow: v } : void 0,
  { autocomplete: [`(overflow|of)-(${overflowValues.join("|")})`, `(overflow|of)-(x|y)-(${overflowValues.join("|")})`] }
], [/^(?:overflow|of)-([xy])-(.+)$/, ([, d, v]) => overflowValues.includes(v) ? { [`overflow-${d}`]: v } : void 0]];
var positions = [
  [
    /^(?:position-|pos-)?(relative|absolute|fixed|sticky)$/,
    ([, v]) => ({ position: v }),
    { autocomplete: [
      "(position|pos)-<position>",
      "(position|pos)-<globalKeyword>",
      "<position>"
    ] }
  ],
  [/^(?:position-|pos-)([-\w]+)$/, ([, v]) => globalKeywords.includes(v) ? { position: v } : void 0],
  [/^(?:position-|pos-)?(static)$/, ([, v]) => ({ position: v })]
];
var justifies = [
  ["justify-start", { "justify-content": "flex-start" }],
  ["justify-end", { "justify-content": "flex-end" }],
  ["justify-center", { "justify-content": "center" }],
  ["justify-between", { "justify-content": "space-between" }],
  ["justify-around", { "justify-content": "space-around" }],
  ["justify-evenly", { "justify-content": "space-evenly" }],
  ["justify-stretch", { "justify-content": "stretch" }],
  ["justify-left", { "justify-content": "left" }],
  ["justify-right", { "justify-content": "right" }],
  ["justify-center-safe", { "justify-content": "safe center" }],
  ["justify-end-safe", { "justify-content": "safe flex-end" }],
  ["justify-normal", { "justify-content": "normal" }],
  ...makeGlobalStaticRules("justify", "justify-content"),
  ["justify-items-start", { "justify-items": "start" }],
  ["justify-items-end", { "justify-items": "end" }],
  ["justify-items-center", { "justify-items": "center" }],
  ["justify-items-stretch", { "justify-items": "stretch" }],
  ["justify-items-center-safe", { "justify-items": "safe center" }],
  ["justify-items-end-safe", { "justify-items": "safe flex-end" }],
  ...makeGlobalStaticRules("justify-items"),
  ["justify-self-auto", { "justify-self": "auto" }],
  ["justify-self-start", { "justify-self": "start" }],
  ["justify-self-end", { "justify-self": "end" }],
  ["justify-self-center", { "justify-self": "center" }],
  ["justify-self-stretch", { "justify-self": "stretch" }],
  ["justify-self-baseline", { "justify-self": "baseline" }],
  ["justify-self-center-safe", { "justify-self": "safe center" }],
  ["justify-self-end-safe", { "justify-self": "safe flex-end" }],
  ...makeGlobalStaticRules("justify-self")
];
var orders = [
  [/^order-(.+)$/, ([, v]) => ({ order: h.bracket.cssvar.number(v) })],
  ["order-first", { order: "-9999" }],
  ["order-last", { order: "9999" }],
  ["order-none", { order: "0" }]
];
var alignments = [
  ["content-center", { "align-content": "center" }],
  ["content-start", { "align-content": "flex-start" }],
  ["content-end", { "align-content": "flex-end" }],
  ["content-between", { "align-content": "space-between" }],
  ["content-around", { "align-content": "space-around" }],
  ["content-evenly", { "align-content": "space-evenly" }],
  ["content-baseline", { "align-content": "baseline" }],
  ["content-center-safe", { "align-content": "safe center" }],
  ["content-end-safe", { "align-content": "safe flex-end" }],
  ["content-stretch", { "align-content": "stretch" }],
  ["content-normal", { "align-content": "normal" }],
  ...makeGlobalStaticRules("content", "align-content"),
  ["items-start", { "align-items": "flex-start" }],
  ["items-end", { "align-items": "flex-end" }],
  ["items-center", { "align-items": "center" }],
  ["items-baseline", { "align-items": "baseline" }],
  ["items-stretch", { "align-items": "stretch" }],
  ["items-baseline-last", { "align-items": "last baseline" }],
  ["items-center-safe", { "align-items": "safe center" }],
  ["items-end-safe", { "align-items": "safe flex-end" }],
  ...makeGlobalStaticRules("items", "align-items"),
  ["self-auto", { "align-self": "auto" }],
  ["self-start", { "align-self": "flex-start" }],
  ["self-end", { "align-self": "flex-end" }],
  ["self-center", { "align-self": "center" }],
  ["self-stretch", { "align-self": "stretch" }],
  ["self-baseline", { "align-self": "baseline" }],
  ["self-baseline-last", { "align-self": "last baseline" }],
  ["self-center-safe", { "align-self": "safe center" }],
  ["self-end-safe", { "align-self": "safe flex-end" }],
  ...makeGlobalStaticRules("self", "align-self")
];
var placements = [
  ["place-content-center", { "place-content": "center" }],
  ["place-content-start", { "place-content": "start" }],
  ["place-content-end", { "place-content": "end" }],
  ["place-content-between", { "place-content": "space-between" }],
  ["place-content-around", { "place-content": "space-around" }],
  ["place-content-evenly", { "place-content": "space-evenly" }],
  ["place-content-stretch", { "place-content": "stretch" }],
  ["place-content-baseline", { "place-content": "baseline" }],
  ["place-content-center-safe", { "place-content": "safe center" }],
  ["place-content-end-safe", { "place-content": "safe flex-end" }],
  ...makeGlobalStaticRules("place-content"),
  ["place-items-start", { "place-items": "start" }],
  ["place-items-end", { "place-items": "end" }],
  ["place-items-center", { "place-items": "center" }],
  ["place-items-stretch", { "place-items": "stretch" }],
  ["place-items-baseline", { "place-items": "baseline" }],
  ["place-items-center-safe", { "place-items": "safe center" }],
  ["place-items-end-safe", { "place-items": "safe flex-end" }],
  ...makeGlobalStaticRules("place-items"),
  ["place-self-auto", { "place-self": "auto" }],
  ["place-self-start", { "place-self": "start" }],
  ["place-self-end", { "place-self": "end" }],
  ["place-self-center", { "place-self": "center" }],
  ["place-self-stretch", { "place-self": "stretch" }],
  ["place-self-center-safe", { "place-self": "safe center" }],
  ["place-self-end-safe", { "place-self": "safe flex-end" }],
  ...makeGlobalStaticRules("place-self")
];
var flexGridJustifiesAlignments = [
  ...justifies,
  ...alignments,
  ...placements
].flatMap(([k, v]) => [[`flex-${k}`, v], [`grid-${k}`, v]]);
function handleInsetValue(v, { theme: theme4 }) {
  var _a;
  return ((_a = theme4.spacing) == null ? void 0 : _a[v]) ?? h.bracket.cssvar.global.auto.fraction.rem(v);
}
function handleInsetValues([, d, v], ctx) {
  const r = handleInsetValue(v, ctx);
  if (r != null && d in insetMap) return insetMap[d].map((i) => [i.slice(1), r]);
}
var insets = [
  [
    /^(?:position-|pos-)?inset-(.+)$/,
    ([, v], ctx) => ({ inset: handleInsetValue(v, ctx) }),
    { autocomplete: [
      "(position|pos)-inset-<directions>-$spacing",
      "(position|pos)-inset-(block|inline)-$spacing",
      "(position|pos)-inset-(bs|be|is|ie)-$spacing",
      "(position|pos)-(top|left|right|bottom)-$spacing"
    ] }
  ],
  [/^(?:position-|pos-)?(start|end)-(.+)$/, handleInsetValues],
  [/^(?:position-|pos-)?inset-([xy])-(.+)$/, handleInsetValues],
  [/^(?:position-|pos-)?inset-([rltbse])-(.+)$/, handleInsetValues],
  [/^(?:position-|pos-)?inset-(block|inline)-(.+)$/, handleInsetValues],
  [/^(?:position-|pos-)?inset-([bi][se])-(.+)$/, handleInsetValues],
  [/^(?:position-|pos-)?(top|left|right|bottom)-(.+)$/, ([, d, v], ctx) => ({ [d]: handleInsetValue(v, ctx) })]
];
var floats = [
  ["float-left", { float: "left" }],
  ["float-right", { float: "right" }],
  ["float-start", { float: "inline-start" }],
  ["float-end", { float: "inline-end" }],
  ["float-none", { float: "none" }],
  ...makeGlobalStaticRules("float"),
  ["clear-left", { clear: "left" }],
  ["clear-right", { clear: "right" }],
  ["clear-both", { clear: "both" }],
  ["clear-start", { clear: "inline-start" }],
  ["clear-end", { clear: "inline-end" }],
  ["clear-none", { clear: "none" }],
  ...makeGlobalStaticRules("clear")
];
var zIndexes = [[/^(?:position-|pos-)?z([\d.]+)$/, ([, v]) => ({ "z-index": h.number(v) })], [
  /^(?:position-|pos-)?z-(.+)$/,
  ([, v], { theme: theme4 }) => {
    var _a;
    return { "z-index": ((_a = theme4.zIndex) == null ? void 0 : _a[v]) ?? h.bracket.cssvar.global.auto.number(v) };
  },
  { autocomplete: "z-<num>" }
]];
var boxSizing = [
  ["box-border", { "box-sizing": "border-box" }],
  ["box-content", { "box-sizing": "content-box" }],
  ...makeGlobalStaticRules("box", "box-sizing")
];
var questionMark = [[/^(where|\?)$/, (_, { constructCSS, generator }) => {
  if (generator.userConfig.envMode === "dev") return `@keyframes __un_qm{0%{box-shadow:inset 4px 4px #ff1e90, inset -4px -4px #ff1e90}100%{box-shadow:inset 8px 8px #3399ff, inset -8px -8px #3399ff}} ${constructCSS({ animation: "__un_qm 0.5s ease-in-out alternate infinite" })}`;
}]];
var cursorValues = [
  "auto",
  "default",
  "none",
  "context-menu",
  "help",
  "pointer",
  "progress",
  "wait",
  "cell",
  "crosshair",
  "text",
  "vertical-text",
  "alias",
  "copy",
  "move",
  "no-drop",
  "not-allowed",
  "grab",
  "grabbing",
  "all-scroll",
  "col-resize",
  "row-resize",
  "n-resize",
  "e-resize",
  "s-resize",
  "w-resize",
  "ne-resize",
  "nw-resize",
  "se-resize",
  "sw-resize",
  "ew-resize",
  "ns-resize",
  "nesw-resize",
  "nwse-resize",
  "zoom-in",
  "zoom-out"
];
var containValues = [
  "none",
  "strict",
  "content",
  "size",
  "inline-size",
  "layout",
  "style",
  "paint"
];
var varEmpty = " ";
var displays = [
  ["inline", { display: "inline" }],
  ["block", { display: "block" }],
  ["inline-block", { display: "inline-block" }],
  ["contents", { display: "contents" }],
  ["flow-root", { display: "flow-root" }],
  ["list-item", { display: "list-item" }],
  ["hidden", { display: "none" }],
  [/^display-(.+)$/, ([, c]) => ({ display: h.bracket.cssvar.global(c) })]
];
var appearances = [
  ["visible", { visibility: "visible" }],
  ["invisible", { visibility: "hidden" }],
  ["backface-visible", { "backface-visibility": "visible" }],
  ["backface-hidden", { "backface-visibility": "hidden" }],
  ...makeGlobalStaticRules("backface", "backface-visibility")
];
var cursors = [[/^cursor-(.+)$/, ([, c]) => ({ cursor: h.bracket.cssvar.global(c) })], ...cursorValues.map((v) => [`cursor-${v}`, { cursor: v }])];
var contains = [[/^contain-(.*)$/, ([, d]) => {
  if (h.bracket(d) != null) return { contain: h.bracket(d).split(" ").map((e2) => h.cssvar.fraction(e2) ?? e2).join(" ") };
  return containValues.includes(d) ? { contain: d } : void 0;
}]];
var pointerEvents = [
  ["pointer-events-auto", { "pointer-events": "auto" }],
  ["pointer-events-none", { "pointer-events": "none" }],
  ...makeGlobalStaticRules("pointer-events")
];
var resizes = [
  ["resize-x", { resize: "horizontal" }],
  ["resize-y", { resize: "vertical" }],
  ["resize", { resize: "both" }],
  ["resize-none", { resize: "none" }],
  ...makeGlobalStaticRules("resize")
];
var userSelects = [
  ["select-auto", {
    "-webkit-user-select": "auto",
    "user-select": "auto"
  }],
  ["select-all", {
    "-webkit-user-select": "all",
    "user-select": "all"
  }],
  ["select-text", {
    "-webkit-user-select": "text",
    "user-select": "text"
  }],
  ["select-none", {
    "-webkit-user-select": "none",
    "user-select": "none"
  }],
  ...makeGlobalStaticRules("select", "user-select")
];
var whitespaces = [[
  /^(?:whitespace-|ws-)([-\w]+)$/,
  ([, v]) => [
    "normal",
    "nowrap",
    "pre",
    "pre-line",
    "pre-wrap",
    "break-spaces",
    ...globalKeywords
  ].includes(v) ? { "white-space": v } : void 0,
  { autocomplete: "(whitespace|ws)-(normal|nowrap|pre|pre-line|pre-wrap|break-spaces)" }
]];
var contentVisibility = [
  [
    /^intrinsic(?:-(block|inline|w|h))?(?:-size)?-(.+)$/,
    ([, d, s]) => {
      return { [`contain-intrinsic-${{
        block: "block-size",
        inline: "inline-size",
        w: "width",
        h: "height"
      }[d] ?? "size"}`]: h.bracket.cssvar.global.fraction.rem(s) };
    },
    { autocomplete: [
      "intrinsic-size-<num>",
      "intrinsic-<num>",
      "intrinsic-(block|inline|w|h)-<num>"
    ] }
  ],
  ["content-visibility-visible", { "content-visibility": "visible" }],
  ["content-visibility-hidden", { "content-visibility": "hidden" }],
  ["content-visibility-auto", { "content-visibility": "auto" }],
  ...makeGlobalStaticRules("content-visibility")
];
var contents = [
  [/^content-(.+)$/, ([, v]) => ({ content: h.bracket.cssvar(v) })],
  ["content-empty", { content: '""' }],
  ["content-none", { content: "none" }]
];
var breaks = [
  ["break-normal", {
    "overflow-wrap": "normal",
    "word-break": "normal"
  }],
  ["break-words", { "overflow-wrap": "break-word" }],
  ["break-all", { "word-break": "break-all" }],
  ["break-keep", { "word-break": "keep-all" }],
  ["break-anywhere", { "overflow-wrap": "anywhere" }]
];
var textWraps = [
  ["text-wrap", { "text-wrap": "wrap" }],
  ["text-nowrap", { "text-wrap": "nowrap" }],
  ["text-balance", { "text-wrap": "balance" }],
  ["text-pretty", { "text-wrap": "pretty" }]
];
var textOverflows = [
  ["truncate", {
    "overflow": "hidden",
    "text-overflow": "ellipsis",
    "white-space": "nowrap"
  }],
  ["text-truncate", {
    "overflow": "hidden",
    "text-overflow": "ellipsis",
    "white-space": "nowrap"
  }],
  ["text-ellipsis", { "text-overflow": "ellipsis" }],
  ["text-clip", { "text-overflow": "clip" }]
];
var textTransforms = [
  ["case-upper", { "text-transform": "uppercase" }],
  ["case-lower", { "text-transform": "lowercase" }],
  ["case-capital", { "text-transform": "capitalize" }],
  ["case-normal", { "text-transform": "none" }],
  ...makeGlobalStaticRules("case", "text-transform")
];
var fontStyles = [
  ["italic", { "font-style": "italic" }],
  ["not-italic", { "font-style": "normal" }],
  ["font-italic", { "font-style": "italic" }],
  ["font-not-italic", { "font-style": "normal" }],
  ["oblique", { "font-style": "oblique" }],
  ["not-oblique", { "font-style": "normal" }],
  ["font-oblique", { "font-style": "oblique" }],
  ["font-not-oblique", { "font-style": "normal" }]
];
var fontSmoothings = [["antialiased", {
  "-webkit-font-smoothing": "antialiased",
  "-moz-osx-font-smoothing": "grayscale"
}], ["subpixel-antialiased", {
  "-webkit-font-smoothing": "auto",
  "-moz-osx-font-smoothing": "auto"
}]];
var fieldSizing = [["field-sizing-fixed", { "field-sizing": "fixed" }], ["field-sizing-content", { "field-sizing": "content" }]];
var ringBase = {
  "--un-ring-inset": varEmpty,
  "--un-ring-offset-width": "0px",
  "--un-ring-offset-color": "#fff",
  "--un-ring-width": "0px",
  "--un-ring-color": "rgb(147 197 253 / 0.5)",
  "--un-shadow": "0 0 rgb(0 0 0 / 0)"
};
var preflightKeys$2 = Object.keys(ringBase);
var rings = [
  [
    /^ring(?:-(.+))?$/,
    ([, d], { theme: theme4 }) => {
      var _a;
      const value = ((_a = theme4.ringWidth) == null ? void 0 : _a[d || "DEFAULT"]) ?? h.px(d || "1");
      if (value) return {
        "--un-ring-width": value,
        "--un-ring-offset-shadow": "var(--un-ring-inset) 0 0 0 var(--un-ring-offset-width) var(--un-ring-offset-color)",
        "--un-ring-shadow": "var(--un-ring-inset) 0 0 0 calc(var(--un-ring-width) + var(--un-ring-offset-width)) var(--un-ring-color)",
        "box-shadow": "var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow)"
      };
    },
    {
      custom: { preflightKeys: preflightKeys$2 },
      autocomplete: "ring-$ringWidth"
    }
  ],
  [
    /^ring-(?:width-|size-)(.+)$/,
    handleWidth$1,
    { autocomplete: "ring-(width|size)-$lineWidth" }
  ],
  ["ring-offset", { "--un-ring-offset-width": "1px" }],
  [
    /^ring-offset-(?:width-|size-)?(.+)$/,
    ([, d], { theme: theme4 }) => {
      var _a;
      return { "--un-ring-offset-width": ((_a = theme4.lineWidth) == null ? void 0 : _a[d]) ?? h.bracket.cssvar.px(d) };
    },
    { autocomplete: "ring-offset-(width|size)-$lineWidth" }
  ],
  [
    /^ring-(.+)$/,
    handleColorOrWidth$1,
    { autocomplete: "ring-$colors" }
  ],
  [
    /^ring-op(?:acity)?-?(.+)$/,
    ([, opacity$1]) => ({ "--un-ring-opacity": h.bracket.percent.cssvar(opacity$1) }),
    { autocomplete: "ring-(op|opacity)-<percent>" }
  ],
  [
    /^ring-offset-(.+)$/,
    colorResolver("--un-ring-offset-color", "ring-offset", "borderColor"),
    { autocomplete: "ring-offset-$colors" }
  ],
  [
    /^ring-offset-op(?:acity)?-?(.+)$/,
    ([, opacity$1]) => ({ "--un-ring-offset-opacity": h.bracket.percent.cssvar(opacity$1) }),
    { autocomplete: "ring-offset-(op|opacity)-<percent>" }
  ],
  ["ring-inset", { "--un-ring-inset": "inset" }]
];
function handleWidth$1([, b], { theme: theme4 }) {
  var _a;
  return { "--un-ring-width": ((_a = theme4.ringWidth) == null ? void 0 : _a[b]) ?? h.bracket.cssvar.px(b) };
}
function handleColorOrWidth$1(match, ctx) {
  if (isCSSMathFn(h.bracket(match[1]))) return handleWidth$1(match, ctx);
  return colorResolver("--un-ring-color", "ring", "borderColor")(match, ctx);
}
var boxShadowsBase = {
  "--un-ring-offset-shadow": "0 0 rgb(0 0 0 / 0)",
  "--un-ring-shadow": "0 0 rgb(0 0 0 / 0)",
  "--un-shadow-inset": varEmpty,
  "--un-shadow": "0 0 rgb(0 0 0 / 0)"
};
var preflightKeys$1 = Object.keys(boxShadowsBase);
var boxShadows = [
  [
    /^shadow(?:-(.+))?$/,
    (match, context) => {
      var _a;
      const [, d] = match;
      const { theme: theme4 } = context;
      const v = (_a = theme4.boxShadow) == null ? void 0 : _a[d || "DEFAULT"];
      const c = d ? h.bracket.cssvar(d) : void 0;
      if ((v != null || c != null) && !hasParseableColor(c, theme4, "shadowColor")) return {
        "--un-shadow": colorableShadows(v || c, "--un-shadow-color").join(","),
        "box-shadow": "var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow)"
      };
      return colorResolver("--un-shadow-color", "shadow", "shadowColor")(match, context);
    },
    {
      custom: { preflightKeys: preflightKeys$1 },
      autocomplete: ["shadow-$colors", "shadow-$boxShadow"]
    }
  ],
  [
    /^shadow-op(?:acity)?-?(.+)$/,
    ([, opacity$1]) => ({ "--un-shadow-opacity": h.bracket.percent.cssvar(opacity$1) }),
    { autocomplete: "shadow-(op|opacity)-<percent>" }
  ],
  ["shadow-inset", { "--un-shadow-inset": "inset" }]
];
var sizeMapping = {
  h: "height",
  w: "width",
  inline: "inline-size",
  block: "block-size"
};
function getPropName(minmax, hw) {
  return `${minmax || ""}${sizeMapping[hw]}`;
}
function getSizeValue(minmax, hw, theme4, prop) {
  var _a;
  const v = (_a = theme4[getPropName(minmax, hw).replace(/-(\w)/g, (_, p) => p.toUpperCase())]) == null ? void 0 : _a[prop];
  if (v != null) return v;
  switch (prop) {
    case "fit":
    case "max":
    case "min":
      return `${prop}-content`;
    case "stretch":
      return "stretch";
  }
  return h.bracket.cssvar.global.auto.fraction.rem(prop);
}
var sizes = [
  [/^size-(min-|max-)?(.+)$/, ([, m, s], { theme: theme4 }) => ({
    [getPropName(m, "w")]: getSizeValue(m, "w", theme4, s),
    [getPropName(m, "h")]: getSizeValue(m, "h", theme4, s)
  })],
  [/^(?:size-)?(min-|max-)?([wh])-?(.+)$/, ([, m, w, s], { theme: theme4 }) => ({ [getPropName(m, w)]: getSizeValue(m, w, theme4, s) })],
  [
    /^(?:size-)?(min-|max-)?(block|inline)-(.+)$/,
    ([, m, w, s], { theme: theme4 }) => ({ [getPropName(m, w)]: getSizeValue(m, w, theme4, s) }),
    { autocomplete: [
      "(w|h)-$width|height|maxWidth|maxHeight|minWidth|minHeight|inlineSize|blockSize|maxInlineSize|maxBlockSize|minInlineSize|minBlockSize",
      "(block|inline)-$width|height|maxWidth|maxHeight|minWidth|minHeight|inlineSize|blockSize|maxInlineSize|maxBlockSize|minInlineSize|minBlockSize",
      "(max|min)-(w|h|block|inline)",
      "(max|min)-(w|h|block|inline)-$width|height|maxWidth|maxHeight|minWidth|minHeight|inlineSize|blockSize|maxInlineSize|maxBlockSize|minInlineSize|minBlockSize",
      "(w|h)-full",
      "(max|min)-(w|h)-full"
    ] }
  ],
  [/^(?:size-)?(min-|max-)?(h)-screen-(.+)$/, ([, m, h$1, p], context) => ({ [getPropName(m, h$1)]: handleBreakpoint(context, p, "verticalBreakpoints") })],
  [
    /^(?:size-)?(min-|max-)?(w)-screen-(.+)$/,
    ([, m, w, p], context) => ({ [getPropName(m, w)]: handleBreakpoint(context, p) }),
    { autocomplete: [
      "(w|h)-screen",
      "(min|max)-(w|h)-screen",
      "h-screen-$verticalBreakpoints",
      "(min|max)-h-screen-$verticalBreakpoints",
      "w-screen-$breakpoints",
      "(min|max)-w-screen-$breakpoints"
    ] }
  ]
];
function handleBreakpoint(context, point, key = "breakpoints") {
  var _a;
  const bp = resolveBreakpoints(context, key);
  if (bp) return (_a = bp.find((i) => i.point === point)) == null ? void 0 : _a.size;
}
function getAspectRatio(prop) {
  if (/^\d+\/\d+$/.test(prop)) return prop;
  switch (prop) {
    case "square":
      return "1/1";
    case "video":
      return "16/9";
  }
  return h.bracket.cssvar.global.auto.number(prop);
}
var aspectRatio = [[
  /^(?:size-)?aspect-(?:ratio-)?(.+)$/,
  ([, d]) => ({ "aspect-ratio": getAspectRatio(d) }),
  { autocomplete: ["aspect-(square|video|ratio)", "aspect-ratio-(square|video)"] }
]];
var paddings = [
  [
    /^pa?()-?(.+)$/,
    directionSize("padding"),
    { autocomplete: ["(m|p)<num>", "(m|p)-<num>"] }
  ],
  [
    /^p-?xy()()$/,
    directionSize("padding"),
    { autocomplete: "(m|p)-(xy)" }
  ],
  [/^p-?([xy])(?:-?(.+))?$/, directionSize("padding")],
  [
    /^p-?([rltbse])(?:-?(.+))?$/,
    directionSize("padding"),
    { autocomplete: "(m|p)<directions>-<num>" }
  ],
  [
    /^p-(block|inline)(?:-(.+))?$/,
    directionSize("padding"),
    { autocomplete: "(m|p)-(block|inline)-<num>" }
  ],
  [
    /^p-?([bi][se])(?:-?(.+))?$/,
    directionSize("padding"),
    { autocomplete: "(m|p)-(bs|be|is|ie)-<num>" }
  ]
];
var margins = [
  [/^ma?()-?(.+)$/, directionSize("margin")],
  [/^m-?xy()()$/, directionSize("margin")],
  [/^m-?([xy])(?:-?(.+))?$/, directionSize("margin")],
  [/^m-?([rltbse])(?:-?(.+))?$/, directionSize("margin")],
  [/^m-(block|inline)(?:-(.+))?$/, directionSize("margin")],
  [/^m-?([bi][se])(?:-?(.+))?$/, directionSize("margin")]
];
var svgUtilities = [
  [
    /^fill-(.+)$/,
    colorResolver("fill", "fill", "backgroundColor"),
    { autocomplete: "fill-$colors" }
  ],
  [
    /^fill-op(?:acity)?-?(.+)$/,
    ([, opacity$1]) => ({ "--un-fill-opacity": h.bracket.percent.cssvar(opacity$1) }),
    { autocomplete: "fill-(op|opacity)-<percent>" }
  ],
  ["fill-none", { fill: "none" }],
  [
    /^stroke-(?:width-|size-)?(.+)$/,
    handleWidth,
    { autocomplete: ["stroke-width-$lineWidth", "stroke-size-$lineWidth"] }
  ],
  [
    /^stroke-dash-(.+)$/,
    ([, s]) => ({ "stroke-dasharray": h.bracket.cssvar.number(s) }),
    { autocomplete: "stroke-dash-<num>" }
  ],
  [
    /^stroke-offset-(.+)$/,
    ([, s], { theme: theme4 }) => {
      var _a;
      return { "stroke-dashoffset": ((_a = theme4.lineWidth) == null ? void 0 : _a[s]) ?? h.bracket.cssvar.px.numberWithUnit(s) };
    },
    { autocomplete: "stroke-offset-$lineWidth" }
  ],
  [
    /^stroke-(.+)$/,
    handleColorOrWidth,
    { autocomplete: "stroke-$colors" }
  ],
  [
    /^stroke-op(?:acity)?-?(.+)$/,
    ([, opacity$1]) => ({ "--un-stroke-opacity": h.bracket.percent.cssvar(opacity$1) }),
    { autocomplete: "stroke-(op|opacity)-<percent>" }
  ],
  ["stroke-cap-square", { "stroke-linecap": "square" }],
  ["stroke-cap-round", { "stroke-linecap": "round" }],
  ["stroke-cap-auto", { "stroke-linecap": "butt" }],
  ["stroke-join-arcs", { "stroke-linejoin": "arcs" }],
  ["stroke-join-bevel", { "stroke-linejoin": "bevel" }],
  ["stroke-join-clip", { "stroke-linejoin": "miter-clip" }],
  ["stroke-join-round", { "stroke-linejoin": "round" }],
  ["stroke-join-auto", { "stroke-linejoin": "miter" }],
  ["stroke-none", { stroke: "none" }]
];
function handleWidth([, b], { theme: theme4 }) {
  var _a;
  return { "stroke-width": ((_a = theme4.lineWidth) == null ? void 0 : _a[b]) ?? h.bracket.cssvar.fraction.px.number(b) };
}
function handleColorOrWidth(match, ctx) {
  if (isCSSMathFn(h.bracket(match[1]))) return handleWidth(match, ctx);
  return colorResolver("stroke", "stroke", "borderColor")(match, ctx);
}
var transformValues = [
  "translate",
  "rotate",
  "scale"
];
var transformCpu = [
  "translateX(var(--un-translate-x))",
  "translateY(var(--un-translate-y))",
  "rotate(var(--un-rotate))",
  "rotateZ(var(--un-rotate-z))",
  "skewX(var(--un-skew-x))",
  "skewY(var(--un-skew-y))",
  "scaleX(var(--un-scale-x))",
  "scaleY(var(--un-scale-y))"
].join(" ");
var transform = [
  "translateX(var(--un-translate-x))",
  "translateY(var(--un-translate-y))",
  "translateZ(var(--un-translate-z))",
  "rotate(var(--un-rotate))",
  "rotateX(var(--un-rotate-x))",
  "rotateY(var(--un-rotate-y))",
  "rotateZ(var(--un-rotate-z))",
  "skewX(var(--un-skew-x))",
  "skewY(var(--un-skew-y))",
  "scaleX(var(--un-scale-x))",
  "scaleY(var(--un-scale-y))",
  "scaleZ(var(--un-scale-z))"
].join(" ");
var transformGpu = [
  "translate3d(var(--un-translate-x), var(--un-translate-y), var(--un-translate-z))",
  "rotate(var(--un-rotate))",
  "rotateX(var(--un-rotate-x))",
  "rotateY(var(--un-rotate-y))",
  "rotateZ(var(--un-rotate-z))",
  "skewX(var(--un-skew-x))",
  "skewY(var(--un-skew-y))",
  "scaleX(var(--un-scale-x))",
  "scaleY(var(--un-scale-y))",
  "scaleZ(var(--un-scale-z))"
].join(" ");
var transformBase = {
  "--un-rotate": 0,
  "--un-rotate-x": 0,
  "--un-rotate-y": 0,
  "--un-rotate-z": 0,
  "--un-scale-x": 1,
  "--un-scale-y": 1,
  "--un-scale-z": 1,
  "--un-skew-x": 0,
  "--un-skew-y": 0,
  "--un-translate-x": 0,
  "--un-translate-y": 0,
  "--un-translate-z": 0
};
var preflightKeys = Object.keys(transformBase);
var transforms = [
  [
    /^(?:transform-)?origin-(.+)$/,
    ([, s]) => ({ "transform-origin": positionMap[s] ?? h.bracket.cssvar(s) }),
    { autocomplete: [`transform-origin-(${Object.keys(positionMap).join("|")})`, `origin-(${Object.keys(positionMap).join("|")})`] }
  ],
  [/^(?:transform-)?perspect(?:ive)?-(.+)$/, ([, s]) => {
    const v = h.bracket.cssvar.px.numberWithUnit(s);
    if (v != null) return {
      "-webkit-perspective": v,
      "perspective": v
    };
  }],
  [/^(?:transform-)?perspect(?:ive)?-origin-(.+)$/, ([, s]) => {
    const v = h.bracket.cssvar(s) ?? (s.length >= 3 ? positionMap[s] : void 0);
    if (v != null) return {
      "-webkit-perspective-origin": v,
      "perspective-origin": v
    };
  }],
  [
    /^(?:transform-)?translate-()(.+)$/,
    handleTranslate,
    { custom: { preflightKeys } }
  ],
  [
    /^(?:transform-)?translate-([xyz])-(.+)$/,
    handleTranslate,
    { custom: { preflightKeys } }
  ],
  [
    /^(?:transform-)?rotate-()(.+)$/,
    handleRotate,
    { custom: { preflightKeys } }
  ],
  [
    /^(?:transform-)?rotate-([xyz])-(.+)$/,
    handleRotate,
    { custom: { preflightKeys } }
  ],
  [
    /^(?:transform-)?skew-()(.+)$/,
    handleSkew,
    { custom: { preflightKeys } }
  ],
  [
    /^(?:transform-)?skew-([xy])-(.+)$/,
    handleSkew,
    {
      custom: { preflightKeys },
      autocomplete: ["transform-skew-(x|y)-<percent>", "skew-(x|y)-<percent>"]
    }
  ],
  [
    /^(?:transform-)?scale-()(.+)$/,
    handleScale,
    { custom: { preflightKeys } }
  ],
  [
    /^(?:transform-)?scale-([xyz])-(.+)$/,
    handleScale,
    {
      custom: { preflightKeys },
      autocomplete: [
        `transform-(${transformValues.join("|")})-<percent>`,
        `transform-(${transformValues.join("|")})-(x|y|z)-<percent>`,
        `(${transformValues.join("|")})-<percent>`,
        `(${transformValues.join("|")})-(x|y|z)-<percent>`
      ]
    }
  ],
  [/^(?:transform-)?preserve-3d$/, () => ({ "transform-style": "preserve-3d" })],
  [/^(?:transform-)?preserve-flat$/, () => ({ "transform-style": "flat" })],
  [
    "transform",
    { transform },
    { custom: { preflightKeys } }
  ],
  [
    "transform-cpu",
    { transform: transformCpu },
    { custom: { preflightKeys: [
      "--un-translate-x",
      "--un-translate-y",
      "--un-rotate",
      "--un-rotate-z",
      "--un-skew-x",
      "--un-skew-y",
      "--un-scale-x",
      "--un-scale-y"
    ] } }
  ],
  [
    "transform-gpu",
    { transform: transformGpu },
    { custom: { preflightKeys } }
  ],
  ["transform-none", { transform: "none" }],
  ...makeGlobalStaticRules("transform")
];
function handleTranslate([, d, b], { theme: theme4 }) {
  var _a;
  const v = ((_a = theme4.spacing) == null ? void 0 : _a[b]) ?? h.bracket.cssvar.fraction.rem(b);
  if (v != null) return [...transformXYZ(d, v, "translate"), ["transform", transform]];
}
function handleScale([, d, b]) {
  const v = h.bracket.cssvar.fraction.percent(b);
  if (v != null) return [...transformXYZ(d, v, "scale"), ["transform", transform]];
}
function handleRotate([, d = "", b]) {
  const v = h.bracket.cssvar.degree(b);
  if (v != null) if (d) return {
    "--un-rotate": 0,
    [`--un-rotate-${d}`]: v,
    "transform": transform
  };
  else return {
    "--un-rotate-x": 0,
    "--un-rotate-y": 0,
    "--un-rotate-z": 0,
    "--un-rotate": v,
    "transform": transform
  };
}
function handleSkew([, d, b]) {
  const v = h.bracket.cssvar.degree(b);
  if (v != null) return [...transformXYZ(d, v, "skew"), ["transform", transform]];
}
function resolveTransitionProperty(prop, theme4) {
  let p;
  if (h.cssvar(prop) != null) p = h.cssvar(prop);
  else {
    if (prop.startsWith("[") && prop.endsWith("]")) prop = prop.slice(1, -1);
    const props = prop.split(",").map((p$1) => {
      var _a;
      return ((_a = theme4.transitionProperty) == null ? void 0 : _a[p$1]) ?? h.properties(p$1);
    });
    if (props.every(Boolean)) p = props.join(",");
  }
  return p;
}
var transitions = [
  [
    /^transition(?:-(\D+?))?(?:-(\d+))?$/,
    ([, prop, d], { theme: theme4 }) => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      if (!prop && !d) return {
        "transition-property": (_a = theme4.transitionProperty) == null ? void 0 : _a.DEFAULT,
        "transition-timing-function": (_b = theme4.easing) == null ? void 0 : _b.DEFAULT,
        "transition-duration": ((_c = theme4.duration) == null ? void 0 : _c.DEFAULT) ?? h.time("150")
      };
      else if (prop != null) {
        const p = resolveTransitionProperty(prop, theme4);
        const duration2 = ((_d = theme4.duration) == null ? void 0 : _d[d || "DEFAULT"]) ?? h.time(d || "150");
        if (p) return {
          "transition-property": p,
          "transition-timing-function": (_e = theme4.easing) == null ? void 0 : _e.DEFAULT,
          "transition-duration": duration2
        };
      } else if (d != null) return {
        "transition-property": (_f = theme4.transitionProperty) == null ? void 0 : _f.DEFAULT,
        "transition-timing-function": (_g = theme4.easing) == null ? void 0 : _g.DEFAULT,
        "transition-duration": ((_h = theme4.duration) == null ? void 0 : _h[d]) ?? h.time(d)
      };
    },
    { autocomplete: "transition-$transitionProperty-$duration" }
  ],
  [
    /^(?:transition-)?duration-(.+)$/,
    ([, d], { theme: theme4 }) => {
      var _a;
      return { "transition-duration": ((_a = theme4.duration) == null ? void 0 : _a[d || "DEFAULT"]) ?? h.bracket.cssvar.time(d) };
    },
    { autocomplete: ["transition-duration-$duration", "duration-$duration"] }
  ],
  [
    /^(?:transition-)?delay-(.+)$/,
    ([, d], { theme: theme4 }) => {
      var _a;
      return { "transition-delay": ((_a = theme4.duration) == null ? void 0 : _a[d || "DEFAULT"]) ?? h.bracket.cssvar.time(d) };
    },
    { autocomplete: ["transition-delay-$duration", "delay-$duration"] }
  ],
  [
    /^(?:transition-)?ease(?:-(.+))?$/,
    ([, d], { theme: theme4 }) => {
      var _a;
      return { "transition-timing-function": ((_a = theme4.easing) == null ? void 0 : _a[d || "DEFAULT"]) ?? h.bracket.cssvar(d) };
    },
    { autocomplete: ["transition-ease-(linear|in|out|in-out|DEFAULT)", "ease-(linear|in|out|in-out|DEFAULT)"] }
  ],
  [
    /^(?:transition-)?property-(.+)$/,
    ([, v], { theme: theme4 }) => {
      const p = h.global(v) || resolveTransitionProperty(v, theme4);
      if (p) return { "transition-property": p };
    },
    { autocomplete: [
      `transition-property-(${[...globalKeywords].join("|")})`,
      "transition-property-$transitionProperty",
      "property-$transitionProperty"
    ] }
  ],
  ["transition-none", { transition: "none" }],
  ...makeGlobalStaticRules("transition"),
  ["transition-discrete", { "transition-behavior": "allow-discrete" }],
  ["transition-normal", { "transition-behavior": "normal" }]
];
var fonts = [
  [
    /^text-(.+)$/,
    handleText,
    { autocomplete: "text-$fontSize" }
  ],
  [
    /^(?:text|font)-size-(.+)$/,
    handleSize,
    { autocomplete: "text-size-$fontSize" }
  ],
  [
    /^text-(?:color-)?(.+)$/,
    handlerColorOrSize,
    { autocomplete: "text-$colors" }
  ],
  [
    /^(?:color|c)-(.+)$/,
    colorResolver("color", "text", "textColor"),
    { autocomplete: "(color|c)-$colors" }
  ],
  [
    /^(?:text|color|c)-(.+)$/,
    ([, v]) => globalKeywords.includes(v) ? { color: v } : void 0,
    { autocomplete: `(text|color|c)-(${globalKeywords.join("|")})` }
  ],
  [
    /^(?:text|color|c)-op(?:acity)?-?(.+)$/,
    ([, opacity$1]) => ({ "--un-text-opacity": h.bracket.percent.cssvar(opacity$1) }),
    { autocomplete: "(text|color|c)-(op|opacity)-<percent>" }
  ],
  [
    /^(?:font|fw)-?([^-]+)$/,
    ([, s], { theme: theme4 }) => {
      var _a;
      return { "font-weight": ((_a = theme4.fontWeight) == null ? void 0 : _a[s]) || h.bracket.global.number(s) };
    },
    { autocomplete: ["(font|fw)-(100|200|300|400|500|600|700|800|900)", "(font|fw)-$fontWeight"] }
  ],
  [
    /^(?:font-)?(?:leading|lh|line-height)-(.+)$/,
    ([, s], { theme: theme4 }) => ({ "line-height": handleThemeByKey(s, theme4, "lineHeight") }),
    { autocomplete: "(leading|lh|line-height)-$lineHeight" }
  ],
  ["font-synthesis-weight", { "font-synthesis": "weight" }],
  ["font-synthesis-style", { "font-synthesis": "style" }],
  ["font-synthesis-small-caps", { "font-synthesis": "small-caps" }],
  ["font-synthesis-none", { "font-synthesis": "none" }],
  [/^font-synthesis-(.+)$/, ([, s]) => ({ "font-synthesis": h.bracket.cssvar.global(s) })],
  [
    /^(?:font-)?tracking-(.+)$/,
    ([, s], { theme: theme4 }) => {
      var _a;
      return { "letter-spacing": ((_a = theme4.letterSpacing) == null ? void 0 : _a[s]) || h.bracket.cssvar.global.rem(s) };
    },
    { autocomplete: "tracking-$letterSpacing" }
  ],
  [
    /^(?:font-)?word-spacing-(.+)$/,
    ([, s], { theme: theme4 }) => {
      var _a;
      return { "word-spacing": ((_a = theme4.wordSpacing) == null ? void 0 : _a[s]) || h.bracket.cssvar.global.rem(s) };
    },
    { autocomplete: "word-spacing-$wordSpacing" }
  ],
  ["font-stretch-normal", { "font-stretch": "normal" }],
  ["font-stretch-ultra-condensed", { "font-stretch": "ultra-condensed" }],
  ["font-stretch-extra-condensed", { "font-stretch": "extra-condensed" }],
  ["font-stretch-condensed", { "font-stretch": "condensed" }],
  ["font-stretch-semi-condensed", { "font-stretch": "semi-condensed" }],
  ["font-stretch-semi-expanded", { "font-stretch": "semi-expanded" }],
  ["font-stretch-expanded", { "font-stretch": "expanded" }],
  ["font-stretch-extra-expanded", { "font-stretch": "extra-expanded" }],
  ["font-stretch-ultra-expanded", { "font-stretch": "ultra-expanded" }],
  [
    /^font-stretch-(.+)$/,
    ([, s]) => ({ "font-stretch": h.bracket.cssvar.fraction.global(s) }),
    { autocomplete: "font-stretch-<percentage>" }
  ],
  [
    /^font-(.+)$/,
    ([, d], { theme: theme4 }) => {
      var _a;
      return { "font-family": ((_a = theme4.fontFamily) == null ? void 0 : _a[d]) || h.bracket.cssvar.global(d) };
    },
    { autocomplete: "font-$fontFamily" }
  ]
];
var tabSizes = [[/^tab(?:-(.+))?$/, ([, s]) => {
  const v = h.bracket.cssvar.global.number(s || "4");
  if (v != null) return {
    "-moz-tab-size": v,
    "-o-tab-size": v,
    "tab-size": v
  };
}]];
var textIndents = [[
  /^indent(?:-(.+))?$/,
  ([, s], { theme: theme4 }) => {
    var _a;
    return { "text-indent": ((_a = theme4.textIndent) == null ? void 0 : _a[s || "DEFAULT"]) || h.bracket.cssvar.global.fraction.rem(s) };
  },
  { autocomplete: "indent-$textIndent" }
]];
var textStrokes = [
  [
    /^text-stroke(?:-(.+))?$/,
    ([, s], { theme: theme4 }) => {
      var _a;
      return { "-webkit-text-stroke-width": ((_a = theme4.textStrokeWidth) == null ? void 0 : _a[s || "DEFAULT"]) || h.bracket.cssvar.px(s) };
    },
    { autocomplete: "text-stroke-$textStrokeWidth" }
  ],
  [
    /^text-stroke-(.+)$/,
    colorResolver("-webkit-text-stroke-color", "text-stroke", "borderColor"),
    { autocomplete: "text-stroke-$colors" }
  ],
  [
    /^text-stroke-op(?:acity)?-?(.+)$/,
    ([, opacity$1]) => ({ "--un-text-stroke-opacity": h.bracket.percent.cssvar(opacity$1) }),
    { autocomplete: "text-stroke-(op|opacity)-<percent>" }
  ]
];
var textShadows = [
  [
    /^text-shadow(?:-(.+))?$/,
    ([, s], { theme: theme4 }) => {
      var _a;
      const v = (_a = theme4.textShadow) == null ? void 0 : _a[s || "DEFAULT"];
      if (v != null) return {
        "--un-text-shadow": colorableShadows(v, "--un-text-shadow-color").join(","),
        "text-shadow": "var(--un-text-shadow)"
      };
      return { "text-shadow": h.bracket.cssvar.global(s) };
    },
    { autocomplete: "text-shadow-$textShadow" }
  ],
  [
    /^text-shadow-color-(.+)$/,
    colorResolver("--un-text-shadow-color", "text-shadow", "shadowColor"),
    { autocomplete: "text-shadow-color-$colors" }
  ],
  [
    /^text-shadow-color-op(?:acity)?-?(.+)$/,
    ([, opacity$1]) => ({ "--un-text-shadow-opacity": h.bracket.percent.cssvar(opacity$1) }),
    { autocomplete: "text-shadow-color-(op|opacity)-<percent>" }
  ]
];
function handleThemeByKey(s, theme4, key) {
  var _a;
  return ((_a = theme4[key]) == null ? void 0 : _a[s]) || h.bracket.cssvar.global.rem(s);
}
function handleSize([, s], { theme: theme4 }) {
  var _a, _b;
  const size = ((_b = toArray((_a = theme4.fontSize) == null ? void 0 : _a[s])) == null ? void 0 : _b[0]) ?? h.bracket.cssvar.global.rem(s);
  if (size != null) return { "font-size": size };
}
function handlerColorOrSize(match, ctx) {
  if (isCSSMathFn(h.bracket(match[1]))) return handleSize(match, ctx);
  return colorResolver("color", "text", "textColor")(match, ctx);
}
function handleText([, s = "base"], { theme: theme4 }) {
  var _a;
  const split = splitShorthand(s, "length");
  if (!split) return;
  const [size, leading2] = split;
  const sizePairs = toArray((_a = theme4.fontSize) == null ? void 0 : _a[size]);
  const lineHeight2 = leading2 ? handleThemeByKey(leading2, theme4, "lineHeight") : void 0;
  if (sizePairs == null ? void 0 : sizePairs[0]) {
    const [fontSize$1, height2, letterSpacing2] = sizePairs;
    if (typeof height2 === "object") return {
      "font-size": fontSize$1,
      ...height2
    };
    return {
      "font-size": fontSize$1,
      "line-height": lineHeight2 ?? height2 ?? "1",
      "letter-spacing": letterSpacing2 ? handleThemeByKey(letterSpacing2, theme4, "letterSpacing") : void 0
    };
  }
  const fontSize2 = h.bracketOfLength.rem(size);
  if (lineHeight2 && fontSize2) return {
    "font-size": fontSize2,
    "line-height": lineHeight2
  };
  return { "font-size": h.bracketOfLength.rem(s) };
}
var variablesAbbrMap = {
  backface: "backface-visibility",
  break: "word-break",
  case: "text-transform",
  content: "align-content",
  fw: "font-weight",
  items: "align-items",
  justify: "justify-content",
  select: "user-select",
  self: "align-self",
  vertical: "vertical-align",
  visible: "visibility",
  whitespace: "white-space",
  ws: "white-space"
};
var cssVariables = [[/^(.+?)-(\$.+)$/, ([, name50, varname]) => {
  const prop = variablesAbbrMap[name50];
  if (prop) return { [prop]: h.cssvar(varname) };
}]];
var cssProperty = [[/^\[(.*)\]$/, ([_, body]) => {
  if (!body.includes(":")) return;
  const [prop, ...rest] = body.split(":");
  const value = rest.join(":");
  if (!isURI(body) && /^[\w-]+$/.test(prop) && isValidCSSBody(value)) {
    const parsed = h.bracket(`[${value}]`);
    if (parsed) return { [prop]: parsed };
  }
}]];
function isValidCSSBody(body) {
  let i = 0;
  function findUntil(c) {
    while (i < body.length) {
      i += 1;
      if (body[i] === c) return true;
    }
    return false;
  }
  for (i = 0; i < body.length; i++) {
    const c = body[i];
    if ("\"`'".includes(c)) {
      if (!findUntil(c)) return false;
    } else if (c === "(") {
      if (!findUntil(")")) return false;
    } else if ("[]{}:".includes(c)) return false;
  }
  return true;
}
function isURI(declaration) {
  if (!declaration.includes("://")) return false;
  try {
    return new URL(declaration).host !== "";
  } catch {
    return false;
  }
}
var rules = [
  cssVariables,
  cssProperty,
  contains,
  pointerEvents,
  appearances,
  positions,
  insets,
  zIndexes,
  orders,
  grids,
  floats,
  margins,
  boxSizing,
  displays,
  aspectRatio,
  sizes,
  flex,
  transforms,
  cursors,
  userSelects,
  resizes,
  appearance,
  placements,
  alignments,
  justifies,
  gaps,
  flexGridJustifiesAlignments,
  overflows,
  textOverflows,
  whitespaces,
  breaks,
  borders,
  bgColors,
  colorScheme,
  svgUtilities,
  paddings,
  textAligns,
  textIndents,
  textWraps,
  verticalAligns,
  fonts,
  textTransforms,
  fontStyles,
  textDecorations,
  fontSmoothings,
  tabSizes,
  textStrokes,
  textShadows,
  opacity,
  boxShadows,
  outline,
  rings,
  transitions,
  willChange,
  contentVisibility,
  contents,
  containerParent,
  fieldSizing,
  questionMark
].flat(1);

// node_modules/@unocss/preset-mini/dist/colors-Cxq9P2g9.mjs
var colors = {
  inherit: "inherit",
  current: "currentColor",
  transparent: "transparent",
  black: "#000",
  white: "#fff",
  rose: {
    50: "#fff1f2",
    100: "#ffe4e6",
    200: "#fecdd3",
    300: "#fda4af",
    400: "#fb7185",
    500: "#f43f5e",
    600: "#e11d48",
    700: "#be123c",
    800: "#9f1239",
    900: "#881337",
    950: "#4c0519"
  },
  pink: {
    50: "#fdf2f8",
    100: "#fce7f3",
    200: "#fbcfe8",
    300: "#f9a8d4",
    400: "#f472b6",
    500: "#ec4899",
    600: "#db2777",
    700: "#be185d",
    800: "#9d174d",
    900: "#831843",
    950: "#500724"
  },
  fuchsia: {
    50: "#fdf4ff",
    100: "#fae8ff",
    200: "#f5d0fe",
    300: "#f0abfc",
    400: "#e879f9",
    500: "#d946ef",
    600: "#c026d3",
    700: "#a21caf",
    800: "#86198f",
    900: "#701a75",
    950: "#4a044e"
  },
  purple: {
    50: "#faf5ff",
    100: "#f3e8ff",
    200: "#e9d5ff",
    300: "#d8b4fe",
    400: "#c084fc",
    500: "#a855f7",
    600: "#9333ea",
    700: "#7e22ce",
    800: "#6b21a8",
    900: "#581c87",
    950: "#3b0764"
  },
  violet: {
    50: "#f5f3ff",
    100: "#ede9fe",
    200: "#ddd6fe",
    300: "#c4b5fd",
    400: "#a78bfa",
    500: "#8b5cf6",
    600: "#7c3aed",
    700: "#6d28d9",
    800: "#5b21b6",
    900: "#4c1d95",
    950: "#2e1065"
  },
  indigo: {
    50: "#eef2ff",
    100: "#e0e7ff",
    200: "#c7d2fe",
    300: "#a5b4fc",
    400: "#818cf8",
    500: "#6366f1",
    600: "#4f46e5",
    700: "#4338ca",
    800: "#3730a3",
    900: "#312e81",
    950: "#1e1b4b"
  },
  blue: {
    50: "#eff6ff",
    100: "#dbeafe",
    200: "#bfdbfe",
    300: "#93c5fd",
    400: "#60a5fa",
    500: "#3b82f6",
    600: "#2563eb",
    700: "#1d4ed8",
    800: "#1e40af",
    900: "#1e3a8a",
    950: "#172554"
  },
  sky: {
    50: "#f0f9ff",
    100: "#e0f2fe",
    200: "#bae6fd",
    300: "#7dd3fc",
    400: "#38bdf8",
    500: "#0ea5e9",
    600: "#0284c7",
    700: "#0369a1",
    800: "#075985",
    900: "#0c4a6e",
    950: "#082f49"
  },
  cyan: {
    50: "#ecfeff",
    100: "#cffafe",
    200: "#a5f3fc",
    300: "#67e8f9",
    400: "#22d3ee",
    500: "#06b6d4",
    600: "#0891b2",
    700: "#0e7490",
    800: "#155e75",
    900: "#164e63",
    950: "#083344"
  },
  teal: {
    50: "#f0fdfa",
    100: "#ccfbf1",
    200: "#99f6e4",
    300: "#5eead4",
    400: "#2dd4bf",
    500: "#14b8a6",
    600: "#0d9488",
    700: "#0f766e",
    800: "#115e59",
    900: "#134e4a",
    950: "#042f2e"
  },
  emerald: {
    50: "#ecfdf5",
    100: "#d1fae5",
    200: "#a7f3d0",
    300: "#6ee7b7",
    400: "#34d399",
    500: "#10b981",
    600: "#059669",
    700: "#047857",
    800: "#065f46",
    900: "#064e3b",
    950: "#022c22"
  },
  green: {
    50: "#f0fdf4",
    100: "#dcfce7",
    200: "#bbf7d0",
    300: "#86efac",
    400: "#4ade80",
    500: "#22c55e",
    600: "#16a34a",
    700: "#15803d",
    800: "#166534",
    900: "#14532d",
    950: "#052e16"
  },
  lime: {
    50: "#f7fee7",
    100: "#ecfccb",
    200: "#d9f99d",
    300: "#bef264",
    400: "#a3e635",
    500: "#84cc16",
    600: "#65a30d",
    700: "#4d7c0f",
    800: "#3f6212",
    900: "#365314",
    950: "#1a2e05"
  },
  yellow: {
    50: "#fefce8",
    100: "#fef9c3",
    200: "#fef08a",
    300: "#fde047",
    400: "#facc15",
    500: "#eab308",
    600: "#ca8a04",
    700: "#a16207",
    800: "#854d0e",
    900: "#713f12",
    950: "#422006"
  },
  amber: {
    50: "#fffbeb",
    100: "#fef3c7",
    200: "#fde68a",
    300: "#fcd34d",
    400: "#fbbf24",
    500: "#f59e0b",
    600: "#d97706",
    700: "#b45309",
    800: "#92400e",
    900: "#78350f",
    950: "#451a03"
  },
  orange: {
    50: "#fff7ed",
    100: "#ffedd5",
    200: "#fed7aa",
    300: "#fdba74",
    400: "#fb923c",
    500: "#f97316",
    600: "#ea580c",
    700: "#c2410c",
    800: "#9a3412",
    900: "#7c2d12",
    950: "#431407"
  },
  red: {
    50: "#fef2f2",
    100: "#fee2e2",
    200: "#fecaca",
    300: "#fca5a5",
    400: "#f87171",
    500: "#ef4444",
    600: "#dc2626",
    700: "#b91c1c",
    800: "#991b1b",
    900: "#7f1d1d",
    950: "#450a0a"
  },
  gray: {
    50: "#f9fafb",
    100: "#f3f4f6",
    200: "#e5e7eb",
    300: "#d1d5db",
    400: "#9ca3af",
    500: "#6b7280",
    600: "#4b5563",
    700: "#374151",
    800: "#1f2937",
    900: "#111827",
    950: "#030712"
  },
  slate: {
    50: "#f8fafc",
    100: "#f1f5f9",
    200: "#e2e8f0",
    300: "#cbd5e1",
    400: "#94a3b8",
    500: "#64748b",
    600: "#475569",
    700: "#334155",
    800: "#1e293b",
    900: "#0f172a",
    950: "#020617"
  },
  zinc: {
    50: "#fafafa",
    100: "#f4f4f5",
    200: "#e4e4e7",
    300: "#d4d4d8",
    400: "#a1a1aa",
    500: "#71717a",
    600: "#52525b",
    700: "#3f3f46",
    800: "#27272a",
    900: "#18181b",
    950: "#09090b"
  },
  neutral: {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#e5e5e5",
    300: "#d4d4d4",
    400: "#a3a3a3",
    500: "#737373",
    600: "#525252",
    700: "#404040",
    800: "#262626",
    900: "#171717",
    950: "#0a0a0a"
  },
  stone: {
    50: "#fafaf9",
    100: "#f5f5f4",
    200: "#e7e5e4",
    300: "#d6d3d1",
    400: "#a8a29e",
    500: "#78716c",
    600: "#57534e",
    700: "#44403c",
    800: "#292524",
    900: "#1c1917",
    950: "#0c0a09"
  },
  light: {
    50: "#fdfdfd",
    100: "#fcfcfc",
    200: "#fafafa",
    300: "#f8f9fa",
    400: "#f6f6f6",
    500: "#f2f2f2",
    600: "#f1f3f5",
    700: "#e9ecef",
    800: "#dee2e6",
    900: "#dde1e3",
    950: "#d8dcdf"
  },
  dark: {
    50: "#4a4a4a",
    100: "#3c3c3c",
    200: "#323232",
    300: "#2d2d2d",
    400: "#222222",
    500: "#1f1f1f",
    600: "#1c1c1e",
    700: "#1b1b1b",
    800: "#181818",
    900: "#0f0f0f",
    950: "#080808"
  },
  get lightblue() {
    return this.sky;
  },
  get lightBlue() {
    return this.sky;
  },
  get warmgray() {
    return this.stone;
  },
  get warmGray() {
    return this.stone;
  },
  get truegray() {
    return this.neutral;
  },
  get trueGray() {
    return this.neutral;
  },
  get coolgray() {
    return this.gray;
  },
  get coolGray() {
    return this.gray;
  },
  get bluegray() {
    return this.slate;
  },
  get blueGray() {
    return this.slate;
  }
};
Object.values(colors).forEach((color) => {
  if (typeof color !== "string" && color !== void 0) {
    color.DEFAULT = color.DEFAULT || color[400];
    Object.keys(color).forEach((key) => {
      const short = +key / 100;
      if (short === Math.round(short)) color[short] = color[key];
    });
  }
});

// node_modules/@unocss/preset-mini/dist/theme-B2Jp9h34.mjs
var blur = {
  "DEFAULT": "8px",
  "0": "0",
  "sm": "4px",
  "md": "12px",
  "lg": "16px",
  "xl": "24px",
  "2xl": "40px",
  "3xl": "64px"
};
var dropShadow = {
  "DEFAULT": ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
  "sm": "0 1px 1px rgb(0 0 0 / 0.05)",
  "md": ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
  "lg": ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
  "xl": ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
  "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
  "none": "0 0 rgb(0 0 0 / 0)"
};
var fontFamily = {
  sans: [
    "ui-sans-serif",
    "system-ui",
    "-apple-system",
    "BlinkMacSystemFont",
    '"Segoe UI"',
    "Roboto",
    '"Helvetica Neue"',
    "Arial",
    '"Noto Sans"',
    "sans-serif",
    '"Apple Color Emoji"',
    '"Segoe UI Emoji"',
    '"Segoe UI Symbol"',
    '"Noto Color Emoji"'
  ].join(","),
  serif: [
    "ui-serif",
    "Georgia",
    "Cambria",
    '"Times New Roman"',
    "Times",
    "serif"
  ].join(","),
  mono: [
    "ui-monospace",
    "SFMono-Regular",
    "Menlo",
    "Monaco",
    "Consolas",
    '"Liberation Mono"',
    '"Courier New"',
    "monospace"
  ].join(",")
};
var fontSize = {
  "xs": ["0.75rem", "1rem"],
  "sm": ["0.875rem", "1.25rem"],
  "base": ["1rem", "1.5rem"],
  "lg": ["1.125rem", "1.75rem"],
  "xl": ["1.25rem", "1.75rem"],
  "2xl": ["1.5rem", "2rem"],
  "3xl": ["1.875rem", "2.25rem"],
  "4xl": ["2.25rem", "2.5rem"],
  "5xl": ["3rem", "1"],
  "6xl": ["3.75rem", "1"],
  "7xl": ["4.5rem", "1"],
  "8xl": ["6rem", "1"],
  "9xl": ["8rem", "1"]
};
var textIndent = {
  "DEFAULT": "1.5rem",
  "xs": "0.5rem",
  "sm": "1rem",
  "md": "1.5rem",
  "lg": "2rem",
  "xl": "2.5rem",
  "2xl": "3rem",
  "3xl": "4rem"
};
var textStrokeWidth = {
  DEFAULT: "1.5rem",
  none: "0",
  sm: "thin",
  md: "medium",
  lg: "thick"
};
var textShadow = {
  DEFAULT: ["0 0 1px rgb(0 0 0 / 0.2)", "0 0 1px rgb(1 0 5 / 0.1)"],
  none: "0 0 rgb(0 0 0 / 0)",
  sm: "1px 1px 3px rgb(36 37 47 / 0.25)",
  md: ["0 1px 2px rgb(30 29 39 / 0.19)", "1px 2px 4px rgb(54 64 147 / 0.18)"],
  lg: ["3px 3px 6px rgb(0 0 0 / 0.26)", "0 0 5px rgb(15 3 86 / 0.22)"],
  xl: ["1px 1px 3px rgb(0 0 0 / 0.29)", "2px 4px 7px rgb(73 64 125 / 0.35)"]
};
var lineHeight = {
  none: "1",
  tight: "1.25",
  snug: "1.375",
  normal: "1.5",
  relaxed: "1.625",
  loose: "2"
};
var letterSpacing = {
  tighter: "-0.05em",
  tight: "-0.025em",
  normal: "0em",
  wide: "0.025em",
  wider: "0.05em",
  widest: "0.1em"
};
var fontWeight = {
  thin: "100",
  extralight: "200",
  light: "300",
  normal: "400",
  medium: "500",
  semibold: "600",
  bold: "700",
  extrabold: "800",
  black: "900"
};
var wordSpacing = letterSpacing;
var breakpoints = {
  "sm": "640px",
  "md": "768px",
  "lg": "1024px",
  "xl": "1280px",
  "2xl": "1536px"
};
var verticalBreakpoints = { ...breakpoints };
var lineWidth = {
  DEFAULT: "1px",
  none: "0"
};
var spacing = {
  "DEFAULT": "1rem",
  "none": "0",
  "xs": "0.75rem",
  "sm": "0.875rem",
  "lg": "1.125rem",
  "xl": "1.25rem",
  "2xl": "1.5rem",
  "3xl": "1.875rem",
  "4xl": "2.25rem",
  "5xl": "3rem",
  "6xl": "3.75rem",
  "7xl": "4.5rem",
  "8xl": "6rem",
  "9xl": "8rem"
};
var duration = {
  DEFAULT: "150ms",
  none: "0s",
  75: "75ms",
  100: "100ms",
  150: "150ms",
  200: "200ms",
  300: "300ms",
  500: "500ms",
  700: "700ms",
  1e3: "1000ms"
};
var borderRadius = {
  "DEFAULT": "0.25rem",
  "none": "0",
  "sm": "0.125rem",
  "md": "0.375rem",
  "lg": "0.5rem",
  "xl": "0.75rem",
  "2xl": "1rem",
  "3xl": "1.5rem",
  "full": "9999px"
};
var boxShadow = {
  "DEFAULT": ["var(--un-shadow-inset) 0 1px 3px 0 rgb(0 0 0 / 0.1)", "var(--un-shadow-inset) 0 1px 2px -1px rgb(0 0 0 / 0.1)"],
  "none": "0 0 rgb(0 0 0 / 0)",
  "sm": "var(--un-shadow-inset) 0 1px 2px 0 rgb(0 0 0 / 0.05)",
  "md": ["var(--un-shadow-inset) 0 4px 6px -1px rgb(0 0 0 / 0.1)", "var(--un-shadow-inset) 0 2px 4px -2px rgb(0 0 0 / 0.1)"],
  "lg": ["var(--un-shadow-inset) 0 10px 15px -3px rgb(0 0 0 / 0.1)", "var(--un-shadow-inset) 0 4px 6px -4px rgb(0 0 0 / 0.1)"],
  "xl": ["var(--un-shadow-inset) 0 20px 25px -5px rgb(0 0 0 / 0.1)", "var(--un-shadow-inset) 0 8px 10px -6px rgb(0 0 0 / 0.1)"],
  "2xl": "var(--un-shadow-inset) 0 25px 50px -12px rgb(0 0 0 / 0.25)",
  "inner": "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)"
};
var ringWidth = {
  DEFAULT: "3px",
  none: "0"
};
var zIndex = { auto: "auto" };
var media = { mouse: "(hover) and (pointer: fine)" };
var preflightBase = {
  ...transformBase,
  ...boxShadowsBase,
  ...ringBase
};
var baseSize = {
  "xs": "20rem",
  "sm": "24rem",
  "md": "28rem",
  "lg": "32rem",
  "xl": "36rem",
  "2xl": "42rem",
  "3xl": "48rem",
  "4xl": "56rem",
  "5xl": "64rem",
  "6xl": "72rem",
  "7xl": "80rem",
  "prose": "65ch"
};
var width = {
  auto: "auto",
  ...baseSize,
  screen: "100vw"
};
var maxWidth = {
  none: "none",
  ...baseSize,
  screen: "100vw"
};
var blockSize = {
  auto: "auto",
  ...baseSize,
  screen: "100vb"
};
var inlineSize = {
  auto: "auto",
  ...baseSize,
  screen: "100vi"
};
var height = {
  auto: "auto",
  ...baseSize,
  screen: "100vh"
};
var maxHeight = {
  none: "none",
  ...baseSize,
  screen: "100vh"
};
var maxBlockSize = {
  none: "none",
  ...baseSize,
  screen: "100vb"
};
var maxInlineSize = {
  none: "none",
  ...baseSize,
  screen: "100vi"
};
var containers = { ...baseSize };
var easing = {
  "DEFAULT": "cubic-bezier(0.4, 0, 0.2, 1)",
  "linear": "linear",
  "in": "cubic-bezier(0.4, 0, 1, 1)",
  "out": "cubic-bezier(0, 0, 0.2, 1)",
  "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
};
var transitionProperty = {
  none: "none",
  all: "all",
  colors: [
    "color",
    "background-color",
    "border-color",
    "text-decoration-color",
    "fill",
    "stroke"
  ].join(","),
  opacity: "opacity",
  shadow: "box-shadow",
  transform: "transform",
  get DEFAULT() {
    return [
      this.colors,
      "opacity",
      "box-shadow",
      "transform",
      "filter",
      "backdrop-filter"
    ].join(",");
  }
};
var theme = {
  width,
  height,
  maxWidth,
  maxHeight,
  minWidth: maxWidth,
  minHeight: maxHeight,
  inlineSize,
  blockSize,
  maxInlineSize,
  maxBlockSize,
  minInlineSize: maxInlineSize,
  minBlockSize: maxBlockSize,
  colors,
  fontFamily,
  fontSize,
  fontWeight,
  breakpoints,
  verticalBreakpoints,
  borderRadius,
  lineHeight,
  letterSpacing,
  wordSpacing,
  boxShadow,
  textIndent,
  textShadow,
  textStrokeWidth,
  blur,
  dropShadow,
  easing,
  transitionProperty,
  lineWidth,
  spacing,
  duration,
  ringWidth,
  preflightBase,
  containers,
  zIndex,
  media
};

// node_modules/@unocss/preset-mini/dist/variants.mjs
var variantAria = {
  name: "aria",
  match(matcher, ctx) {
    var _a;
    const variant = (0, utils_exports.variantGetParameter)("aria-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const aria2 = h.bracket(match) ?? ((_a = ctx.theme.aria) == null ? void 0 : _a[match]) ?? "";
      if (aria2) return {
        matcher: rest,
        selector: (s) => `${s}[aria-${aria2}]`
      };
    }
  },
  multiPass: true
};
function taggedAria(tagName, combinator, options = {}) {
  return {
    name: `${tagName}-aria`,
    match(matcher, ctx) {
      var _a;
      const variant = (0, utils_exports.variantGetParameter)(`${tagName}-aria-`, matcher, ctx.generator.config.separators);
      if (variant) {
        const [match, rest, label] = variant;
        const ariaAttribute = h.bracket(match) ?? ((_a = ctx.theme.aria) == null ? void 0 : _a[match]) ?? "";
        if (ariaAttribute) {
          const attributify = !!(options == null ? void 0 : options.attributifyPseudo);
          let firstPrefix = (options == null ? void 0 : options.prefix) ?? "";
          firstPrefix = (Array.isArray(firstPrefix) ? firstPrefix : [firstPrefix]).filter(Boolean)[0] ?? "";
          const parent = `${attributify ? `[${firstPrefix}${tagName}=""]` : `.${firstPrefix}${tagName}`}`;
          const escapedLabel = escapeSelector(label ? `/${label}` : "");
          return {
            matcher: rest,
            handle: (input, next) => {
              const regexp = new RegExp(`${escapeRegExp(parent)}${escapeRegExp(escapedLabel)}(?:\\[.+?\\])+`);
              const match$1 = input.prefix.match(regexp);
              let nextPrefix;
              if (match$1) {
                const insertIndex = (match$1.index ?? 0) + parent.length + escapedLabel.length;
                nextPrefix = [
                  input.prefix.slice(0, insertIndex),
                  `[aria-${ariaAttribute}]`,
                  input.prefix.slice(insertIndex)
                ].join("");
              } else {
                const prefixGroupIndex = Math.max(input.prefix.indexOf(parent), 0);
                nextPrefix = [
                  input.prefix.slice(0, prefixGroupIndex),
                  parent,
                  escapedLabel,
                  `[aria-${ariaAttribute}]`,
                  combinator,
                  input.prefix.slice(prefixGroupIndex)
                ].join("");
              }
              return next({
                ...input,
                prefix: nextPrefix
              });
            }
          };
        }
      }
    },
    multiPass: true
  };
}
function taggedHasAria() {
  return {
    name: "has-aria",
    match(matcher, ctx) {
      var _a;
      const variant = (0, utils_exports.variantGetParameter)("has-aria-", matcher, ctx.generator.config.separators);
      if (variant) {
        const [match, rest] = variant;
        const ariaAttribute = h.bracket(match) ?? ((_a = ctx.theme.aria) == null ? void 0 : _a[match]) ?? "";
        if (ariaAttribute) return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            pseudo: `${input.pseudo}:has([aria-${ariaAttribute}])`
          })
        };
      }
    },
    multiPass: true
  };
}
function variantTaggedAriaAttributes(options = {}) {
  return [
    taggedAria("group", " ", options),
    taggedAria("peer", "~", options),
    taggedAria("parent", ">", options),
    taggedAria("previous", "+", options),
    taggedHasAria()
  ];
}
var sizePseudo = /(max|min)-\[([^\]]*)\]:/;
function variantBreakpoints() {
  const regexCache2 = {};
  return {
    name: "breakpoints",
    match(matcher, context) {
      if (sizePseudo.test(matcher)) {
        const match = matcher.match(sizePseudo);
        return {
          matcher: matcher.replace(match[0], ""),
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (${match[1]}-width: ${match[2]})`
          })
        };
      }
      const variantEntries = (resolveBreakpoints(context) ?? []).map(({ point, size }, idx) => [
        point,
        size,
        idx
      ]);
      for (const [point, size, idx] of variantEntries) {
        if (!regexCache2[point]) regexCache2[point] = new RegExp(`^((?:([al]t-|[<~]|max-))?${point}(?:${context.generator.config.separators.join("|")}))`);
        const match = matcher.match(regexCache2[point]);
        if (!match) continue;
        const [, pre] = match;
        const m = matcher.slice(pre.length);
        if (m === "container") continue;
        const isLtPrefix = pre.startsWith("lt-") || pre.startsWith("<") || pre.startsWith("max-");
        const isAtPrefix = pre.startsWith("at-") || pre.startsWith("~");
        let order = 3e3;
        if (isLtPrefix) {
          order -= idx + 1;
          return {
            matcher: m,
            handle: (input, next) => next({
              ...input,
              parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (max-width: ${(0, utils_exports.calcMaxWidthBySize)(size)})`,
              parentOrder: order
            })
          };
        }
        order += idx + 1;
        if (isAtPrefix && idx < variantEntries.length - 1) return {
          matcher: m,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (min-width: ${size}) and (max-width: ${(0, utils_exports.calcMaxWidthBySize)(variantEntries[idx + 1][1])})`,
            parentOrder: order
          })
        };
        return {
          matcher: m,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (min-width: ${size})`,
            parentOrder: order
          })
        };
      }
    },
    multiPass: true,
    autocomplete: "(at-|lt-|max-|)$breakpoints:"
  };
}
var variantChildren = [(0, utils_exports.variantMatcher)("*", (input) => ({ selector: `${input.selector} > *` }), { order: -1 })];
function scopeMatcher(name50, combinator) {
  return {
    name: `combinator:${name50}`,
    match(matcher, ctx) {
      if (!matcher.startsWith(name50)) return;
      const separators = ctx.generator.config.separators;
      let body = (0, utils_exports.variantGetBracket)(`${name50}-`, matcher, separators);
      if (!body) {
        for (const separator of separators) if (matcher.startsWith(`${name50}${separator}`)) {
          body = ["", matcher.slice(name50.length + separator.length)];
          break;
        }
        if (!body) return;
      }
      let bracketValue = h.bracket(body[0]) ?? "";
      if (bracketValue === "") bracketValue = "*";
      return {
        matcher: body[1],
        selector: (s) => `${s}${combinator}${bracketValue}`
      };
    },
    multiPass: true
  };
}
var variantCombinators = [
  scopeMatcher("all", " "),
  scopeMatcher("children", ">"),
  scopeMatcher("next", "+"),
  scopeMatcher("sibling", "+"),
  scopeMatcher("siblings", "~")
];
var variantContainerQuery = {
  name: "@",
  match(matcher, ctx) {
    var _a;
    if (matcher.startsWith("@container")) return;
    const variant = (0, utils_exports.variantGetParameter)("@", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest, label] = variant;
      const unbracket = h.bracket(match);
      let container4;
      if (unbracket) container4 = h.numberWithUnit(unbracket);
      else container4 = ((_a = ctx.theme.containers) == null ? void 0 : _a[match]) ?? "";
      if (container4) {
        let order = 1e3 + Object.keys(ctx.theme.containers ?? {}).indexOf(match);
        if (label) order += 1e3;
        return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@container${label ? ` ${label} ` : " "}(min-width: ${container4})`,
            parentOrder: order
          })
        };
      }
    }
  },
  multiPass: true
};
function variantColorsMediaOrClass(options = {}) {
  if ((options == null ? void 0 : options.dark) === "class" || typeof options.dark === "object") {
    const { dark = ".dark", light = ".light" } = typeof options.dark === "string" ? {} : options.dark;
    return [(0, utils_exports.variantMatcher)("dark", toArray(dark).map((dark$1) => (input) => ({ prefix: `${dark$1} $$ ${input.prefix}` }))), (0, utils_exports.variantMatcher)("light", toArray(light).map((light$1) => (input) => ({ prefix: `${light$1} $$ ${input.prefix}` })))];
  }
  return [(0, utils_exports.variantParentMatcher)("dark", "@media (prefers-color-scheme: dark)"), (0, utils_exports.variantParentMatcher)("light", "@media (prefers-color-scheme: light)")];
}
var variantDataAttribute = {
  name: "data",
  match(matcher, ctx) {
    var _a;
    const variant = (0, utils_exports.variantGetParameter)("data-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const dataAttribute = h.bracket(match) ?? ((_a = ctx.theme.data) == null ? void 0 : _a[match]) ?? "";
      if (dataAttribute) return {
        matcher: rest,
        selector: (s) => `${s}[data-${dataAttribute}]`
      };
    }
  },
  multiPass: true
};
function taggedData(tagName, combinator, options = {}) {
  return {
    name: `${tagName}-data`,
    match(matcher, ctx) {
      var _a;
      const variant = (0, utils_exports.variantGetParameter)(`${tagName}-data-`, matcher, ctx.generator.config.separators);
      if (variant) {
        const [match, rest, label] = variant;
        const dataAttribute = h.bracket(match) ?? ((_a = ctx.theme.data) == null ? void 0 : _a[match]) ?? "";
        if (dataAttribute) {
          const attributify = !!(options == null ? void 0 : options.attributifyPseudo);
          let firstPrefix = (options == null ? void 0 : options.prefix) ?? "";
          firstPrefix = (Array.isArray(firstPrefix) ? firstPrefix : [firstPrefix]).filter(Boolean)[0] ?? "";
          const parent = `${attributify ? `[${firstPrefix}${tagName}=""]` : `.${firstPrefix}${tagName}`}`;
          const escapedLabel = escapeSelector(label ? `/${label}` : "");
          return {
            matcher: rest,
            handle: (input, next) => {
              const regexp = new RegExp(`${escapeRegExp(parent)}${escapeRegExp(escapedLabel)}(?:\\[.+?\\])+`);
              const match$1 = input.prefix.match(regexp);
              let nextPrefix;
              if (match$1) {
                const insertIndex = (match$1.index ?? 0) + parent.length + escapedLabel.length;
                nextPrefix = [
                  input.prefix.slice(0, insertIndex),
                  `[data-${dataAttribute}]`,
                  input.prefix.slice(insertIndex)
                ].join("");
              } else {
                const prefixGroupIndex = Math.max(input.prefix.indexOf(parent), 0);
                nextPrefix = [
                  input.prefix.slice(0, prefixGroupIndex),
                  parent,
                  escapedLabel,
                  `[data-${dataAttribute}]`,
                  combinator,
                  input.prefix.slice(prefixGroupIndex)
                ].join("");
              }
              return next({
                ...input,
                prefix: nextPrefix
              });
            }
          };
        }
      }
    },
    multiPass: true
  };
}
function taggedHasData() {
  return {
    name: "has-data",
    match(matcher, ctx) {
      var _a;
      const variant = (0, utils_exports.variantGetParameter)("has-data-", matcher, ctx.generator.config.separators);
      if (variant) {
        const [match, rest] = variant;
        const dataAttribute = h.bracket(match) ?? ((_a = ctx.theme.data) == null ? void 0 : _a[match]) ?? "";
        if (dataAttribute) return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            pseudo: `${input.pseudo}:has([data-${dataAttribute}])`
          })
        };
      }
    },
    multiPass: true
  };
}
function variantTaggedDataAttributes(options = {}) {
  return [
    taggedData("group", " ", options),
    taggedData("peer", "~", options),
    taggedData("parent", ">", options),
    taggedData("previous", "+", options),
    taggedHasData()
  ];
}
var variantLanguageDirections = [(0, utils_exports.variantMatcher)("rtl", (input) => ({ prefix: `[dir="rtl"] $$ ${input.prefix}` })), (0, utils_exports.variantMatcher)("ltr", (input) => ({ prefix: `[dir="ltr"] $$ ${input.prefix}` }))];
function variantImportant() {
  let re;
  return {
    name: "important",
    match(matcher, ctx) {
      if (!re) re = new RegExp(`^(important(?:${ctx.generator.config.separators.join("|")})|!)`);
      let base;
      const match = matcher.match(re);
      if (match) base = matcher.slice(match[0].length);
      else if (matcher.endsWith("!")) base = matcher.slice(0, -1);
      if (base) return {
        matcher: base,
        body: (body) => {
          body.forEach((v) => {
            if (v[1] != null) v[1] += " !important";
          });
          return body;
        }
      };
    }
  };
}
var variantPrint = (0, utils_exports.variantParentMatcher)("print", "@media print");
var variantCustomMedia = {
  name: "media",
  match(matcher, ctx) {
    var _a;
    const variant = (0, utils_exports.variantGetParameter)("media-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      let media3 = h.bracket(match) ?? "";
      if (media3 === "") media3 = ((_a = ctx.theme.media) == null ? void 0 : _a[match]) ?? "";
      if (media3) return {
        matcher: rest,
        handle: (input, next) => next({
          ...input,
          parent: `${input.parent ? `${input.parent} $$ ` : ""}@media ${media3}`
        })
      };
    }
  },
  multiPass: true
};
var variantSelector = {
  name: "selector",
  match(matcher, ctx) {
    const variant = (0, utils_exports.variantGetBracket)("selector-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const selector2 = h.bracket(match);
      if (selector2) return {
        matcher: rest,
        selector: () => selector2
      };
    }
  }
};
var variantCssLayer = {
  name: "layer",
  match(matcher, ctx) {
    const variant = (0, utils_exports.variantGetParameter)("layer-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const layer = h.bracket(match) ?? match;
      if (layer) return {
        matcher: rest,
        handle: (input, next) => next({
          ...input,
          parent: `${input.parent ? `${input.parent} $$ ` : ""}@layer ${layer}`
        })
      };
    }
  }
};
var variantInternalLayer = {
  name: "uno-layer",
  match(matcher, ctx) {
    const variant = (0, utils_exports.variantGetParameter)("uno-layer-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const layer = h.bracket(match) ?? match;
      if (layer) return {
        matcher: rest,
        layer
      };
    }
  }
};
var variantScope = {
  name: "scope",
  match(matcher, ctx) {
    const variant = (0, utils_exports.variantGetBracket)("scope-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const scope = h.bracket(match);
      if (scope) return {
        matcher: rest,
        selector: (s) => `${scope} $$ ${s}`
      };
    }
  }
};
var variantVariables = {
  name: "variables",
  match(matcher, ctx) {
    if (!matcher.startsWith("[")) return;
    const [match, rest] = (0, utils_exports.getBracket)(matcher, "[", "]") ?? [];
    if (!(match && rest)) return;
    let newMatcher;
    for (const separator of ctx.generator.config.separators) if (rest.startsWith(separator)) {
      newMatcher = rest.slice(separator.length);
      break;
    }
    if (newMatcher == null) return;
    const variant = h.bracket(match) ?? "";
    const useParent = variant.startsWith("@");
    if (!(useParent || variant.includes("&"))) return;
    return {
      matcher: newMatcher,
      handle(input, next) {
        const updates = useParent ? { parent: `${input.parent ? `${input.parent} $$ ` : ""}${variant}` } : { selector: variant.replace(/&/g, input.selector) };
        return next({
          ...input,
          ...updates
        });
      }
    };
  },
  multiPass: true
};
var variantTheme = {
  name: "theme-variables",
  match(matcher, ctx) {
    if (!(0, utils_exports.hasThemeFn)(matcher)) return;
    return {
      matcher,
      handle(input, next) {
        return next({
          ...input,
          entries: JSON.parse((0, utils_exports.transformThemeFn)(JSON.stringify(input.entries), ctx.theme))
        });
      }
    };
  }
};
var anchoredNumberRE = /^-?[0-9.]+(?:[a-z]+|%)?$/;
var numberRE2 = /-?[0-9.]+(?:[a-z]+|%)?/;
var ignoreProps = [/\b(opacity|color|flex|backdrop-filter|^filter|transform)\b/];
function negateMathFunction(value) {
  const match = value.match(cssMathFnRE) || value.match(cssVarFnRE);
  if (match) {
    const [fnBody, rest] = getStringComponent(`(${match[2]})${match[3]}`, "(", ")", " ") ?? [];
    if (fnBody) return `calc(${match[1]}${fnBody} * -1)${rest ? ` ${rest}` : ""}`;
  }
}
var negateFunctionBodyRE = /\b(hue-rotate)\s*(\(.*)/;
function negateFunctionBody(value) {
  const match = value.match(negateFunctionBodyRE);
  if (match) {
    const [fnBody, rest] = getStringComponent(match[2], "(", ")", " ") ?? [];
    if (fnBody) {
      const body = anchoredNumberRE.test(fnBody.slice(1, -1)) ? fnBody.replace(numberRE2, (i) => i.startsWith("-") ? i.slice(1) : `-${i}`) : `(calc(${fnBody} * -1))`;
      return `${match[1]}${body}${rest ? ` ${rest}` : ""}`;
    }
  }
}
var variantNegative = {
  name: "negative",
  match(matcher) {
    if (!matcher.startsWith("-")) return;
    return {
      matcher: matcher.slice(1),
      body: (body) => {
        if (body.find((v) => v[0] === CONTROL_MINI_NO_NEGATIVE)) return;
        let changed = false;
        body.forEach((v) => {
          var _a;
          const value = (_a = v[1]) == null ? void 0 : _a.toString();
          if (!value || value === "0") return;
          if (ignoreProps.some((i) => i.test(v[0]))) return;
          const negatedFn = negateMathFunction(value);
          if (negatedFn) {
            v[1] = negatedFn;
            changed = true;
            return;
          }
          const negatedBody = negateFunctionBody(value);
          if (negatedBody) {
            v[1] = negatedBody;
            changed = true;
            return;
          }
          if (anchoredNumberRE.test(value)) {
            v[1] = value.replace(numberRE2, (i) => i.startsWith("-") ? i.slice(1) : `-${i}`);
            changed = true;
          }
        });
        if (changed) return body;
        return [];
      }
    };
  }
};
function variantPseudoClassesAndElements() {
  return createPseudoClassesAndElements({
    getBracket: _utils_exports.getBracket,
    h,
    variantGetBracket: _utils_exports.variantGetBracket
  });
}
function variantPseudoClassFunctions() {
  return createPseudoClassFunctions({
    getBracket: _utils_exports.getBracket,
    h,
    variantGetBracket: _utils_exports.variantGetBracket
  });
}
function variantTaggedPseudoClasses(options = {}) {
  return createTaggedPseudoClasses(options, {
    getBracket: _utils_exports.getBracket,
    h,
    variantGetBracket: _utils_exports.variantGetBracket
  });
}
var variantPartClasses = createPartClasses();
var variantStartingStyle = {
  name: "starting",
  match(matcher) {
    if (!matcher.startsWith("starting:")) return;
    return {
      matcher: matcher.slice(9),
      handle: (input, next) => next({
        ...input,
        parent: `@starting-style`
      })
    };
  }
};
var variantSupports = {
  name: "supports",
  match(matcher, ctx) {
    var _a;
    const variant = (0, utils_exports.variantGetParameter)("supports-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      let supports2 = h.bracket(match) ?? "";
      if (supports2 === "") supports2 = ((_a = ctx.theme.supports) == null ? void 0 : _a[match]) ?? "";
      if (supports2) {
        if (!(supports2.startsWith("(") && supports2.endsWith(")"))) supports2 = `(${supports2})`;
        return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@supports ${supports2}`
          })
        };
      }
    }
  },
  multiPass: true
};
function variants(options) {
  return [
    variantAria,
    variantDataAttribute,
    variantCssLayer,
    variantSelector,
    variantInternalLayer,
    variantNegative,
    variantStartingStyle,
    variantImportant(),
    variantSupports,
    variantPrint,
    variantCustomMedia,
    variantBreakpoints(),
    ...variantCombinators,
    ...variantPseudoClassesAndElements(),
    variantPseudoClassFunctions(),
    ...variantTaggedPseudoClasses(options),
    variantPartClasses,
    ...variantColorsMediaOrClass(options),
    ...variantLanguageDirections,
    variantScope,
    ...variantChildren,
    variantContainerQuery,
    variantVariables,
    ...variantTaggedDataAttributes(options),
    ...variantTaggedAriaAttributes(options),
    variantTheme
  ];
}

// node_modules/@unocss/extractor-arbitrary-variants/dist/index.mjs
function hash(str) {
  let i;
  let l;
  let hval = 2166136261;
  for (i = 0, l = str.length; i < l; i++) {
    hval ^= str.charCodeAt(i);
    hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
  }
  return `00000${(hval >>> 0).toString(36)}`.slice(-6);
}
function transformSkipCode(code2, map, SKIP_RULES_RE, keyFlag) {
  for (const item of Array.from(code2.matchAll(SKIP_RULES_RE))) if (item != null) {
    const matched = item[0];
    const withHashKey = `${keyFlag}${hash(matched)}`;
    map.set(withHashKey, matched);
    code2 = code2.replace(matched, withHashKey);
  }
  return code2;
}
function restoreSkipCode(code2, map) {
  for (const [withHashKey, matched] of map.entries()) code2 = code2.replaceAll(withHashKey, matched);
  return code2;
}
var sourceMapRE = /\/\/#\s*sourceMappingURL=.*\n?/g;
function removeSourceMap(code2) {
  if (code2.includes("sourceMappingURL=")) return code2.replace(sourceMapRE, "");
  return code2;
}
var quotedArbitraryValuesRE = /(?:[\w&:[\]-]|\[\S{1,64}=\S{1,64}\]){1,64}\[\\?['"]?\S{1,64}?['"]\]\]?[\w:-]{0,64}/g;
var arbitraryPropertyRE = /\[(\\\W|[\w-]){1,64}:[^\s:]{0,64}?("\S{1,64}?"|'\S{1,64}?'|`\S{1,64}?`|[^\s:]{1,64}?)[^\s:]{0,64}?\)?\]/g;
var arbitraryPropertyCandidateRE = /^\[(?:\\\W|[\w-]){1,64}:['"]?\S{1,64}?['"]?\]$/;
function splitCodeWithArbitraryVariants(code2) {
  const result = [];
  for (const match of code2.matchAll(arbitraryPropertyRE)) {
    if (match.index !== 0 && !/^[\s'"`]/.test(code2[match.index - 1] ?? "")) continue;
    result.push(match[0]);
  }
  for (const match of code2.matchAll(quotedArbitraryValuesRE)) result.push(match[0]);
  const skipMap = /* @__PURE__ */ new Map();
  const skipFlag = "@unocss-skip-arbitrary-brackets";
  code2 = transformSkipCode(code2, skipMap, /-\[(?!&.+?;)[^\]]*\]/g, skipFlag);
  if (!code2) return result;
  code2.split(defaultSplitRE).forEach((match) => {
    if (match.includes(skipFlag)) match = restoreSkipCode(match, skipMap);
    if (isValidSelector(match) && !arbitraryPropertyCandidateRE.test(match)) result.push(match);
  });
  return result;
}
function extractorArbitraryVariants() {
  return {
    name: "@unocss/extractor-arbitrary-variants",
    order: 0,
    extract({ code: code2 }) {
      return splitCodeWithArbitraryVariants(removeSourceMap(code2));
    }
  };
}

// node_modules/@unocss/preset-mini/dist/index.mjs
function preflights(options) {
  if (options.preflight) return [{
    layer: "preflights",
    getCSS({ theme: theme$12, generator }) {
      if (theme$12.preflightBase) {
        let entries = Object.entries(theme$12.preflightBase);
        if (options.preflight === "on-demand") {
          const keys = new Set(Array.from(generator.activatedRules).map((r) => {
            var _a, _b;
            return (_b = (_a = r[2]) == null ? void 0 : _a.custom) == null ? void 0 : _b.preflightKeys;
          }).filter(Boolean).flat());
          entries = entries.filter(([k]) => keys.has(k));
        }
        if (entries.length > 0) {
          let css = entriesToCss(entries);
          if (options.variablePrefix !== "un-") css = css.replace(/--un-/g, `--${options.variablePrefix}`);
          return toArray(theme$12.preflightRoot ?? ["*,::before,::after", "::backdrop"]).map((root) => `${root}{${css}}`).join("");
        }
      }
    }
  }];
}
var shorthands = {
  position: [
    "relative",
    "absolute",
    "fixed",
    "sticky",
    "static"
  ],
  globalKeyword: globalKeywords
};
var presetMini = definePreset((options = {}) => {
  options.dark = options.dark ?? "class";
  options.attributifyPseudo = options.attributifyPseudo ?? false;
  options.preflight = options.preflight ?? true;
  options.variablePrefix = options.variablePrefix ?? "un-";
  return {
    name: "@unocss/preset-mini",
    theme,
    rules,
    variants: variants(options),
    options,
    prefix: options.prefix,
    postprocess: VarPrefixPostprocessor(options.variablePrefix),
    preflights: preflights(options),
    extractorDefault: options.arbitraryVariants === false ? void 0 : extractorArbitraryVariants(),
    autocomplete: { shorthands }
  };
});
var src_default2 = presetMini;
function VarPrefixPostprocessor(prefix) {
  if (prefix !== "un-") return (obj) => {
    obj.entries.forEach((i) => {
      i[0] = i[0].replace(/^--un-/, `--${prefix}`);
      if (typeof i[1] === "string") i[1] = i[1].replace(/var\(--un-/g, `var(--${prefix}`);
    });
  };
}

// node_modules/@unocss/preset-tagify/dist/index.mjs
var MARKER = "__TAGIFY__";
var htmlTagRE = /<([\w:-]+)/g;
function extractorTagify(options) {
  const { prefix = "", excludedTags = [
    "b",
    /^h\d+$/,
    "table"
  ] } = options;
  return {
    name: "tagify",
    extract({ code: code2 }) {
      return Array.from(code2.matchAll(htmlTagRE)).filter(({ 1: match }) => {
        for (const exclude of excludedTags) if (typeof exclude === "string") {
          if (match === exclude) return false;
        } else {
          exclude.lastIndex = 0;
          if (exclude.test(match)) return false;
        }
        return match.startsWith(prefix);
      }).map(([, matched]) => `${MARKER}${matched}`);
    }
  };
}
function variantTagify(options) {
  const { extraProperties } = options;
  const prefix = `${MARKER}${options.prefix ?? ""}`;
  return {
    name: "tagify",
    match(input) {
      if (!input.startsWith(prefix)) return;
      const matcher = input.slice(prefix.length);
      const handler3 = {
        matcher,
        selector: (i) => i.slice(MARKER.length + 1)
      };
      if (extraProperties) if (typeof extraProperties === "function") handler3.body = (entries) => [...entries, ...Object.entries(extraProperties(matcher) ?? {})];
      else handler3.body = (entries) => [...entries, ...Object.entries(extraProperties)];
      return handler3;
    }
  };
}
var presetTagify = definePreset((options = {}) => {
  const { defaultExtractor = true } = options;
  return {
    name: "@unocss/preset-tagify",
    variants: [variantTagify(options)],
    extractors: [extractorTagify(options)],
    extractorDefault: defaultExtractor ? void 0 : false
  };
});
var src_default3 = presetTagify;

// node_modules/@unocss/preset-typography/dist/index.mjs
var modifiers = [
  [
    "headings",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "th"
  ],
  ["h1"],
  ["h2"],
  ["h3"],
  ["h4"],
  ["h5"],
  ["h6"],
  ["p"],
  ["a"],
  ["blockquote"],
  ["figure"],
  ["figcaption"],
  ["strong"],
  ["em"],
  ["kbd"],
  ["code"],
  ["pre"],
  ["ol"],
  ["ul"],
  ["li"],
  ["table"],
  ["thead"],
  ["tr"],
  ["th"],
  ["td"],
  ["img"],
  ["video"],
  ["hr"]
];
var defaultColorScheme = {
  "body": [700, 300],
  "headings": [900, "white"],
  "lead": [600, 400],
  "links": [900, "white"],
  "bold": [900, "white"],
  "counters": [500, 400],
  "bullets": [300, 600],
  "hr": [200, 700],
  "quotes": [900, 100],
  "quote-borders": [200, 700],
  "captions": [500, 400],
  "kbd": [900, "white"],
  "kbd-shadows": [900, "white"],
  "code": [900, "white"],
  "pre-code": [200, 300],
  "pre-bg": [800, "rgb(0 0 0 / 50%)"],
  "th-borders": [300, 600],
  "td-borders": [200, 700]
};
var round2 = (num) => num.toFixed(7).replace(/0+$/, "").replace(/\.$/, "");
var rem2 = (px3) => `${round2(px3 / 16)}rem`;
var em = (px3, base) => `${round2(px3 / base)}em`;
var ProseDefaultCSSObject = {
  "color": "var(--un-prose-body)",
  "max-width": "65ch",
  "p": {},
  '[class~="lead"]': { color: "var(--un-prose-lead)" },
  "a": {
    "color": "var(--un-prose-links)",
    "text-decoration": "underline",
    "font-weight": "500"
  },
  "strong": {
    "color": "var(--un-prose-bold)",
    "font-weight": "600"
  },
  "a strong": { color: "inherit" },
  "blockquote strong": { color: "inherit" },
  "thead th strong": { color: "inherit" },
  "ol": { "list-style-type": "decimal" },
  'ol[type="A"]': { "list-style-type": "upper-alpha" },
  'ol[type="a"]': { "list-style-type": "lower-alpha" },
  'ol[type="A" s]': { "list-style-type": "upper-alpha" },
  'ol[type="a" s]': { "list-style-type": "lower-alpha" },
  'ol[type="I"]': { "list-style-type": "upper-roman" },
  'ol[type="i"]': { "list-style-type": "lower-roman" },
  'ol[type="I" s]': { "list-style-type": "upper-roman" },
  'ol[type="i" s]': { "list-style-type": "lower-roman" },
  'ol[type="1"]': { "list-style-type": "decimal" },
  "ul": { "list-style-type": "disc" },
  "ol > li::marker": {
    "font-weight": "400",
    "color": "var(--un-prose-counters)"
  },
  "ul > li::marker": { color: "var(--un-prose-bullets)" },
  "dt": {
    "color": "var(--un-prose-headings)",
    "font-weight": "600"
  },
  "hr": {
    "border-color": "var(--un-prose-hr)",
    "border-top-width": "1px"
  },
  "blockquote": {
    "font-weight": "500",
    "font-style": "italic",
    "color": "var(--un-prose-quotes)",
    "border-inline-start-width": "0.25rem",
    "border-inline-start-color": "var(--un-prose-quote-borders)",
    "quotes": '"\\201C""\\201D""\\2018""\\2019"'
  },
  "blockquote p:first-of-type::before": { content: "open-quote" },
  "blockquote p:last-of-type::after": { content: "close-quote" },
  "h1": {
    "color": "var(--un-prose-headings)",
    "font-weight": "800"
  },
  "h1 strong": {
    "font-weight": "900",
    "color": "inherit"
  },
  "h2": {
    "color": "var(--un-prose-headings)",
    "font-weight": "700"
  },
  "h2 strong": {
    "font-weight": "800",
    "color": "inherit"
  },
  "h3": {
    "color": "var(--un-prose-headings)",
    "font-weight": "600"
  },
  "h3 strong": {
    "font-weight": "700",
    "color": "inherit"
  },
  "h4": {
    "color": "var(--un-prose-headings)",
    "font-weight": "600"
  },
  "h4 strong": {
    "font-weight": "700",
    "color": "inherit"
  },
  "img": {},
  "picture": { display: "block" },
  "video": {},
  "kbd": {
    "font-weight": "500",
    "font-family": "inherit",
    "color": "var(--un-prose-kbd)",
    "box-shadow": "0 0 0 1px rgb(var(--un-prose-kbd-shadows) / 10%), 0 3px 0 rgb(var(--un-prose-kbd-shadows) / 10%)"
  },
  "code": {
    "color": "var(--un-prose-code)",
    "font-weight": "600"
  },
  "code::before": { content: '"`"' },
  "code::after": { content: '"`"' },
  "a code": { color: "inherit" },
  "h1 code": { color: "inherit" },
  "h2 code": { color: "inherit" },
  "h3 code": { color: "inherit" },
  "h4 code": { color: "inherit" },
  "blockquote code": { color: "inherit" },
  "thead th code": { color: "inherit" },
  "pre": {
    "color": "var(--un-prose-pre-code)",
    "background-color": "var(--un-prose-pre-bg)",
    "overflow-x": "auto",
    "font-weight": "400"
  },
  "pre code": {
    "background-color": "transparent",
    "border-width": "0",
    "border-radius": "0",
    "padding": "0",
    "font-weight": "inherit",
    "color": "inherit",
    "font-size": "inherit",
    "font-family": "inherit",
    "line-height": "inherit"
  },
  "pre code::before": { content: "none" },
  "pre code::after": { content: "none" },
  "table": {
    "width": "100%",
    "table-layout": "auto",
    "margin-top": em(32, 16),
    "margin-bottom": em(32, 16)
  },
  "thead": {
    "border-bottom-width": "1px",
    "border-bottom-color": "var(--un-prose-th-borders)"
  },
  "thead th": {
    "color": "var(--un-prose-headings)",
    "font-weight": "600",
    "vertical-align": "bottom"
  },
  "tbody tr": {
    "border-bottom-width": "1px",
    "border-bottom-color": "var(--un-prose-td-borders)"
  },
  "tbody tr:last-child": { "border-bottom-width": "0" },
  "tbody td": { "vertical-align": "baseline" },
  "tfoot": {
    "border-top-width": "1px",
    "border-top-color": "var(--un-prose-th-borders)"
  },
  "tfoot td": { "vertical-align": "top" },
  "th, td": { "text-align": "start" },
  "figure > *": {},
  "figcaption": { color: "var(--un-prose-captions)" }
};
var ProseDefaultSize = {
  "sm": {
    "font-size": rem2(14),
    "line-height": round2(24 / 14),
    "p": {
      "margin-top": em(16, 14),
      "margin-bottom": em(16, 14)
    },
    '[class~="lead"]': {
      "font-size": em(18, 14),
      "line-height": round2(28 / 18),
      "margin-top": em(16, 18),
      "margin-bottom": em(16, 18)
    },
    "blockquote": {
      "margin-top": em(24, 18),
      "margin-bottom": em(24, 18),
      "padding-inline-start": em(20, 18)
    },
    "h1": {
      "font-size": em(30, 14),
      "margin-top": "0",
      "margin-bottom": em(24, 30),
      "line-height": round2(36 / 30)
    },
    "h2": {
      "font-size": em(20, 14),
      "margin-top": em(32, 20),
      "margin-bottom": em(16, 20),
      "line-height": round2(28 / 20)
    },
    "h3": {
      "font-size": em(18, 14),
      "margin-top": em(28, 18),
      "margin-bottom": em(8, 18),
      "line-height": round2(28 / 18)
    },
    "h4": {
      "margin-top": em(20, 14),
      "margin-bottom": em(8, 14),
      "line-height": round2(20 / 14)
    },
    "img": {
      "margin-top": em(24, 14),
      "margin-bottom": em(24, 14)
    },
    "picture": {
      "margin-top": em(24, 14),
      "margin-bottom": em(24, 14)
    },
    "picture > img": {
      "margin-top": "0",
      "margin-bottom": "0"
    },
    "video": {
      "margin-top": em(24, 14),
      "margin-bottom": em(24, 14)
    },
    "kbd": {
      "font-size": em(12, 14),
      "border-radius": rem2(5),
      "padding-top": em(2, 14),
      "padding-inline-end": em(5, 14),
      "padding-bottom": em(2, 14),
      "padding-inline-start": em(5, 14)
    },
    "code": { "font-size": em(12, 14) },
    "h2 code": { "font-size": em(18, 20) },
    "h3 code": { "font-size": em(16, 18) },
    "pre": {
      "font-size": em(12, 14),
      "line-height": round2(20 / 12),
      "margin-top": em(20, 12),
      "margin-bottom": em(20, 12),
      "border-radius": rem2(4),
      "padding-top": em(8, 12),
      "padding-inline-end": em(12, 12),
      "padding-bottom": em(8, 12),
      "padding-inline-start": em(12, 12)
    },
    "ol": {
      "margin-top": em(16, 14),
      "margin-bottom": em(16, 14),
      "padding-inline-start": em(22, 14)
    },
    "ul": {
      "margin-top": em(16, 14),
      "margin-bottom": em(16, 14),
      "padding-inline-start": em(22, 14)
    },
    "li": {
      "margin-top": em(4, 14),
      "margin-bottom": em(4, 14)
    },
    "ol > li": { "padding-inline-start": em(6, 14) },
    "ul > li": { "padding-inline-start": em(6, 14) },
    "> ul > li p": {
      "margin-top": em(8, 14),
      "margin-bottom": em(8, 14)
    },
    "> ul > li > p:first-child": { "margin-top": em(16, 14) },
    "> ul > li > p:last-child": { "margin-bottom": em(16, 14) },
    "> ol > li > p:first-child": { "margin-top": em(16, 14) },
    "> ol > li > p:last-child": { "margin-bottom": em(16, 14) },
    "ul ul, ul ol, ol ul, ol ol": {
      "margin-top": em(8, 14),
      "margin-bottom": em(8, 14)
    },
    "dl": {
      "margin-top": em(16, 14),
      "margin-bottom": em(16, 14)
    },
    "dt": { "margin-top": em(16, 14) },
    "dd": {
      "margin-top": em(4, 14),
      "padding-inline-start": em(22, 14)
    },
    "hr": {
      "margin-top": em(40, 14),
      "margin-bottom": em(40, 14)
    },
    "hr + *": { "margin-top": "0" },
    "h2 + *": { "margin-top": "0" },
    "h3 + *": { "margin-top": "0" },
    "h4 + *": { "margin-top": "0" },
    "table": {
      "font-size": em(12, 14),
      "line-height": round2(18 / 12)
    },
    "thead th": {
      "padding-inline-end": em(12, 12),
      "padding-bottom": em(8, 12),
      "padding-inline-start": em(12, 12)
    },
    "thead th:first-child": { "padding-inline-start": "0" },
    "thead th:last-child": { "padding-inline-end": "0" },
    "tbody td, tfoot td": {
      "padding-top": em(8, 12),
      "padding-inline-end": em(12, 12),
      "padding-bottom": em(8, 12),
      "padding-inline-start": em(12, 12)
    },
    "tbody td:first-child, tfoot td:first-child": { "padding-inline-start": "0" },
    "tbody td:last-child, tfoot td:last-child": { "padding-inline-end": "0" },
    "figure": {
      "margin-top": em(24, 14),
      "margin-bottom": em(24, 14)
    },
    "figure > *": {
      "margin-top": "0",
      "margin-bottom": "0"
    },
    "figcaption": {
      "font-size": em(12, 14),
      "line-height": round2(16 / 12),
      "margin-top": em(8, 12)
    },
    "> :first-child": { "margin-top": "0" },
    "> :last-child": { "margin-bottom": "0" }
  },
  "base": {
    "font-size": rem2(16),
    "line-height": round2(28 / 16),
    "p": {
      "margin-top": em(20, 16),
      "margin-bottom": em(20, 16)
    },
    '[class~="lead"]': {
      "font-size": em(20, 16),
      "line-height": round2(32 / 20),
      "margin-top": em(24, 20),
      "margin-bottom": em(24, 20)
    },
    "blockquote": {
      "margin-top": em(32, 20),
      "margin-bottom": em(32, 20),
      "padding-inline-start": em(20, 20)
    },
    "h1": {
      "font-size": em(36, 16),
      "margin-top": "0",
      "margin-bottom": em(32, 36),
      "line-height": round2(40 / 36)
    },
    "h2": {
      "font-size": em(24, 16),
      "margin-top": em(48, 24),
      "margin-bottom": em(24, 24),
      "line-height": round2(32 / 24)
    },
    "h3": {
      "font-size": em(20, 16),
      "margin-top": em(32, 20),
      "margin-bottom": em(12, 20),
      "line-height": round2(32 / 20)
    },
    "h4": {
      "margin-top": em(24, 16),
      "margin-bottom": em(8, 16),
      "line-height": round2(24 / 16)
    },
    "img": {
      "margin-top": em(32, 16),
      "margin-bottom": em(32, 16)
    },
    "picture": {
      "margin-top": em(32, 16),
      "margin-bottom": em(32, 16)
    },
    "picture > img": {
      "margin-top": "0",
      "margin-bottom": "0"
    },
    "video": {
      "margin-top": em(32, 16),
      "margin-bottom": em(32, 16)
    },
    "kbd": {
      "font-size": em(14, 16),
      "border-radius": rem2(5),
      "padding-top": em(3, 16),
      "padding-inline-end": em(6, 16),
      "padding-bottom": em(3, 16),
      "padding-inline-start": em(6, 16)
    },
    "code": { "font-size": em(14, 16) },
    "h2 code": { "font-size": em(21, 24) },
    "h3 code": { "font-size": em(18, 20) },
    "pre": {
      "font-size": em(14, 16),
      "line-height": round2(24 / 14),
      "margin-top": em(24, 14),
      "margin-bottom": em(24, 14),
      "border-radius": rem2(6),
      "padding-top": em(12, 14),
      "padding-inline-end": em(16, 14),
      "padding-bottom": em(12, 14),
      "padding-inline-start": em(16, 14)
    },
    "ol": {
      "margin-top": em(20, 16),
      "margin-bottom": em(20, 16),
      "padding-inline-start": em(26, 16)
    },
    "ul": {
      "margin-top": em(20, 16),
      "margin-bottom": em(20, 16),
      "padding-inline-start": em(26, 16)
    },
    "li": {
      "margin-top": em(8, 16),
      "margin-bottom": em(8, 16)
    },
    "ol > li": { "padding-inline-start": em(6, 16) },
    "ul > li": { "padding-inline-start": em(6, 16) },
    "> ul > li p": {
      "margin-top": em(12, 16),
      "margin-bottom": em(12, 16)
    },
    "> ul > li > p:first-child": { "margin-top": em(20, 16) },
    "> ul > li > p:last-child": { "margin-bottom": em(20, 16) },
    "> ol > li > p:first-child": { "margin-top": em(20, 16) },
    "> ol > li > p:last-child": { "margin-bottom": em(20, 16) },
    "ul ul, ul ol, ol ul, ol ol": {
      "margin-top": em(12, 16),
      "margin-bottom": em(12, 16)
    },
    "dl": {
      "margin-top": em(20, 16),
      "margin-bottom": em(20, 16)
    },
    "dt": { "margin-top": em(20, 16) },
    "dd": {
      "margin-top": em(8, 16),
      "padding-inline-start": em(26, 16)
    },
    "hr": {
      "margin-top": em(48, 16),
      "margin-bottom": em(48, 16)
    },
    "hr + *": { "margin-top": "0" },
    "h2 + *": { "margin-top": "0" },
    "h3 + *": { "margin-top": "0" },
    "h4 + *": { "margin-top": "0" },
    "table": {
      "font-size": em(14, 16),
      "line-height": round2(24 / 14)
    },
    "thead th": {
      "padding-inline-end": em(8, 14),
      "padding-bottom": em(8, 14),
      "padding-inline-start": em(8, 14)
    },
    "thead th:first-child": { "padding-inline-start": "0" },
    "thead th:last-child": { "padding-inline-end": "0" },
    "tbody td, tfoot td": {
      "padding-top": em(8, 14),
      "padding-inline-end": em(8, 14),
      "padding-bottom": em(8, 14),
      "padding-inline-start": em(8, 14)
    },
    "tbody td:first-child, tfoot td:first-child": { "padding-inline-start": "0" },
    "tbody td:last-child, tfoot td:last-child": { "padding-inline-end": "0" },
    "figure": {
      "margin-top": em(32, 16),
      "margin-bottom": em(32, 16)
    },
    "figure > *": {
      "margin-top": "0",
      "margin-bottom": "0"
    },
    "figcaption": {
      "font-size": em(14, 16),
      "line-height": round2(20 / 14),
      "margin-top": em(12, 14)
    },
    "> :first-child": { "margin-top": "0" },
    "> :last-child": { "margin-bottom": "0" }
  },
  "lg": {
    "font-size": rem2(18),
    "line-height": round2(32 / 18),
    "p": {
      "margin-top": em(24, 18),
      "margin-bottom": em(24, 18)
    },
    '[class~="lead"]': {
      "font-size": em(22, 18),
      "line-height": round2(32 / 22),
      "margin-top": em(24, 22),
      "margin-bottom": em(24, 22)
    },
    "blockquote": {
      "margin-top": em(40, 24),
      "margin-bottom": em(40, 24),
      "padding-inline-start": em(24, 24)
    },
    "h1": {
      "font-size": em(48, 18),
      "margin-top": "0",
      "margin-bottom": em(40, 48),
      "line-height": round2(48 / 48)
    },
    "h2": {
      "font-size": em(30, 18),
      "margin-top": em(56, 30),
      "margin-bottom": em(32, 30),
      "line-height": round2(40 / 30)
    },
    "h3": {
      "font-size": em(24, 18),
      "margin-top": em(40, 24),
      "margin-bottom": em(16, 24),
      "line-height": round2(36 / 24)
    },
    "h4": {
      "margin-top": em(32, 18),
      "margin-bottom": em(8, 18),
      "line-height": round2(28 / 18)
    },
    "img": {
      "margin-top": em(32, 18),
      "margin-bottom": em(32, 18)
    },
    "picture": {
      "margin-top": em(32, 18),
      "margin-bottom": em(32, 18)
    },
    "picture > img": {
      "margin-top": "0",
      "margin-bottom": "0"
    },
    "video": {
      "margin-top": em(32, 18),
      "margin-bottom": em(32, 18)
    },
    "kbd": {
      "font-size": em(16, 18),
      "border-radius": rem2(5),
      "padding-top": em(4, 18),
      "padding-inline-end": em(8, 18),
      "padding-bottom": em(4, 18),
      "padding-inline-start": em(8, 18)
    },
    "code": { "font-size": em(16, 18) },
    "h2 code": { "font-size": em(26, 30) },
    "h3 code": { "font-size": em(21, 24) },
    "pre": {
      "font-size": em(16, 18),
      "line-height": round2(28 / 16),
      "margin-top": em(32, 16),
      "margin-bottom": em(32, 16),
      "border-radius": rem2(6),
      "padding-top": em(16, 16),
      "padding-inline-end": em(24, 16),
      "padding-bottom": em(16, 16),
      "padding-inline-start": em(24, 16)
    },
    "ol": {
      "margin-top": em(24, 18),
      "margin-bottom": em(24, 18),
      "padding-inline-start": em(28, 18)
    },
    "ul": {
      "margin-top": em(24, 18),
      "margin-bottom": em(24, 18),
      "padding-inline-start": em(28, 18)
    },
    "li": {
      "margin-top": em(12, 18),
      "margin-bottom": em(12, 18)
    },
    "ol > li": { "padding-inline-start": em(8, 18) },
    "ul > li": { "padding-inline-start": em(8, 18) },
    "> ul > li p": {
      "margin-top": em(16, 18),
      "margin-bottom": em(16, 18)
    },
    "> ul > li > p:first-child": { "margin-top": em(24, 18) },
    "> ul > li > p:last-child": { "margin-bottom": em(24, 18) },
    "> ol > li > p:first-child": { "margin-top": em(24, 18) },
    "> ol > li > p:last-child": { "margin-bottom": em(24, 18) },
    "ul ul, ul ol, ol ul, ol ol": {
      "margin-top": em(16, 18),
      "margin-bottom": em(16, 18)
    },
    "dl": {
      "margin-top": em(24, 18),
      "margin-bottom": em(24, 18)
    },
    "dt": { "margin-top": em(24, 18) },
    "dd": {
      "margin-top": em(12, 18),
      "padding-inline-start": em(28, 18)
    },
    "hr": {
      "margin-top": em(56, 18),
      "margin-bottom": em(56, 18)
    },
    "hr + *": { "margin-top": "0" },
    "h2 + *": { "margin-top": "0" },
    "h3 + *": { "margin-top": "0" },
    "h4 + *": { "margin-top": "0" },
    "table": {
      "font-size": em(16, 18),
      "line-height": round2(24 / 16)
    },
    "thead th": {
      "padding-inline-end": em(12, 16),
      "padding-bottom": em(12, 16),
      "padding-inline-start": em(12, 16)
    },
    "thead th:first-child": { "padding-inline-start": "0" },
    "thead th:last-child": { "padding-inline-end": "0" },
    "tbody td, tfoot td": {
      "padding-top": em(12, 16),
      "padding-inline-end": em(12, 16),
      "padding-bottom": em(12, 16),
      "padding-inline-start": em(12, 16)
    },
    "tbody td:first-child, tfoot td:first-child": { "padding-inline-start": "0" },
    "tbody td:last-child, tfoot td:last-child": { "padding-inline-end": "0" },
    "figure": {
      "margin-top": em(32, 18),
      "margin-bottom": em(32, 18)
    },
    "figure > *": {
      "margin-top": "0",
      "margin-bottom": "0"
    },
    "figcaption": {
      "font-size": em(16, 18),
      "line-height": round2(24 / 16),
      "margin-top": em(16, 16)
    },
    "> :first-child": { "margin-top": "0" },
    "> :last-child": { "margin-bottom": "0" }
  },
  "xl": {
    "font-size": rem2(20),
    "line-height": round2(36 / 20),
    "p": {
      "margin-top": em(24, 20),
      "margin-bottom": em(24, 20)
    },
    '[class~="lead"]': {
      "font-size": em(24, 20),
      "line-height": round2(36 / 24),
      "margin-top": em(24, 24),
      "margin-bottom": em(24, 24)
    },
    "blockquote": {
      "margin-top": em(48, 30),
      "margin-bottom": em(48, 30),
      "padding-inline-start": em(32, 30)
    },
    "h1": {
      "font-size": em(56, 20),
      "margin-top": "0",
      "margin-bottom": em(48, 56),
      "line-height": round2(56 / 56)
    },
    "h2": {
      "font-size": em(36, 20),
      "margin-top": em(56, 36),
      "margin-bottom": em(32, 36),
      "line-height": round2(40 / 36)
    },
    "h3": {
      "font-size": em(30, 20),
      "margin-top": em(48, 30),
      "margin-bottom": em(20, 30),
      "line-height": round2(40 / 30)
    },
    "h4": {
      "margin-top": em(36, 20),
      "margin-bottom": em(12, 20),
      "line-height": round2(32 / 20)
    },
    "img": {
      "margin-top": em(40, 20),
      "margin-bottom": em(40, 20)
    },
    "picture": {
      "margin-top": em(40, 20),
      "margin-bottom": em(40, 20)
    },
    "picture > img": {
      "margin-top": "0",
      "margin-bottom": "0"
    },
    "video": {
      "margin-top": em(40, 20),
      "margin-bottom": em(40, 20)
    },
    "kbd": {
      "font-size": em(18, 20),
      "border-radius": rem2(5),
      "padding-top": em(5, 20),
      "padding-inline-end": em(8, 20),
      "padding-bottom": em(5, 20),
      "padding-inline-start": em(8, 20)
    },
    "code": { "font-size": em(18, 20) },
    "h2 code": { "font-size": em(31, 36) },
    "h3 code": { "font-size": em(27, 30) },
    "pre": {
      "font-size": em(18, 20),
      "line-height": round2(32 / 18),
      "margin-top": em(36, 18),
      "margin-bottom": em(36, 18),
      "border-radius": rem2(8),
      "padding-top": em(20, 18),
      "padding-inline-end": em(24, 18),
      "padding-bottom": em(20, 18),
      "padding-inline-start": em(24, 18)
    },
    "ol": {
      "margin-top": em(24, 20),
      "margin-bottom": em(24, 20),
      "padding-inline-start": em(32, 20)
    },
    "ul": {
      "margin-top": em(24, 20),
      "margin-bottom": em(24, 20),
      "padding-inline-start": em(32, 20)
    },
    "li": {
      "margin-top": em(12, 20),
      "margin-bottom": em(12, 20)
    },
    "ol > li": { "padding-inline-start": em(8, 20) },
    "ul > li": { "padding-inline-start": em(8, 20) },
    "> ul > li p": {
      "margin-top": em(16, 20),
      "margin-bottom": em(16, 20)
    },
    "> ul > li > p:first-child": { "margin-top": em(24, 20) },
    "> ul > li > p:last-child": { "margin-bottom": em(24, 20) },
    "> ol > li > p:first-child": { "margin-top": em(24, 20) },
    "> ol > li > p:last-child": { "margin-bottom": em(24, 20) },
    "ul ul, ul ol, ol ul, ol ol": {
      "margin-top": em(16, 20),
      "margin-bottom": em(16, 20)
    },
    "dl": {
      "margin-top": em(24, 20),
      "margin-bottom": em(24, 20)
    },
    "dt": { "margin-top": em(24, 20) },
    "dd": {
      "margin-top": em(12, 20),
      "padding-inline-start": em(32, 20)
    },
    "hr": {
      "margin-top": em(56, 20),
      "margin-bottom": em(56, 20)
    },
    "hr + *": { "margin-top": "0" },
    "h2 + *": { "margin-top": "0" },
    "h3 + *": { "margin-top": "0" },
    "h4 + *": { "margin-top": "0" },
    "table": {
      "font-size": em(18, 20),
      "line-height": round2(28 / 18)
    },
    "thead th": {
      "padding-inline-end": em(12, 18),
      "padding-bottom": em(16, 18),
      "padding-inline-start": em(12, 18)
    },
    "thead th:first-child": { "padding-inline-start": "0" },
    "thead th:last-child": { "padding-inline-end": "0" },
    "tbody td, tfoot td": {
      "padding-top": em(16, 18),
      "padding-inline-end": em(12, 18),
      "padding-bottom": em(16, 18),
      "padding-inline-start": em(12, 18)
    },
    "tbody td:first-child, tfoot td:first-child": { "padding-inline-start": "0" },
    "tbody td:last-child, tfoot td:last-child": { "padding-inline-end": "0" },
    "figure": {
      "margin-top": em(40, 20),
      "margin-bottom": em(40, 20)
    },
    "figure > *": {
      "margin-top": "0",
      "margin-bottom": "0"
    },
    "figcaption": {
      "font-size": em(18, 20),
      "line-height": round2(28 / 18),
      "margin-top": em(18, 18)
    },
    "> :first-child": { "margin-top": "0" },
    "> :last-child": { "margin-bottom": "0" }
  },
  "2xl": {
    "font-size": rem2(24),
    "line-height": round2(40 / 24),
    "p": {
      "margin-top": em(32, 24),
      "margin-bottom": em(32, 24)
    },
    '[class~="lead"]': {
      "font-size": em(30, 24),
      "line-height": round2(44 / 30),
      "margin-top": em(32, 30),
      "margin-bottom": em(32, 30)
    },
    "blockquote": {
      "margin-top": em(64, 36),
      "margin-bottom": em(64, 36),
      "padding-inline-start": em(40, 36)
    },
    "h1": {
      "font-size": em(64, 24),
      "margin-top": "0",
      "margin-bottom": em(56, 64),
      "line-height": round2(64 / 64)
    },
    "h2": {
      "font-size": em(48, 24),
      "margin-top": em(72, 48),
      "margin-bottom": em(40, 48),
      "line-height": round2(52 / 48)
    },
    "h3": {
      "font-size": em(36, 24),
      "margin-top": em(56, 36),
      "margin-bottom": em(24, 36),
      "line-height": round2(44 / 36)
    },
    "h4": {
      "margin-top": em(40, 24),
      "margin-bottom": em(16, 24),
      "line-height": round2(36 / 24)
    },
    "img": {
      "margin-top": em(48, 24),
      "margin-bottom": em(48, 24)
    },
    "picture": {
      "margin-top": em(48, 24),
      "margin-bottom": em(48, 24)
    },
    "picture > img": {
      "margin-top": "0",
      "margin-bottom": "0"
    },
    "video": {
      "margin-top": em(48, 24),
      "margin-bottom": em(48, 24)
    },
    "kbd": {
      "font-size": em(20, 24),
      "border-radius": rem2(6),
      "padding-top": em(6, 24),
      "padding-inline-end": em(8, 24),
      "padding-bottom": em(6, 24),
      "padding-inline-start": em(8, 24)
    },
    "code": { "font-size": em(20, 24) },
    "h2 code": { "font-size": em(42, 48) },
    "h3 code": { "font-size": em(32, 36) },
    "pre": {
      "font-size": em(20, 24),
      "line-height": round2(36 / 20),
      "margin-top": em(40, 20),
      "margin-bottom": em(40, 20),
      "border-radius": rem2(8),
      "padding-top": em(24, 20),
      "padding-inline-end": em(32, 20),
      "padding-bottom": em(24, 20),
      "padding-inline-start": em(32, 20)
    },
    "ol": {
      "margin-top": em(32, 24),
      "margin-bottom": em(32, 24),
      "padding-inline-start": em(38, 24)
    },
    "ul": {
      "margin-top": em(32, 24),
      "margin-bottom": em(32, 24),
      "padding-inline-start": em(38, 24)
    },
    "li": {
      "margin-top": em(12, 24),
      "margin-bottom": em(12, 24)
    },
    "ol > li": { "padding-inline-start": em(10, 24) },
    "ul > li": { "padding-inline-start": em(10, 24) },
    "> ul > li p": {
      "margin-top": em(20, 24),
      "margin-bottom": em(20, 24)
    },
    "> ul > li > p:first-child": { "margin-top": em(32, 24) },
    "> ul > li > p:last-child": { "margin-bottom": em(32, 24) },
    "> ol > li > p:first-child": { "margin-top": em(32, 24) },
    "> ol > li > p:last-child": { "margin-bottom": em(32, 24) },
    "ul ul, ul ol, ol ul, ol ol": {
      "margin-top": em(16, 24),
      "margin-bottom": em(16, 24)
    },
    "dl": {
      "margin-top": em(32, 24),
      "margin-bottom": em(32, 24)
    },
    "dt": { "margin-top": em(32, 24) },
    "dd": {
      "margin-top": em(12, 24),
      "padding-inline-start": em(38, 24)
    },
    "hr": {
      "margin-top": em(72, 24),
      "margin-bottom": em(72, 24)
    },
    "hr + *": { "margin-top": "0" },
    "h2 + *": { "margin-top": "0" },
    "h3 + *": { "margin-top": "0" },
    "h4 + *": { "margin-top": "0" },
    "table": {
      "font-size": em(20, 24),
      "line-height": round2(28 / 20)
    },
    "thead th": {
      "padding-inline-end": em(12, 20),
      "padding-bottom": em(16, 20),
      "padding-inline-start": em(12, 20)
    },
    "thead th:first-child": { "padding-inline-start": "0" },
    "thead th:last-child": { "padding-inline-end": "0" },
    "tbody td, tfoot td": {
      "padding-top": em(16, 20),
      "padding-inline-end": em(12, 20),
      "padding-bottom": em(16, 20),
      "padding-inline-start": em(12, 20)
    },
    "tbody td:first-child, tfoot td:first-child": { "padding-inline-start": "0" },
    "tbody td:last-child, tfoot td:last-child": { "padding-inline-end": "0" },
    "figure": {
      "margin-top": em(48, 24),
      "margin-bottom": em(48, 24)
    },
    "figure > *": {
      "margin-top": "0",
      "margin-bottom": "0"
    },
    "figcaption": {
      "font-size": em(20, 24),
      "line-height": round2(32 / 20),
      "margin-top": em(20, 20)
    },
    "> :first-child": { "margin-top": "0" },
    "> :last-child": { "margin-bottom": "0" }
  }
};
function resolveColorScheme(userColorScheme) {
  const scheme = clone(defaultColorScheme);
  if (userColorScheme) for (const key in userColorScheme) {
    const [color, invertColor] = toArray(userColorScheme[key]);
    const [defaultColor, defaultInvertColor] = scheme[key];
    scheme[key] = [color ?? defaultColor, invertColor ?? defaultInvertColor];
  }
  return scheme;
}
function resolveSizeScheme(userSizeScheme) {
  if (userSizeScheme) return mergeDeep(ProseDefaultSize, userSizeScheme);
  return ProseDefaultSize;
}
function getCSS(preflights3, options) {
  const selectorName = options.selectorName || "prose";
  const notProseSelector = `:not(:where([class~="not-${selectorName}"],[class~="not-${selectorName}"] *))`;
  const important3 = options.important === true;
  let css = "";
  for (const [selectorOrKey, cssObjectOrValue] of Object.entries(preflights3)) if (typeof cssObjectOrValue !== "object") css += `${selectorOrKey}:${cssObjectOrValue}${important3 ? " !important" : ""};`;
  else {
    const [selectorOrGroup, pseudo] = selectorOrKey.split("::");
    const _selector = `:where(${selectorOrGroup})${notProseSelector}${pseudo ? `::${pseudo}` : ""}`;
    css += `${_selector} {`;
    for (const [key, value] of Object.entries(cssObjectOrValue)) css += `${key}:${value}${important3 ? " !important" : ""};`;
    css += `}`;
  }
  return css;
}
function getElements(modifier) {
  for (const [name50, ...selectors] of modifiers) if (name50 === modifier) return selectors.length > 0 ? selectors : [name50];
}
var presetTypography = definePreset((options) => {
  var _a, _b;
  const selectorName = (options == null ? void 0 : options.selectorName) ?? "prose";
  const disableNotUtility = ((_a = options == null ? void 0 : options.compatibility) == null ? void 0 : _a.noColonNot) || ((_b = options == null ? void 0 : options.compatibility) == null ? void 0 : _b.noColonWhere);
  const cssVarPrefix = (options == null ? void 0 : options.cssVarPrefix) ?? "--un-prose";
  const resolvedColorScheme = resolveColorScheme(options == null ? void 0 : options.colorScheme);
  const resolvedSizeScheme = resolveSizeScheme(options == null ? void 0 : options.sizeScheme);
  const extended = (entries, theme4) => {
    return mergeDeep(entries, (typeof (options == null ? void 0 : options.cssExtend) === "function" ? options == null ? void 0 : options.cssExtend(theme4) : options == null ? void 0 : options.cssExtend) ?? {});
  };
  const normalizeSelector = (s) => {
    var _a2;
    if (typeof (options == null ? void 0 : options.important) === "string") s = `${options.important} ${s}`;
    if (!((_a2 = options == null ? void 0 : options.compatibility) == null ? void 0 : _a2.noColonIs)) s = `:is(${s})`;
    return s;
  };
  const defaultRE = new RegExp(`^${selectorName}-default$`);
  const colorsRE = new RegExp(`^${selectorName}-([-\\w]+)$`);
  const sizeRE = new RegExp(`^${selectorName}-(${Object.keys(resolvedSizeScheme).join("|")})$`);
  return {
    name: "@unocss/preset-typography",
    enforce: "post",
    layers: { typography: -20 },
    shortcuts: [[
      selectorName,
      [`${selectorName}-default`, `${selectorName}-gray`],
      { layer: "typography" }
    ]],
    rules: [
      [
        defaultRE,
        (_, { symbols: symbols$1, theme: theme4 }) => {
          const css = getCSS(extended(mergeDeep(ProseDefaultCSSObject, ProseDefaultSize.base), theme4), options ?? {});
          return {
            [symbols$1.body]: css,
            [symbols$1.selector]: normalizeSelector
          };
        },
        {
          layer: "typography",
          autocomplete: "prose",
          internal: true
        }
      ],
      [
        colorsRE,
        ([, color], { theme: theme4, symbols: symbols$1 }) => {
          var _a2;
          const baseColor = (_a2 = theme4.colors) == null ? void 0 : _a2[color];
          if (!baseColor || typeof baseColor !== "object") return;
          if ([
            "red",
            "orange",
            "amber",
            "yellow",
            "lime",
            "green",
            "emerald",
            "teal",
            "cyan",
            "sky",
            "blue",
            "indigo",
            "violet",
            "purple",
            "fuchsia",
            "pink",
            "rose"
          ].includes(color)) return {
            [`${cssVarPrefix}-links`]: baseColor["600"],
            [`${cssVarPrefix}-invert-links`]: baseColor["500"],
            [symbols$1.selector]: normalizeSelector
          };
          else return Object.entries(resolvedColorScheme).reduce((acc, [key, value]) => {
            const [colorKey, invertKey] = value;
            const resolve = (key$1) => baseColor[key$1] ?? theme4[key$1] ?? key$1;
            const color$1 = resolve(colorKey);
            const invertColor = resolve(invertKey);
            const cssVarColorKey = `${cssVarPrefix}-${key}`;
            const cssVarInvertColorKey = `${cssVarPrefix}-invert-${key}`;
            acc[cssVarColorKey] = colorToString2(color$1, `var(${cssVarColorKey}-opacity)`);
            acc[cssVarInvertColorKey] = colorToString2(invertColor, `var(${cssVarInvertColorKey}-opacity)`);
            for (const [c, k] of [[color$1, `${cssVarColorKey}-opacity`], [invertColor, `${cssVarInvertColorKey}-opacity`]]) if (alphaPlaceholders.some((p) => c.includes(p))) acc[k] = "1";
            return acc;
          }, { [symbols$1.selector]: normalizeSelector });
        },
        {
          layer: "typography",
          autocomplete: `${selectorName}-$colors`
        }
      ],
      [
        sizeRE,
        ([, size], { symbols: symbols$1, theme: theme4 }) => {
          const css = getCSS(extended(resolvedSizeScheme[size], theme4), options ?? {});
          return {
            [symbols$1.body]: css,
            [symbols$1.selector]: normalizeSelector
          };
        },
        {
          layer: "typography",
          autocomplete: `${selectorName}-(${Object.keys(resolvedSizeScheme).join("|")})`
        }
      ],
      [
        `${selectorName}-invert`,
        [{
          [`${cssVarPrefix}-body`]: `var(${cssVarPrefix}-invert-body)`,
          [`${cssVarPrefix}-headings`]: `var(${cssVarPrefix}-invert-headings)`,
          [`${cssVarPrefix}-lead`]: `var(${cssVarPrefix}-invert-lead)`,
          [`${cssVarPrefix}-links`]: `var(${cssVarPrefix}-invert-links)`,
          [`${cssVarPrefix}-bold`]: `var(${cssVarPrefix}-invert-bold)`,
          [`${cssVarPrefix}-counters`]: `var(${cssVarPrefix}-invert-counters)`,
          [`${cssVarPrefix}-bullets`]: `var(${cssVarPrefix}-invert-bullets)`,
          [`${cssVarPrefix}-hr`]: `var(${cssVarPrefix}-invert-hr)`,
          [`${cssVarPrefix}-quotes`]: `var(${cssVarPrefix}-invert-quotes)`,
          [`${cssVarPrefix}-quote-borders`]: `var(${cssVarPrefix}-invert-quote-borders)`,
          [`${cssVarPrefix}-captions`]: `var(${cssVarPrefix}-invert-captions)`,
          [`${cssVarPrefix}-kbd`]: `var(${cssVarPrefix}-invert-kbd)`,
          [`${cssVarPrefix}-kbd-shadows`]: `var(${cssVarPrefix}-invert-kbd-shadows)`,
          [`${cssVarPrefix}-code`]: `var(${cssVarPrefix}-invert-code)`,
          [`${cssVarPrefix}-pre-code`]: `var(${cssVarPrefix}-invert-pre-code)`,
          [`${cssVarPrefix}-pre-bg`]: `var(${cssVarPrefix}-invert-pre-bg)`,
          [`${cssVarPrefix}-th-borders`]: `var(${cssVarPrefix}-invert-th-borders)`,
          [`${cssVarPrefix}-td-borders`]: `var(${cssVarPrefix}-invert-td-borders)`,
          [symbols.selector]: normalizeSelector
        }],
        { layer: "typography" }
      ]
    ],
    variants: [{
      name: "typography element modifiers",
      match: (matcher) => {
        var _a2;
        if (matcher.startsWith(`${selectorName}-`)) {
          const modifyRe = new RegExp(`^${selectorName}-(\\w+)[:-].+$`);
          const modifier = (_a2 = matcher.match(modifyRe)) == null ? void 0 : _a2[1];
          if (modifier) {
            const elements = getElements(modifier);
            if (elements == null ? void 0 : elements.length) return {
              matcher: matcher.slice(selectorName.length + modifier.length + 2),
              selector: (s) => {
                const notProseSelector = `:not(:where([class~="not-${selectorName}"],[class~="not-${selectorName}"] *))`;
                return disableNotUtility ? elements.map((e2) => `${s} ${e2}`).join(",") : `${s} :is(:where(${elements})${notProseSelector})`;
              }
            };
          }
        }
      },
      autocomplete: `${selectorName}-(${modifiers.map((m) => `${m[0]}:`).join("|")})`
    }]
  };
});
var src_default4 = presetTypography;

// node_modules/@unocss/preset-wind3/dist/container-re6ef8hp.mjs
var queryMatcher = /@media \(min-width: (.+)\)/;
var container = [[
  /^__container$/,
  (m, context) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const { theme: theme4, variantHandlers } = context;
    const themePadding = (_a = theme4.container) == null ? void 0 : _a.padding;
    let padding;
    if (isString(themePadding)) padding = themePadding;
    else padding = themePadding == null ? void 0 : themePadding.DEFAULT;
    const themeMaxWidth = (_b = theme4.container) == null ? void 0 : _b.maxWidth;
    let maxWidth2;
    for (const v of variantHandlers) {
      const query = (_d = (_c = v.handle) == null ? void 0 : _c.call(v, {}, (x) => x)) == null ? void 0 : _d.parent;
      if (isString(query)) {
        const match = (_e = query.match(queryMatcher)) == null ? void 0 : _e[1];
        if (match) {
          const matchBp = (_f = (resolveBreakpoints(context) ?? []).find((i) => i.size === match)) == null ? void 0 : _f.point;
          if (!themeMaxWidth) maxWidth2 = match;
          else if (matchBp) maxWidth2 = themeMaxWidth == null ? void 0 : themeMaxWidth[matchBp];
          if (matchBp && !isString(themePadding)) padding = (themePadding == null ? void 0 : themePadding[matchBp]) ?? padding;
        }
      }
    }
    const css = { "max-width": maxWidth2 };
    if (!variantHandlers.length) css.width = "100%";
    if ((_g = theme4.container) == null ? void 0 : _g.center) {
      css["margin-left"] = "auto";
      css["margin-right"] = "auto";
    }
    if (themePadding) {
      css["padding-left"] = padding;
      css["padding-right"] = padding;
    }
    return css;
  },
  { internal: true }
]];
var containerShortcuts = [[/^(?:(\w+)[:-])?container$/, ([, bp], context) => {
  let points = (resolveBreakpoints(context) ?? []).map((i) => i.point);
  if (bp) {
    if (!points.includes(bp)) return;
    points = points.slice(points.indexOf(bp));
  }
  const shortcuts3 = points.map((p) => `${p}:__container`);
  if (!bp) shortcuts3.unshift("__container");
  return shortcuts3;
}]];

// node_modules/@unocss/preset-wind3/dist/rules.mjs
var animations = [
  [
    /^(?:animate-)?keyframes-(.+)$/,
    ([, name50], { theme: theme4 }) => {
      var _a, _b;
      const kf = (_b = (_a = theme4.animation) == null ? void 0 : _a.keyframes) == null ? void 0 : _b[name50];
      if (kf) return [`@keyframes ${name50}${kf}`, { animation: name50 }];
    },
    { autocomplete: ["animate-keyframes-$animation.keyframes", "keyframes-$animation.keyframes"] }
  ],
  [
    /^animate-(.+)$/,
    ([, name50], { theme: theme4 }) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
      const kf = (_b = (_a = theme4.animation) == null ? void 0 : _a.keyframes) == null ? void 0 : _b[name50];
      if (kf) {
        const duration2 = ((_d = (_c = theme4.animation) == null ? void 0 : _c.durations) == null ? void 0 : _d[name50]) ?? "1s";
        const timing = ((_f = (_e = theme4.animation) == null ? void 0 : _e.timingFns) == null ? void 0 : _f[name50]) ?? "linear";
        const count = ((_h = (_g = theme4.animation) == null ? void 0 : _g.counts) == null ? void 0 : _h[name50]) ?? 1;
        const props = (_j = (_i = theme4.animation) == null ? void 0 : _i.properties) == null ? void 0 : _j[name50];
        return [`@keyframes ${name50}${kf}`, {
          animation: `${name50} ${duration2} ${timing} ${count}`,
          ...props
        }];
      }
      return { animation: h.bracket.cssvar(name50) };
    },
    { autocomplete: "animate-$animation.keyframes" }
  ],
  [/^animate-name-(.+)/, ([, d]) => ({ "animation-name": h.bracket.cssvar(d) ?? d })],
  [
    /^animate-duration-(.+)$/,
    ([, d], { theme: theme4 }) => {
      var _a;
      return { "animation-duration": ((_a = theme4.duration) == null ? void 0 : _a[d || "DEFAULT"]) ?? h.bracket.cssvar.time(d) };
    },
    { autocomplete: ["animate-duration", "animate-duration-$duration"] }
  ],
  [
    /^animate-delay-(.+)$/,
    ([, d], { theme: theme4 }) => {
      var _a;
      return { "animation-delay": ((_a = theme4.duration) == null ? void 0 : _a[d || "DEFAULT"]) ?? h.bracket.cssvar.time(d) };
    },
    { autocomplete: ["animate-delay", "animate-delay-$duration"] }
  ],
  [
    /^animate-ease(?:-(.+))?$/,
    ([, d], { theme: theme4 }) => {
      var _a;
      return { "animation-timing-function": ((_a = theme4.easing) == null ? void 0 : _a[d || "DEFAULT"]) ?? h.bracket.cssvar(d) };
    },
    { autocomplete: ["animate-ease", "animate-ease-$easing"] }
  ],
  [
    /^animate-(fill-mode-|fill-|mode-)?(.+)$/,
    ([, t, d]) => [
      "none",
      "forwards",
      "backwards",
      "both",
      ...[t ? globalKeywords : []]
    ].includes(d) ? { "animation-fill-mode": d } : void 0,
    { autocomplete: [
      "animate-(fill|mode|fill-mode)",
      "animate-(fill|mode|fill-mode)-(none|forwards|backwards|both|inherit|initial|revert|revert-layer|unset)",
      "animate-(none|forwards|backwards|both|inherit|initial|revert|revert-layer|unset)"
    ] }
  ],
  [
    /^animate-(direction-)?(.+)$/,
    ([, t, d]) => [
      "normal",
      "reverse",
      "alternate",
      "alternate-reverse",
      ...[t ? globalKeywords : []]
    ].includes(d) ? { "animation-direction": d } : void 0,
    { autocomplete: [
      "animate-direction",
      "animate-direction-(normal|reverse|alternate|alternate-reverse|inherit|initial|revert|revert-layer|unset)",
      "animate-(normal|reverse|alternate|alternate-reverse|inherit|initial|revert|revert-layer|unset)"
    ] }
  ],
  [
    /^animate-(?:iteration-count-|iteration-|count-)(.+)$/,
    ([, d]) => ({ "animation-iteration-count": h.bracket.cssvar(d) ?? d.replace(/-/g, ",") }),
    { autocomplete: ["animate-(iteration|count|iteration-count)", "animate-(iteration|count|iteration-count)-<num>"] }
  ],
  [
    /^animate-(play-state-|play-|state-)?(.+)$/,
    ([, t, d]) => [
      "paused",
      "running",
      ...[t ? globalKeywords : []]
    ].includes(d) ? { "animation-play-state": d } : void 0,
    { autocomplete: [
      "animate-(play|state|play-state)",
      "animate-(play|state|play-state)-(paused|running|inherit|initial|revert|revert-layer|unset)",
      "animate-(paused|running|inherit|initial|revert|revert-layer|unset)"
    ] }
  ],
  ["animate-none", { animation: "none" }],
  ...makeGlobalStaticRules("animate", "animation")
];
function bgGradientToValue(cssColor) {
  if (cssColor) return colorToString2(cssColor, 0);
  return "rgb(255 255 255 / 0)";
}
function bgGradientColorValue(mode, cssColor, color, alpha) {
  if (cssColor) if (alpha != null) return colorToString2(cssColor, alpha);
  else return colorToString2(cssColor, `var(--un-${mode}-opacity, ${colorOpacityToString(cssColor)})`);
  return colorToString2(color, alpha);
}
function bgGradientColorResolver() {
  return ([, mode, body], { theme: theme4 }) => {
    const data = parseColor2(body, theme4, "backgroundColor");
    if (!data) return;
    const { alpha, color, cssColor } = data;
    if (!color) return;
    const colorString = bgGradientColorValue(mode, cssColor, color, alpha);
    switch (mode) {
      case "from":
        return {
          "--un-gradient-from-position": "0%",
          "--un-gradient-from": `${colorString} var(--un-gradient-from-position)`,
          "--un-gradient-to-position": "100%",
          "--un-gradient-to": `${bgGradientToValue(cssColor)} var(--un-gradient-to-position)`,
          "--un-gradient-stops": "var(--un-gradient-from), var(--un-gradient-to)"
        };
      case "via":
        return {
          "--un-gradient-via-position": "50%",
          "--un-gradient-to": bgGradientToValue(cssColor),
          "--un-gradient-stops": `var(--un-gradient-from), ${colorString} var(--un-gradient-via-position), var(--un-gradient-to)`
        };
      case "to":
        return {
          "--un-gradient-to-position": "100%",
          "--un-gradient-to": `${colorString} var(--un-gradient-to-position)`
        };
    }
  };
}
function bgGradientPositionResolver() {
  return ([, mode, body]) => {
    return { [`--un-gradient-${mode}-position`]: `${Number(h.bracket.cssvar.percent(body)) * 100}%` };
  };
}
var backgroundStyles = [
  [
    /^bg-gradient-(.+)$/,
    ([, d]) => ({ "--un-gradient": h.bracket(d) }),
    { autocomplete: [
      "bg-gradient",
      "bg-gradient-(from|to|via)",
      "bg-gradient-(from|to|via)-$colors",
      "bg-gradient-(from|to|via)-(op|opacity)",
      "bg-gradient-(from|to|via)-(op|opacity)-<percent>"
    ] }
  ],
  [/^(?:bg-gradient-)?stops-(\[.+\])$/, ([, s]) => ({ "--un-gradient-stops": h.bracket(s) })],
  [/^(?:bg-gradient-)?(from)-(.+)$/, bgGradientColorResolver()],
  [/^(?:bg-gradient-)?(via)-(.+)$/, bgGradientColorResolver()],
  [/^(?:bg-gradient-)?(to)-(.+)$/, bgGradientColorResolver()],
  [/^(?:bg-gradient-)?(from|via|to)-op(?:acity)?-?(.+)$/, ([, position3, opacity3]) => ({ [`--un-${position3}-opacity`]: h.bracket.percent(opacity3) })],
  [/^(from|via|to)-([\d.]+)%$/, bgGradientPositionResolver()],
  [
    /^bg-gradient-((?:repeating-)?(?:linear|radial|conic))$/,
    ([, s]) => ({ "background-image": `${s}-gradient(var(--un-gradient, var(--un-gradient-stops, rgb(255 255 255 / 0))))` }),
    { autocomplete: [
      "bg-gradient-repeating",
      "bg-gradient-(linear|radial|conic)",
      "bg-gradient-repeating-(linear|radial|conic)"
    ] }
  ],
  [
    /^bg-gradient-to-([rltb]{1,2})$/,
    ([, d]) => {
      if (d in positionMap) return {
        "--un-gradient-shape": `to ${positionMap[d]} in oklch`,
        "--un-gradient": "var(--un-gradient-shape), var(--un-gradient-stops)",
        "background-image": "linear-gradient(var(--un-gradient))"
      };
    },
    { autocomplete: `bg-gradient-to-(${Object.keys(positionMap).filter((k) => k.length <= 2 && Array.from(k).every((c) => "rltb".includes(c))).join("|")})` }
  ],
  [
    /^(?:bg-gradient-)?shape-(.+)$/,
    ([, d]) => {
      const v = d in positionMap ? `to ${positionMap[d]}` : h.bracket(d);
      if (v != null) return {
        "--un-gradient-shape": `${v} in oklch`,
        "--un-gradient": "var(--un-gradient-shape), var(--un-gradient-stops)"
      };
    },
    { autocomplete: [
      "bg-gradient-shape",
      `bg-gradient-shape-(${Object.keys(positionMap).join("|")})`,
      `shape-(${Object.keys(positionMap).join("|")})`
    ] }
  ],
  ["bg-none", { "background-image": "none" }],
  ["box-decoration-slice", { "box-decoration-break": "slice" }],
  ["box-decoration-clone", { "box-decoration-break": "clone" }],
  ...makeGlobalStaticRules("box-decoration", "box-decoration-break"),
  ["bg-auto", { "background-size": "auto" }],
  ["bg-cover", { "background-size": "cover" }],
  ["bg-contain", { "background-size": "contain" }],
  ["bg-fixed", { "background-attachment": "fixed" }],
  ["bg-local", { "background-attachment": "local" }],
  ["bg-scroll", { "background-attachment": "scroll" }],
  ["bg-clip-border", {
    "-webkit-background-clip": "border-box",
    "background-clip": "border-box"
  }],
  ["bg-clip-content", {
    "-webkit-background-clip": "content-box",
    "background-clip": "content-box"
  }],
  ["bg-clip-padding", {
    "-webkit-background-clip": "padding-box",
    "background-clip": "padding-box"
  }],
  ["bg-clip-text", {
    "-webkit-background-clip": "text",
    "background-clip": "text"
  }],
  ...globalKeywords.map((keyword2) => [`bg-clip-${keyword2}`, {
    "-webkit-background-clip": keyword2,
    "background-clip": keyword2
  }]),
  [/^bg-([-\w]{3,})$/, ([, s]) => ({ "background-position": positionMap[s] })],
  ["bg-repeat", { "background-repeat": "repeat" }],
  ["bg-no-repeat", { "background-repeat": "no-repeat" }],
  ["bg-repeat-x", { "background-repeat": "repeat-x" }],
  ["bg-repeat-y", { "background-repeat": "repeat-y" }],
  ["bg-repeat-round", { "background-repeat": "round" }],
  ["bg-repeat-space", { "background-repeat": "space" }],
  ...makeGlobalStaticRules("bg-repeat", "background-repeat"),
  ["bg-origin-border", { "background-origin": "border-box" }],
  ["bg-origin-padding", { "background-origin": "padding-box" }],
  ["bg-origin-content", { "background-origin": "content-box" }],
  ...makeGlobalStaticRules("bg-origin", "background-origin")
];
var listStyles = {
  "disc": "disc",
  "circle": "circle",
  "square": "square",
  "decimal": "decimal",
  "zero-decimal": "decimal-leading-zero",
  "greek": "lower-greek",
  "roman": "lower-roman",
  "upper-roman": "upper-roman",
  "alpha": "lower-alpha",
  "upper-alpha": "upper-alpha",
  "latin": "lower-latin",
  "upper-latin": "upper-latin"
};
var listStyle = [
  [
    /^list-(.+?)(?:-(outside|inside))?$/,
    ([, alias, position3]) => {
      const style = listStyles[alias];
      if (style) {
        if (position3) return {
          "list-style-position": position3,
          "list-style-type": style
        };
        return { "list-style-type": style };
      }
    },
    { autocomplete: [`list-(${Object.keys(listStyles).join("|")})`, `list-(${Object.keys(listStyles).join("|")})-(outside|inside)`] }
  ],
  ["list-outside", { "list-style-position": "outside" }],
  ["list-inside", { "list-style-position": "inside" }],
  ["list-none", { "list-style-type": "none" }],
  [/^list-image-(.+)$/, ([, d]) => {
    if (/^\[url\(.+\)\]$/.test(d)) return { "list-style-image": h.bracket(d) };
  }],
  ["list-image-none", { "list-style-image": "none" }],
  ...makeGlobalStaticRules("list", "list-style-type")
];
var accents = [[
  /^accent-(.+)$/,
  colorResolver("accent-color", "accent", "accentColor"),
  { autocomplete: "accent-$colors" }
], [
  /^accent-op(?:acity)?-?(.+)$/,
  ([, d]) => ({ "--un-accent-opacity": h.bracket.percent(d) }),
  { autocomplete: ["accent-(op|opacity)", "accent-(op|opacity)-<percent>"] }
]];
var carets = [[
  /^caret-(.+)$/,
  colorResolver("caret-color", "caret", "textColor"),
  { autocomplete: "caret-$colors" }
], [
  /^caret-op(?:acity)?-?(.+)$/,
  ([, d]) => ({ "--un-caret-opacity": h.bracket.percent(d) }),
  { autocomplete: ["caret-(op|opacity)", "caret-(op|opacity)-<percent>"] }
]];
var imageRenderings = [
  ["image-render-auto", { "image-rendering": "auto" }],
  ["image-render-edge", { "image-rendering": "crisp-edges" }],
  ["image-render-pixel", [
    ["-ms-interpolation-mode", "nearest-neighbor"],
    ["image-rendering", "-webkit-optimize-contrast"],
    ["image-rendering", "-moz-crisp-edges"],
    ["image-rendering", "-o-pixelated"],
    ["image-rendering", "pixelated"]
  ]]
];
var overscrolls = [
  ["overscroll-auto", { "overscroll-behavior": "auto" }],
  ["overscroll-contain", { "overscroll-behavior": "contain" }],
  ["overscroll-none", { "overscroll-behavior": "none" }],
  ...makeGlobalStaticRules("overscroll", "overscroll-behavior"),
  ["overscroll-x-auto", { "overscroll-behavior-x": "auto" }],
  ["overscroll-x-contain", { "overscroll-behavior-x": "contain" }],
  ["overscroll-x-none", { "overscroll-behavior-x": "none" }],
  ...makeGlobalStaticRules("overscroll-x", "overscroll-behavior-x"),
  ["overscroll-y-auto", { "overscroll-behavior-y": "auto" }],
  ["overscroll-y-contain", { "overscroll-behavior-y": "contain" }],
  ["overscroll-y-none", { "overscroll-behavior-y": "none" }],
  ...makeGlobalStaticRules("overscroll-y", "overscroll-behavior-y")
];
var scrollBehaviors = [
  ["scroll-auto", { "scroll-behavior": "auto" }],
  ["scroll-smooth", { "scroll-behavior": "smooth" }],
  ...makeGlobalStaticRules("scroll", "scroll-behavior")
];
var columns = [
  [
    /^columns-(.+)$/,
    ([, v], { theme: theme4 }) => {
      if (theme4.containers && v in theme4.containers) return { columns: theme4.containers[v] };
      return { columns: h.bracket.numberWithUnit.number.cssvar(v) };
    },
    { autocomplete: ["columns-<num>", "columns-$containers"] }
  ],
  ["columns-auto", { columns: "auto" }],
  ["break-before-auto", { "break-before": "auto" }],
  ["break-before-avoid", { "break-before": "avoid" }],
  ["break-before-all", { "break-before": "all" }],
  ["break-before-avoid-page", { "break-before": "avoid-page" }],
  ["break-before-page", { "break-before": "page" }],
  ["break-before-left", { "break-before": "left" }],
  ["break-before-right", { "break-before": "right" }],
  ["break-before-column", { "break-before": "column" }],
  ...makeGlobalStaticRules("break-before"),
  ["break-inside-auto", { "break-inside": "auto" }],
  ["break-inside-avoid", { "break-inside": "avoid" }],
  ["break-inside-avoid-page", { "break-inside": "avoid-page" }],
  ["break-inside-avoid-column", { "break-inside": "avoid-column" }],
  ...makeGlobalStaticRules("break-inside"),
  ["break-after-auto", { "break-after": "auto" }],
  ["break-after-avoid", { "break-after": "avoid" }],
  ["break-after-all", { "break-after": "all" }],
  ["break-after-avoid-page", { "break-after": "avoid-page" }],
  ["break-after-page", { "break-after": "page" }],
  ["break-after-left", { "break-after": "left" }],
  ["break-after-right", { "break-after": "right" }],
  ["break-after-column", { "break-after": "column" }],
  ...makeGlobalStaticRules("break-after")
];
var divides = [
  [
    /^divide-?([xy])$/,
    handlerDivide,
    { autocomplete: [
      "divide-(x|y|block|inline)",
      "divide-(x|y|block|inline)-reverse",
      "divide-(x|y|block|inline)-$lineWidth"
    ] }
  ],
  [/^divide-?([xy])-?(.+)$/, handlerDivide],
  [/^divide-?([xy])-reverse$/, ([, d]) => ({ [`--un-divide-${d}-reverse`]: 1 })],
  [/^divide-(block|inline)$/, handlerDivide],
  [/^divide-(block|inline)-(.+)$/, handlerDivide],
  [/^divide-(block|inline)-reverse$/, ([, d]) => ({ [`--un-divide-${d}-reverse`]: 1 })],
  [
    /^divide-(.+)$/,
    colorResolver("border-color", "divide", "borderColor"),
    { autocomplete: "divide-$colors" }
  ],
  [
    /^divide-op(?:acity)?-?(.+)$/,
    ([, opacity3]) => ({ "--un-divide-opacity": h.bracket.percent(opacity3) }),
    { autocomplete: ["divide-(op|opacity)", "divide-(op|opacity)-<percent>"] }
  ],
  ...borderStyles.map((style) => [`divide-${style}`, { "border-style": style }])
];
function handlerDivide([, d, s], { theme: theme4 }) {
  var _a;
  let v = ((_a = theme4.lineWidth) == null ? void 0 : _a[s || "DEFAULT"]) ?? h.bracket.cssvar.px(s || "1");
  if (v != null) {
    if (v === "0") v = "0px";
    const results = directionMap[d].map((item) => {
      return [`border${item}-width`, item.endsWith("right") || item.endsWith("bottom") ? `calc(${v} * var(--un-divide-${d}-reverse))` : `calc(${v} * calc(1 - var(--un-divide-${d}-reverse)))`];
    });
    if (results) return [[`--un-divide-${d}-reverse`, 0], ...results];
  }
}
var filterBase = {
  "--un-blur": varEmpty,
  "--un-brightness": varEmpty,
  "--un-contrast": varEmpty,
  "--un-drop-shadow": varEmpty,
  "--un-grayscale": varEmpty,
  "--un-hue-rotate": varEmpty,
  "--un-invert": varEmpty,
  "--un-saturate": varEmpty,
  "--un-sepia": varEmpty
};
var filterBaseKeys = Object.keys(filterBase);
var filterMetaCustom = { preflightKeys: filterBaseKeys };
var filterProperty = "var(--un-blur) var(--un-brightness) var(--un-contrast) var(--un-drop-shadow) var(--un-grayscale) var(--un-hue-rotate) var(--un-invert) var(--un-saturate) var(--un-sepia)";
var backdropFilterBase = {
  "--un-backdrop-blur": varEmpty,
  "--un-backdrop-brightness": varEmpty,
  "--un-backdrop-contrast": varEmpty,
  "--un-backdrop-grayscale": varEmpty,
  "--un-backdrop-hue-rotate": varEmpty,
  "--un-backdrop-invert": varEmpty,
  "--un-backdrop-opacity": varEmpty,
  "--un-backdrop-saturate": varEmpty,
  "--un-backdrop-sepia": varEmpty
};
var backdropFilterBaseKeys = Object.keys(backdropFilterBase);
var backdropMetaCustom = { preflightKeys: backdropFilterBaseKeys };
var backdropFilterProperty = "var(--un-backdrop-blur) var(--un-backdrop-brightness) var(--un-backdrop-contrast) var(--un-backdrop-grayscale) var(--un-backdrop-hue-rotate) var(--un-backdrop-invert) var(--un-backdrop-opacity) var(--un-backdrop-saturate) var(--un-backdrop-sepia)";
var composeMetaCustom = { preflightKeys: [...filterBaseKeys, ...backdropFilterBaseKeys] };
function percentWithDefault(str) {
  let v = h.bracket.cssvar(str || "");
  if (v != null) return v;
  v = str ? h.percent(str) : "1";
  if (v != null && Number.parseFloat(v) <= 1) return v;
}
function toFilter(varName, resolver) {
  return ([, b, s], { theme: theme4 }) => {
    const value = resolver(s, theme4) ?? (s === "none" ? "0" : "");
    if (value !== "") if (b) return {
      [`--un-${b}${varName}`]: `${varName}(${value})`,
      "-webkit-backdrop-filter": backdropFilterProperty,
      "backdrop-filter": backdropFilterProperty
    };
    else return {
      [`--un-${varName}`]: `${varName}(${value})`,
      filter: filterProperty
    };
  };
}
function dropShadowResolver([, s], { theme: theme4 }) {
  var _a;
  let v = (_a = theme4.dropShadow) == null ? void 0 : _a[s || "DEFAULT"];
  if (v != null) {
    const shadows = colorableShadows(v, "--un-drop-shadow-color");
    return {
      "--un-drop-shadow": `drop-shadow(${shadows.join(") drop-shadow(")})`,
      "filter": filterProperty
    };
  }
  v = h.bracket.cssvar(s);
  if (v != null) return {
    "--un-drop-shadow": `drop-shadow(${v})`,
    "filter": filterProperty
  };
}
var filters = [
  [
    /^(?:(backdrop-)|filter-)?blur(?:-(.+))?$/,
    toFilter("blur", (s, theme4) => {
      var _a;
      return ((_a = theme4.blur) == null ? void 0 : _a[s || "DEFAULT"]) || h.bracket.cssvar.px(s);
    }),
    {
      custom: composeMetaCustom,
      autocomplete: [
        "(backdrop|filter)-blur-$blur",
        "blur-$blur",
        "filter-blur"
      ]
    }
  ],
  [
    /^(?:(backdrop-)|filter-)?brightness-(.+)$/,
    toFilter("brightness", (s) => h.bracket.cssvar.percent(s)),
    {
      custom: composeMetaCustom,
      autocomplete: ["(backdrop|filter)-brightness-<percent>", "brightness-<percent>"]
    }
  ],
  [
    /^(?:(backdrop-)|filter-)?contrast-(.+)$/,
    toFilter("contrast", (s) => h.bracket.cssvar.percent(s)),
    {
      custom: composeMetaCustom,
      autocomplete: ["(backdrop|filter)-contrast-<percent>", "contrast-<percent>"]
    }
  ],
  [
    /^(?:filter-)?drop-shadow(?:-(.+))?$/,
    dropShadowResolver,
    {
      custom: filterMetaCustom,
      autocomplete: [
        "filter-drop",
        "filter-drop-shadow",
        "filter-drop-shadow-color",
        "drop-shadow",
        "drop-shadow-color",
        "filter-drop-shadow-$dropShadow",
        "drop-shadow-$dropShadow",
        "filter-drop-shadow-color-$colors",
        "drop-shadow-color-$colors",
        "filter-drop-shadow-color-(op|opacity)",
        "drop-shadow-color-(op|opacity)",
        "filter-drop-shadow-color-(op|opacity)-<percent>",
        "drop-shadow-color-(op|opacity)-<percent>"
      ]
    }
  ],
  [/^(?:filter-)?drop-shadow-color-(.+)$/, colorResolver("--un-drop-shadow-color", "drop-shadow", "shadowColor")],
  [/^(?:filter-)?drop-shadow-color-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-drop-shadow-opacity": h.bracket.percent(opacity3) })],
  [
    /^(?:(backdrop-)|filter-)?grayscale(?:-(.+))?$/,
    toFilter("grayscale", percentWithDefault),
    {
      custom: composeMetaCustom,
      autocomplete: [
        "(backdrop|filter)-grayscale",
        "(backdrop|filter)-grayscale-<percent>",
        "grayscale-<percent>"
      ]
    }
  ],
  [
    /^(?:(backdrop-)|filter-)?hue-rotate-(.+)$/,
    toFilter("hue-rotate", (s) => h.bracket.cssvar.degree(s)),
    { custom: composeMetaCustom }
  ],
  [
    /^(?:(backdrop-)|filter-)?invert(?:-(.+))?$/,
    toFilter("invert", percentWithDefault),
    {
      custom: composeMetaCustom,
      autocomplete: [
        "(backdrop|filter)-invert",
        "(backdrop|filter)-invert-<percent>",
        "invert-<percent>"
      ]
    }
  ],
  [
    /^(backdrop-)op(?:acity)?-(.+)$/,
    toFilter("opacity", (s) => h.bracket.cssvar.percent(s)),
    {
      custom: composeMetaCustom,
      autocomplete: ["backdrop-(op|opacity)", "backdrop-(op|opacity)-<percent>"]
    }
  ],
  [
    /^(?:(backdrop-)|filter-)?saturate-(.+)$/,
    toFilter("saturate", (s) => h.bracket.cssvar.percent(s)),
    {
      custom: composeMetaCustom,
      autocomplete: [
        "(backdrop|filter)-saturate",
        "(backdrop|filter)-saturate-<percent>",
        "saturate-<percent>"
      ]
    }
  ],
  [
    /^(?:(backdrop-)|filter-)?sepia(?:-(.+))?$/,
    toFilter("sepia", percentWithDefault),
    {
      custom: composeMetaCustom,
      autocomplete: [
        "(backdrop|filter)-sepia",
        "(backdrop|filter)-sepia-<percent>",
        "sepia-<percent>"
      ]
    }
  ],
  [
    "filter",
    { filter: filterProperty },
    { custom: filterMetaCustom }
  ],
  [
    "backdrop-filter",
    {
      "-webkit-backdrop-filter": backdropFilterProperty,
      "backdrop-filter": backdropFilterProperty
    },
    { custom: backdropMetaCustom }
  ],
  ["filter-none", { filter: "none" }],
  ["backdrop-filter-none", {
    "-webkit-backdrop-filter": "none",
    "backdrop-filter": "none"
  }],
  ...globalKeywords.map((keyword2) => [`filter-${keyword2}`, { filter: keyword2 }]),
  ...globalKeywords.map((keyword2) => [`backdrop-filter-${keyword2}`, {
    "-webkit-backdrop-filter": keyword2,
    "backdrop-filter": keyword2
  }])
];
var lineClamps = [[
  /^line-clamp-(\d+)$/,
  ([, v]) => ({
    "overflow": "hidden",
    "display": "-webkit-box",
    "-webkit-box-orient": "vertical",
    "-webkit-line-clamp": v,
    "line-clamp": v
  }),
  { autocomplete: ["line-clamp", "line-clamp-<num>"] }
], ...["none", ...globalKeywords].map((keyword2) => [`line-clamp-${keyword2}`, {
  "overflow": "visible",
  "display": "block",
  "-webkit-box-orient": "horizontal",
  "-webkit-line-clamp": keyword2,
  "line-clamp": keyword2
}])];
var placeholders = [[
  /^\$ placeholder-(.+)$/,
  colorResolver("color", "placeholder", "accentColor"),
  { autocomplete: "placeholder-$colors" }
], [
  /^\$ placeholder-op(?:acity)?-?(.+)$/,
  ([, opacity3]) => ({ "--un-placeholder-opacity": h.bracket.percent(opacity3) }),
  { autocomplete: ["placeholder-(op|opacity)", "placeholder-(op|opacity)-<percent>"] }
]];
var scrollSnapTypeBase = { "--un-scroll-snap-strictness": "proximity" };
var custom$3 = { preflightKeys: Object.keys(scrollSnapTypeBase) };
var scrolls = [
  [
    /^snap-(x|y)$/,
    ([, d]) => ({ "scroll-snap-type": `${d} var(--un-scroll-snap-strictness)` }),
    {
      custom: custom$3,
      autocomplete: "snap-(x|y|both)"
    }
  ],
  [
    /^snap-both$/,
    () => ({ "scroll-snap-type": "both var(--un-scroll-snap-strictness)" }),
    { custom: custom$3 }
  ],
  ["snap-mandatory", { "--un-scroll-snap-strictness": "mandatory" }],
  ["snap-proximity", { "--un-scroll-snap-strictness": "proximity" }],
  ["snap-none", { "scroll-snap-type": "none" }],
  ["snap-start", { "scroll-snap-align": "start" }],
  ["snap-end", { "scroll-snap-align": "end" }],
  ["snap-center", { "scroll-snap-align": "center" }],
  ["snap-align-none", { "scroll-snap-align": "none" }],
  ["snap-normal", { "scroll-snap-stop": "normal" }],
  ["snap-always", { "scroll-snap-stop": "always" }],
  [
    /^scroll-ma?()-?(.+)$/,
    directionSize("scroll-margin"),
    { autocomplete: [
      "scroll-(m|p|ma|pa|block|inline)",
      "scroll-(m|p|ma|pa|block|inline)-$spacing",
      "scroll-(m|p|ma|pa|block|inline)-(x|y|r|l|t|b|bs|be|is|ie)",
      "scroll-(m|p|ma|pa|block|inline)-(x|y|r|l|t|b|bs|be|is|ie)-$spacing"
    ] }
  ],
  [/^scroll-m-?([xy])-?(.+)$/, directionSize("scroll-margin")],
  [/^scroll-m-?([rltb])-?(.+)$/, directionSize("scroll-margin")],
  [/^scroll-m-(block|inline)-(.+)$/, directionSize("scroll-margin")],
  [/^scroll-m-?([bi][se])-?(.+)$/, directionSize("scroll-margin")],
  [/^scroll-pa?()-?(.+)$/, directionSize("scroll-padding")],
  [/^scroll-p-?([xy])-?(.+)$/, directionSize("scroll-padding")],
  [/^scroll-p-?([rltb])-?(.+)$/, directionSize("scroll-padding")],
  [/^scroll-p-(block|inline)-(.+)$/, directionSize("scroll-padding")],
  [/^scroll-p-?([bi][se])-?(.+)$/, directionSize("scroll-padding")]
];
var spaces = [
  [
    /^space-([xy])-(.+)$/,
    handlerSpace,
    { autocomplete: [
      "space-(x|y|block|inline)",
      "space-(x|y|block|inline)-reverse",
      "space-(x|y|block|inline)-$spacing"
    ] }
  ],
  [/^space-([xy])-reverse$/, ([, d]) => ({ [`--un-space-${d}-reverse`]: 1 })],
  [/^space-(block|inline)-(.+)$/, handlerSpace],
  [/^space-(block|inline)-reverse$/, ([, d]) => ({ [`--un-space-${d}-reverse`]: 1 })]
];
function handlerSpace([, d, s], { theme: theme4 }) {
  var _a;
  let v = ((_a = theme4.spacing) == null ? void 0 : _a[s || "DEFAULT"]) ?? h.bracket.cssvar.auto.fraction.rem(s || "1");
  if (v != null) {
    if (v === "0") v = "0px";
    const results = directionMap[d].map((item) => {
      return [`margin${item}`, item.endsWith("right") || item.endsWith("bottom") ? `calc(${v} * var(--un-space-${d}-reverse))` : `calc(${v} * calc(1 - var(--un-space-${d}-reverse)))`];
    });
    if (results) return [[`--un-space-${d}-reverse`, 0], ...results];
  }
}
var textTransforms2 = [
  ["uppercase", { "text-transform": "uppercase" }],
  ["lowercase", { "text-transform": "lowercase" }],
  ["capitalize", { "text-transform": "capitalize" }],
  ["normal-case", { "text-transform": "none" }]
];
var hyphens = [...[
  "manual",
  "auto",
  "none",
  ...globalKeywords
].map((keyword2) => [`hyphens-${keyword2}`, {
  "-webkit-hyphens": keyword2,
  "-ms-hyphens": keyword2,
  "hyphens": keyword2
}])];
var writingModes = [
  ["write-vertical-right", { "writing-mode": "vertical-rl" }],
  ["write-vertical-left", { "writing-mode": "vertical-lr" }],
  ["write-normal", { "writing-mode": "horizontal-tb" }],
  ...makeGlobalStaticRules("write", "writing-mode")
];
var writingOrientations = [
  ["write-orient-mixed", { "text-orientation": "mixed" }],
  ["write-orient-sideways", { "text-orientation": "sideways" }],
  ["write-orient-upright", { "text-orientation": "upright" }],
  ...makeGlobalStaticRules("write-orient", "text-orientation")
];
var screenReadersAccess = [["sr-only", {
  "position": "absolute",
  "width": "1px",
  "height": "1px",
  "padding": "0",
  "margin": "-1px",
  "overflow": "hidden",
  "clip": "rect(0,0,0,0)",
  "white-space": "nowrap",
  "border-width": 0
}], ["not-sr-only", {
  "position": "static",
  "width": "auto",
  "height": "auto",
  "padding": "0",
  "margin": "0",
  "overflow": "visible",
  "clip": "auto",
  "white-space": "normal"
}]];
var isolations = [
  ["isolate", { isolation: "isolate" }],
  ["isolate-auto", { isolation: "auto" }],
  ["isolation-auto", { isolation: "auto" }]
];
var objectPositions = [
  ["object-cover", { "object-fit": "cover" }],
  ["object-contain", { "object-fit": "contain" }],
  ["object-fill", { "object-fit": "fill" }],
  ["object-scale-down", { "object-fit": "scale-down" }],
  ["object-none", { "object-fit": "none" }],
  [
    /^object-(.+)$/,
    ([, d]) => {
      if (positionMap[d]) return { "object-position": positionMap[d] };
      if (h.bracketOfPosition(d) != null) return { "object-position": h.bracketOfPosition(d).split(" ").map((e2) => h.position.fraction.auto.px.cssvar(e2) ?? e2).join(" ") };
    },
    { autocomplete: `object-(${Object.keys(positionMap).join("|")})` }
  ]
];
var backgroundBlendModes = [
  ["bg-blend-multiply", { "background-blend-mode": "multiply" }],
  ["bg-blend-screen", { "background-blend-mode": "screen" }],
  ["bg-blend-overlay", { "background-blend-mode": "overlay" }],
  ["bg-blend-darken", { "background-blend-mode": "darken" }],
  ["bg-blend-lighten", { "background-blend-mode": "lighten" }],
  ["bg-blend-color-dodge", { "background-blend-mode": "color-dodge" }],
  ["bg-blend-color-burn", { "background-blend-mode": "color-burn" }],
  ["bg-blend-hard-light", { "background-blend-mode": "hard-light" }],
  ["bg-blend-soft-light", { "background-blend-mode": "soft-light" }],
  ["bg-blend-difference", { "background-blend-mode": "difference" }],
  ["bg-blend-exclusion", { "background-blend-mode": "exclusion" }],
  ["bg-blend-hue", { "background-blend-mode": "hue" }],
  ["bg-blend-saturation", { "background-blend-mode": "saturation" }],
  ["bg-blend-color", { "background-blend-mode": "color" }],
  ["bg-blend-luminosity", { "background-blend-mode": "luminosity" }],
  ["bg-blend-normal", { "background-blend-mode": "normal" }],
  ...makeGlobalStaticRules("bg-blend", "background-blend")
];
var mixBlendModes = [
  ["mix-blend-multiply", { "mix-blend-mode": "multiply" }],
  ["mix-blend-screen", { "mix-blend-mode": "screen" }],
  ["mix-blend-overlay", { "mix-blend-mode": "overlay" }],
  ["mix-blend-darken", { "mix-blend-mode": "darken" }],
  ["mix-blend-lighten", { "mix-blend-mode": "lighten" }],
  ["mix-blend-color-dodge", { "mix-blend-mode": "color-dodge" }],
  ["mix-blend-color-burn", { "mix-blend-mode": "color-burn" }],
  ["mix-blend-hard-light", { "mix-blend-mode": "hard-light" }],
  ["mix-blend-soft-light", { "mix-blend-mode": "soft-light" }],
  ["mix-blend-difference", { "mix-blend-mode": "difference" }],
  ["mix-blend-exclusion", { "mix-blend-mode": "exclusion" }],
  ["mix-blend-hue", { "mix-blend-mode": "hue" }],
  ["mix-blend-saturation", { "mix-blend-mode": "saturation" }],
  ["mix-blend-color", { "mix-blend-mode": "color" }],
  ["mix-blend-luminosity", { "mix-blend-mode": "luminosity" }],
  ["mix-blend-plus-lighter", { "mix-blend-mode": "plus-lighter" }],
  ["mix-blend-normal", { "mix-blend-mode": "normal" }],
  ...makeGlobalStaticRules("mix-blend")
];
var dynamicViewportHeight = [
  ["min-h-dvh", { "min-height": "100dvh" }],
  ["min-h-svh", { "min-height": "100svh" }],
  ["min-h-lvh", { "min-height": "100lvh" }],
  ["h-dvh", { height: "100dvh" }],
  ["h-svh", { height: "100svh" }],
  ["h-lvh", { height: "100lvh" }],
  ["max-h-dvh", { "max-height": "100dvh" }],
  ["max-h-svh", { "max-height": "100svh" }],
  ["max-h-lvh", { "max-height": "100lvh" }]
];
var borderSpacingBase = {
  "--un-border-spacing-x": 0,
  "--un-border-spacing-y": 0
};
var custom$2 = { preflightKeys: Object.keys(borderSpacingBase) };
var borderSpacingProperty = "var(--un-border-spacing-x) var(--un-border-spacing-y)";
var tables = [
  ["inline-table", { display: "inline-table" }],
  ["table", { display: "table" }],
  ["table-caption", { display: "table-caption" }],
  ["table-cell", { display: "table-cell" }],
  ["table-column", { display: "table-column" }],
  ["table-column-group", { display: "table-column-group" }],
  ["table-footer-group", { display: "table-footer-group" }],
  ["table-header-group", { display: "table-header-group" }],
  ["table-row", { display: "table-row" }],
  ["table-row-group", { display: "table-row-group" }],
  ["border-collapse", { "border-collapse": "collapse" }],
  ["border-separate", { "border-collapse": "separate" }],
  [
    /^border-spacing-(.+)$/,
    ([, s], { theme: theme4 }) => {
      var _a;
      const v = ((_a = theme4.spacing) == null ? void 0 : _a[s]) ?? h.bracket.cssvar.global.auto.fraction.rem(s);
      if (v != null) return {
        "--un-border-spacing-x": v,
        "--un-border-spacing-y": v,
        "border-spacing": borderSpacingProperty
      };
    },
    {
      custom: custom$2,
      autocomplete: ["border-spacing", "border-spacing-$spacing"]
    }
  ],
  [
    /^border-spacing-([xy])-(.+)$/,
    ([, d, s], { theme: theme4 }) => {
      var _a;
      const v = ((_a = theme4.spacing) == null ? void 0 : _a[s]) ?? h.bracket.cssvar.global.auto.fraction.rem(s);
      if (v != null) return {
        [`--un-border-spacing-${d}`]: v,
        "border-spacing": borderSpacingProperty
      };
    },
    {
      custom: custom$2,
      autocomplete: ["border-spacing-(x|y)", "border-spacing-(x|y)-$spacing"]
    }
  ],
  ["caption-top", { "caption-side": "top" }],
  ["caption-bottom", { "caption-side": "bottom" }],
  ["table-auto", { "table-layout": "auto" }],
  ["table-fixed", { "table-layout": "fixed" }],
  ["table-empty-cells-visible", { "empty-cells": "show" }],
  ["table-empty-cells-hidden", { "empty-cells": "hide" }]
];
var touchActionBase = {
  "--un-pan-x": varEmpty,
  "--un-pan-y": varEmpty,
  "--un-pinch-zoom": varEmpty
};
var custom$1 = { preflightKeys: Object.keys(touchActionBase) };
var touchActionProperty = "var(--un-pan-x) var(--un-pan-y) var(--un-pinch-zoom)";
var touchActions = [
  [
    /^touch-pan-(x|left|right)$/,
    ([, d]) => ({
      "--un-pan-x": `pan-${d}`,
      "touch-action": touchActionProperty
    }),
    {
      custom: custom$1,
      autocomplete: ["touch-pan", "touch-pan-(x|left|right|y|up|down)"]
    }
  ],
  [
    /^touch-pan-(y|up|down)$/,
    ([, d]) => ({
      "--un-pan-y": `pan-${d}`,
      "touch-action": touchActionProperty
    }),
    { custom: custom$1 }
  ],
  [
    "touch-pinch-zoom",
    {
      "--un-pinch-zoom": "pinch-zoom",
      "touch-action": touchActionProperty
    },
    { custom: custom$1 }
  ],
  ["touch-auto", { "touch-action": "auto" }],
  ["touch-manipulation", { "touch-action": "manipulation" }],
  ["touch-none", { "touch-action": "none" }],
  ...makeGlobalStaticRules("touch", "touch-action")
];
var fontVariantNumericBase = {
  "--un-ordinal": varEmpty,
  "--un-slashed-zero": varEmpty,
  "--un-numeric-figure": varEmpty,
  "--un-numeric-spacing": varEmpty,
  "--un-numeric-fraction": varEmpty
};
var custom = { preflightKeys: Object.keys(fontVariantNumericBase) };
function toEntries(entry) {
  return {
    ...entry,
    "font-variant-numeric": "var(--un-ordinal) var(--un-slashed-zero) var(--un-numeric-figure) var(--un-numeric-spacing) var(--un-numeric-fraction)"
  };
}
var fontVariantNumeric = [
  [
    /^ordinal$/,
    () => toEntries({ "--un-ordinal": "ordinal" }),
    {
      custom,
      autocomplete: "ordinal"
    }
  ],
  [
    /^slashed-zero$/,
    () => toEntries({ "--un-slashed-zero": "slashed-zero" }),
    {
      custom,
      autocomplete: "slashed-zero"
    }
  ],
  [
    /^lining-nums$/,
    () => toEntries({ "--un-numeric-figure": "lining-nums" }),
    {
      custom,
      autocomplete: "lining-nums"
    }
  ],
  [
    /^oldstyle-nums$/,
    () => toEntries({ "--un-numeric-figure": "oldstyle-nums" }),
    {
      custom,
      autocomplete: "oldstyle-nums"
    }
  ],
  [
    /^proportional-nums$/,
    () => toEntries({ "--un-numeric-spacing": "proportional-nums" }),
    {
      custom,
      autocomplete: "proportional-nums"
    }
  ],
  [
    /^tabular-nums$/,
    () => toEntries({ "--un-numeric-spacing": "tabular-nums" }),
    {
      custom,
      autocomplete: "tabular-nums"
    }
  ],
  [
    /^diagonal-fractions$/,
    () => toEntries({ "--un-numeric-fraction": "diagonal-fractions" }),
    {
      custom,
      autocomplete: "diagonal-fractions"
    }
  ],
  [
    /^stacked-fractions$/,
    () => toEntries({ "--un-numeric-fraction": "stacked-fractions" }),
    {
      custom,
      autocomplete: "stacked-fractions"
    }
  ],
  ["normal-nums", { "font-variant-numeric": "normal" }]
];
var variablesAbbrMap2 = {
  "bg-blend": "background-blend-mode",
  "bg-clip": "-webkit-background-clip",
  "bg-gradient": "linear-gradient",
  "bg-image": "background-image",
  "bg-origin": "background-origin",
  "bg-position": "background-position",
  "bg-repeat": "background-repeat",
  "bg-size": "background-size",
  "mix-blend": "mix-blend-mode",
  "object": "object-fit",
  "object-position": "object-position",
  "write": "writing-mode",
  "write-orient": "text-orientation"
};
var cssVariables2 = [[/^(.+?)-(\$.+)$/, ([, name50, varname]) => {
  const prop = variablesAbbrMap2[name50];
  if (prop) return { [prop]: h.cssvar(varname) };
}]];
var viewTransition = [[/^view-transition-([\w-]+)$/, ([, name50]) => {
  return { "view-transition-name": name50 };
}]];
var rules2 = [
  cssVariables,
  cssVariables2,
  cssProperty,
  container,
  contains,
  screenReadersAccess,
  pointerEvents,
  appearances,
  positions,
  insets,
  lineClamps,
  isolations,
  zIndexes,
  orders,
  grids,
  floats,
  margins,
  boxSizing,
  displays,
  aspectRatio,
  sizes,
  flex,
  tables,
  transforms,
  animations,
  cursors,
  touchActions,
  userSelects,
  resizes,
  scrolls,
  listStyle,
  appearance,
  columns,
  placements,
  alignments,
  justifies,
  gaps,
  flexGridJustifiesAlignments,
  spaces,
  divides,
  overflows,
  overscrolls,
  scrollBehaviors,
  textOverflows,
  whitespaces,
  breaks,
  borders,
  bgColors,
  backgroundStyles,
  colorScheme,
  svgUtilities,
  objectPositions,
  paddings,
  textAligns,
  textIndents,
  textWraps,
  verticalAligns,
  fonts,
  textTransforms,
  textTransforms2,
  fontStyles,
  fontVariantNumeric,
  textDecorations,
  fontSmoothings,
  tabSizes,
  textStrokes,
  textShadows,
  hyphens,
  writingModes,
  writingOrientations,
  carets,
  accents,
  opacity,
  backgroundBlendModes,
  mixBlendModes,
  boxShadows,
  outline,
  rings,
  imageRenderings,
  filters,
  transitions,
  willChange,
  contentVisibility,
  contents,
  placeholders,
  containerParent,
  viewTransition,
  dynamicViewportHeight,
  fieldSizing,
  questionMark
].flat(1);

// node_modules/@unocss/preset-wind3/dist/shortcuts.mjs
var shortcuts = [...containerShortcuts];

// node_modules/@unocss/preset-wind3/dist/theme.mjs
var theme2 = {
  ...theme,
  aria: {
    busy: 'busy="true"',
    checked: 'checked="true"',
    disabled: 'disabled="true"',
    expanded: 'expanded="true"',
    hidden: 'hidden="true"',
    pressed: 'pressed="true"',
    readonly: 'readonly="true"',
    required: 'required="true"',
    selected: 'selected="true"'
  },
  animation: {
    keyframes: {
      "pulse": "{0%, 100% {opacity:1} 50% {opacity:.5}}",
      "bounce": "{0%, 100% {transform:translateY(-25%);animation-timing-function:cubic-bezier(0.8,0,1,1)} 50% {transform:translateY(0);animation-timing-function:cubic-bezier(0,0,0.2,1)}}",
      "spin": "{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}",
      "ping": "{0%{transform:scale(1);opacity:1}75%,100%{transform:scale(2);opacity:0}}",
      "bounce-alt": "{from,20%,53%,80%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1);transform:translate3d(0,0,0)}40%,43%{animation-timing-function:cubic-bezier(0.755,0.05,0.855,0.06);transform:translate3d(0,-30px,0)}70%{animation-timing-function:cubic-bezier(0.755,0.05,0.855,0.06);transform:translate3d(0,-15px,0)}90%{transform:translate3d(0,-4px,0)}}",
      "flash": "{from,50%,to{opacity:1}25%,75%{opacity:0}}",
      "pulse-alt": "{from{transform:scale3d(1,1,1)}50%{transform:scale3d(1.05,1.05,1.05)}to{transform:scale3d(1,1,1)}}",
      "rubber-band": "{from{transform:scale3d(1,1,1)}30%{transform:scale3d(1.25,0.75,1)}40%{transform:scale3d(0.75,1.25,1)}50%{transform:scale3d(1.15,0.85,1)}65%{transform:scale3d(0.95,1.05,1)}75%{transform:scale3d(1.05,0.95,1)}to{transform:scale3d(1,1,1)}}",
      "shake-x": "{from,to{transform:translate3d(0,0,0)}10%,30%,50%,70%,90%{transform:translate3d(-10px,0,0)}20%,40%,60%,80%{transform:translate3d(10px,0,0)}}",
      "shake-y": "{from,to{transform:translate3d(0,0,0)}10%,30%,50%,70%,90%{transform:translate3d(0,-10px,0)}20%,40%,60%,80%{transform:translate3d(0,10px,0)}}",
      "head-shake": "{0%{transform:translateX(0)}6.5%{transform:translateX(-6px) rotateY(-9deg)}18.5%{transform:translateX(5px) rotateY(7deg)}31.5%{transform:translateX(-3px) rotateY(-5deg)}43.5%{transform:translateX(2px) rotateY(3deg)}50%{transform:translateX(0)}}",
      "swing": "{20%{transform:rotate3d(0,0,1,15deg)}40%{transform:rotate3d(0,0,1,-10deg)}60%{transform:rotate3d(0,0,1,5deg)}80%{transform:rotate3d(0,0,1,-5deg)}to{transform:rotate3d(0,0,1,0deg)}}",
      "tada": "{from{transform:scale3d(1,1,1)}10%,20%{transform:scale3d(0.9,0.9,0.9) rotate3d(0,0,1,-3deg)}30%,50%,70%,90%{transform:scale3d(1.1,1.1,1.1) rotate3d(0,0,1,3deg)}40%,60%,80%{transform:scale3d(1.1,1.1,1.1) rotate3d(0,0,1,-3deg)}to{transform:scale3d(1,1,1)}}",
      "wobble": "{from{transform:translate3d(0,0,0)}15%{transform:translate3d(-25%,0,0) rotate3d(0,0,1,-5deg)}30%{transform:translate3d(20%,0,0) rotate3d(0,0,1,3deg)}45%{transform:translate3d(-15%,0,0) rotate3d(0,0,1,-3deg)}60%{transform:translate3d(10%,0,0) rotate3d(0,0,1,2deg)}75%{transform:translate3d(-5%,0,0) rotate3d(0,0,1,-1deg)}to{transform:translate3d(0,0,0)}}",
      "jello": "{from,11.1%,to{transform:translate3d(0,0,0)}22.2%{transform:skewX(-12.5deg) skewY(-12.5deg)}33.3%{transform:skewX(6.25deg) skewY(6.25deg)}44.4%{transform:skewX(-3.125deg)skewY(-3.125deg)}55.5%{transform:skewX(1.5625deg) skewY(1.5625deg)}66.6%{transform:skewX(-0.78125deg) skewY(-0.78125deg)}77.7%{transform:skewX(0.390625deg) skewY(0.390625deg)}88.8%{transform:skewX(-0.1953125deg) skewY(-0.1953125deg)}}",
      "heart-beat": "{0%{transform:scale(1)}14%{transform:scale(1.3)}28%{transform:scale(1)}42%{transform:scale(1.3)}70%{transform:scale(1)}}",
      "hinge": "{0%{transform-origin:top left;animation-timing-function:ease-in-out}20%,60%{transform:rotate3d(0,0,1,80deg);transform-origin:top left;animation-timing-function:ease-in-out}40%,80%{transform:rotate3d(0,0,1,60deg);transform-origin:top left;animation-timing-function:ease-in-out}to{transform:translate3d(0,700px,0);opacity:0}}",
      "jack-in-the-box": "{from{opacity:0;transform-origin:center bottom;transform:scale(0.1) rotate(30deg)}50%{transform:rotate(-10deg)}70%{transform:rotate(3deg)}to{transform:scale(1)}}",
      "light-speed-in-left": "{from{opacity:0;transform:translate3d(-100%,0,0) skewX(-30deg)}60%{opacity:1;transform:skewX(20deg)}80%{transform:skewX(-5deg)}to{transform:translate3d(0,0,0)}}",
      "light-speed-in-right": "{from{opacity:0;transform:translate3d(100%,0,0) skewX(-30deg)}60%{opacity:1;transform:skewX(20deg)}80%{transform:skewX(-5deg)}to{transform:translate3d(0,0,0)}}",
      "light-speed-out-left": "{from{opacity:1}to{opacity:0;transform:translate3d(-100%,0,0) skewX(30deg)}}",
      "light-speed-out-right": "{from{opacity:1}to{opacity:0;transform:translate3d(100%,0,0) skewX(30deg)}}",
      "flip": "{from{transform:perspective(400px) scale3d(1,1,1) translate3d(0,0,0) rotate3d(0,1,0,-360deg);animation-timing-function:ease-out}40%{transform:perspective(400px) scale3d(1,1,1) translate3d(0,0,150px) rotate3d(0,1,0,-190deg);animation-timing-function:ease-out}50%{transform:perspective(400px) scale3d(1,1,1) translate3d(0,0,150px) rotate3d(0,1,0,-170deg);animation-timing-function:ease-in}80%{transform:perspective(400px) scale3d(0.95,0.95,0.95) translate3d(0,0,0) rotate3d(0,1,0,0deg);animation-timing-function:ease-in}to{transform:perspective(400px) scale3d(1,1,1) translate3d(0,0,0) rotate3d(0,1,0,0deg);animation-timing-function:ease-in}}",
      "flip-in-x": "{from{transform:perspective(400px) rotate3d(1,0,0,90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotate3d(1,0,0,-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotate3d(1,0,0,10deg);opacity:1}80%{transform:perspective(400px) rotate3d(1,0,0,-5deg)}to{transform:perspective(400px)}}",
      "flip-in-y": "{from{transform:perspective(400px) rotate3d(0,1,0,90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotate3d(0,1,0,-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotate3d(0,1,0,10deg);opacity:1}80%{transform:perspective(400px) rotate3d(0,1,0,-5deg)}to{transform:perspective(400px)}}",
      "flip-out-x": "{from{transform:perspective(400px)}30%{transform:perspective(400px) rotate3d(1,0,0,-20deg);opacity:1}to{transform:perspective(400px) rotate3d(1,0,0,90deg);opacity:0}}",
      "flip-out-y": "{from{transform:perspective(400px)}30%{transform:perspective(400px) rotate3d(0,1,0,-15deg);opacity:1}to{transform:perspective(400px) rotate3d(0,1,0,90deg);opacity:0}}",
      "rotate-in": "{from{transform-origin:center;transform:rotate3d(0,0,1,-200deg);opacity:0}to{transform-origin:center;transform:translate3d(0,0,0);opacity:1}}",
      "rotate-in-down-left": "{from{transform-origin:left bottom;transform:rotate3d(0,0,1,-45deg);opacity:0}to{transform-origin:left bottom;transform:translate3d(0,0,0);opacity:1}}",
      "rotate-in-down-right": "{from{transform-origin:right bottom;transform:rotate3d(0,0,1,45deg);opacity:0}to{transform-origin:right bottom;transform:translate3d(0,0,0);opacity:1}}",
      "rotate-in-up-left": "{from{transform-origin:left top;transform:rotate3d(0,0,1,45deg);opacity:0}to{transform-origin:left top;transform:translate3d(0,0,0);opacity:1}}",
      "rotate-in-up-right": "{from{transform-origin:right bottom;transform:rotate3d(0,0,1,-90deg);opacity:0}to{transform-origin:right bottom;transform:translate3d(0,0,0);opacity:1}}",
      "rotate-out": "{from{transform-origin:center;opacity:1}to{transform-origin:center;transform:rotate3d(0,0,1,200deg);opacity:0}}",
      "rotate-out-down-left": "{from{transform-origin:left bottom;opacity:1}to{transform-origin:left bottom;transform:rotate3d(0,0,1,45deg);opacity:0}}",
      "rotate-out-down-right": "{from{transform-origin:right bottom;opacity:1}to{transform-origin:right bottom;transform:rotate3d(0,0,1,-45deg);opacity:0}}",
      "rotate-out-up-left": "{from{transform-origin:left bottom;opacity:1}to{transform-origin:left bottom;transform:rotate3d(0,0,1,-45deg);opacity:0}}",
      "rotate-out-up-right": "{from{transform-origin:right bottom;opacity:1}to{transform-origin:left bottom;transform:rotate3d(0,0,1,90deg);opacity:0}}",
      "roll-in": "{from{opacity:0;transform:translate3d(-100%,0,0) rotate3d(0,0,1,-120deg)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "roll-out": "{from{opacity:1}to{opacity:0;transform:translate3d(100%,0,0) rotate3d(0,0,1,120deg)}}",
      "zoom-in": "{from{opacity:0;transform:scale3d(0.3,0.3,0.3)}50%{opacity:1}}",
      "zoom-in-down": "{from{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(0,-1000px,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}60%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(0,60px,0);animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
      "zoom-in-left": "{from{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(-1000px,0,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}60%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(10px,0,0);animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
      "zoom-in-right": "{from{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(1000px,0,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}60%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(-10px,0,0);animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
      "zoom-in-up": "{from{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(0,1000px,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}60%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(0,-60px,0);animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
      "zoom-out": "{from{opacity:1}50%{opacity:0;transform:scale3d(0.3,0.3,0.3)}to{opacity:0}}",
      "zoom-out-down": "{40%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(0,-60px,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}to{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(0,2000px,0);transform-origin:center bottom;animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
      "zoom-out-left": "{40%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(42px,0,0)}to{opacity:0;transform:scale(0.1) translate3d(-2000px,0,0);transform-origin:left center}}",
      "zoom-out-right": "{40%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(-42px,0,0)}to{opacity:0;transform:scale(0.1) translate3d(2000px,0,0);transform-origin:right center}}",
      "zoom-out-up": "{40%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(0,60px,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}to{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(0,-2000px,0);transform-origin:center bottom;animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
      "bounce-in": "{from,20%,40%,60%,80%,to{animation-timing-function:ease-in-out}0%{opacity:0;transform:scale3d(0.3,0.3,0.3)}20%{transform:scale3d(1.1,1.1,1.1)}40%{transform:scale3d(0.9,0.9,0.9)}60%{transform:scale3d(1.03,1.03,1.03);opacity:1}80%{transform:scale3d(0.97,0.97,0.97)}to{opacity:1;transform:scale3d(1,1,1)}}",
      "bounce-in-down": "{from,60%,75%,90%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1)}0%{opacity:0;transform:translate3d(0,-3000px,0)}60%{opacity:1;transform:translate3d(0,25px,0)}75%{transform:translate3d(0,-10px,0)}90%{transform:translate3d(0,5px,0)}to{transform:translate3d(0,0,0)}}",
      "bounce-in-left": "{from,60%,75%,90%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1)}0%{opacity:0;transform:translate3d(-3000px,0,0)}60%{opacity:1;transform:translate3d(25px,0,0)}75%{transform:translate3d(-10px,0,0)}90%{transform:translate3d(5px,0,0)}to{transform:translate3d(0,0,0)}}",
      "bounce-in-right": "{from,60%,75%,90%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1)}0%{opacity:0;transform:translate3d(3000px,0,0)}60%{opacity:1;transform:translate3d(-25px,0,0)}75%{transform:translate3d(10px,0,0)}90%{transform:translate3d(-5px,0,0)}to{transform:translate3d(0,0,0)}}",
      "bounce-in-up": "{from,60%,75%,90%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1)}0%{opacity:0;transform:translate3d(0,3000px,0)}60%{opacity:1;transform:translate3d(0,-20px,0)}75%{transform:translate3d(0,10px,0)}90%{transform:translate3d(0,-5px,0)}to{transform:translate3d(0,0,0)}}",
      "bounce-out": "{20%{transform:scale3d(0.9,0.9,0.9)}50%,55%{opacity:1;transform:scale3d(1.1,1.1,1.1)}to{opacity:0;transform:scale3d(0.3,0.3,0.3)}}",
      "bounce-out-down": "{20%{transform:translate3d(0,10px,0)}40%,45%{opacity:1;transform:translate3d(0,-20px,0)}to{opacity:0;transform:translate3d(0,2000px,0)}}",
      "bounce-out-left": "{20%{opacity:1;transform:translate3d(20px,0,0)}to{opacity:0;transform:translate3d(-2000px,0,0)}}",
      "bounce-out-right": "{20%{opacity:1;transform:translate3d(-20px,0,0)}to{opacity:0;transform:translate3d(2000px,0,0)}}",
      "bounce-out-up": "{20%{transform:translate3d(0,-10px,0)}40%,45%{opacity:1;transform:translate3d(0,20px,0)}to{opacity:0;transform:translate3d(0,-2000px,0)}}",
      "slide-in-down": "{from{transform:translate3d(0,-100%,0);visibility:visible}to{transform:translate3d(0,0,0)}}",
      "slide-in-left": "{from{transform:translate3d(-100%,0,0);visibility:visible}to{transform:translate3d(0,0,0)}}",
      "slide-in-right": "{from{transform:translate3d(100%,0,0);visibility:visible}to{transform:translate3d(0,0,0)}}",
      "slide-in-up": "{from{transform:translate3d(0,100%,0);visibility:visible}to{transform:translate3d(0,0,0)}}",
      "slide-out-down": "{from{transform:translate3d(0,0,0)}to{visibility:hidden;transform:translate3d(0,100%,0)}}",
      "slide-out-left": "{from{transform:translate3d(0,0,0)}to{visibility:hidden;transform:translate3d(-100%,0,0)}}",
      "slide-out-right": "{from{transform:translate3d(0,0,0)}to{visibility:hidden;transform:translate3d(100%,0,0)}}",
      "slide-out-up": "{from{transform:translate3d(0,0,0)}to{visibility:hidden;transform:translate3d(0,-100%,0)}}",
      "fade-in": "{from{opacity:0}to{opacity:1}}",
      "fade-in-down": "{from{opacity:0;transform:translate3d(0,-100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-down-big": "{from{opacity:0;transform:translate3d(0,-2000px,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-left": "{from{opacity:0;transform:translate3d(-100%,0,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-left-big": "{from{opacity:0;transform:translate3d(-2000px,0,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-right": "{from{opacity:0;transform:translate3d(100%,0,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-right-big": "{from{opacity:0;transform:translate3d(2000px,0,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-up": "{from{opacity:0;transform:translate3d(0,100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-up-big": "{from{opacity:0;transform:translate3d(0,2000px,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-top-left": "{from{opacity:0;transform:translate3d(-100%,-100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-top-right": "{from{opacity:0;transform:translate3d(100%,-100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-bottom-left": "{from{opacity:0;transform:translate3d(-100%,100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-bottom-right": "{from{opacity:0;transform:translate3d(100%,100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-out": "{from{opacity:1}to{opacity:0}}",
      "fade-out-down": "{from{opacity:1}to{opacity:0;transform:translate3d(0,100%,0)}}",
      "fade-out-down-big": "{from{opacity:1}to{opacity:0;transform:translate3d(0,2000px,0)}}",
      "fade-out-left": "{from{opacity:1}to{opacity:0;transform:translate3d(-100%,0,0)}}",
      "fade-out-left-big": "{from{opacity:1}to{opacity:0;transform:translate3d(-2000px,0,0)}}",
      "fade-out-right": "{from{opacity:1}to{opacity:0;transform:translate3d(100%,0,0)}}",
      "fade-out-right-big": "{from{opacity:1}to{opacity:0;transform:translate3d(2000px,0,0)}}",
      "fade-out-up": "{from{opacity:1}to{opacity:0;transform:translate3d(0,-100%,0)}}",
      "fade-out-up-big": "{from{opacity:1}to{opacity:0;transform:translate3d(0,-2000px,0)}}",
      "fade-out-top-left": "{from{opacity:1;transform:translate3d(0,0,0)}to{opacity:0;transform:translate3d(-100%,-100%,0)}}",
      "fade-out-top-right": "{from{opacity:1;transform:translate3d(0,0,0)}to{opacity:0;transform:translate3d(100%,-100%,0)}}",
      "fade-out-bottom-left": "{from{opacity:1;transform:translate3d(0,0,0)}to{opacity:0;transform:translate3d(-100%,100%,0)}}",
      "fade-out-bottom-right": "{from{opacity:1;transform:translate3d(0,0,0)}to{opacity:0;transform:translate3d(100%,100%,0)}}",
      "back-in-up": "{0%{opacity:0.7;transform:translateY(1200px) scale(0.7)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:1;transform:scale(1)}}",
      "back-in-down": "{0%{opacity:0.7;transform:translateY(-1200px) scale(0.7)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:1;transform:scale(1)}}",
      "back-in-right": "{0%{opacity:0.7;transform:translateX(2000px) scale(0.7)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:1;transform:scale(1)}}",
      "back-in-left": "{0%{opacity:0.7;transform:translateX(-2000px) scale(0.7)}80%{opacity:0.7;transform:translateX(0px) scale(0.7)}100%{opacity:1;transform:scale(1)}}",
      "back-out-up": "{0%{opacity:1;transform:scale(1)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:0.7;transform:translateY(-700px) scale(0.7)}}",
      "back-out-down": "{0%{opacity:1;transform:scale(1)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:0.7;transform:translateY(700px) scale(0.7)}}",
      "back-out-right": "{0%{opacity:1;transform:scale(1)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:0.7;transform:translateX(2000px) scale(0.7)}}",
      "back-out-left": "{0%{opacity:1;transform:scale(1)}80%{opacity:0.7;transform:translateX(-2000px) scale(0.7)}100%{opacity:0.7;transform:translateY(-700px) scale(0.7)}}"
    },
    durations: {
      "pulse": "2s",
      "heart-beat": "1.3s",
      "bounce-in": "0.75s",
      "bounce-out": "0.75s",
      "flip-out-x": "0.75s",
      "flip-out-y": "0.75s",
      "hinge": "2s"
    },
    timingFns: {
      "pulse": "cubic-bezier(0.4,0,.6,1)",
      "ping": "cubic-bezier(0,0,.2,1)",
      "head-shake": "ease-in-out",
      "heart-beat": "ease-in-out",
      "pulse-alt": "ease-in-out",
      "light-speed-in-left": "ease-out",
      "light-speed-in-right": "ease-out",
      "light-speed-out-left": "ease-in",
      "light-speed-out-right": "ease-in"
    },
    properties: {
      "bounce-alt": { "transform-origin": "center bottom" },
      "jello": { "transform-origin": "center" },
      "swing": { "transform-origin": "top center" },
      "flip": { "backface-visibility": "visible" },
      "flip-in-x": { "backface-visibility": "visible !important" },
      "flip-in-y": { "backface-visibility": "visible !important" },
      "flip-out-x": { "backface-visibility": "visible !important" },
      "flip-out-y": { "backface-visibility": "visible !important" },
      "rotate-in": { "transform-origin": "center" },
      "rotate-in-down-left": { "transform-origin": "left bottom" },
      "rotate-in-down-right": { "transform-origin": "right bottom" },
      "rotate-in-up-left": { "transform-origin": "left bottom" },
      "rotate-in-up-right": { "transform-origin": "right bottom" },
      "rotate-out": { "transform-origin": "center" },
      "rotate-out-down-left": { "transform-origin": "left bottom" },
      "rotate-out-down-right": { "transform-origin": "right bottom" },
      "rotate-out-up-left": { "transform-origin": "left bottom" },
      "rotate-out-up-right": { "transform-origin": "right bottom" },
      "hinge": { "transform-origin": "top left" },
      "zoom-out-down": { "transform-origin": "center bottom" },
      "zoom-out-left": { "transform-origin": "left center" },
      "zoom-out-right": { "transform-origin": "right center" },
      "zoom-out-up": { "transform-origin": "center bottom" }
    },
    counts: {
      "spin": "infinite",
      "ping": "infinite",
      "pulse": "infinite",
      "pulse-alt": "infinite",
      "bounce": "infinite",
      "bounce-alt": "infinite"
    },
    category: {
      "pulse": "Attention Seekers",
      "bounce": "Attention Seekers",
      "spin": "Attention Seekers",
      "ping": "Attention Seekers",
      "bounce-alt": "Attention Seekers",
      "flash": "Attention Seekers",
      "pulse-alt": "Attention Seekers",
      "rubber-band": "Attention Seekers",
      "shake-x": "Attention Seekers",
      "shake-y": "Attention Seekers",
      "head-shake": "Attention Seekers",
      "swing": "Attention Seekers",
      "tada": "Attention Seekers",
      "wobble": "Attention Seekers",
      "jello": "Attention Seekers",
      "heart-beat": "Attention Seekers",
      "hinge": "Specials",
      "jack-in-the-box": "Specials",
      "light-speed-in-left": "Lightspeed",
      "light-speed-in-right": "Lightspeed",
      "light-speed-out-left": "Lightspeed",
      "light-speed-out-right": "Lightspeed",
      "flip": "Flippers",
      "flip-in-x": "Flippers",
      "flip-in-y": "Flippers",
      "flip-out-x": "Flippers",
      "flip-out-y": "Flippers",
      "rotate-in": "Rotating Entrances",
      "rotate-in-down-left": "Rotating Entrances",
      "rotate-in-down-right": "Rotating Entrances",
      "rotate-in-up-left": "Rotating Entrances",
      "rotate-in-up-right": "Rotating Entrances",
      "rotate-out": "Rotating Exits",
      "rotate-out-down-left": "Rotating Exits",
      "rotate-out-down-right": "Rotating Exits",
      "rotate-out-up-left": "Rotating Exits",
      "rotate-out-up-right": "Rotating Exits",
      "roll-in": "Specials",
      "roll-out": "Specials",
      "zoom-in": "Zooming Entrances",
      "zoom-in-down": "Zooming Entrances",
      "zoom-in-left": "Zooming Entrances",
      "zoom-in-right": "Zooming Entrances",
      "zoom-in-up": "Zooming Entrances",
      "zoom-out": "Zooming Exits",
      "zoom-out-down": "Zooming Exits",
      "zoom-out-left": "Zooming Exits",
      "zoom-out-right": "Zooming Exits",
      "zoom-out-up": "Zooming Exits",
      "bounce-in": "Bouncing Entrances",
      "bounce-in-down": "Bouncing Entrances",
      "bounce-in-left": "Bouncing Entrances",
      "bounce-in-right": "Bouncing Entrances",
      "bounce-in-up": "Bouncing Entrances",
      "bounce-out": "Bouncing Exits",
      "bounce-out-down": "Bouncing Exits",
      "bounce-out-left": "Bouncing Exits",
      "bounce-out-right": "Bouncing Exits",
      "bounce-out-up": "Bouncing Exits",
      "slide-in-down": "Sliding Entrances",
      "slide-in-left": "Sliding Entrances",
      "slide-in-right": "Sliding Entrances",
      "slide-in-up": "Sliding Entrances",
      "slide-out-down": "Sliding Exits",
      "slide-out-left": "Sliding Exits",
      "slide-out-right": "Sliding Exits",
      "slide-out-up": "Sliding Exits",
      "fade-in": "Fading Entrances",
      "fade-in-down": "Fading Entrances",
      "fade-in-down-big": "Fading Entrances",
      "fade-in-left": "Fading Entrances",
      "fade-in-left-big": "Fading Entrances",
      "fade-in-right": "Fading Entrances",
      "fade-in-right-big": "Fading Entrances",
      "fade-in-up": "Fading Entrances",
      "fade-in-up-big": "Fading Entrances",
      "fade-in-top-left": "Fading Entrances",
      "fade-in-top-right": "Fading Entrances",
      "fade-in-bottom-left": "Fading Entrances",
      "fade-in-bottom-right": "Fading Entrances",
      "fade-out": "Fading Exits",
      "fade-out-down": "Fading Exits",
      "fade-out-down-big": "Fading Exits",
      "fade-out-left": "Fading Exits",
      "fade-out-left-big": "Fading Exits",
      "fade-out-right": "Fading Exits",
      "fade-out-right-big": "Fading Exits",
      "fade-out-up": "Fading Exits",
      "fade-out-up-big": "Fading Exits",
      "fade-out-top-left": "Fading Exits",
      "fade-out-top-right": "Fading Exits",
      "fade-out-bottom-left": "Fading Exits",
      "fade-out-bottom-right": "Fading Exits",
      "back-in-up": "Back Entrances",
      "back-in-down": "Back Entrances",
      "back-in-right": "Back Entrances",
      "back-in-left": "Back Entrances",
      "back-out-up": "Back Exits",
      "back-out-down": "Back Exits",
      "back-out-right": "Back Exits",
      "back-out-left": "Back Exits"
    }
  },
  media: {
    portrait: "(orientation: portrait)",
    landscape: "(orientation: landscape)",
    os_dark: "(prefers-color-scheme: dark)",
    os_light: "(prefers-color-scheme: light)",
    motion_ok: "(prefers-reduced-motion: no-preference)",
    motion_not_ok: "(prefers-reduced-motion: reduce)",
    high_contrast: "(prefers-contrast: high)",
    low_contrast: "(prefers-contrast: low)",
    opacity_ok: "(prefers-reduced-transparency: no-preference)",
    opacity_not_ok: "(prefers-reduced-transparency: reduce)",
    use_data_ok: "(prefers-reduced-data: no-preference)",
    use_data_not_ok: "(prefers-reduced-data: reduce)",
    touch: "(hover: none) and (pointer: coarse)",
    stylus: "(hover: none) and (pointer: fine)",
    pointer: "(hover) and (pointer: coarse)",
    mouse: "(hover) and (pointer: fine)",
    hd_color: "(dynamic-range: high)"
  },
  supports: { grid: "(display: grid)" },
  preflightBase: {
    ...transformBase,
    ...touchActionBase,
    ...scrollSnapTypeBase,
    ...fontVariantNumericBase,
    ...borderSpacingBase,
    ...boxShadowsBase,
    ...ringBase,
    ...filterBase,
    ...backdropFilterBase
  }
};

// node_modules/@unocss/preset-wind3/dist/variants.mjs
var variantCombinators2 = [variantMatcher("svg", (input) => ({ selector: `${input.selector} svg` }))];
var variantColorsScheme = [
  variantMatcher(".dark", (input) => ({ prefix: `.dark $$ ${input.prefix}` })),
  variantMatcher(".light", (input) => ({ prefix: `.light $$ ${input.prefix}` })),
  variantParentMatcher("@dark", "@media (prefers-color-scheme: dark)"),
  variantParentMatcher("@light", "@media (prefers-color-scheme: light)")
];
var variantContrasts = [variantParentMatcher("contrast-more", "@media (prefers-contrast: more)"), variantParentMatcher("contrast-less", "@media (prefers-contrast: less)")];
var variantMotions = [variantParentMatcher("motion-reduce", "@media (prefers-reduced-motion: reduce)"), variantParentMatcher("motion-safe", "@media (prefers-reduced-motion: no-preference)")];
var variantOrientations = [variantParentMatcher("landscape", "@media (orientation: landscape)"), variantParentMatcher("portrait", "@media (orientation: portrait)")];
var variantSpaceAndDivide = (matcher) => {
  if (matcher.startsWith("_")) return;
  if (/space-[xy]-.+$/.test(matcher) || /divide-/.test(matcher)) return {
    matcher,
    selector: (input) => {
      const not = ">:not([hidden])~:not([hidden])";
      return input.includes(not) ? input : `${input}${not}`;
    }
  };
};
var variantStickyHover = [variantMatcher("@hover", (input) => ({
  parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (hover: hover) and (pointer: fine)`,
  selector: `${input.selector || ""}:hover`
}))];
function mixComponent(v1, v2, w) {
  return `calc(${v2} + (${v1} - ${v2}) * ${w} / 100)`;
}
function mixColor(color1, color2, weight) {
  const colors3 = [color1, color2];
  const cssColors = [];
  for (let c = 0; c < 2; c++) {
    const color = typeof colors3[c] === "string" ? parseCssColor(colors3[c]) : colors3[c];
    if (!color || !["rgb", "rgba"].includes(color.type)) return;
    cssColors.push(color);
  }
  const newComponents = [];
  for (let x = 0; x < 3; x++) newComponents.push(mixComponent(cssColors[0].components[x], cssColors[1].components[x], weight));
  return {
    type: "rgb",
    components: newComponents,
    alpha: mixComponent(cssColors[0].alpha ?? 1, cssColors[1].alpha ?? 1, weight)
  };
}
function tint(color, weight) {
  return mixColor("#fff", color, weight);
}
function shade(color, weight) {
  return mixColor("#000", color, weight);
}
function shift(color, weight) {
  const num = Number.parseFloat(`${weight}`);
  if (!Number.isNaN(num)) return num > 0 ? shade(color, weight) : tint(color, -num);
}
var fns = {
  tint,
  shade,
  shift
};
function variantColorMix() {
  let re;
  return {
    name: "mix",
    match(matcher, ctx) {
      if (!re) re = new RegExp(`^mix-(tint|shade|shift)-(-?\\d{1,3})(?:${ctx.generator.config.separators.join("|")})`);
      const m = matcher.match(re);
      if (m) return {
        matcher: matcher.slice(m[0].length),
        body: (body) => {
          body.forEach((v) => {
            if (v[1]) {
              const color = parseCssColor(`${v[1]}`);
              if (color) {
                const mixed = fns[m[1]](color, m[2]);
                if (mixed) v[1] = colorToString2(mixed);
              }
            }
          });
          return body;
        }
      };
    }
  };
}
var placeholderModifier = (input, { theme: theme4 }) => {
  const m = input.match(/^(.*)\b(placeholder-)(.+)$/);
  if (m) {
    const [, pre = "", p, body] = m;
    if (hasParseableColor(body, theme4, "accentColor") || hasOpacityValue(body)) return { matcher: `${pre}placeholder-$ ${p}${body}` };
  }
};
function hasOpacityValue(body) {
  const match = body.match(/^op(?:acity)?-?(.+)$/);
  if (match && match[1] != null) return h.bracket.percent(match[1]) != null;
  return false;
}
function variants2(options) {
  return [
    placeholderModifier,
    variantSpaceAndDivide,
    ...variants(options),
    ...variantContrasts,
    ...variantOrientations,
    ...variantMotions,
    ...variantCombinators2,
    ...variantColorsScheme,
    ...variantStickyHover,
    variantColorMix()
  ];
}

// node_modules/@unocss/preset-wind3/dist/index.mjs
function important(option) {
  if (option == null || option === false) return [];
  const wrapWithIs = (selector2) => {
    if (selector2.startsWith(":is(") && selector2.endsWith(")")) return selector2;
    if (selector2.includes("::")) return selector2.replace(/(.*?)((?:\s\*)?::.*)/, ":is($1)$2");
    return `:is(${selector2})`;
  };
  return [option === true ? (util) => {
    util.entries.forEach((i) => {
      if (i[1] != null && !String(i[1]).endsWith("!important")) i[1] += " !important";
    });
  } : (util) => {
    if (!util.selector.startsWith(option)) util.selector = `${option} ${wrapWithIs(util.selector)}`;
  }];
}
function postprocessors(options) {
  return [...toArray(src_default2(options).postprocess), ...important(options.important)];
}
var presetWind3 = definePreset((options = {}) => {
  options.important = options.important ?? false;
  return {
    ...presetMini(options),
    name: "@unocss/preset-wind3",
    theme: theme2,
    rules: rules2,
    shortcuts,
    variants: variants2(options),
    postprocess: postprocessors(options)
  };
});
var src_default5 = presetWind3;

// node_modules/@unocss/preset-uno/dist/index.mjs
var presetUno = definePreset((options = {}) => {
  return {
    ...presetWind3(options),
    name: "@unocss/preset-uno"
  };
});
var src_default6 = presetUno;

// node_modules/@unocss/preset-web-fonts/dist/index.mjs
function createBunnyFontsProvider(name50, host) {
  return {
    name: name50,
    getImportUrl(fonts3) {
      return `${host}/css?family=${fonts3.map((font2) => {
        const { name: name$1, weights, italic } = font2;
        const formattedName = name$1.toLowerCase().replace(/\s/g, "-");
        if (!(weights == null ? void 0 : weights.length)) return `${formattedName}${italic ? ":i" : ""}`;
        let weightsAsString = weights.map((weight) => weight.toString());
        if (!weightsAsString.some((weight) => weight.endsWith("i")) && italic) weightsAsString = weightsAsString.map((weight) => weight += "i");
        return `${formattedName}:${weightsAsString.join(",")}`;
      }).join("|")}&display=swap`;
    }
  };
}
var BunnyFontsProvider = createBunnyFontsProvider("bunny", "https://fonts.bunny.net");
function generateFontAxes(axes) {
  if (!axes || axes.length === 0) return "";
  let combinations = [[]];
  for (const { values } of axes) {
    const newCombinations = [];
    for (const combo of combinations) for (const value of values) newCombinations.push([...combo, value]);
    combinations = newCombinations;
  }
  return combinations.map((arr) => arr.join(",")).join(";");
}
function createGoogleCompatibleProvider(name50, host) {
  return {
    name: name50,
    getImportUrl(fonts3) {
      return `${host}/css2?${fonts3.map((i) => {
        var _a, _b;
        let name$1 = i.name.replace(/\s+/g, "+");
        const axisValues = [];
        if (i.italic) axisValues.push({
          axis: "ital",
          values: ["0", "1"]
        });
        if ((_a = i.widths) == null ? void 0 : _a.length) axisValues.push({
          axis: "wdth",
          values: i.widths.map((w) => w.toString())
        });
        if ((_b = i.weights) == null ? void 0 : _b.length) axisValues.push({
          axis: "wght",
          values: i.weights.map((w) => w.toString())
        });
        if (axisValues.length) {
          name$1 += ":";
          name$1 += axisValues.map((a) => a.axis).join(",");
          name$1 += "@";
          name$1 += generateFontAxes(axisValues);
        }
        return `family=${name$1}`;
      }).join("&")}&display=swap`;
    }
  };
}
var GoogleFontsProvider = createGoogleCompatibleProvider("google", "https://fonts.googleapis.com");
var CoolLabsFontsProvider = createGoogleCompatibleProvider("coollabs", "https://api.fonts.coollabs.io");
var FontshareProvider = createFontshareProvider("fontshare", "https://api.fontshare.com");
function createFontshareProvider(name50, host) {
  return {
    name: name50,
    getImportUrl(fonts3) {
      return `${host}/v2/css?${fonts3.map((f) => {
        var _a;
        let name$1 = f.name.replace(/\s+/g, "-").toLocaleLowerCase();
        if ((_a = f.weights) == null ? void 0 : _a.length) name$1 += `@${f.weights.flatMap((w) => f.italic ? Number(w) + 1 : w).sort().join()}`;
        else name$1 += `@${f.italic ? 2 : 1}`;
        return `f[]=${name$1}`;
      }).join("&")}&display=swap`;
    }
  };
}
function createFontSourceProvider(name50, host) {
  const fontsMap = /* @__PURE__ */ new Map();
  const variablesMap = /* @__PURE__ */ new Map();
  return {
    name: name50,
    async getPreflight(fonts3, fetcher) {
      return (await Promise.all(fonts3.map(async (font2) => {
        const css = [];
        const id = font2.name.toLowerCase().replace(/\s+/g, "-");
        let metadata = fontsMap.get(id);
        if (!metadata) {
          const url = `https://api.fontsource.org/v1/fonts/${id}`;
          try {
            metadata = await fetcher(url);
            fontsMap.set(id, metadata);
          } catch {
            throw new Error(`Failed to fetch font: ${font2.name}`);
          }
        }
        const { weights, unicodeRange, variants: variants4, family } = metadata;
        const subsets = metadata.subsets.filter((subset) => font2.subsets ? font2.subsets.includes(subset) : true);
        const style = font2.italic ? "italic" : "normal";
        if (metadata.variable && !font2.preferStatic) {
          let variableData = variablesMap.get(id);
          const url = `https://api.fontsource.org/v1/variable/${id}`;
          try {
            variableData = await fetcher(url);
            variablesMap.set(id, variableData);
          } catch {
            throw new Error(`Failed to fetch font variable: ${font2.name}`);
          }
          const mergeAxes = mergeDeep(variableData.axes, font2.variable ?? {});
          for (const subset of subsets) if (unicodeRange[subset]) {
            const fontObj = {
              family,
              display: "swap",
              style,
              weight: 400,
              src: [{
                url: `${host}/fontsource/fonts/${metadata.id}:vf@latest/${subset}-wght-${style}.woff2`,
                format: "woff2-variations"
              }],
              variable: {
                wght: mergeAxes.wght ?? void 0,
                wdth: mergeAxes.wdth ?? void 0,
                slnt: mergeAxes.slnt ?? void 0
              },
              unicodeRange: unicodeRange[subset],
              comment: `${metadata.id}-${subset}-wght-normal`
            };
            css.push(generateFontFace(fontObj));
          } else Object.entries(unicodeRange).filter(([subKey]) => !metadata.subsets.includes(subKey)).forEach(([subKey, range]) => {
            const fontObj = {
              family,
              display: "swap",
              style,
              weight: 400,
              src: [{
                url: `${host}/fontsource/fonts/${metadata.id}:vf@latest/${subKey.slice(1, -1)}-wght-${style}.woff2`,
                format: "woff2-variations"
              }],
              variable: {
                wght: mergeAxes.wght ?? void 0,
                wdth: mergeAxes.wdth ?? void 0,
                slnt: mergeAxes.slnt ?? void 0
              },
              unicodeRange: range,
              comment: `${metadata.id}-${subKey}-wght-normal`
            };
            css.push(generateFontFace(fontObj));
          });
        } else {
          const _weights = font2.weights && font2.weights.length > 0 ? font2.weights : weights;
          for (const subset of subsets) for (const weight of _weights) {
            const url = variants4[weight][style][subset].url;
            const fontObj = {
              family,
              display: "swap",
              style,
              weight: Number(weight),
              src: [{
                url: url.woff2,
                format: "woff2"
              }],
              unicodeRange: unicodeRange[subset],
              comment: `${metadata.id}-${subset}-${weight}-${style}`
            };
            css.push(generateFontFace(fontObj));
          }
        }
        return css;
      }))).flat().join("\n\n");
    }
  };
}
var FontSourceProvider = createFontSourceProvider("fontsource", "https://cdn.jsdelivr.net");
function generateFontFace(font2) {
  const { family, style, display, weight, variable, src, unicodeRange, comment, spacer = "\n  " } = font2;
  const { wght, wdth, slnt } = variable ?? {};
  let result = "@font-face {";
  result += `${spacer}font-family: '${family}';`;
  result += `${spacer}font-style: ${slnt ? `oblique ${Number(slnt.max) * -1}deg ${Number(slnt.min) * -1}deg` : style};`;
  result += `${spacer}font-display: ${display};`;
  result += `${spacer}font-weight: ${wght ? getVariableWght(wght) : weight};`;
  if (wdth) result += `${spacer}font-stretch: ${wdth.min}% ${wdth.max}%;`;
  result += `${spacer}src: ${src.map(({ url, format }) => `url(${url}) format('${format}')`).join(", ")};`;
  if (unicodeRange) result += `${spacer}unicode-range: ${unicodeRange};`;
  if (comment) result = `/* ${comment} */
${result}`;
  return `${result}
}`;
}
function getVariableWght(axes) {
  if (!axes) return "400";
  if (axes.min === axes.max) return `${axes.min}`;
  return `${axes.min} ${axes.max}`;
}
var NoneProvider = {
  name: "none",
  getPreflight() {
    return "";
  },
  getFontName(font2) {
    return font2.name;
  }
};
var builtinProviders = {
  google: GoogleFontsProvider,
  bunny: BunnyFontsProvider,
  fontshare: FontshareProvider,
  fontsource: FontSourceProvider,
  coollabs: CoolLabsFontsProvider,
  none: NoneProvider
};
function resolveProvider(provider) {
  if (typeof provider === "string") return builtinProviders[provider];
  return provider;
}
function normalizedFontMeta(meta, defaultProvider) {
  if (typeof meta !== "string") {
    meta.provider = resolveProvider(meta.provider || defaultProvider);
    if (meta.weights) meta.weights = [...new Set(meta.weights.sort((a, b) => a.toString().localeCompare(b.toString(), "en", { numeric: true })))];
    if (meta.widths) meta.widths = [...new Set(meta.widths.sort((a, b) => a.toString().localeCompare(b.toString(), "en", { numeric: true })))];
    return meta;
  }
  const [name50, weights = ""] = meta.split(":");
  return {
    name: name50,
    weights: [...new Set(weights.split(/[,;]\s*/).filter(Boolean).sort((a, b) => a.localeCompare(b, "en", { numeric: true })))],
    provider: resolveProvider(defaultProvider)
  };
}
function createWebFontPreset(fetcher) {
  return (options = {}) => {
    const { provider: defaultProvider = "google", extendTheme = true, inlineImports = true, customFetch = fetcher, timeouts = {} } = options;
    const fontLayer = "fonts";
    const layerName = inlineImports ? fontLayer : LAYER_IMPORTS;
    const processors = toArray(options.processors || []);
    const fontObject = Object.fromEntries(Object.entries(options.fonts || {}).map(([name50, meta]) => [name50, toArray(meta).map((m) => normalizedFontMeta(m, defaultProvider))]));
    const fonts3 = Object.values(fontObject).flatMap((i) => i);
    const importCache = {};
    async function fetchWithTimeout(url) {
      if (timeouts === false) return customFetch(url);
      const { warning = 1e3, failure = 2e3 } = timeouts;
      let warned3 = false;
      const timer = setTimeout(() => {
        console.warn(`[unocss] Fetching web fonts: ${url}`);
        warned3 = true;
      }, warning);
      return await Promise.race([customFetch(url), new Promise((_, reject) => {
        setTimeout(() => reject(new Error(`[unocss] Fetch web fonts timeout.`)), failure);
      })]).then((res) => {
        if (warned3) console.info(`[unocss] Web fonts fetched.`);
        return res;
      }).finally(() => clearTimeout(timer));
    }
    async function importUrl(url) {
      if (inlineImports) {
        if (!importCache[url]) importCache[url] = fetchWithTimeout(url).catch((e2) => {
          console.error(`[unocss] Failed to fetch web fonts: ${url}`);
          console.error(e2);
          if (typeof process !== "undefined" && process.env.CI) throw e2;
        });
        return await importCache[url];
      } else return `@import url('${url}');`;
    }
    const enabledProviders = Array.from(new Set(fonts3.map((i) => i.provider)));
    async function getCSSDefault(fonts$1, providers) {
      var _a;
      const preflights3 = [];
      for (const provider of providers) {
        const fontsForProvider = fonts$1.filter((i) => i.provider.name === provider.name);
        if (provider.getImportUrl) {
          const url = provider.getImportUrl(fontsForProvider);
          if (url) preflights3.push(await importUrl(url));
        }
        try {
          preflights3.push(await ((_a = provider.getPreflight) == null ? void 0 : _a.call(provider, fontsForProvider, fetchWithTimeout)));
        } catch (e2) {
          console.warn(`[unocss] Web fonts preflight fetch failed.`, e2);
        }
      }
      return preflights3.filter(Boolean).join("\n");
    }
    const preset = {
      name: "@unocss/preset-web-fonts",
      preflights: [{
        async getCSS() {
          var _a, _b;
          let css;
          for (const processor of processors) {
            const result = await ((_a = processor.getCSS) == null ? void 0 : _a.call(processor, fonts3, enabledProviders, getCSSDefault));
            if (result) {
              css = result;
              break;
            }
          }
          if (!css) css = await getCSSDefault(fonts3, enabledProviders);
          for (const processor of processors) css = await ((_b = processor.transformCSS) == null ? void 0 : _b.call(processor, css)) || css;
          return css;
        },
        layer: layerName
      }],
      layers: { [fontLayer]: -200 }
    };
    if (extendTheme) preset.extendTheme = (theme4, config) => {
      const hasWind4 = config.presets.some((p) => p.name === "@unocss/preset-wind4");
      const themeKey = options.themeKey ?? (hasWind4 ? "font" : "fontFamily");
      if (!theme4[themeKey]) theme4[themeKey] = {};
      const obj = Object.fromEntries(Object.entries(fontObject).map(([name50, fonts$1]) => [name50, fonts$1.map((f) => {
        var _a, _b;
        return ((_b = (_a = f.provider).getFontName) == null ? void 0 : _b.call(_a, f)) ?? `"${f.name}"`;
      })]));
      for (const key of Object.keys(obj)) if (typeof theme4[themeKey][key] === "string") theme4[themeKey][key] = obj[key].map((i) => `${i},`).join("") + theme4[themeKey][key];
      else theme4[themeKey][key] = obj[key].join(",");
    };
    return preset;
  };
}
var userAgentWoff2 = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36";
var defaultFetch = async (url) => (await import("./dist-HFD2ANBM.js")).$fetch(url, {
  headers: { "User-Agent": userAgentWoff2 },
  retry: 3
});
var presetWebFonts = definePreset(createWebFontPreset(defaultFetch));
var src_default7 = presetWebFonts;

// node_modules/@unocss/preset-wind/dist/index.mjs
var presetWind = definePreset((options = {}) => {
  return {
    ...presetWind3(options),
    name: "@unocss/preset-wind"
  };
});
var src_default8 = presetWind;

// node_modules/@unocss/preset-wind4/dist/postprocess.mjs
function important2({ important: option }) {
  if (option == null || option === false) return [];
  const wrapWithIs = (selector2) => {
    if (selector2.startsWith(":is(") && selector2.endsWith(")")) return selector2;
    if (selector2.includes("::")) return selector2.replace(/(.*?)((?:\s\*)?::.*)/, ":is($1)$2");
    return `:is(${selector2})`;
  };
  return [(util) => {
    if (util.layer === "properties") return;
    if (option === true) util.entries.forEach((i) => {
      if (i[1] != null && !String(i[1]).endsWith("!important")) i[1] += " !important";
    });
    else if (!util.selector.startsWith(option)) util.selector = `${option} ${wrapWithIs(util.selector)}`;
  }];
}
function varPrefix({ variablePrefix: prefix }) {
  const processor = (obj) => {
    obj.entries.forEach((i) => {
      i[0] = i[0].replace(/^--un-/, `--${prefix}`);
      if (typeof i[1] === "string") i[1] = i[1].replace(/var\(--un-/g, `var(--${prefix}`);
    });
  };
  return prefix !== "un-" ? [processor] : [];
}
function postprocessors2(options) {
  return [important2, varPrefix].flatMap((i) => i(options));
}

// node_modules/@unocss/preset-wind4/dist/chunk-w_xFUvYo.mjs
var __defProp2 = Object.defineProperty;
var __exportAll2 = (all, symbols2) => {
  let target = {};
  for (var name50 in all) {
    __defProp2(target, name50, {
      get: all[name50],
      enumerable: true
    });
  }
  if (symbols2) {
    __defProp2(target, Symbol.toStringTag, { value: "Module" });
  }
  return target;
};

// node_modules/@unocss/preset-wind4/dist/utils-BiCtQrPC.mjs
var PRESET_NAME = "@unocss/preset-wind4";
var CONTROL_NO_NEGATIVE = "$$mini-no-negative";
var SpecialColorKey = {
  transparent: "transparent",
  current: "currentColor",
  inherit: "inherit"
};
var directionMap2 = {
  "l": ["-left"],
  "r": ["-right"],
  "t": ["-top"],
  "b": ["-bottom"],
  "s": ["-inline-start"],
  "e": ["-inline-end"],
  "x": ["-inline"],
  "y": ["-block"],
  "": [""],
  "bs": ["-block-start"],
  "be": ["-block-end"],
  "is": ["-inline-start"],
  "ie": ["-inline-end"],
  "block": ["-block-start", "-block-end"],
  "inline": ["-inline-start", "-inline-end"]
};
var insetMap2 = {
  ...directionMap2,
  x: ["-inset-inline"],
  y: ["-inset-block"],
  s: ["-inset-inline-start"],
  start: ["-inset-inline-start"],
  e: ["-inset-inline-end"],
  end: ["-inset-inline-end"],
  bs: ["-inset-block-start"],
  be: ["-inset-block-end"],
  is: ["-inset-inline-start"],
  ie: ["-inset-inline-end"],
  block: ["-inset-block-start", "-inset-block-end"],
  inline: ["-inset-inline-start", "-inset-inline-end"]
};
var cornerMap2 = {
  "l": ["-top-left", "-bottom-left"],
  "r": ["-top-right", "-bottom-right"],
  "t": ["-top-left", "-top-right"],
  "b": ["-bottom-left", "-bottom-right"],
  "tl": ["-top-left"],
  "lt": ["-top-left"],
  "tr": ["-top-right"],
  "rt": ["-top-right"],
  "bl": ["-bottom-left"],
  "lb": ["-bottom-left"],
  "br": ["-bottom-right"],
  "rb": ["-bottom-right"],
  "": [""],
  "bs": ["-start-start", "-start-end"],
  "be": ["-end-start", "-end-end"],
  "s": ["-end-start", "-start-start"],
  "is": ["-end-start", "-start-start"],
  "e": ["-start-end", "-end-end"],
  "ie": ["-start-end", "-end-end"],
  "ss": ["-start-start"],
  "bs-is": ["-start-start"],
  "is-bs": ["-start-start"],
  "se": ["-start-end"],
  "bs-ie": ["-start-end"],
  "ie-bs": ["-start-end"],
  "es": ["-end-start"],
  "be-is": ["-end-start"],
  "is-be": ["-end-start"],
  "ee": ["-end-end"],
  "be-ie": ["-end-end"],
  "ie-be": ["-end-end"]
};
var xyzMap2 = {
  "x": ["-x"],
  "y": ["-y"],
  "z": ["-z"],
  "": ["-x", "-y"]
};
var xyzArray2 = [
  "x",
  "y",
  "z"
];
var basePositionMap2 = [
  "top",
  "top center",
  "top left",
  "top right",
  "bottom",
  "bottom center",
  "bottom left",
  "bottom right",
  "left",
  "left center",
  "left top",
  "left bottom",
  "right",
  "right center",
  "right top",
  "right bottom",
  "center",
  "center top",
  "center bottom",
  "center left",
  "center right",
  "center center"
];
var positionMap2 = Object.assign({}, ...basePositionMap2.map((p) => ({ [p.replace(/ /, "-")]: p })), ...basePositionMap2.map((p) => ({ [p.replace(/\b(\w)\w+/g, "$1").replace(/ /, "")]: p })));
var globalKeywords2 = [
  "inherit",
  "initial",
  "revert",
  "revert-layer",
  "unset"
];
var cssMathFnRE2 = /^(calc|clamp|min|max)\s*\((.+)\)(.*)/;
var cssVarFnRE2 = /^(var)\s*\((.+)\)(.*)/;
var numberWithUnitRE2 = /^(-?\d*(?:\.\d+)?)(px|pt|pc|%|r?(?:em|ex|lh|cap|ch|ic)|(?:[sld]?v|cq)(?:[whib]|min|max)|in|cm|mm|rpx)?$/i;
var numberRE3 = /^(-?\d*(?:\.\d+)?)$/;
var unitOnlyRE2 = /^(px|[sld]?v[wh])$/i;
var unitOnlyMap2 = {
  px: 1,
  vw: 100,
  vh: 100,
  svw: 100,
  svh: 100,
  dvw: 100,
  dvh: 100,
  lvh: 100,
  lvw: 100
};
var bracketTypeRe2 = /^\[(color|image|length|size|position|quoted|string|number|family):/i;
var splitComma2 = /,(?![^()]*\))/g;
var remRE = /(-?[.\d]+)rem/g;
var handlers_exports2 = __exportAll2({
  auto: () => auto2,
  bracket: () => bracket2,
  bracketOfColor: () => bracketOfColor2,
  bracketOfFamily: () => bracketOfFamily,
  bracketOfLength: () => bracketOfLength2,
  bracketOfNumber: () => bracketOfNumber,
  bracketOfPosition: () => bracketOfPosition2,
  cssvar: () => cssvar2,
  degree: () => degree2,
  fraction: () => fraction2,
  global: () => global3,
  none: () => none,
  number: () => number2,
  numberWithUnit: () => numberWithUnit2,
  percent: () => percent2,
  position: () => position2,
  properties: () => properties2,
  px: () => px2,
  rem: () => rem3,
  time: () => time2
});
var cssProps2 = [
  "color",
  "border-color",
  "background-color",
  "outline-color",
  "text-decoration-color",
  "flex-grow",
  "flex",
  "flex-shrink",
  "caret-color",
  "font",
  "gap",
  "opacity",
  "visibility",
  "z-index",
  "font-weight",
  "zoom",
  "text-shadow",
  "transform",
  "box-shadow",
  "border",
  "background-position",
  "left",
  "right",
  "top",
  "bottom",
  "object-position",
  "max-height",
  "min-height",
  "max-width",
  "min-width",
  "height",
  "width",
  "border-width",
  "margin",
  "padding",
  "outline-width",
  "outline-offset",
  "font-size",
  "line-height",
  "text-indent",
  "vertical-align",
  "border-spacing",
  "letter-spacing",
  "word-spacing",
  "stroke",
  "filter",
  "backdrop-filter",
  "fill",
  "mask",
  "mask-size",
  "mask-border",
  "clip-path",
  "clip",
  "border-radius"
];
function round3(n2) {
  return +n2.toFixed(10);
}
function numberWithUnit2(str) {
  const match = str.match(numberWithUnitRE2);
  if (!match) return;
  const [, n2, unit] = match;
  const num = Number.parseFloat(n2);
  if (unit && !Number.isNaN(num)) return `${round3(num)}${unit}`;
}
function auto2(str) {
  if (str === "auto" || str === "a") return "auto";
}
function rem3(str) {
  if (!str) return;
  if (unitOnlyRE2.test(str)) return `${unitOnlyMap2[str]}${str}`;
  const match = str.match(numberWithUnitRE2);
  if (!match) return;
  const [, n2, unit] = match;
  const num = Number.parseFloat(n2);
  if (!Number.isNaN(num)) {
    if (num === 0) return "0";
    return unit ? `${round3(num)}${unit}` : `${round3(num / 4)}rem`;
  }
}
function px2(str) {
  if (unitOnlyRE2.test(str)) return `${unitOnlyMap2[str]}${str}`;
  const match = str.match(numberWithUnitRE2);
  if (!match) return;
  const [, n2, unit] = match;
  const num = Number.parseFloat(n2);
  if (!Number.isNaN(num)) return unit ? `${round3(num)}${unit}` : `${round3(num)}px`;
}
function number2(str) {
  if (!numberRE3.test(str)) return;
  const num = Number.parseFloat(str);
  if (!Number.isNaN(num)) return round3(num);
}
function percent2(str) {
  if (str.endsWith("%")) str = str.slice(0, -1);
  const num = number2(str);
  if (num != null) return `${num}%`;
}
function fraction2(str) {
  if (!str) return;
  if (str === "full") return "100%";
  const [left, right] = str.split("/");
  const num = Number.parseFloat(left) / Number.parseFloat(right);
  if (!Number.isNaN(num)) {
    if (num === 0) return "0";
    return `${round3(num * 100)}%`;
  }
}
function processThemeVariable(name50, key, paths, theme4) {
  const valOrObj = getThemeByKey(theme4, key, paths);
  const hasDefault = typeof valOrObj === "object" && "DEFAULT" in valOrObj;
  if (hasDefault) paths.push("DEFAULT");
  const val = hasDefault ? valOrObj.DEFAULT : valOrObj;
  const varKey = hasDefault && key !== "spacing" ? `${name50}.DEFAULT` : name50;
  if (val != null) themeTracking(key, paths.length ? paths : void 0);
  return {
    val,
    varKey
  };
}
function bracketWithType2(str, requiredType, theme4) {
  if (str && str.startsWith("[") && str.endsWith("]")) {
    let base;
    let hintedType;
    const match = str.match(bracketTypeRe2);
    if (!match) base = str.slice(1, -1);
    else {
      if (!requiredType) hintedType = match[1];
      else if (match[1] !== requiredType) return;
      base = str.slice(match[0].length, -1);
    }
    if (!base) return;
    if (base === '=""') return;
    if (base.startsWith("--")) {
      const calcMatch = base.match(/^--([\w.-]+)\(([^)]+)\)$/);
      if (calcMatch != null && theme4) {
        const [, name50, factor] = calcMatch;
        const [key, ...paths] = name50.split(".");
        const { val, varKey } = processThemeVariable(name50, key, paths, theme4);
        if (val != null) base = `calc(var(--${escapeSelector(varKey.replaceAll(".", "-"))}) * ${factor})`;
      } else {
        const [name50, defaultValue] = base.slice(2).split(",");
        const suffix = defaultValue ? `, ${defaultValue}` : "";
        const escapedName = escapeSelector(name50);
        if (theme4) {
          const [key, ...paths] = name50.split(".");
          const { val, varKey } = processThemeVariable(name50, key, paths, theme4);
          base = val != null ? `var(--${escapeSelector(varKey.replaceAll(".", "-"))}${suffix})` : `var(--${escapedName}${suffix})`;
        } else base = `var(--${escapedName}${suffix})`;
      }
    }
    let curly = 0;
    for (const i of base) if (i === "[") curly += 1;
    else if (i === "]") {
      curly -= 1;
      if (curly < 0) return;
    }
    if (curly) return;
    switch (hintedType) {
      case "string":
        return base.replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_");
      case "quoted":
        return base.replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_").replace(/(["\\])/g, "\\$1").replace(/^(.+)$/, '"$1"');
    }
    return base.replace(/(url\(.*?\))/g, (v) => v.replace(/_/g, "\\_")).replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_").replace(/(?:calc|clamp|max|min)\((.*)/g, (match$1) => {
      const vars = [];
      return match$1.replace(/var\((--.+?)[,)]/g, (match$2, g1) => {
        vars.push(g1);
        return match$2.replace(g1, "--un-calc");
      }).replace(/(-?\d*\.?\d(?!-\d.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ").replace(/--un-calc/g, () => vars.shift());
    });
  }
}
function bracket2(str, theme4) {
  return bracketWithType2(str, void 0, theme4);
}
function bracketOfColor2(str, theme4) {
  return bracketWithType2(str, "color", theme4);
}
function bracketOfLength2(str, theme4) {
  return bracketWithType2(str, "length", theme4) || bracketWithType2(str, "size", theme4);
}
function bracketOfPosition2(str, theme4) {
  return bracketWithType2(str, "position", theme4);
}
function bracketOfFamily(str, theme4) {
  return bracketWithType2(str, "family", theme4);
}
function bracketOfNumber(str, theme4) {
  return bracketWithType2(str, "number", theme4);
}
function cssvar2(str) {
  if (str.startsWith("var(")) return str;
  const match = str.match(/^(?:\$|--)([^\s'"`;{}]+)$/);
  if (match) {
    const [name50, defaultValue] = match[1].split(",");
    return `var(--${escapeSelector(name50)}${defaultValue ? `, ${defaultValue}` : ""})`;
  }
}
function time2(str) {
  const match = str.match(/^(-?[0-9.]+)(s|ms)?$/i);
  if (!match) return;
  const [, n2, unit] = match;
  const num = Number.parseFloat(n2);
  if (!Number.isNaN(num)) {
    if (num === 0 && !unit) return "0s";
    return unit ? `${round3(num)}${unit}` : `${round3(num)}ms`;
  }
}
function degree2(str) {
  const match = str.match(/^(-?[0-9.]+)(deg|rad|grad|turn)?$/i);
  if (!match) return;
  const [, n2, unit] = match;
  const num = Number.parseFloat(n2);
  if (!Number.isNaN(num)) {
    if (num === 0) return "0deg";
    return unit ? `${round3(num)}${unit}` : `${round3(num)}deg`;
  }
}
function global3(str) {
  if (globalKeywords2.includes(str)) return str;
}
function properties2(str) {
  if (str.split(",").every((prop) => cssProps2.includes(prop))) return str;
}
function position2(str) {
  if ([
    "top",
    "left",
    "right",
    "bottom",
    "center"
  ].includes(str)) return str;
}
function none(str) {
  if (str === "none") return "none";
}
var handler2 = createValueHandler(handlers_exports2);
var h2 = handler2;
function numberResolver(size, defaultValue) {
  const v = h2.number(size) ?? defaultValue;
  if (v != null) {
    let num = Number(v);
    if (String(v).endsWith("%")) num = Number(String(v).slice(0, -1)) / 100;
    return num;
  }
}
function directionSize2(property4, map = directionMap2, formatter = (p, d) => `${p}${d}`) {
  return ([_, direction, size = "4"], { theme: theme4 }) => {
    if (size != null && direction != null) {
      let v;
      const isNegative = size.startsWith("-");
      if (isNegative) size = size.slice(1);
      v = numberResolver(size);
      if (v != null && !Number.isNaN(v)) {
        themeTracking("spacing");
        return map[direction].map((i) => [formatter(property4, i), `calc(var(--spacing) * ${isNegative ? "-" : ""}${v})`]);
      } else if (theme4.spacing && size in theme4.spacing) {
        themeTracking("spacing", size);
        return map[direction].map((i) => [formatter(property4, i), isNegative ? `calc(var(--${escapeSelector(`spacing-${size}`)}) * -1)` : `var(--${escapeSelector(`spacing-${size}`)})`]);
      }
      v = h2.bracket.cssvar.global.auto.fraction.rem(isNegative ? `-${size}` : size, theme4);
      if (v != null) return map[direction].map((i) => [formatter(property4, i), v]);
    }
  };
}
function splitShorthand2(body, type) {
  const [front, rest] = getStringComponent(body, "[", "]", ["/", ":"]) ?? [];
  if (front != null) {
    const match = (front.match(bracketTypeRe2) ?? [])[1];
    if (match == null || match === type) return [front, rest];
  }
}
function parseColor3(body, theme4) {
  let split;
  const [front, ...rest] = getStringComponents(body, ["/", ":"], 3) ?? [];
  if (front != null) {
    const match = (front.match(bracketTypeRe2) ?? [])[1];
    if (match == null || match === "color") split = [front, ...rest];
  }
  if (!split) return;
  let opacity3;
  let [main, opacityOrModifier, modifier] = split;
  if (isInterpolatedMethod(opacityOrModifier) || isInterpolatedMethod(h2.bracket(opacityOrModifier ?? ""))) modifier = opacityOrModifier;
  else opacity3 = opacityOrModifier;
  const colors3 = main.replace(/([a-z])(\d)(?![-_a-z])/g, "$1-$2").split(/-/g);
  const [name50] = colors3;
  if (!name50) return;
  let parsed = parseThemeColor(theme4, colors3);
  if (!parsed && colors3.length >= 2) {
    const last = colors3.at(-1);
    const secondLast = colors3.at(-2);
    if (/^\d+$/.test(last)) parsed = parseThemeColor(theme4, colors3.slice(0, -2).concat([`${secondLast}${last}`]));
  }
  let { no, keys, color } = parsed ?? {};
  if (!color) {
    const bracket$1 = h2.bracketOfColor(main, theme4);
    const bracketOrMain = bracket$1 || main;
    if (h2.numberWithUnit(bracketOrMain)) return;
    if (/^#[\da-f]+$/i.test(bracketOrMain)) color = bracketOrMain;
    else if (/^hex-[\da-fA-F]+$/.test(bracketOrMain)) color = `#${bracketOrMain.slice(4)}`;
    else if (main.startsWith("$")) color = h2.cssvar(main);
    color = color || bracket$1;
  }
  return {
    opacity: opacity3,
    modifier: modifier && h2.bracket.cssvar(modifier) || modifier,
    name: name50,
    no,
    color: color ?? SpecialColorKey[name50],
    alpha: h2.bracket.cssvar.percent(opacity3 ?? ""),
    keys,
    get cssColor() {
      return parseCssColor(this.color);
    }
  };
}
function parseThemeColor(theme4, keys) {
  let color;
  let no;
  let key;
  const colorData = getThemeByKey(theme4, "colors", keys);
  if (typeof colorData === "object") {
    if ("DEFAULT" in colorData) {
      color = colorData.DEFAULT;
      no = "DEFAULT";
      key = [...keys, no];
    }
  } else if (typeof colorData === "string") {
    color = colorData;
    key = keys;
    no = keys.at(-1);
  }
  if (!color) return;
  return {
    color,
    no,
    keys: key
  };
}
function getThemeByKey(theme4, themeKey, keys) {
  const obj = theme4[themeKey];
  function deepGet(current, path) {
    if (path.length === 0) return current;
    if (!current || typeof current !== "object") return void 0;
    for (let i = path.length; i > 0; i--) {
      const flatKey = path.slice(0, i).join("-");
      if (flatKey in current) {
        const v = current[flatKey];
        if (i === path.length) return v;
        return deepGet(v, path.slice(i));
      }
    }
  }
  return deepGet(obj, keys);
}
function colorCSSGenerator(data, property4, varName, ctx) {
  if (!data) return;
  const { color, keys, alpha, modifier } = data;
  const rawColorComment = (ctx == null ? void 0 : ctx.generator.config.envMode) === "dev" && color ? ` /* ${color} */` : "";
  const css = {};
  if (color) {
    const result = [css];
    const isCSSVar = color.includes("var(");
    const isSpecial = Object.values(SpecialColorKey).includes(color);
    if (isSpecial && !alpha) {
      css[property4] = color;
      return result;
    }
    const alphaKey = `--un-${varName}-opacity`;
    const value = keys && !isCSSVar && !isSpecial ? generateThemeVariable("colors", keys) : color;
    let method = modifier ?? (keys ? "in srgb" : "in oklab");
    if (!method.startsWith("in ") && !method.startsWith("var(")) method = `in ${method}`;
    css[property4] = `color-mix(${method}, ${value} ${alpha ?? `var(${alphaKey})`}, transparent)${rawColorComment}`;
    result.push(defineProperty(alphaKey, {
      syntax: "<percentage>",
      initialValue: "100%"
    }));
    if (!isSpecial) {
      if (keys && !isCSSVar) {
        themeTracking(`colors`, keys);
        if (!modifier) {
          const colorValue = [
            "shadow",
            "inset-shadow",
            "text-shadow",
            "drop-shadow"
          ].includes(varName) ? `${alpha ? `color-mix(in oklab, ${value} ${alpha}, transparent)` : `${value}`} var(${alphaKey})` : `${value} ${alpha ?? `var(${alphaKey})`}`;
          result.push({
            [symbols.parent]: "@supports (color: color-mix(in lab, red, red))",
            [symbols.noMerge]: true,
            [property4]: `color-mix(in oklab, ${colorValue}, transparent)${rawColorComment}`
          });
        }
      }
      if (ctx == null ? void 0 : ctx.theme) detectThemeValue(color, ctx.theme);
    }
    return result;
  }
}
function colorResolver2(property4, varName) {
  return ([, body], ctx) => {
    const data = parseColor3(body ?? "", ctx.theme);
    if (!data) return;
    return colorCSSGenerator(data, property4, varName, ctx);
  };
}
function colorableShadows2(shadows, colorVar, alpha) {
  const colored = [];
  shadows = toArray(shadows);
  for (let i = 0; i < shadows.length; i++) {
    const components = getStringComponents(shadows[i], " ", 6);
    if (!components || components.length < 3) return shadows;
    let isInset = false;
    const pos = components.indexOf("inset");
    if (pos !== -1) {
      components.splice(pos, 1);
      isInset = true;
    }
    let colorVarValue = "";
    const lastComp = components.at(-1);
    if (parseCssColor(components.at(0))) {
      const color = parseCssColor(components.shift());
      if (color) colorVarValue = colorToString2(color);
    } else if (parseCssColor(lastComp)) {
      const color = parseCssColor(components.pop());
      if (color) colorVarValue = colorToString2(color);
    } else if (lastComp && lastComp.startsWith("var(")) {
      const color = components.pop();
      if (color) colorVarValue = color;
    }
    colored.push(`${isInset ? "inset " : ""}${components.join(" ")} var(${colorVar}, ${alpha ? `oklab(from ${colorVarValue} l a b / ${alpha})` : colorVarValue})`);
  }
  return colored;
}
function hasParseableColor2(color, theme4) {
  var _a;
  return color != null && !!((_a = parseColor3(color, theme4)) == null ? void 0 : _a.color);
}
var reLetters2 = /[a-z]+/gi;
var resolvedBreakpoints2 = /* @__PURE__ */ new WeakMap();
function resolveBreakpoints2({ theme: theme4, generator }, key = "breakpoint") {
  var _a, _b;
  const breakpoints2 = ((_b = (_a = generator == null ? void 0 : generator.userConfig) == null ? void 0 : _a.theme) == null ? void 0 : _b[key]) || theme4[key];
  if (!breakpoints2) return void 0;
  if (resolvedBreakpoints2.has(theme4)) return resolvedBreakpoints2.get(theme4);
  const resolved = Object.entries(breakpoints2).sort((a, b) => Number.parseInt(a[1].replace(reLetters2, "")) - Number.parseInt(b[1].replace(reLetters2, ""))).map(([point, size]) => ({
    point,
    size
  }));
  resolvedBreakpoints2.set(theme4, resolved);
  return resolved;
}
function resolveVerticalBreakpoints2(context) {
  return resolveBreakpoints2(context, "verticalBreakpoint");
}
function makeGlobalStaticRules2(prefix, property4) {
  return globalKeywords2.map((keyword2) => [`${prefix}-${keyword2}`, { [property4 ?? prefix]: keyword2 }]);
}
function defineProperty(property4, options = {}) {
  const { syntax = "*", inherits = false, initialValue } = options;
  const value = {
    [symbols.shortcutsNoMerge]: true,
    [symbols.noMerge]: true,
    [symbols.variants]: () => [{
      parent: "",
      layer: "properties",
      selector: () => `@property ${property4}`
    }],
    syntax: JSON.stringify(syntax),
    inherits: inherits ? "true" : "false"
  };
  if (initialValue != null) value["initial-value"] = initialValue;
  propertyTracking(property4, initialValue ? String(initialValue) : "initial");
  return value;
}
function isCSSMathFn2(value) {
  return value != null && cssMathFnRE2.test(value);
}
function isSize2(str) {
  if (str[0] === "[" && str.slice(-1) === "]") str = str.slice(1, -1);
  return cssMathFnRE2.test(str) || numberWithUnitRE2.test(str);
}
function camelize2(str) {
  return str.replace(/-(\w)/g, (_, c) => c ? c.toUpperCase() : "");
}
function hyphenate(str) {
  return str.replace(/(?:^|\B)([A-Z])/g, "-$1").toLowerCase();
}
function compressCSS(css, isDev = false) {
  if (isDev) return css.trim();
  return css.trim().replace(/\s+/g, " ").replace(/\/\*[\s\S]*?\*\//g, "");
}
var trackedTheme = /* @__PURE__ */ new Set([]);
function themeTracking(key, props = "DEFAULT") {
  const k = `${key}:${toArray(props).join("-")}`;
  if (!trackedTheme.has(k)) trackedTheme.add(k);
}
function generateThemeVariable(key, props) {
  return `var(--${key}-${toArray(props).join("-")})`;
}
function detectThemeValue(value, theme4) {
  var _a;
  if (value.startsWith("var(")) {
    const variable = (_a = value.match(/var\(--([\w-]+)(?:,.*)?\)/)) == null ? void 0 : _a[1];
    if (variable) {
      const [key, ...path] = variable.split("-");
      const themeValue = getThemeByKey(theme4, key, path);
      if (typeof themeValue === "string") {
        themeTracking(key, path);
        detectThemeValue(themeValue, theme4);
      }
    }
  }
}
var trackedProperties = /* @__PURE__ */ new Map();
function propertyTracking(property4, value) {
  if (!trackedProperties.has(property4)) trackedProperties.set(property4, value);
}
function createRemToPxProcessor(base = 16) {
  function resolver(utility) {
    if (typeof utility[1] === "string" && remRE.test(utility[1])) utility[1] = utility[1].replace(remRE, (_, p1) => `${p1 * base}px`);
  }
  return (utilObjectOrEntry) => {
    if (Array.isArray(utilObjectOrEntry)) resolver(utilObjectOrEntry);
    else utilObjectOrEntry.entries.forEach(resolver);
  };
}
var utils_exports2 = __exportAll2({
  CONTROL_NO_NEGATIVE: () => CONTROL_NO_NEGATIVE,
  PRESET_NAME: () => PRESET_NAME,
  SpecialColorKey: () => SpecialColorKey,
  camelize: () => camelize2,
  colorCSSGenerator: () => colorCSSGenerator,
  colorResolver: () => colorResolver2,
  colorableShadows: () => colorableShadows2,
  compressCSS: () => compressCSS,
  cornerMap: () => cornerMap2,
  createRemToPxProcessor: () => createRemToPxProcessor,
  cssMathFnRE: () => cssMathFnRE2,
  cssVarFnRE: () => cssVarFnRE2,
  defineProperty: () => defineProperty,
  detectThemeValue: () => detectThemeValue,
  directionMap: () => directionMap2,
  directionSize: () => directionSize2,
  generateThemeVariable: () => generateThemeVariable,
  getThemeByKey: () => getThemeByKey,
  globalKeywords: () => globalKeywords2,
  h: () => h2,
  handler: () => handler2,
  hasParseableColor: () => hasParseableColor2,
  hyphenate: () => hyphenate,
  insetMap: () => insetMap2,
  isCSSMathFn: () => isCSSMathFn2,
  isSize: () => isSize2,
  makeGlobalStaticRules: () => makeGlobalStaticRules2,
  numberResolver: () => numberResolver,
  parseColor: () => parseColor3,
  parseThemeColor: () => parseThemeColor,
  positionMap: () => positionMap2,
  propertyTracking: () => propertyTracking,
  resolveBreakpoints: () => resolveBreakpoints2,
  resolveVerticalBreakpoints: () => resolveVerticalBreakpoints2,
  splitShorthand: () => splitShorthand2,
  themeTracking: () => themeTracking,
  trackedProperties: () => trackedProperties,
  trackedTheme: () => trackedTheme,
  valueHandlers: () => handlers_exports2,
  xyzArray: () => xyzArray2,
  xyzMap: () => xyzMap2
});

// node_modules/@unocss/preset-wind4/dist/container-Bma9LDm4.mjs
var containerParent2 = [[/^@container(?:\/(\w+))?(?:-(normal))?$/, ([, l, v]) => {
  return {
    "container-type": v ?? "inline-size",
    "container-name": l
  };
}]];
var queryMatcher2 = /@media \(min-width: (.+)\)/;
var container2 = [[
  /^__container$/,
  (_, context) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const { theme: theme4, variantHandlers } = context;
    const themePadding = (_a = theme4.containers) == null ? void 0 : _a.padding;
    let padding;
    if (isString(themePadding)) padding = themePadding;
    else padding = themePadding == null ? void 0 : themePadding.DEFAULT;
    const themeMaxWidth = (_b = theme4.containers) == null ? void 0 : _b.maxWidth;
    let maxWidth2;
    for (const v of variantHandlers) {
      const query = (_d = (_c = v.handle) == null ? void 0 : _c.call(v, {}, (x) => x)) == null ? void 0 : _d.parent;
      if (isString(query)) {
        const match = (_e = query.match(queryMatcher2)) == null ? void 0 : _e[1];
        if (match) {
          const matchBp = (_f = (resolveBreakpoints2(context) ?? []).find((i) => i.size === match)) == null ? void 0 : _f.point;
          if (!themeMaxWidth) maxWidth2 = match;
          else if (matchBp) maxWidth2 = themeMaxWidth == null ? void 0 : themeMaxWidth[matchBp];
          if (matchBp && !isString(themePadding)) padding = (themePadding == null ? void 0 : themePadding[matchBp]) ?? padding;
        }
      }
    }
    const css = { "max-width": maxWidth2 };
    if (!variantHandlers.length) css.width = "100%";
    if ((_g = theme4.containers) == null ? void 0 : _g.center) {
      css["margin-left"] = "auto";
      css["margin-right"] = "auto";
    }
    if (themePadding) {
      css["padding-left"] = padding;
      css["padding-right"] = padding;
    }
    return css;
  },
  { internal: true }
]];
var containerShortcuts2 = [[/^(?:(\w+)[:-])?container$/, ([, bp], context) => {
  let points = (resolveBreakpoints2(context) ?? []).map((i) => i.point);
  if (bp) {
    if (!points.includes(bp)) return;
    points = points.slice(points.indexOf(bp));
  }
  const shortcuts3 = points.map((p) => `${p}:__container`);
  if (!bp) shortcuts3.unshift("__container");
  return shortcuts3;
}]];

// node_modules/@unocss/preset-wind4/dist/rules.mjs
var verticalAlignAlias2 = {
  "mid": "middle",
  "base": "baseline",
  "btm": "bottom",
  "baseline": "baseline",
  "top": "top",
  "start": "top",
  "middle": "middle",
  "bottom": "bottom",
  "end": "bottom",
  "text-top": "text-top",
  "text-bottom": "text-bottom",
  "sub": "sub",
  "super": "super",
  ...Object.fromEntries(globalKeywords2.map((x) => [x, x]))
};
var verticalAligns2 = [[
  /^(?:vertical|align|v)-(.+)$/,
  ([, v]) => ({ "vertical-align": verticalAlignAlias2[v] ?? h2.bracket.cssvar.numberWithUnit(v) }),
  { autocomplete: [`(vertical|align|v)-(${Object.keys(verticalAlignAlias2).join("|")})`, "(vertical|align|v)-<percentage>"] }
]];
var textAlignValues2 = [
  "center",
  "left",
  "right",
  "justify",
  "start",
  "end"
];
var textAligns2 = [...textAlignValues2.map((v) => [`text-${v}`, { "text-align": v }]), ...[...globalKeywords2, ...textAlignValues2].map((v) => [`text-align-${v}`, { "text-align": v }])];
var animations2 = [
  [
    /^(?:animate-)?keyframes-(.+)$/,
    ([, name50], { theme: theme4 }) => {
      var _a, _b;
      const kf = (_b = (_a = theme4.animation) == null ? void 0 : _a.keyframes) == null ? void 0 : _b[name50];
      if (kf) return [`@keyframes ${name50}${kf}`, { animation: name50 }];
    },
    { autocomplete: ["animate-keyframes-$animation.keyframes", "keyframes-$animation.keyframes"] }
  ],
  [
    /^animate-(.+)$/,
    ([, name50], { theme: theme4 }) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
      const kf = (_b = (_a = theme4.animation) == null ? void 0 : _a.keyframes) == null ? void 0 : _b[name50];
      if (kf) {
        const duration2 = ((_d = (_c = theme4.animation) == null ? void 0 : _c.durations) == null ? void 0 : _d[name50]) ?? "1s";
        const timing = ((_f = (_e = theme4.animation) == null ? void 0 : _e.timingFns) == null ? void 0 : _f[name50]) ?? "linear";
        const count = ((_h = (_g = theme4.animation) == null ? void 0 : _g.counts) == null ? void 0 : _h[name50]) ?? 1;
        const props = (_j = (_i = theme4.animation) == null ? void 0 : _i.properties) == null ? void 0 : _j[name50];
        return [`@keyframes ${name50}${kf}`, {
          animation: `${name50} ${duration2} ${timing} ${count}`,
          ...props
        }];
      }
      return { animation: h2.bracket.cssvar(name50) };
    },
    { autocomplete: "animate-$animation.keyframes" }
  ],
  [/^animate-name-(.+)/, ([, d]) => ({ "animation-name": h2.bracket.cssvar(d) ?? d })],
  [
    /^animate-duration-(.+)$/,
    ([, d], { theme: theme4 }) => {
      var _a;
      return { "animation-duration": ((_a = theme4.duration) == null ? void 0 : _a[d || "DEFAULT"]) ?? h2.bracket.cssvar.time(d) };
    },
    { autocomplete: ["animate-duration"] }
  ],
  [
    /^animate-delay-(.+)$/,
    ([, d], { theme: theme4 }) => {
      var _a;
      return { "animation-delay": ((_a = theme4.duration) == null ? void 0 : _a[d || "DEFAULT"]) ?? h2.bracket.cssvar.time(d) };
    },
    { autocomplete: ["animate-delay"] }
  ],
  [
    /^animate-ease(?:-(.+))?$/,
    ([, d], { theme: theme4 }) => {
      var _a;
      return { "animation-timing-function": ((_a = theme4.ease) == null ? void 0 : _a[d || "DEFAULT"]) ?? h2.bracket.cssvar(d) };
    },
    { autocomplete: ["animate-ease", "animate-ease-$ease"] }
  ],
  [
    /^animate-(fill-mode-|fill-|mode-)?(.+)$/,
    ([, t, d]) => [
      "none",
      "forwards",
      "backwards",
      "both",
      ...[t ? globalKeywords2 : []]
    ].includes(d) ? { "animation-fill-mode": d } : void 0,
    { autocomplete: [
      "animate-(fill|mode|fill-mode)",
      "animate-(fill|mode|fill-mode)-(none|forwards|backwards|both|inherit|initial|revert|revert-layer|unset)",
      "animate-(none|forwards|backwards|both|inherit|initial|revert|revert-layer|unset)"
    ] }
  ],
  [
    /^animate-(direction-)?(.+)$/,
    ([, t, d]) => [
      "normal",
      "reverse",
      "alternate",
      "alternate-reverse",
      ...[t ? globalKeywords2 : []]
    ].includes(d) ? { "animation-direction": d } : void 0,
    { autocomplete: [
      "animate-direction",
      "animate-direction-(normal|reverse|alternate|alternate-reverse|inherit|initial|revert|revert-layer|unset)",
      "animate-(normal|reverse|alternate|alternate-reverse|inherit|initial|revert|revert-layer|unset)"
    ] }
  ],
  [
    /^animate-(?:iteration-count-|iteration-|count-)(.+)$/,
    ([, d]) => ({ "animation-iteration-count": h2.bracket.cssvar(d) ?? d.replace(/-/g, ",") }),
    { autocomplete: ["animate-(iteration|count|iteration-count)", "animate-(iteration|count|iteration-count)-<num>"] }
  ],
  [
    /^animate-(play-state-|play-|state-)?(.+)$/,
    ([, t, d]) => [
      "paused",
      "running",
      ...[t ? globalKeywords2 : []]
    ].includes(d) ? { "animation-play-state": d } : void 0,
    { autocomplete: [
      "animate-(play|state|play-state)",
      "animate-(play|state|play-state)-(paused|running|inherit|initial|revert|revert-layer|unset)",
      "animate-(paused|running|inherit|initial|revert|revert-layer|unset)"
    ] }
  ],
  ["animate-none", { animation: "none" }],
  ...makeGlobalStaticRules2("animate", "animation")
];
var properties3 = {
  "gradient-position": defineProperty("--un-gradient-position"),
  "gradient-from": defineProperty("--un-gradient-from", {
    syntax: "<color>",
    initialValue: "#0000"
  }),
  "gradient-via": defineProperty("--un-gradient-via", {
    syntax: "<color>",
    initialValue: "#0000"
  }),
  "gradient-to": defineProperty("--un-gradient-to", {
    syntax: "<color>",
    initialValue: "#0000"
  }),
  "gradient-stops": defineProperty("--un-gradient-stops"),
  "gradient-via-stops": defineProperty("--un-gradient-via-stops"),
  "gradient-from-position": defineProperty("--un-gradient-from-position", {
    syntax: "<length-percentage>",
    initialValue: "0%"
  }),
  "gradient-via-position": defineProperty("--un-gradient-via-position", {
    syntax: "<length-percentage>",
    initialValue: "50%"
  }),
  "gradient-to-position": defineProperty("--un-gradient-to-position", {
    syntax: "<length-percentage>",
    initialValue: "100%"
  })
};
function resolveModifier(modifier) {
  let interpolationMethod = "in oklab";
  if (modifier) if (modifier.startsWith("[") && modifier.endsWith("]")) interpolationMethod = modifier.slice(1, -1);
  else switch (modifier) {
    case "longer":
    case "shorter":
    case "increasing":
    case "decreasing":
      interpolationMethod = `in oklch ${modifier} hue`;
      break;
    default:
      interpolationMethod = `in ${modifier}`;
  }
  return interpolationMethod;
}
function bgGradientColorResolver2() {
  return function* ([, position3, body], { theme: theme4 }) {
    const css = {};
    const data = parseColor3(body, theme4);
    if (data) {
      const { color, keys, alpha } = data;
      if (color) {
        if (Object.values(SpecialColorKey).includes(color)) css[`--un-gradient-${position3}`] = color;
        else {
          css[`--un-${position3}-opacity`] = alpha;
          const value = keys ? generateThemeVariable("colors", keys) : color;
          css[`--un-gradient-${position3}`] = `color-mix(in oklab, ${value} var(--un-${position3}-opacity), transparent)`;
          yield defineProperty(`--un-${position3}-opacity`, {
            syntax: "<percentage>",
            initialValue: "100%"
          });
        }
        if (keys) themeTracking(`colors`, keys);
        if (theme4) detectThemeValue(color, theme4);
      }
    } else css[`--un-gradient-${position3}`] = h2.bracket.cssvar(body);
    if (css[`--un-gradient-${position3}`]) {
      switch (position3) {
        case "from":
          yield {
            ...css,
            "--un-gradient-stops": "var(--un-gradient-via-stops, var(--un-gradient-position), var(--un-gradient-from) var(--un-gradient-from-position), var(--un-gradient-to) var(--un-gradient-to-position))"
          };
          break;
        case "via":
          yield {
            ...css,
            "--un-gradient-via-stops": `var(--un-gradient-position), var(--un-gradient-from) var(--un-gradient-from-position), var(--un-gradient-via) var(--un-gradient-via-position), var(--un-gradient-to) var(--un-gradient-to-position)`,
            "--un-gradient-stops": `var(--un-gradient-via-stops)`
          };
          break;
        case "to":
          yield {
            ...css,
            "--un-gradient-stops": "var(--un-gradient-via-stops, var(--un-gradient-position), var(--un-gradient-from) var(--un-gradient-from-position), var(--un-gradient-to) var(--un-gradient-to-position))"
          };
          break;
        case "stops":
          yield { ...css };
          break;
      }
      for (const p of Object.values(properties3)) yield p;
    }
  };
}
function bgGradientPositionResolver2() {
  return function* ([, mode, body]) {
    yield { [`--un-gradient-${mode}-position`]: `${h2.bracket.cssvar.percent(body)}` };
    for (const p of Object.values(properties3)) yield p;
  };
}
var backgroundStyles2 = [
  [
    /^bg-(linear|radial|conic)-([^/]+)(?:\/(.+))?$/,
    ([, m, d, s]) => {
      let v;
      if (h2.number(d) != null) v = `from ${h2.number(d)}deg ${resolveModifier(s)};`;
      else v = h2.bracket(d);
      if (v) return {
        "--un-gradient-position": v,
        "background-image": `${m}-gradient(var(--un-gradient-stops))`
      };
    },
    { autocomplete: [
      "bg-(linear|radial|conic)",
      "(from|to|via)-$colors",
      "(from|to|via)-(op|opacity)",
      "(from|to|via)-(op|opacity)-<percent>"
    ] }
  ],
  [/^(from|via|to|stops)-(.+)$/, bgGradientColorResolver2()],
  [/^(from|via|to)-op(?:acity)?-?(.+)$/, ([, position3, opacity$1]) => ({ [`--un-${position3}-opacity`]: h2.bracket.percent(opacity$1) })],
  [/^(from|via|to)-([\d.]+%)$/, bgGradientPositionResolver2()],
  [
    /^bg-((?:repeating-)?(?:linear|radial|conic))$/,
    ([, s]) => ({ "background-image": `${s}-gradient(var(--un-gradient, var(--un-gradient-stops, rgb(255 255 255 / 0))))` }),
    { autocomplete: [
      "bg-gradient-repeating",
      "bg-gradient-(linear|radial|conic)",
      "bg-gradient-repeating-(linear|radial|conic)"
    ] }
  ],
  [
    /^bg-(gradient|linear|radial|conic)(?:-to-([rltb]{1,2}))?(?:\/(.+))?$/,
    ([, m, d, s]) => {
      return {
        "--un-gradient-position": `${d in positionMap2 ? `to ${positionMap2[d]} ` : " "}${resolveModifier(s)}`,
        "background-image": `${m === "gradient" ? "linear" : m}-gradient(var(--un-gradient-stops))`
      };
    },
    { autocomplete: [
      "gradient",
      "linear",
      "radial",
      "conic"
    ].map((i) => {
      return `bg-${i}-to-(${Object.keys(positionMap2).filter((k) => k.length <= 2 && Array.from(k).every((c) => "rltb".includes(c))).join("|")})`;
    }) }
  ],
  ["bg-none", { "background-image": "none" }],
  ["box-decoration-slice", { "box-decoration-break": "slice" }],
  ["box-decoration-clone", { "box-decoration-break": "clone" }],
  ...makeGlobalStaticRules2("box-decoration", "box-decoration-break"),
  ["bg-auto", { "background-size": "auto" }],
  ["bg-cover", { "background-size": "cover" }],
  ["bg-contain", { "background-size": "contain" }],
  [/^bg-size-(.+)$/, ([, v]) => ({ "background-size": h2.bracket.cssvar(v) })],
  ["bg-fixed", { "background-attachment": "fixed" }],
  ["bg-local", { "background-attachment": "local" }],
  ["bg-scroll", { "background-attachment": "scroll" }],
  ["bg-clip-border", {
    "-webkit-background-clip": "border-box",
    "background-clip": "border-box"
  }],
  ["bg-clip-content", {
    "-webkit-background-clip": "content-box",
    "background-clip": "content-box"
  }],
  ["bg-clip-padding", {
    "-webkit-background-clip": "padding-box",
    "background-clip": "padding-box"
  }],
  ["bg-clip-text", {
    "-webkit-background-clip": "text",
    "background-clip": "text"
  }],
  ...globalKeywords2.map((keyword2) => [`bg-clip-${keyword2}`, {
    "-webkit-background-clip": keyword2,
    "background-clip": keyword2
  }]),
  [/^bg-([-\w]{3,})$/, ([, s]) => ({ "background-position": positionMap2[s] })],
  ["bg-repeat", { "background-repeat": "repeat" }],
  ["bg-no-repeat", { "background-repeat": "no-repeat" }],
  ["bg-repeat-x", { "background-repeat": "repeat-x" }],
  ["bg-repeat-y", { "background-repeat": "repeat-y" }],
  ["bg-repeat-round", { "background-repeat": "round" }],
  ["bg-repeat-space", { "background-repeat": "space" }],
  ...makeGlobalStaticRules2("bg-repeat", "background-repeat"),
  ["bg-origin-border", { "background-origin": "border-box" }],
  ["bg-origin-padding", { "background-origin": "padding-box" }],
  ["bg-origin-content", { "background-origin": "content-box" }],
  ...makeGlobalStaticRules2("bg-origin", "background-origin")
];
var outline2 = [
  [
    /^outline-(?:width-|size-)?(.+)$/,
    handleWidth$22,
    { autocomplete: "outline-(width|size)-<num>" }
  ],
  [
    /^outline-(?:color-)?(.+)$/,
    handleColorOrWidth$22,
    { autocomplete: "outline-$colors" }
  ],
  [
    /^outline-op(?:acity)?-?(.+)$/,
    ([, opacity$1]) => ({ "--un-outline-opacity": h2.bracket.percent.cssvar(opacity$1) }),
    { autocomplete: "outline-(op|opacity)-<percent>" }
  ],
  [
    /^outline-offset-(.+)$/,
    ([, d]) => ({ "outline-offset": h2.bracket.cssvar.global.px(d) }),
    { autocomplete: "outline-(offset)-<num>" }
  ],
  ["outline-offset-none", { "outline-offset": "0" }],
  ["outline", [{
    "outline-style": "var(--un-outline-style)",
    "outline-width": "1px"
  }, defineProperty("--un-outline-style", { initialValue: "solid" })]],
  ["outline-hidden", [{ "outline-style": "none" }, {
    [symbols.parent]: `@media (forced-colors: active)`,
    "outline": `2px solid transparent`,
    "outline-offset": `2px`
  }]],
  ["outline-none", {
    "--un-outline-style": "none",
    "outline-style": "none"
  }],
  ...[
    "auto",
    "dashed",
    "dotted",
    "double",
    "solid",
    "groove",
    "ridge",
    "inset",
    "outset",
    ...globalKeywords2
  ].map((v) => [`outline-${v}`, {
    "--un-outline-style": v,
    "outline-style": v
  }])
];
function* handleWidth$22([, b]) {
  const v = h2.bracket.cssvar.global.px(b);
  if (v != null) {
    yield {
      "outline-style": "var(--un-outline-style)",
      "outline-width": v
    };
    yield defineProperty("--un-outline-style", { initialValue: "solid" });
  }
}
function* handleColorOrWidth$22(match, ctx) {
  if (isCSSMathFn2(h2.bracket(match[1]))) yield* handleWidth$22(match);
  else {
    const result = colorResolver2("outline-color", "outline")(match, ctx);
    if (result) for (const i of result) yield i;
  }
}
var appearance2 = [["appearance-auto", {
  "-webkit-appearance": "auto",
  "appearance": "auto"
}], ["appearance-none", {
  "-webkit-appearance": "none",
  "appearance": "none"
}]];
function willChangeProperty2(prop) {
  const v = h2.bracket(prop);
  if (v && h2.properties(v)) return v;
  return h2.properties.auto.cssvar.global(prop) ?? {
    contents: "contents",
    scroll: "scroll-position"
  }[prop];
}
var willChange2 = [[/^will-change-(.+)/, ([, p]) => ({ "will-change": willChangeProperty2(p) })]];
var listStyles2 = {
  "disc": "disc",
  "circle": "circle",
  "square": "square",
  "decimal": "decimal",
  "zero-decimal": "decimal-leading-zero",
  "greek": "lower-greek",
  "roman": "lower-roman",
  "upper-roman": "upper-roman",
  "alpha": "lower-alpha",
  "upper-alpha": "upper-alpha",
  "latin": "lower-latin",
  "upper-latin": "upper-latin"
};
var listStyle2 = [
  [
    /^list-(.+?)(?:-(outside|inside))?$/,
    ([, alias, position3]) => {
      const style = listStyles2[alias];
      if (style) {
        if (position3) return {
          "list-style-position": position3,
          "list-style-type": style
        };
        return { "list-style-type": style };
      }
    },
    { autocomplete: [`list-(${Object.keys(listStyles2).join("|")})`, `list-(${Object.keys(listStyles2).join("|")})-(outside|inside)`] }
  ],
  ["list-outside", { "list-style-position": "outside" }],
  ["list-inside", { "list-style-position": "inside" }],
  ["list-none", { "list-style-type": "none" }],
  [/^list-image-(.+)$/, ([, d]) => {
    if (/^\[url\(.+\)\]$/.test(d)) return { "list-style-image": h2.bracket(d) };
  }],
  ["list-image-none", { "list-style-image": "none" }],
  ...makeGlobalStaticRules2("list", "list-style-type")
];
var accents2 = [[
  /^accent-(.+)$/,
  colorResolver2("accent-color", "accent"),
  { autocomplete: "accent-$colors" }
], [
  /^accent-op(?:acity)?-?(.+)$/,
  ([, d]) => ({ "--un-accent-opacity": h2.bracket.percent(d) }),
  { autocomplete: ["accent-(op|opacity)", "accent-(op|opacity)-<percent>"] }
]];
var carets2 = [[
  /^caret-(.+)$/,
  colorResolver2("caret-color", "caret"),
  { autocomplete: "caret-$colors" }
], [
  /^caret-op(?:acity)?-?(.+)$/,
  ([, d]) => ({ "--un-caret-opacity": h2.bracket.percent(d) }),
  { autocomplete: ["caret-(op|opacity)", "caret-(op|opacity)-<percent>"] }
]];
var imageRenderings2 = [
  ["image-render-auto", { "image-rendering": "auto" }],
  ["image-render-edge", { "image-rendering": "crisp-edges" }],
  ["image-render-pixel", [
    ["-ms-interpolation-mode", "nearest-neighbor"],
    ["image-rendering", "-webkit-optimize-contrast"],
    ["image-rendering", "-moz-crisp-edges"],
    ["image-rendering", "-o-pixelated"],
    ["image-rendering", "pixelated"]
  ]]
];
var overscrolls2 = [
  ["overscroll-auto", { "overscroll-behavior": "auto" }],
  ["overscroll-contain", { "overscroll-behavior": "contain" }],
  ["overscroll-none", { "overscroll-behavior": "none" }],
  ...makeGlobalStaticRules2("overscroll", "overscroll-behavior"),
  ["overscroll-x-auto", { "overscroll-behavior-x": "auto" }],
  ["overscroll-x-contain", { "overscroll-behavior-x": "contain" }],
  ["overscroll-x-none", { "overscroll-behavior-x": "none" }],
  ...makeGlobalStaticRules2("overscroll-x", "overscroll-behavior-x"),
  ["overscroll-y-auto", { "overscroll-behavior-y": "auto" }],
  ["overscroll-y-contain", { "overscroll-behavior-y": "contain" }],
  ["overscroll-y-none", { "overscroll-behavior-y": "none" }],
  ...makeGlobalStaticRules2("overscroll-y", "overscroll-behavior-y")
];
var scrollBehaviors2 = [
  ["scroll-auto", { "scroll-behavior": "auto" }],
  ["scroll-smooth", { "scroll-behavior": "smooth" }],
  ...makeGlobalStaticRules2("scroll", "scroll-behavior")
];
var borderStyles2 = [
  "solid",
  "dashed",
  "dotted",
  "double",
  "hidden",
  "none",
  "groove",
  "ridge",
  "inset",
  "outset",
  ...globalKeywords2
];
var borders2 = [
  [
    /^(?:border|b)()(?:-(.+))?$/,
    handlerBorderSize2,
    { autocomplete: "(border|b)-<directions>" }
  ],
  [/^(?:border|b)-([xy])(?:-(.+))?$/, handlerBorderSize2],
  [/^(?:border|b)-([rltbse])(?:-(.+))?$/, handlerBorderSize2],
  [/^(?:border|b)-(block|inline)(?:-(.+))?$/, handlerBorderSize2],
  [/^(?:border|b)-([bi][se])(?:-(.+))?$/, handlerBorderSize2],
  [
    /^(?:border|b)-()(?:width|size)-(.+)$/,
    handlerBorderSize2,
    { autocomplete: ["(border|b)-<num>", "(border|b)-<directions>-<num>"] }
  ],
  [/^(?:border|b)-([xy])-(?:width|size)-(.+)$/, handlerBorderSize2],
  [/^(?:border|b)-([rltbse])-(?:width|size)-(.+)$/, handlerBorderSize2],
  [/^(?:border|b)-(block|inline)-(?:width|size)-(.+)$/, handlerBorderSize2],
  [/^(?:border|b)-([bi][se])-(?:width|size)-(.+)$/, handlerBorderSize2],
  [
    /^(?:border|b)-()(?:color-)?(.+)$/,
    handlerBorderColorOrSize2,
    { autocomplete: ["(border|b)-$colors", "(border|b)-<directions>-$colors"] }
  ],
  [/^(?:border|b)-([xy])-(?:color-)?(.+)$/, handlerBorderColorOrSize2],
  [/^(?:border|b)-([rltbse])-(?:color-)?(.+)$/, handlerBorderColorOrSize2],
  [/^(?:border|b)-(block|inline)-(?:color-)?(.+)$/, handlerBorderColorOrSize2],
  [/^(?:border|b)-([bi][se])-(?:color-)?(.+)$/, handlerBorderColorOrSize2],
  [
    /^(?:border|b)-()op(?:acity)?-?(.+)$/,
    handlerBorderOpacity2,
    { autocomplete: "(border|b)-(op|opacity)-<percent>" }
  ],
  [/^(?:border|b)-([xy])-op(?:acity)?-?(.+)$/, handlerBorderOpacity2],
  [/^(?:border|b)-([rltbse])-op(?:acity)?-?(.+)$/, handlerBorderOpacity2],
  [/^(?:border|b)-(block|inline)-op(?:acity)?-?(.+)$/, handlerBorderOpacity2],
  [/^(?:border|b)-([bi][se])-op(?:acity)?-?(.+)$/, handlerBorderOpacity2],
  [
    /^(?:border-|b-)?(?:rounded|rd)()(?:-(.+))?$/,
    handlerRounded2,
    { autocomplete: [
      "(border|b)-(rounded|rd)",
      "(border|b)-(rounded|rd)-$radius",
      "(rounded|rd)",
      "(rounded|rd)-$radius"
    ] }
  ],
  [/^(?:border-|b-)?(?:rounded|rd)-([rltbse])(?:-(.+))?$/, handlerRounded2],
  [/^(?:border-|b-)?(?:rounded|rd)-([rltb]{2})(?:-(.+))?$/, handlerRounded2],
  [/^(?:border-|b-)?(?:rounded|rd)-([bise][se])(?:-(.+))?$/, handlerRounded2],
  [/^(?:border-|b-)?(?:rounded|rd)-([bi][se]-[bi][se])(?:-(.+))?$/, handlerRounded2],
  [
    /^(?:border|b)-(?:style-)?()(.+)$/,
    handlerBorderStyle2,
    { autocomplete: [
      "(border|b)-style",
      `(border|b)-(${borderStyles2.join("|")})`,
      "(border|b)-<directions>-style",
      `(border|b)-<directions>-(${borderStyles2.join("|")})`,
      `(border|b)-<directions>-style-(${borderStyles2.join("|")})`,
      `(border|b)-style-(${borderStyles2.join("|")})`
    ] }
  ],
  [/^(?:border|b)-([xy])-(?:style-)?(.+)$/, handlerBorderStyle2],
  [/^(?:border|b)-([rltbse])-(?:style-)?(.+)$/, handlerBorderStyle2],
  [/^(?:border|b)-(block|inline)-(?:style-)?(.+)$/, handlerBorderStyle2],
  [/^(?:border|b)-([bi][se])-(?:style-)?(.+)$/, handlerBorderStyle2]
];
function borderColorResolver2(direction) {
  return ([, body], ctx) => {
    const data = parseColor3(body, ctx.theme);
    const result = colorCSSGenerator(data, `border${direction}-color`, `border${direction}`, ctx);
    if (result) {
      const css = result[0];
      if ((data == null ? void 0 : data.color) && !Object.values(SpecialColorKey).includes(data.color) && !data.alpha && direction && direction !== "") css[`--un-border${direction}-opacity`] = `var(--un-border-opacity)`;
      return result;
    }
  };
}
function handlerBorderSize2([, a = "", b = "1"]) {
  const v = h2.bracket.cssvar.global.px(b);
  if (a in directionMap2 && v != null) return directionMap2[a].map((i) => [`border${i}-width`, v]);
}
function handlerBorderColorOrSize2([, a = "", b], ctx) {
  if (a in directionMap2) {
    if (isCSSMathFn2(h2.bracket(b))) return handlerBorderSize2([
      "",
      a,
      b
    ]);
    if (hasParseableColor2(b, ctx.theme)) {
      const directions$1 = directionMap2[a].map((i) => borderColorResolver2(i)(["", b], ctx)).filter(notNull);
      return [directions$1.map((d) => d[0]).reduce((acc, item) => {
        Object.assign(acc, item);
        return acc;
      }, {}), ...directions$1.flatMap((d) => d.slice(1))];
    }
  }
}
function handlerBorderOpacity2([, a = "", opacity$1]) {
  const v = h2.bracket.percent.cssvar(opacity$1);
  if (a in directionMap2 && v != null) return directionMap2[a].map((i) => [`--un-border${i}-opacity`, v]);
}
function handlerRounded2([, a = "", s = "DEFAULT"], { theme: theme4 }) {
  var _a;
  if (a in cornerMap2) {
    if (s === "full") return cornerMap2[a].map((i) => [`border${i}-radius`, "calc(infinity * 1px)"]);
    const _v = ((_a = theme4.radius) == null ? void 0 : _a[s]) ?? h2.bracket.cssvar.global.fraction.rem(s);
    if (_v != null) {
      const isVar = theme4.radius && s in theme4.radius;
      if (isVar) themeTracking(`radius`, s);
      return cornerMap2[a].map((i) => [`border${i}-radius`, isVar ? generateThemeVariable("radius", s) : _v]);
    }
  }
}
function handlerBorderStyle2([, a = "", s]) {
  if (borderStyles2.includes(s) && a in directionMap2) return [["--un-border-style", s], ...directionMap2[a].map((i) => [`border${i}-style`, s])];
}
var opacity2 = [[/^op(?:acity)?-?(.+)$/, ([, d]) => ({ opacity: h2.bracket.percent.cssvar(d) })]];
var bgUrlRE2 = /^\[url\(.+\)\]$/;
var bgLengthRE2 = /^\[(?:length|size):.+\]$/;
var bgPositionRE2 = /^\[position:.+\]$/;
var bgGradientRE2 = /^\[(?:linear|conic|radial)-gradient\(.+\)\]$/;
var bgImageRE2 = /^\[image:.+\]$/;
var bgColors2 = [[
  /^bg-(.+)$/,
  (...args) => {
    const d = args[0][1];
    if (bgUrlRE2.test(d)) return {
      "--un-url": h2.bracket(d),
      "background-image": "var(--un-url)"
    };
    if (bgLengthRE2.test(d) && h2.bracketOfLength(d) != null) return { "background-size": h2.bracketOfLength(d).split(" ").map((e2) => h2.fraction.auto.px.cssvar(e2) ?? e2).join(" ") };
    if ((isSize2(d) || bgPositionRE2.test(d)) && h2.bracketOfPosition(d) != null) return { "background-position": h2.bracketOfPosition(d).split(" ").map((e2) => h2.position.fraction.auto.px.cssvar(e2) ?? e2).join(" ") };
    if (bgGradientRE2.test(d) || bgImageRE2.test(d)) {
      const s = h2.bracket(d);
      if (s) {
        const url = s.startsWith("http") ? `url(${s})` : h2.cssvar(s);
        return { "background-image": url ?? s };
      }
    }
    return colorResolver2("background-color", "bg")(...args);
  },
  { autocomplete: "bg-$colors" }
], [
  /^bg-op(?:acity)?-?(.+)$/,
  ([, opacity$1]) => ({ "--un-bg-opacity": h2.bracket.percent.cssvar(opacity$1) }),
  { autocomplete: "bg-(op|opacity)-<percent>" }
]];
var colorScheme2 = [[/^(?:color-)?scheme-(.+)$/, ([, v]) => ({ "color-scheme": v.split("-").join(" ") })]];
var columns2 = [
  [
    /^columns-(.+)$/,
    ([, v], { theme: theme4 }) => {
      if (theme4.container && v in theme4.container) {
        themeTracking("container", v);
        return { columns: generateThemeVariable("container", v) };
      }
      return { columns: h2.bracket.numberWithUnit.number.cssvar(v) };
    },
    { autocomplete: ["columns-<num>", "columns-$container"] }
  ],
  ["columns-auto", { columns: "auto" }],
  ["break-before-auto", { "break-before": "auto" }],
  ["break-before-avoid", { "break-before": "avoid" }],
  ["break-before-all", { "break-before": "all" }],
  ["break-before-avoid-page", { "break-before": "avoid-page" }],
  ["break-before-page", { "break-before": "page" }],
  ["break-before-left", { "break-before": "left" }],
  ["break-before-right", { "break-before": "right" }],
  ["break-before-column", { "break-before": "column" }],
  ...makeGlobalStaticRules2("break-before"),
  ["break-inside-auto", { "break-inside": "auto" }],
  ["break-inside-avoid", { "break-inside": "avoid" }],
  ["break-inside-avoid-page", { "break-inside": "avoid-page" }],
  ["break-inside-avoid-column", { "break-inside": "avoid-column" }],
  ...makeGlobalStaticRules2("break-inside"),
  ["break-after-auto", { "break-after": "auto" }],
  ["break-after-avoid", { "break-after": "avoid" }],
  ["break-after-all", { "break-after": "all" }],
  ["break-after-avoid-page", { "break-after": "avoid-page" }],
  ["break-after-page", { "break-after": "page" }],
  ["break-after-left", { "break-after": "left" }],
  ["break-after-right", { "break-after": "right" }],
  ["break-after-column", { "break-after": "column" }],
  ...makeGlobalStaticRules2("break-after")
];
var decorationStyles2 = [
  "solid",
  "double",
  "dotted",
  "dashed",
  "wavy",
  ...globalKeywords2
];
var textDecorations2 = [
  [
    /^(?:decoration-)?(underline|overline|line-through)$/,
    ([, s]) => ({ "text-decoration-line": s }),
    { autocomplete: "decoration-(underline|overline|line-through)" }
  ],
  [
    /^(?:underline|decoration)-(?:size-)?(.+)$/,
    handleWidth$12,
    { autocomplete: "(underline|decoration)-<num>" }
  ],
  [
    /^(?:underline|decoration)-(auto|from-font)$/,
    ([, s]) => ({ "text-decoration-thickness": s }),
    { autocomplete: "(underline|decoration)-(auto|from-font)" }
  ],
  [
    /^(?:underline|decoration)-(.+)$/,
    handleColorOrWidth$12,
    { autocomplete: "(underline|decoration)-$colors" }
  ],
  [
    /^(?:underline|decoration)-op(?:acity)?-?(.+)$/,
    ([, opacity$1]) => ({ "--un-line-opacity": h2.bracket.percent.cssvar(opacity$1) }),
    { autocomplete: "(underline|decoration)-(op|opacity)-<percent>" }
  ],
  [
    /^(?:underline|decoration)-offset-(.+)$/,
    ([, s]) => ({ "text-underline-offset": h2.auto.bracket.cssvar.global.px(s) }),
    { autocomplete: "(underline|decoration)-(offset)-<num>" }
  ],
  ...decorationStyles2.map((v) => [`underline-${v}`, { "text-decoration-style": v }]),
  ...decorationStyles2.map((v) => [`decoration-${v}`, { "text-decoration-style": v }]),
  ["no-underline", { "text-decoration": "none" }],
  ["decoration-none", { "text-decoration": "none" }]
];
function handleWidth$12([, b]) {
  return { "text-decoration-thickness": h2.bracket.cssvar.global.px(b) };
}
function handleColorOrWidth$12(match, ctx) {
  if (isCSSMathFn2(h2.bracket(match[1]))) return handleWidth$12(match);
  const result = colorResolver2("text-decoration-color", "line")(match, ctx);
  if (result) {
    const css = result[0];
    css["-webkit-text-decoration-color"] = css["text-decoration-color"];
    return result;
  }
}
var paddings2 = [
  [
    /^pa?()-?(.+)$/,
    directionSize2("padding"),
    { autocomplete: ["(m|p)<num>", "(m|p)-<num>"] }
  ],
  [
    /^p-?xy()()$/,
    directionSize2("padding"),
    { autocomplete: "(m|p)-(xy)" }
  ],
  [/^p-?([xy])(?:-?(.+))?$/, directionSize2("padding")],
  [
    /^p-?([rltbse])(?:-?(.+))?$/,
    directionSize2("padding"),
    { autocomplete: "(m|p)<directions>-<num>" }
  ],
  [
    /^p-(block|inline)(?:-(.+))?$/,
    directionSize2("padding"),
    { autocomplete: "(m|p)-(block|inline)-<num>" }
  ],
  [
    /^p-?([bi][se])(?:-?(.+))?$/,
    directionSize2("padding"),
    { autocomplete: "(m|p)-(bs|be|is|ie)-<num>" }
  ]
];
var margins2 = [
  [/^ma?()-?(.+)$/, directionSize2("margin")],
  [/^m-?xy()()$/, directionSize2("margin")],
  [/^m-?([xy])(?:-?(.+))?$/, directionSize2("margin")],
  [/^m-?([rltbse])(?:-?(.+))?$/, directionSize2("margin")],
  [/^m-(block|inline)(?:-(.+))?$/, directionSize2("margin")],
  [/^m-?([bi][se])(?:-?(.+))?$/, directionSize2("margin")]
];
var spaces2 = [[
  /^space-([xy])-(.+)$/,
  handlerSpace2,
  { autocomplete: [
    "space-(x|y)",
    "space-(x|y)-reverse",
    "space-(x|y)-$spacing"
  ] }
], [/^space-([xy])-reverse$/, function* ([m, d], { symbols: symbols$1 }) {
  yield {
    [symbols$1.variants]: [notLastChildSelectorVariant(m)],
    [`--un-space-${d}-reverse`]: "1"
  };
  yield defineProperty(`--un-space-${d}-reverse`, { initialValue: 0 });
}]];
function notLastChildSelectorVariant(s) {
  return {
    matcher: s,
    handle: (input, next) => next({
      ...input,
      parent: `${input.parent ? `${input.parent} $$ ` : ""}${input.selector}`,
      selector: ":where(&>:not(:last-child))"
    })
  };
}
function* handlerSpace2([m, d, s], { theme: theme4, symbols: symbols$1 }) {
  var _a;
  let v;
  const num = numberResolver(s);
  if (num != null) {
    themeTracking(`spacing`);
    v = `calc(var(--spacing) * ${num})`;
  } else v = ((_a = theme4.spacing) == null ? void 0 : _a[s]) ?? h2.bracket.cssvar.auto.fraction.rem(s || "1");
  if (v != null) {
    const results = directionMap2[d === "x" ? "inline" : "block"].map((item, index) => {
      return [`margin${item}`, ` calc(${v} * ${index === 0 ? `var(--un-space-${d}-reverse)` : `calc(1 - var(--un-space-${d}-reverse))`})`];
    });
    if (results) {
      yield {
        [symbols$1.variants]: [notLastChildSelectorVariant(m)],
        [`--un-space-${d}-reverse`]: "0",
        ...Object.fromEntries(results)
      };
      yield defineProperty(`--un-space-${d}-reverse`, { initialValue: 0 });
    }
  }
}
var divides2 = [
  [
    /^divide-(.+)$/,
    function* (match, ctx) {
      const result = colorResolver2("border-color", "divide")(match, ctx);
      if (result) {
        yield {
          [ctx.symbols.variants]: [notLastChildSelectorVariant(match[0])],
          ...result[0]
        };
        yield result[1];
      }
    },
    { autocomplete: "divide-$colors" }
  ],
  [
    /^divide-op(?:acity)?-?(.+)$/,
    function* ([match, opacity$1], { symbols: symbols$1 }) {
      yield {
        [symbols$1.variants]: [notLastChildSelectorVariant(match)],
        "--un-divide-opacity": h2.bracket.percent(opacity$1)
      };
    },
    { autocomplete: ["divide-(op|opacity)", "divide-(op|opacity)-<percent>"] }
  ],
  [
    /^divide-?([xy])$/,
    handlerDivide2,
    { autocomplete: ["divide-(x|y)", "divide-(x|y)-reverse"] }
  ],
  [/^divide-?([xy])-?(.+)$/, handlerDivide2],
  [/^divide-?([xy])-reverse$/, function* ([m, d], { symbols: symbols$1 }) {
    yield {
      [symbols$1.variants]: [notLastChildSelectorVariant(m)],
      [`--un-divide-${d}-reverse`]: "1"
    };
    yield defineProperty(`--un-divide-${d}-reverse`, { initialValue: 0 });
  }],
  [
    new RegExp(`^divide-(${borderStyles2.join("|")})$`),
    function* ([match, style], { symbols: symbols$1 }) {
      yield {
        [symbols$1.variants]: [notLastChildSelectorVariant(match)],
        "border-style": style
      };
    },
    { autocomplete: borderStyles2.map((i) => `divide-${i}`) }
  ]
];
function* handlerDivide2([m, d, s], { symbols: symbols$1 }) {
  let v = h2.bracket.cssvar.px(s || "1");
  if (v != null) {
    if (v === "0") v = "0px";
    const results = {
      x: ["-left", "-right"],
      y: ["-top", "-bottom"]
    }[d].map((item) => {
      const value = item.endsWith("left") || item.endsWith("top") ? `calc(${v} * var(--un-divide-${d}-reverse))` : `calc(${v} * calc(1 - var(--un-divide-${d}-reverse)))`;
      return [[`border${item}-width`, value], [`border${item}-style`, `var(--un-border-style)`]];
    });
    if (results) {
      yield {
        [symbols$1.variants]: [notLastChildSelectorVariant(m)],
        [`--un-divide-${d}-reverse`]: 0,
        ...Object.fromEntries(results.flat())
      };
      yield defineProperty(`--un-divide-${d}-reverse`, { initialValue: 0 });
      yield defineProperty(`--un-border-style`, { initialValue: "solid" });
    }
  }
}
var filterBaseKeys2 = [
  "blur",
  "brightness",
  "contrast",
  "grayscale",
  "hue-rotate",
  "invert",
  "saturate",
  "sepia",
  "drop-shadow"
];
var filterProperties = filterBaseKeys2.map((i) => defineProperty(`--un-${i}`));
var filterCSS = filterBaseKeys2.map((i) => `var(--un-${i},)`).join(" ");
var backdropBaseKeys = [
  "backdrop-blur",
  "backdrop-brightness",
  "backdrop-contrast",
  "backdrop-grayscale",
  "backdrop-hue-rotate",
  "backdrop-invert",
  "backdrop-opacity",
  "backdrop-saturate",
  "backdrop-sepia"
];
var backdropProperties = backdropBaseKeys.map((i) => defineProperty(`--un-${i}`));
var backdropCSS = backdropBaseKeys.map((i) => `var(--un-${i},)`).join(" ");
function percentWithDefault2(str) {
  let v = h2.bracket.cssvar(str || "");
  if (v != null) return v;
  v = str ? h2.percent(str) : "100%";
  if (v != null && Number.parseFloat(v.slice(0, -1)) <= 100) return v;
}
function toFilter2(varName, resolver) {
  return ([, b, s], { theme: theme4 }) => {
    const value = resolver(s, theme4) ?? (s === "none" ? "0" : "");
    if (value !== "") if (b) return [{
      [`--un-${b}${varName}`]: `${varName}(${value})`,
      "-webkit-backdrop-filter": backdropCSS,
      "backdrop-filter": backdropCSS
    }, ...backdropProperties];
    else return [{
      [`--un-${varName}`]: `${varName}(${value})`,
      filter: filterCSS
    }, ...filterProperties];
  };
}
function dropShadowResolver2(match, ctx) {
  var _a;
  const [, s] = match;
  const { theme: theme4 } = ctx;
  let res = [];
  if (s) {
    res = getStringComponents(s, "/", 2) ?? [];
    if (s.startsWith("/")) res = ["", s.slice(1)];
  }
  let v = (_a = theme4.dropShadow) == null ? void 0 : _a[res[0] || "DEFAULT"];
  const c = s ? h2.bracket.cssvar(s) : void 0;
  if ((v != null || c != null) && !hasParseableColor2(c, theme4)) {
    const alpha = res[1] ? h2.bracket.percent.cssvar(res[1]) : void 0;
    return [{
      "--un-drop-shadow-opacity": alpha,
      "--un-drop-shadow": `drop-shadow(${colorableShadows2(v || c, "--un-drop-shadow-color", alpha).join(") drop-shadow(")})`,
      "filter": filterCSS
    }, ...filterProperties];
  }
  if (hasParseableColor2(s, theme4)) return colorResolver2("--un-drop-shadow-color", "drop-shadow")(match, ctx);
  v = h2.bracket.cssvar(s) ?? (s === "none" ? "" : void 0);
  if (v != null) return [{
    "--un-drop-shadow": v ? `drop-shadow(${v})` : v,
    "filter": filterCSS
  }, ...filterProperties];
}
var filters2 = [
  [
    /^(?:(backdrop-)|filter-)?blur(?:-(.+))?$/,
    toFilter2("blur", (s, theme4) => {
      var _a;
      return ((_a = theme4.blur) == null ? void 0 : _a[s || "DEFAULT"]) || h2.bracket.cssvar.px(s);
    }),
    { autocomplete: [
      "(backdrop|filter)-blur-$blur",
      "blur-$blur",
      "filter-blur"
    ] }
  ],
  [
    /^(?:(backdrop-)|filter-)?brightness-(.+)$/,
    toFilter2("brightness", (s) => h2.bracket.cssvar.percent(s)),
    { autocomplete: ["(backdrop|filter)-brightness-<percent>", "brightness-<percent>"] }
  ],
  [
    /^(?:(backdrop-)|filter-)?contrast-(.+)$/,
    toFilter2("contrast", (s) => h2.bracket.cssvar.percent(s)),
    { autocomplete: ["(backdrop|filter)-contrast-<percent>", "contrast-<percent>"] }
  ],
  [
    /^(?:filter-)?drop-shadow(?:-?(.+))?$/,
    dropShadowResolver2,
    { autocomplete: [
      "filter-drop",
      "filter-drop-shadow",
      "filter-drop-shadow-color",
      "drop-shadow",
      "drop-shadow-color",
      "filter-drop-shadow-$dropShadow",
      "drop-shadow-$dropShadow",
      "filter-drop-shadow-$colors",
      "drop-shadow-$colors",
      "filter-drop-shadow-color-$colors",
      "drop-shadow-color-$colors",
      "filter-drop-shadow-color-(op|opacity)",
      "drop-shadow-color-(op|opacity)",
      "filter-drop-shadow-color-(op|opacity)-<percent>",
      "drop-shadow(-color)?-(op|opacity)-<percent>"
    ] }
  ],
  [/^(?:filter-)?drop-shadow-color-(.+)$/, colorResolver2("--un-drop-shadow-color", "drop-shadow")],
  [/^(?:filter-)?drop-shadow(?:-color)?-op(?:acity)?-?(.+)$/, ([, opacity$1]) => ({ "--un-drop-shadow-opacity": h2.bracket.percent(opacity$1) })],
  [
    /^(?:(backdrop-)|filter-)?grayscale(?:-(.+))?$/,
    toFilter2("grayscale", percentWithDefault2),
    { autocomplete: [
      "(backdrop|filter)-grayscale",
      "(backdrop|filter)-grayscale-<percent>",
      "grayscale-<percent>"
    ] }
  ],
  [/^(?:(backdrop-)|filter-)?hue-rotate-(.+)$/, toFilter2("hue-rotate", (s) => h2.bracket.cssvar.degree(s))],
  [
    /^(?:(backdrop-)|filter-)?invert(?:-(.+))?$/,
    toFilter2("invert", percentWithDefault2),
    { autocomplete: [
      "(backdrop|filter)-invert",
      "(backdrop|filter)-invert-<percent>",
      "invert-<percent>"
    ] }
  ],
  [
    /^(backdrop-)op(?:acity)?-(.+)$/,
    toFilter2("opacity", (s) => h2.bracket.cssvar.percent(s)),
    { autocomplete: ["backdrop-(op|opacity)", "backdrop-(op|opacity)-<percent>"] }
  ],
  [
    /^(?:(backdrop-)|filter-)?saturate-(.+)$/,
    toFilter2("saturate", (s) => h2.bracket.cssvar.percent(s)),
    { autocomplete: [
      "(backdrop|filter)-saturate",
      "(backdrop|filter)-saturate-<percent>",
      "saturate-<percent>"
    ] }
  ],
  [
    /^(?:(backdrop-)|filter-)?sepia(?:-(.+))?$/,
    toFilter2("sepia", percentWithDefault2),
    { autocomplete: [
      "(backdrop|filter)-sepia",
      "(backdrop|filter)-sepia-<percent>",
      "sepia-<percent>"
    ] }
  ],
  ["filter", { filter: filterCSS }],
  ["backdrop-filter", {
    "-webkit-backdrop-filter": backdropCSS,
    "backdrop-filter": backdropCSS
  }],
  ["filter-none", { filter: "none" }],
  ["backdrop-filter-none", {
    "-webkit-backdrop-filter": "none",
    "backdrop-filter": "none"
  }],
  ...globalKeywords2.map((keyword2) => [`filter-${keyword2}`, { filter: keyword2 }]),
  ...globalKeywords2.map((keyword2) => [`backdrop-filter-${keyword2}`, {
    "-webkit-backdrop-filter": keyword2,
    "backdrop-filter": keyword2
  }])
];
var flex2 = [
  ["flex", { display: "flex" }],
  ["inline-flex", { display: "inline-flex" }],
  ["flex-inline", { display: "inline-flex" }],
  [/^flex-(.*)$/, ([, d]) => ({ flex: h2.bracket(d) != null ? h2.bracket(d).split(" ").map((e2) => h2.cssvar.fraction(e2) ?? e2).join(" ") : h2.cssvar.fraction(d) })],
  ["flex-1", { flex: "1 1 0%" }],
  ["flex-auto", { flex: "1 1 auto" }],
  ["flex-initial", { flex: "0 1 auto" }],
  ["flex-none", { flex: "none" }],
  [
    /^(?:flex-)?shrink(?:-(.*))?$/,
    ([, d = ""]) => ({ "flex-shrink": h2.bracket.cssvar.number(d) ?? 1 }),
    { autocomplete: ["flex-shrink-<num>", "shrink-<num>"] }
  ],
  [
    /^(?:flex-)?grow(?:-(.*))?$/,
    ([, d = ""]) => ({ "flex-grow": h2.bracket.cssvar.number(d) ?? 1 }),
    { autocomplete: ["flex-grow-<num>", "grow-<num>"] }
  ],
  [
    /^(?:flex-)?basis-(.+)$/,
    ([, d]) => {
      const v = numberResolver(d);
      if (v != null) {
        themeTracking(`spacing`);
        return { "flex-basis": `calc(var(--spacing) * ${v})` };
      }
      return { "flex-basis": h2.bracket.cssvar.auto.fraction.rem(d) };
    },
    { autocomplete: ["flex-basis-$spacing", "basis-$spacing"] }
  ],
  ["flex-row", { "flex-direction": "row" }],
  ["flex-row-reverse", { "flex-direction": "row-reverse" }],
  ["flex-col", { "flex-direction": "column" }],
  ["flex-col-reverse", { "flex-direction": "column-reverse" }],
  ["flex-wrap", { "flex-wrap": "wrap" }],
  ["flex-wrap-reverse", { "flex-wrap": "wrap-reverse" }],
  ["flex-nowrap", { "flex-wrap": "nowrap" }]
];
var directions2 = {
  "": [""],
  "x": ["column-"],
  "y": ["row-"],
  "col": ["column-"],
  "row": ["row-"]
};
var gaps2 = [
  [
    /^(?:flex-|grid-)?gap-?()(.+)$/,
    directionSize2("gap", directions2, (p, i) => `${i}${p}`),
    { autocomplete: ["gap-$spacing", "gap-<num>"] }
  ],
  [
    /^(?:flex-|grid-)?gap-([xy])-?(.+)$/,
    directionSize2("gap", directions2, (p, i) => `${i}${p}`),
    { autocomplete: ["gap-(x|y)-$spacing", "gap-(x|y)-<num>"] }
  ],
  [
    /^(?:flex-|grid-)?gap-(col|row)-?(.+)$/,
    directionSize2("gap", directions2, (p, i) => `${i}${p}`),
    { autocomplete: ["gap-(col|row)-$spacing", "gap-(col|row)-<num>"] }
  ]
];
function rowCol2(s) {
  return s.replace("col", "column");
}
function autoDirection2(prop) {
  switch (prop) {
    case "min":
      return "min-content";
    case "max":
      return "max-content";
    case "fr":
      return "minmax(0,1fr)";
  }
  return h2.bracket.cssvar.auto.rem(prop);
}
var grids2 = [
  ["grid", { display: "grid" }],
  ["inline-grid", { display: "inline-grid" }],
  [/^(?:grid-)?(row|col)-(.+)$/, ([, c, v]) => ({ [`grid-${rowCol2(c)}`]: h2.bracket.number.cssvar.auto(v) })],
  [
    /^(?:grid-)?(row|col)-span-(.+)$/,
    ([, c, s]) => {
      if (s === "full") return { [`grid-${rowCol2(c)}`]: "1/-1" };
      const v = h2.bracket.number.cssvar(s);
      if (v != null) return { [`grid-${rowCol2(c)}`]: `span ${v}/span ${v}` };
    },
    { autocomplete: "(grid-row|grid-col|row|col)-span-<num>" }
  ],
  [/^(?:grid-)?(row|col)-start-(.+)$/, ([, c, v]) => ({ [`grid-${rowCol2(c)}-start`]: h2.bracket.cssvar(v) ?? v })],
  [
    /^(?:grid-)?(row|col)-end-(.+)$/,
    ([, c, v]) => ({ [`grid-${rowCol2(c)}-end`]: h2.bracket.cssvar(v) ?? v }),
    { autocomplete: "(grid-row|grid-col|row|col)-(start|end)-<num>" }
  ],
  [
    /^(?:grid-)?auto-(rows|cols)-(.+)$/,
    ([, c, v]) => ({ [`grid-auto-${rowCol2(c)}`]: autoDirection2(v) }),
    { autocomplete: "(grid-auto|auto)-(rows|cols)-<num>" }
  ],
  [/^(?:grid-auto-flow|auto-flow|grid-flow)-(.+)$/, ([, v]) => ({ "grid-auto-flow": h2.bracket.cssvar(v) })],
  [
    /^(?:grid-auto-flow|auto-flow|grid-flow)-(row|col|dense|row-dense|col-dense)$/,
    ([, v]) => ({ "grid-auto-flow": rowCol2(v).replace("-", " ") }),
    { autocomplete: ["(grid-auto-flow|auto-flow|grid-flow)-(row|col|dense|row-dense|col-dense)"] }
  ],
  [/^(?:grid-)?(rows|cols)-(.+)$/, ([, c, v]) => ({ [`grid-template-${rowCol2(c)}`]: h2.bracket.cssvar(v) })],
  [/^(?:grid-)?(rows|cols)-minmax-([\w.-]+)$/, ([, c, d]) => ({ [`grid-template-${rowCol2(c)}`]: `repeat(auto-fill,minmax(${d},1fr))` })],
  [
    /^(?:grid-)?(rows|cols)-(\d+)$/,
    ([, c, d]) => ({ [`grid-template-${rowCol2(c)}`]: `repeat(${d},minmax(0,1fr))` }),
    { autocomplete: "(grid-rows|grid-cols|rows|cols)-<num>" }
  ],
  [/^grid-area(s)?-(.+)$/, ([, s, v]) => {
    if (s != null) return { "grid-template-areas": h2.cssvar(v) ?? v.split("-").map((s$1) => `"${h2.bracket(s$1)}"`).join(" ") };
    return { "grid-area": h2.bracket.cssvar(v) };
  }],
  ["grid-rows-none", { "grid-template-rows": "none" }],
  ["grid-cols-none", { "grid-template-columns": "none" }],
  ["grid-rows-subgrid", { "grid-template-rows": "subgrid" }],
  ["grid-cols-subgrid", { "grid-template-columns": "subgrid" }]
];
var overflowValues2 = [
  "auto",
  "hidden",
  "clip",
  "visible",
  "scroll",
  "overlay",
  ...globalKeywords2
];
var overflows2 = [[
  /^(?:overflow|of)-(.+)$/,
  ([, v]) => overflowValues2.includes(v) ? { overflow: v } : void 0,
  { autocomplete: [`(overflow|of)-(${overflowValues2.join("|")})`, `(overflow|of)-(x|y)-(${overflowValues2.join("|")})`] }
], [/^(?:overflow|of)-([xy])-(.+)$/, ([, d, v]) => overflowValues2.includes(v) ? { [`overflow-${d}`]: v } : void 0]];
var lineClamps2 = [[
  /^line-clamp-(\d+)$/,
  ([, v]) => ({
    "overflow": "hidden",
    "display": "-webkit-box",
    "-webkit-box-orient": "vertical",
    "-webkit-line-clamp": v
  }),
  { autocomplete: ["line-clamp", "line-clamp-(1|2|3|4|5|6|none)"] }
], ["line-clamp-none", {
  "overflow": "visible",
  "display": "block",
  "-webkit-box-orient": "horizontal",
  "-webkit-line-clamp": "unset"
}]];
var linearMap = {
  t: ["top"],
  b: ["bottom"],
  l: ["left"],
  r: ["right"],
  x: ["left", "right"],
  y: ["top", "bottom"]
};
var maskInitialValue = "linear-gradient(#fff, #fff)";
var baseMaskImage = {
  "mask-image": "var(--un-mask-linear), var(--un-mask-radial), var(--un-mask-conic)",
  "mask-composite": "intersect"
};
function handlePosition([, v = ""]) {
  if (v in cornerMap2) {
    const positions$1 = v.split("").flatMap((c) => linearMap[c]).join(" ");
    return { "mask-position": positions$1 };
  }
  const _v = h2.bracket.cssvar.global.position(v);
  if (_v !== null) return { "mask-position": _v };
}
function handleImage([_, gradient = "", direction, val], ctx) {
  const css = { ...baseMaskImage };
  const props = [];
  props.push(...[
    "linear",
    "radial",
    "conic"
  ].map((g) => defineProperty(`--un-mask-${g}`, { initialValue: maskInitialValue })));
  if (gradient in linearMap) {
    css["--un-mask-linear"] = "var(--un-mask-left), var(--un-mask-right), var(--un-mask-bottom), var(--un-mask-top)";
    for (const dir of linearMap[gradient]) {
      css[`--un-mask-${dir}`] = `linear-gradient(to ${dir}, var(--un-mask-${dir}-from-color) var(--un-mask-${dir}-from-position), var(--un-mask-${dir}-to-color) var(--un-mask-${dir}-to-position))`;
      if (numberResolver(val) != null) {
        themeTracking("spacing");
        css[`--un-mask-${dir}-${direction}-position`] = `calc(var(--spacing) * ${h2.bracket.cssvar.fraction.number(val)})`;
      } else css[`--un-mask-${dir}-${direction}-position`] = h2.bracket.cssvar.fraction.rem(val);
      if (hasParseableColor2(val, ctx.theme)) {
        const result = colorResolver2(`--un-mask-${dir}-${direction}-color`, hyphenate("colors"))([_, val], ctx);
        if (result) {
          const [c, ...p] = result;
          Object.assign(css, c);
          props.push(...p);
        }
      }
      props.push(...["from", "to"].flatMap((p) => [defineProperty(`--un-mask-${dir}-${p}-position`, {
        syntax: "<length-percentage>",
        initialValue: p === "from" ? "0%" : "100%"
      }), defineProperty(`--un-mask-${dir}-${p}-color`, {
        syntax: "<color>",
        initialValue: p === "from" ? "black" : "transparent"
      })]));
    }
    props.push(...[
      "top",
      "right",
      "bottom",
      "left"
    ].map((d) => defineProperty(`--un-mask-${d}`, { initialValue: maskInitialValue })));
  } else {
    if (direction == null) if (gradient === "radial") {
      css["--un-mask-radial"] = "radial-gradient(var(--un-mask-radial-stops, var(--un-mask-radial-size)))";
      css["--un-mask-radial-size"] = h2.bracket.cssvar.rem(val);
    } else {
      css[`--un-mask-${gradient}`] = `${gradient}-gradient(var(--un-mask-${gradient}-stops, var(--un-mask-${gradient}-position)))`;
      css[`--un-mask-${gradient}-position`] = numberResolver(val) ? `calc(1deg * ${h2.bracket.cssvar.number(val)})` : h2.bracket.cssvar.fraction(val);
    }
    else {
      const gradientStopsPrefixMap = {
        linear: "",
        radial: "var(--un-mask-radial-shape) var(--un-mask-radial-size) at ",
        conic: "from "
      };
      css[`--un-mask-${gradient}-stops`] = `${gradientStopsPrefixMap[gradient]}var(--un-mask-${gradient}-position), var(--un-mask-${gradient}-from-color) var(--un-mask-${gradient}-from-position), var(--un-mask-${gradient}-to-color) var(--un-mask-${gradient}-to-position)`;
      css[`--un-mask-${gradient}`] = `${gradient}-gradient(var(--un-mask-${gradient}-stops))`;
      if (hasParseableColor2(val, ctx.theme)) {
        const result = colorResolver2(`--un-mask-${gradient}-${direction}-color`, hyphenate("colors"))([_, val], ctx);
        if (result) {
          const [c, ...p] = result;
          Object.assign(css, c);
          props.push(...p);
        }
      } else if (numberResolver(val) != null) {
        themeTracking("spacing");
        css[`--un-mask-${gradient}-${direction}-position`] = `calc(var(--spacing) * ${h2.bracket.cssvar.fraction.number(val)})`;
      } else css[`--un-mask-${gradient}-${direction}-position`] = h2.bracket.cssvar.fraction.rem(val);
    }
    if (gradient === "radial") props.push(...[defineProperty("--un-mask-radial-shape", { initialValue: "ellipse" }), defineProperty("--un-mask-radial-size", { initialValue: "farthest-corner" })]);
    props.push(...["from", "to"].flatMap((p) => [
      defineProperty(`--un-mask-${gradient}-position`, { initialValue: gradient === "radial" ? "center" : "0deg" }),
      defineProperty(`--un-mask-${gradient}-${p}-position`, {
        syntax: "<length-percentage>",
        initialValue: p === "from" ? "0%" : "100%"
      }),
      defineProperty(`--un-mask-${gradient}-${p}-color`, {
        syntax: "<color>",
        initialValue: p === "from" ? "black" : "transparent"
      })
    ]));
  }
  return [css, ...props];
}
function handleSize$1([, v = ""]) {
  const _v = h2.bracket.cssvar.global.fraction.rem(v);
  if (_v !== null) return { "mask-size": _v };
}
var masks = [
  ["mask-clip-border", { "mask-clip": "border-box" }],
  ["mask-clip-padding", { "mask-clip": "padding-box" }],
  ["mask-clip-content", { "mask-clip": "content-box" }],
  ["mask-clip-fill", { "mask-clip": "fill-box" }],
  ["mask-clip-stroke", { "mask-clip": "stroke-box" }],
  ["mask-clip-view", { "mask-clip": "view-box" }],
  ["mask-no-clip", { "mask-clip": "no-clip" }],
  ["mask-add", { "mask-composite": "add" }],
  ["mask-subtract", { "mask-composite": "subtract" }],
  ["mask-intersect", { "mask-composite": "intersect" }],
  ["mask-exclude", { "mask-composite": "exclude" }],
  [/^mask-(.+)$/, ([, v]) => ({ "mask-image": h2.bracket.cssvar(v) })],
  [
    /^mask-(linear|radial|conic|[xytblr])-(from|to)()(?:-(.+))?$/,
    handleImage,
    { autocomplete: [
      "mask-(linear|radial|conic)-(from|to)-$colors",
      "mask-(linear|radial|conic)-(from|to)-<percentage>",
      "mask-(linear|radial|conic)-(from|to)",
      "mask-(linear|radial|conic)-<percent>",
      "mask-(x|y|t|b|l|r)-(from|to)-$colors",
      "mask-(x|y|t|b|l|r)-(from|to)-<percentage>",
      "mask-(x|y|t|b|l|r)-(from|to)",
      "mask-(x|y|t|b|l|r)-<percent>"
    ] }
  ],
  [/^mask-(linear|radial|conic)-(from|to)?-?(.*)$/, handleImage],
  [/^mask-([trblxy])-(from|to)-(.*)$/, handleImage],
  ["mask-none", { "mask-image": "none" }],
  ["mask-radial-circle", { "--un-mask-radial-shape": "circle" }],
  ["mask-radial-ellipse", { "--un-mask-radial-shape": "ellipse" }],
  ["mask-radial-closest-side", { "--un-mask-radial-size": "closest-side" }],
  ["mask-radial-closest-corner", { "--un-mask-radial-size": "closest-corner" }],
  ["mask-radial-farthest-side", { "--un-mask-radial-size": "farthest-side" }],
  ["mask-radial-farthest-corner", { "--un-mask-radial-size": "farthest-corner" }],
  [
    /^mask-radial-at-([-\w]{3,})$/,
    ([, s]) => ({ "--un-mask-radial-position": positionMap2[s] }),
    { autocomplete: [`mask-radial-at-(${Object.keys(positionMap2).filter((p) => p.length > 2).join("|")})`] }
  ],
  ["mask-alpha", { "mask-mode": "alpha" }],
  ["mask-luminance", { "mask-mode": "luminance" }],
  ["mask-match", { "mask-mode": "match-source" }],
  ["mask-origin-border", { "mask-origin": "border-box" }],
  ["mask-origin-padding", { "mask-origin": "padding-box" }],
  ["mask-origin-content", { "mask-origin": "content-box" }],
  ["mask-origin-fill", { "mask-origin": "fill-box" }],
  ["mask-origin-stroke", { "mask-origin": "stroke-box" }],
  ["mask-origin-view", { "mask-origin": "view-box" }],
  [/^mask-([rltb]{1,2})$/, handlePosition],
  [/^mask-([-\w]{3,})$/, ([, s]) => ({ "mask-position": positionMap2[s] })],
  [/^mask-(?:position-|pos-)(.+)$/, handlePosition],
  ["mask-repeat", { "mask-repeat": "repeat" }],
  ["mask-no-repeat", { "mask-repeat": "no-repeat" }],
  ["mask-repeat-x", { "mask-repeat": "repeat-x" }],
  ["mask-repeat-y", { "mask-repeat": "repeat-y" }],
  ["mask-repeat-space", { "mask-repeat": "space" }],
  ["mask-repeat-round", { "mask-repeat": "round" }],
  ["mask-auto", { "mask-size": "auto" }],
  ["mask-cover", { "mask-size": "cover" }],
  ["mask-contain", { "mask-size": "contain" }],
  [/^mask-size-(.+)$/, handleSize$1],
  ["mask-type-luminance", { "mask-type": "luminance" }],
  ["mask-type-alpha", { "mask-type": "alpha" }]
];
var placeholders2 = [[
  /^\$ placeholder-(.+)$/,
  colorResolver2("color", "placeholder"),
  { autocomplete: "placeholder-$colors" }
], [
  /^\$ placeholder-op(?:acity)?-?(.+)$/,
  ([, opacity$1]) => ({ "--un-placeholder-opacity": h2.bracket.percent(opacity$1) }),
  { autocomplete: ["placeholder-(op|opacity)", "placeholder-(op|opacity)-<percent>"] }
]];
var positions2 = [
  [
    /^(?:position-|pos-)?(relative|absolute|fixed|sticky)$/,
    ([, v]) => ({ position: v }),
    { autocomplete: [
      "(position|pos)-<position>",
      "(position|pos)-<globalKeyword>",
      "<position>"
    ] }
  ],
  [/^(?:position-|pos-)([-\w]+)$/, ([, v]) => globalKeywords2.includes(v) ? { position: v } : void 0],
  [/^(?:position-|pos-)?(static)$/, ([, v]) => ({ position: v })]
];
var justifies2 = [
  ["justify-start", { "justify-content": "flex-start" }],
  ["justify-end", { "justify-content": "flex-end" }],
  ["justify-center", { "justify-content": "center" }],
  ["justify-between", { "justify-content": "space-between" }],
  ["justify-around", { "justify-content": "space-around" }],
  ["justify-evenly", { "justify-content": "space-evenly" }],
  ["justify-stretch", { "justify-content": "stretch" }],
  ["justify-left", { "justify-content": "left" }],
  ["justify-right", { "justify-content": "right" }],
  ["justify-center-safe", { "justify-content": "safe center" }],
  ["justify-end-safe", { "justify-content": "safe flex-end" }],
  ["justify-normal", { "justify-content": "normal" }],
  ...makeGlobalStaticRules2("justify", "justify-content"),
  ["justify-items-start", { "justify-items": "start" }],
  ["justify-items-end", { "justify-items": "end" }],
  ["justify-items-center", { "justify-items": "center" }],
  ["justify-items-stretch", { "justify-items": "stretch" }],
  ["justify-items-center-safe", { "justify-items": "safe center" }],
  ["justify-items-end-safe", { "justify-items": "safe flex-end" }],
  ...makeGlobalStaticRules2("justify-items"),
  ["justify-self-auto", { "justify-self": "auto" }],
  ["justify-self-start", { "justify-self": "start" }],
  ["justify-self-end", { "justify-self": "end" }],
  ["justify-self-center", { "justify-self": "center" }],
  ["justify-self-stretch", { "justify-self": "stretch" }],
  ["justify-self-baseline", { "justify-self": "baseline" }],
  ["justify-self-center-safe", { "justify-self": "safe center" }],
  ["justify-self-end-safe", { "justify-self": "safe flex-end" }],
  ...makeGlobalStaticRules2("justify-self")
];
var orders2 = [
  [/^order-(.+)$/, ([, v]) => ({ order: h2.bracket.cssvar.number(v) })],
  ["order-first", { order: "calc(-infinity)" }],
  ["order-last", { order: "calc(infinity)" }],
  ["order-none", { order: "0" }]
];
var alignments2 = [
  ["content-center", { "align-content": "center" }],
  ["content-start", { "align-content": "flex-start" }],
  ["content-end", { "align-content": "flex-end" }],
  ["content-between", { "align-content": "space-between" }],
  ["content-around", { "align-content": "space-around" }],
  ["content-evenly", { "align-content": "space-evenly" }],
  ["content-baseline", { "align-content": "baseline" }],
  ["content-center-safe", { "align-content": "safe center" }],
  ["content-end-safe", { "align-content": "safe flex-end" }],
  ["content-stretch", { "align-content": "stretch" }],
  ["content-normal", { "align-content": "normal" }],
  ...makeGlobalStaticRules2("content", "align-content"),
  ["items-start", { "align-items": "flex-start" }],
  ["items-end", { "align-items": "flex-end" }],
  ["items-center", { "align-items": "center" }],
  ["items-baseline", { "align-items": "baseline" }],
  ["items-stretch", { "align-items": "stretch" }],
  ["items-baseline-last", { "align-items": "last baseline" }],
  ["items-center-safe", { "align-items": "safe center" }],
  ["items-end-safe", { "align-items": "safe flex-end" }],
  ...makeGlobalStaticRules2("items", "align-items"),
  ["self-auto", { "align-self": "auto" }],
  ["self-start", { "align-self": "flex-start" }],
  ["self-end", { "align-self": "flex-end" }],
  ["self-center", { "align-self": "center" }],
  ["self-stretch", { "align-self": "stretch" }],
  ["self-baseline", { "align-self": "baseline" }],
  ["self-baseline-last", { "align-self": "last baseline" }],
  ["self-center-safe", { "align-self": "safe center" }],
  ["self-end-safe", { "align-self": "safe flex-end" }],
  ...makeGlobalStaticRules2("self", "align-self")
];
var placements2 = [
  ["place-content-center", { "place-content": "center" }],
  ["place-content-start", { "place-content": "start" }],
  ["place-content-end", { "place-content": "end" }],
  ["place-content-between", { "place-content": "space-between" }],
  ["place-content-around", { "place-content": "space-around" }],
  ["place-content-evenly", { "place-content": "space-evenly" }],
  ["place-content-stretch", { "place-content": "stretch" }],
  ["place-content-baseline", { "place-content": "baseline" }],
  ["place-content-center-safe", { "place-content": "safe center" }],
  ["place-content-end-safe", { "place-content": "safe flex-end" }],
  ...makeGlobalStaticRules2("place-content"),
  ["place-items-start", { "place-items": "start" }],
  ["place-items-end", { "place-items": "end" }],
  ["place-items-center", { "place-items": "center" }],
  ["place-items-stretch", { "place-items": "stretch" }],
  ["place-items-baseline", { "place-items": "baseline" }],
  ["place-items-center-safe", { "place-items": "safe center" }],
  ["place-items-end-safe", { "place-items": "safe flex-end" }],
  ...makeGlobalStaticRules2("place-items"),
  ["place-self-auto", { "place-self": "auto" }],
  ["place-self-start", { "place-self": "start" }],
  ["place-self-end", { "place-self": "end" }],
  ["place-self-center", { "place-self": "center" }],
  ["place-self-stretch", { "place-self": "stretch" }],
  ["place-self-center-safe", { "place-self": "safe center" }],
  ["place-self-end-safe", { "place-self": "safe flex-end" }],
  ...makeGlobalStaticRules2("place-self")
];
var flexGridJustifiesAlignments2 = [
  ...justifies2,
  ...alignments2,
  ...placements2
].flatMap(([k, v]) => [[`flex-${k}`, v], [`grid-${k}`, v]]);
function handleInsetValue2(v) {
  const _v = numberResolver(v);
  if (_v != null) {
    themeTracking(`spacing`);
    return `calc(var(--spacing) * ${_v})`;
  } else return h2.bracket.cssvar.global.auto.fraction.rem(v);
}
function handleInsetValues2([, d, v]) {
  const r = handleInsetValue2(v);
  if (r != null && d in insetMap2) return insetMap2[d].map((i) => [i.slice(1), r]);
}
var insets2 = [
  [
    /^(?:position-|pos-)?inset-(.+)$/,
    ([, v]) => ({ inset: handleInsetValue2(v) }),
    { autocomplete: [
      "(position|pos)-inset-<directions>-$spacing",
      "(position|pos)-inset-(block|inline)-$spacing",
      "(position|pos)-inset-(bs|be|is|ie)-$spacing",
      "(position|pos)-(top|left|right|bottom)-$spacing"
    ] }
  ],
  [/^(?:position-|pos-)?(start|end)-(.+)$/, handleInsetValues2],
  [/^(?:position-|pos-)?inset-([xy])-(.+)$/, handleInsetValues2],
  [/^(?:position-|pos-)?inset-([rltbse])-(.+)$/, handleInsetValues2],
  [/^(?:position-|pos-)?inset-(block|inline)-(.+)$/, handleInsetValues2],
  [/^(?:position-|pos-)?inset-([bi][se])-(.+)$/, handleInsetValues2],
  [/^(?:position-|pos-)?(top|left|right|bottom)-(.+)$/, ([, d, v]) => ({ [d]: handleInsetValue2(v) })]
];
var floats2 = [
  ["float-left", { float: "left" }],
  ["float-right", { float: "right" }],
  ["float-start", { float: "inline-start" }],
  ["float-end", { float: "inline-end" }],
  ["float-none", { float: "none" }],
  ...makeGlobalStaticRules2("float"),
  ["clear-left", { clear: "left" }],
  ["clear-right", { clear: "right" }],
  ["clear-both", { clear: "both" }],
  ["clear-start", { clear: "inline-start" }],
  ["clear-end", { clear: "inline-end" }],
  ["clear-none", { clear: "none" }],
  ...makeGlobalStaticRules2("clear")
];
var zIndexes2 = [[/^(?:position-|pos-)?z([\d.]+)$/, ([, v]) => ({ "z-index": h2.number(v) })], [
  /^(?:position-|pos-)?z-(.+)$/,
  ([, v]) => ({ "z-index": h2.bracket.cssvar.global.auto.number(v) }),
  { autocomplete: "z-<num>" }
]];
var boxSizing2 = [
  ["box-border", { "box-sizing": "border-box" }],
  ["box-content", { "box-sizing": "content-box" }],
  ...makeGlobalStaticRules2("box", "box-sizing")
];
var questionMark2 = [[/^(where|\?)$/, (_, { constructCSS, generator }) => {
  if (generator.userConfig.envMode === "dev") return `@keyframes __un_qm{0%{box-shadow:inset 4px 4px #ff1e90, inset -4px -4px #ff1e90}100%{box-shadow:inset 8px 8px #3399ff, inset -8px -8px #3399ff}} ${constructCSS({ animation: "__un_qm 0.5s ease-in-out alternate infinite" })}`;
}]];
var shadowProperties = {
  shadow: defineProperty("--un-shadow", { initialValue: "0 0 #0000" }),
  shadowColor: defineProperty("--un-shadow-color"),
  insetShadow: defineProperty("--un-inset-shadow", { initialValue: "0 0 #0000" }),
  insetShadowColor: defineProperty("--un-inset-shadow-color"),
  ringColor: defineProperty("--un-ring-color"),
  ringShadow: defineProperty("--un-ring-shadow", { initialValue: "0 0 #0000" }),
  insetRingColor: defineProperty("--un-inset-ring-color"),
  insetRingShadow: defineProperty("--un-inset-ring-shadow", { initialValue: "0 0 #0000" }),
  ringInset: defineProperty("--un-ring-inset"),
  ringOffsetWidth: defineProperty("--un-ring-offset-width", {
    syntax: "<length>",
    initialValue: "0px"
  }),
  ringOffsetColor: defineProperty("--un-ring-offset-color"),
  ringOffsetShadow: defineProperty("--un-ring-offset-shadow", { initialValue: "0 0 #0000" })
};
var boxShadows2 = [
  [
    /^shadow(?:-?(.+))?$/,
    handleShadow("shadow"),
    { autocomplete: ["shadow-$colors", "shadow-$shadow"] }
  ],
  [
    /^shadow-op(?:acity)?-?(.+)$/,
    ([, opacity$1]) => ({ "--un-shadow-opacity": h2.bracket.percent.cssvar(opacity$1) }),
    { autocomplete: "shadow-(op|opacity)-<percent>" }
  ],
  [
    /^inset-shadow(?:-(.+))?$/,
    handleShadow("insetShadow"),
    { autocomplete: ["inset-shadow-$colors", "inset-shadow-$insetShadow"] }
  ],
  [
    /^inset-shadow-op(?:acity)?-?(.+)$/,
    ([, opacity$1]) => ({ "--un-inset-shadow-opacity": h2.bracket.percent.cssvar(opacity$1) }),
    { autocomplete: "shadow-(op|opacity)-<percent>" }
  ]
];
function handleShadow(themeKey) {
  return (match, ctx) => {
    var _a;
    const [, d] = match;
    const { theme: theme4 } = ctx;
    let res = [];
    if (d) {
      res = getStringComponents(d, "/", 2) ?? [];
      if (d.startsWith("/")) res = ["", d.slice(1)];
    }
    const v = (_a = theme4[themeKey]) == null ? void 0 : _a[res[0] || "DEFAULT"];
    const c = d ? h2.bracket.cssvar(d) : void 0;
    const shadowVar = hyphenate(themeKey);
    if ((v != null || c != null) && !hasParseableColor2(c, theme4)) {
      const alpha = res[1] ? h2.bracket.percent.cssvar(res[1]) : void 0;
      return [{
        [`--un-${shadowVar}-opacity`]: alpha,
        [`--un-${shadowVar}`]: colorableShadows2(v || c, `--un-${shadowVar}-color`, alpha).join(","),
        "box-shadow": "var(--un-inset-shadow), var(--un-inset-ring-shadow), var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow)"
      }, ...Object.values(shadowProperties)];
    }
    return colorResolver2(`--un-${shadowVar}-color`, shadowVar)(match, ctx);
  };
}
var rings2 = [
  [/^ring(?:-(.+))?$/, ([, d]) => {
    const v = h2.bracket.px(d || "1");
    if (v != null) return [{
      "--un-ring-shadow": `var(--un-ring-inset,) 0 0 0 calc(${v} + var(--un-ring-offset-width)) var(--un-ring-color, currentColor)`,
      "box-shadow": "var(--un-inset-shadow), var(--un-inset-ring-shadow), var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow)"
    }, ...Object.values(shadowProperties)];
  }],
  [
    /^ring-(.+)$/,
    colorResolver2(`--un-ring-color`, "ring"),
    { autocomplete: "ring-$colors" }
  ],
  [
    /^ring-op(?:acity)?-?(.+)$/,
    ([, opacity$1]) => ({ "--un-ring-opacity": h2.bracket.percent.cssvar(opacity$1) }),
    { autocomplete: "ring-(op|opacity)-<percent>" }
  ],
  [/^inset-ring(?:-(.+))?$/, ([, d]) => {
    const v = h2.bracket.px(d || "1");
    if (v != null) return [{
      "--un-inset-ring-shadow": `inset 0 0 0 ${v} var(--un-inset-ring-color, currentColor)`,
      "box-shadow": "var(--un-inset-shadow), var(--un-inset-ring-shadow), var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow)"
    }, ...Object.values(shadowProperties)];
  }],
  [
    /^inset-ring-(.+)$/,
    colorResolver2(`--un-inset-ring-color`, "inset-ring"),
    { autocomplete: "inset-ring-$colors" }
  ],
  [
    /^inset-ring-op(?:acity)?-?(.+)$/,
    ([, opacity$1]) => ({ "--un-inset-ring-opacity": h2.bracket.percent.cssvar(opacity$1) }),
    { autocomplete: "inset-ring-(op|opacity)-<percent>" }
  ],
  [
    /^ring-offset(?:-(?:width-|size-)?(.+))?$/,
    ([, d]) => {
      const v = h2.bracket.cssvar.px(d || "1");
      if (v != null) return {
        "--un-ring-offset-width": v,
        "--un-ring-offset-shadow": "var(--un-ring-inset,) 0 0 0 var(--un-ring-offset-width) var(--un-ring-offset-color)"
      };
    },
    { autocomplete: "ring-offset-$colors" }
  ],
  [
    /^ring-offset-(.+)$/,
    colorResolver2(`--un-ring-offset-color`, "ring-offset"),
    { autocomplete: "ring-offset-$colors" }
  ],
  [
    /^ring-offset-op(?:acity)?-?(.+)$/,
    ([, opacity$1]) => ({ "--un-ring-offset-opacity": h2.bracket.percent.cssvar(opacity$1) }),
    { autocomplete: "ring-offset-(op|opacity)-<percent>" }
  ],
  ["ring-inset", { "--un-ring-inset": "inset" }]
];
var scrolls2 = [
  ...[
    "x",
    "y",
    "both"
  ].map((d) => [`snap-${d}`, [{ "scroll-snap-type": `${d} var(--un-scroll-snap-strictness)` }, defineProperty("--un-scroll-snap-strictness", { initialValue: "proximity" })]]),
  ...["mandatory", "proximity"].map((d) => [`snap-${d}`, [{ "--un-scroll-snap-strictness": d }, defineProperty("--un-scroll-snap-strictness", { initialValue: "proximity" })]]),
  ["snap-none", { "scroll-snap-type": "none" }],
  ["snap-start", { "scroll-snap-align": "start" }],
  ["snap-end", { "scroll-snap-align": "end" }],
  ["snap-center", { "scroll-snap-align": "center" }],
  ["snap-align-none", { "scroll-snap-align": "none" }],
  ["snap-normal", { "scroll-snap-stop": "normal" }],
  ["snap-always", { "scroll-snap-stop": "always" }],
  [
    /^scroll-ma?()-?(.+)$/,
    directionSize2("scroll-margin"),
    { autocomplete: [
      "scroll-(m|p|ma|pa|block|inline)",
      "scroll-(m|p|ma|pa|block|inline)-$spacing",
      "scroll-(m|p|ma|pa|block|inline)-(x|y|r|l|t|b|bs|be|is|ie)",
      "scroll-(m|p|ma|pa|block|inline)-(x|y|r|l|t|b|bs|be|is|ie)-$spacing"
    ] }
  ],
  [/^scroll-m-?([xy])-?(.+)$/, directionSize2("scroll-margin")],
  [/^scroll-m-?([rltb])-?(.+)$/, directionSize2("scroll-margin")],
  [/^scroll-m-(block|inline)-(.+)$/, directionSize2("scroll-margin")],
  [/^scroll-m-?([bi][se])-?(.+)$/, directionSize2("scroll-margin")],
  [/^scroll-pa?()-?(.+)$/, directionSize2("scroll-padding")],
  [/^scroll-p-?([xy])-?(.+)$/, directionSize2("scroll-padding")],
  [/^scroll-p-?([rltb])-?(.+)$/, directionSize2("scroll-padding")],
  [/^scroll-p-(block|inline)-(.+)$/, directionSize2("scroll-padding")],
  [/^scroll-p-?([bi][se])-?(.+)$/, directionSize2("scroll-padding")]
];
var sizeMapping2 = {
  h: "height",
  w: "width",
  inline: "inline-size",
  block: "block-size"
};
function getPropName2(minmax, hw) {
  return `${minmax || ""}${sizeMapping2[hw]}`;
}
function getSizeValue2(theme4, hw, prop) {
  var _a;
  let v;
  for (const key of ["container", "spacing"]) if ((_a = theme4[key]) == null ? void 0 : _a[prop]) {
    themeTracking(key, prop);
    v = generateThemeVariable(key, prop);
    break;
  }
  if (!v) switch (prop) {
    case "fit":
    case "max":
    case "min":
      v = `${prop}-content`;
      break;
    case "stretch":
      v = "stretch";
      break;
    case "screen":
      v = hw === "w" ? "100vw" : "100vh";
      break;
  }
  if (!v && h2.number(prop) != null) {
    themeTracking(`spacing`);
    v = `calc(var(--spacing) * ${h2.number(prop)})`;
  }
  return v ?? h2.bracket.cssvar.global.auto.none.fraction.rem(prop);
}
var sizes2 = [
  [/^size-(min-|max-)?(.+)$/, ([, m, s], { theme: theme4 }) => ({
    [getPropName2(m, "w")]: getSizeValue2(theme4, "w", s),
    [getPropName2(m, "h")]: getSizeValue2(theme4, "h", s)
  })],
  [/^(?:size-)?(min-|max-)?([wh])-?(.+)$/, ([, m, w, s], { theme: theme4 }) => ({ [getPropName2(m, w)]: getSizeValue2(theme4, w, s) })],
  [
    /^(?:size-)?(min-|max-)?(block|inline)-(.+)$/,
    ([, m, w, s], { theme: theme4 }) => ({ [getPropName2(m, w)]: getSizeValue2(theme4, w, s) }),
    { autocomplete: [
      "(w|h)-<num>",
      "(w|h)-(full|screen|fit|max|min)",
      "(max|min)-(w|h)-<num>",
      "(max|min)-(w|h)-(full|screen|fit|max|min)",
      "(block|inline)-<num>",
      "(block|inline)-(full|screen|fit|max|min)",
      "(max|min)-(w|h|block|inline)",
      "(max|min)-(w|h|block|inline)-<num>",
      "(max|min)-(w|h|block|inline)-(full|screen|fit|max|min)"
    ] }
  ],
  [/^(?:size-)?(min-|max-)?(h)-screen-(.+)$/, ([, m, h$1, p], context) => ({ [getPropName2(m, h$1)]: handleBreakpoint2(context, p, "verticalBreakpoint") })],
  [
    /^(?:size-)?(min-|max-)?(w)-screen-(.+)$/,
    ([, m, w, p], context) => ({ [getPropName2(m, w)]: handleBreakpoint2(context, p) }),
    { autocomplete: [
      "(w|h)-screen",
      "(min|max)-(w|h)-screen",
      "h-screen-$breakpoint",
      "(min|max)-h-screen-$breakpoint",
      "w-screen-$breakpoint",
      "(min|max)-w-screen-$breakpoint"
    ] }
  ]
];
function handleBreakpoint2(context, point, key = "breakpoint") {
  var _a;
  const bp = resolveBreakpoints2(context, key);
  if (bp) return (_a = bp.find((i) => i.point === point)) == null ? void 0 : _a.size;
}
function getAspectRatio2(prop) {
  if (/^\d+\/\d+$/.test(prop)) return prop;
  switch (prop) {
    case "square":
      return "1/1";
    case "video":
      return "16/9";
  }
  return h2.bracket.cssvar.global.auto.number(prop);
}
var aspectRatio2 = [[
  /^(?:size-)?aspect-(?:ratio-)?(.+)$/,
  ([, d]) => ({ "aspect-ratio": getAspectRatio2(d) }),
  { autocomplete: ["aspect-(square|video|ratio)", "aspect-ratio-(square|video)"] }
]];
var cursorValues2 = [
  "auto",
  "default",
  "none",
  "context-menu",
  "help",
  "pointer",
  "progress",
  "wait",
  "cell",
  "crosshair",
  "text",
  "vertical-text",
  "alias",
  "copy",
  "move",
  "no-drop",
  "not-allowed",
  "grab",
  "grabbing",
  "all-scroll",
  "col-resize",
  "row-resize",
  "n-resize",
  "e-resize",
  "s-resize",
  "w-resize",
  "ne-resize",
  "nw-resize",
  "se-resize",
  "sw-resize",
  "ew-resize",
  "ns-resize",
  "nesw-resize",
  "nwse-resize",
  "zoom-in",
  "zoom-out"
];
var containValues2 = [
  "size",
  "layout",
  "paint",
  "style"
];
var displays2 = [
  ["inline", { display: "inline" }],
  ["block", { display: "block" }],
  ["inline-block", { display: "inline-block" }],
  ["contents", { display: "contents" }],
  ["flow-root", { display: "flow-root" }],
  ["list-item", { display: "list-item" }],
  ["hidden", { display: "none" }],
  [/^display-(.+)$/, ([, c]) => ({ display: h2.bracket.cssvar.global(c) })]
];
var appearances2 = [
  ["visible", { visibility: "visible" }],
  ["invisible", { visibility: "hidden" }],
  ["collapse", { visibility: "collapse" }],
  ["backface-visible", { "backface-visibility": "visible" }],
  ["backface-hidden", { "backface-visibility": "hidden" }],
  ...makeGlobalStaticRules2("backface", "backface-visibility")
];
var cursors2 = [[/^cursor-(.+)$/, ([, c]) => ({ cursor: h2.bracket.cssvar.global(c) })], ...cursorValues2.map((v) => [`cursor-${v}`, { cursor: v }])];
var contains2 = [
  [/^contain-(.*)$/, ([, d]) => {
    if (h2.bracket(d) != null) return { contain: h2.bracket(d).split(" ").map((e2) => h2.cssvar.fraction(e2) ?? e2).join(" ") };
    return containValues2.includes(d) ? [{
      "--un-contain-size": d,
      "contain": containValues2.map((i) => `var(--un-contain-${i})`).join(" ")
    }, ...containValues2.map((i) => defineProperty(`--un-contain-${i}`))] : void 0;
  }],
  ["contain-strict", { contain: "strict" }],
  ["contain-content", { contain: "content" }],
  ["contain-none", { contain: "none" }]
];
var pointerEvents2 = [
  ["pointer-events-auto", { "pointer-events": "auto" }],
  ["pointer-events-none", { "pointer-events": "none" }],
  ...makeGlobalStaticRules2("pointer-events")
];
var resizes2 = [
  ["resize-x", { resize: "horizontal" }],
  ["resize-y", { resize: "vertical" }],
  ["resize", { resize: "both" }],
  ["resize-none", { resize: "none" }],
  ...makeGlobalStaticRules2("resize")
];
var userSelects2 = [
  ["select-auto", {
    "-webkit-user-select": "auto",
    "user-select": "auto"
  }],
  ["select-all", {
    "-webkit-user-select": "all",
    "user-select": "all"
  }],
  ["select-text", {
    "-webkit-user-select": "text",
    "user-select": "text"
  }],
  ["select-none", {
    "-webkit-user-select": "none",
    "user-select": "none"
  }],
  ...makeGlobalStaticRules2("select", "user-select")
];
var whitespaces2 = [[
  /^(?:whitespace-|ws-)([-\w]+)$/,
  ([, v]) => [
    "normal",
    "nowrap",
    "pre",
    "pre-line",
    "pre-wrap",
    "break-spaces",
    ...globalKeywords2
  ].includes(v) ? { "white-space": v } : void 0,
  { autocomplete: "(whitespace|ws)-(normal|nowrap|pre|pre-line|pre-wrap|break-spaces)" }
]];
var contentVisibility2 = [
  [
    /^intrinsic(?:-(block|inline|w|h))?(?:-size)?-(.+)$/,
    ([, d, s]) => {
      return { [`contain-intrinsic-${{
        block: "block-size",
        inline: "inline-size",
        w: "width",
        h: "height"
      }[d] ?? "size"}`]: h2.bracket.cssvar.global.fraction.rem(s) };
    },
    { autocomplete: [
      "intrinsic-size-<num>",
      "intrinsic-<num>",
      "intrinsic-(block|inline|w|h)-<num>"
    ] }
  ],
  ["content-visibility-visible", { "content-visibility": "visible" }],
  ["content-visibility-hidden", { "content-visibility": "hidden" }],
  ["content-visibility-auto", { "content-visibility": "auto" }],
  ...makeGlobalStaticRules2("content-visibility")
];
var contents2 = [
  [/^content-(.+)$/, ([, v]) => {
    if (h2.bracket.cssvar(v) != null) return [{
      "--un-content": h2.bracket.cssvar(v),
      "content": "var(--un-content)"
    }, defineProperty("--un-content", { initialValue: '""' })];
  }],
  ["content-empty", { content: '""' }],
  ["content-none", { content: "none" }]
];
var breaks2 = [
  ["break-normal", {
    "overflow-wrap": "normal",
    "word-break": "normal"
  }],
  ["break-words", { "overflow-wrap": "break-word" }],
  ["break-all", { "word-break": "break-all" }],
  ["break-keep", { "word-break": "keep-all" }],
  ["break-anywhere", { "overflow-wrap": "anywhere" }],
  ["wrap-break-word", { "overflow-wrap": "break-word" }],
  ["wrap-anywhere", { "overflow-wrap": "anywhere" }],
  ["wrap-normal", { "overflow-wrap": "normal" }]
];
var textWraps2 = [
  ["text-wrap", { "text-wrap": "wrap" }],
  ["text-nowrap", { "text-wrap": "nowrap" }],
  ["text-balance", { "text-wrap": "balance" }],
  ["text-pretty", { "text-wrap": "pretty" }]
];
var textOverflows2 = [
  ["truncate", {
    "overflow": "hidden",
    "text-overflow": "ellipsis",
    "white-space": "nowrap"
  }],
  ["text-truncate", {
    "overflow": "hidden",
    "text-overflow": "ellipsis",
    "white-space": "nowrap"
  }],
  ["text-ellipsis", { "text-overflow": "ellipsis" }],
  ["text-clip", { "text-overflow": "clip" }]
];
var textTransforms3 = [
  ["case-upper", { "text-transform": "uppercase" }],
  ["case-lower", { "text-transform": "lowercase" }],
  ["case-capital", { "text-transform": "capitalize" }],
  ["case-normal", { "text-transform": "none" }],
  ["uppercase", { "text-transform": "uppercase" }],
  ["lowercase", { "text-transform": "lowercase" }],
  ["capitalize", { "text-transform": "capitalize" }],
  ["normal-case", { "text-transform": "none" }],
  ...makeGlobalStaticRules2("case", "text-transform")
];
var fontStyles2 = [
  ["italic", { "font-style": "italic" }],
  ["not-italic", { "font-style": "normal" }],
  ["font-italic", { "font-style": "italic" }],
  ["font-not-italic", { "font-style": "normal" }],
  ["oblique", { "font-style": "oblique" }],
  ["not-oblique", { "font-style": "normal" }],
  ["font-oblique", { "font-style": "oblique" }],
  ["font-not-oblique", { "font-style": "normal" }]
];
var fontSmoothings2 = [["antialiased", {
  "-webkit-font-smoothing": "antialiased",
  "-moz-osx-font-smoothing": "grayscale"
}], ["subpixel-antialiased", {
  "-webkit-font-smoothing": "auto",
  "-moz-osx-font-smoothing": "auto"
}]];
var hyphens2 = [...[
  "manual",
  "auto",
  "none",
  ...globalKeywords2
].map((keyword2) => [`hyphens-${keyword2}`, {
  "-webkit-hyphens": keyword2,
  "-ms-hyphens": keyword2,
  "hyphens": keyword2
}])];
var writingModes2 = [
  ["write-vertical-right", { "writing-mode": "vertical-rl" }],
  ["write-vertical-left", { "writing-mode": "vertical-lr" }],
  ["write-normal", { "writing-mode": "horizontal-tb" }],
  ...makeGlobalStaticRules2("write", "writing-mode")
];
var writingOrientations2 = [
  ["write-orient-mixed", { "text-orientation": "mixed" }],
  ["write-orient-sideways", { "text-orientation": "sideways" }],
  ["write-orient-upright", { "text-orientation": "upright" }],
  ...makeGlobalStaticRules2("write-orient", "text-orientation")
];
var screenReadersAccess2 = [["sr-only", {
  "position": "absolute",
  "width": "1px",
  "height": "1px",
  "padding": "0",
  "margin": "-1px",
  "overflow": "hidden",
  "clip": "rect(0,0,0,0)",
  "white-space": "nowrap",
  "border-width": 0
}], ["not-sr-only", {
  "position": "static",
  "width": "auto",
  "height": "auto",
  "padding": "0",
  "margin": "0",
  "overflow": "visible",
  "clip": "auto",
  "white-space": "normal"
}]];
var isolations2 = [
  ["isolate", { isolation: "isolate" }],
  ["isolate-auto", { isolation: "auto" }],
  ["isolation-auto", { isolation: "auto" }]
];
var objectPositions2 = [
  ["object-cover", { "object-fit": "cover" }],
  ["object-contain", { "object-fit": "contain" }],
  ["object-fill", { "object-fit": "fill" }],
  ["object-scale-down", { "object-fit": "scale-down" }],
  ["object-none", { "object-fit": "none" }],
  [
    /^object-(.+)$/,
    ([, d]) => {
      if (positionMap2[d]) return { "object-position": positionMap2[d] };
      if (h2.bracketOfPosition(d) != null) return { "object-position": h2.bracketOfPosition(d).split(" ").map((e2) => h2.position.fraction.auto.px.cssvar(e2) ?? e2).join(" ") };
    },
    { autocomplete: `object-(${Object.keys(positionMap2).join("|")})` }
  ]
];
var backgroundBlendModes2 = [
  ["bg-blend-multiply", { "background-blend-mode": "multiply" }],
  ["bg-blend-screen", { "background-blend-mode": "screen" }],
  ["bg-blend-overlay", { "background-blend-mode": "overlay" }],
  ["bg-blend-darken", { "background-blend-mode": "darken" }],
  ["bg-blend-lighten", { "background-blend-mode": "lighten" }],
  ["bg-blend-color-dodge", { "background-blend-mode": "color-dodge" }],
  ["bg-blend-color-burn", { "background-blend-mode": "color-burn" }],
  ["bg-blend-hard-light", { "background-blend-mode": "hard-light" }],
  ["bg-blend-soft-light", { "background-blend-mode": "soft-light" }],
  ["bg-blend-difference", { "background-blend-mode": "difference" }],
  ["bg-blend-exclusion", { "background-blend-mode": "exclusion" }],
  ["bg-blend-hue", { "background-blend-mode": "hue" }],
  ["bg-blend-saturation", { "background-blend-mode": "saturation" }],
  ["bg-blend-color", { "background-blend-mode": "color" }],
  ["bg-blend-luminosity", { "background-blend-mode": "luminosity" }],
  ["bg-blend-normal", { "background-blend-mode": "normal" }],
  ...makeGlobalStaticRules2("bg-blend", "background-blend")
];
var mixBlendModes2 = [
  ["mix-blend-multiply", { "mix-blend-mode": "multiply" }],
  ["mix-blend-screen", { "mix-blend-mode": "screen" }],
  ["mix-blend-overlay", { "mix-blend-mode": "overlay" }],
  ["mix-blend-darken", { "mix-blend-mode": "darken" }],
  ["mix-blend-lighten", { "mix-blend-mode": "lighten" }],
  ["mix-blend-color-dodge", { "mix-blend-mode": "color-dodge" }],
  ["mix-blend-color-burn", { "mix-blend-mode": "color-burn" }],
  ["mix-blend-hard-light", { "mix-blend-mode": "hard-light" }],
  ["mix-blend-soft-light", { "mix-blend-mode": "soft-light" }],
  ["mix-blend-difference", { "mix-blend-mode": "difference" }],
  ["mix-blend-exclusion", { "mix-blend-mode": "exclusion" }],
  ["mix-blend-hue", { "mix-blend-mode": "hue" }],
  ["mix-blend-saturation", { "mix-blend-mode": "saturation" }],
  ["mix-blend-color", { "mix-blend-mode": "color" }],
  ["mix-blend-luminosity", { "mix-blend-mode": "luminosity" }],
  ["mix-blend-plus-lighter", { "mix-blend-mode": "plus-lighter" }],
  ["mix-blend-normal", { "mix-blend-mode": "normal" }],
  ...makeGlobalStaticRules2("mix-blend")
];
var dynamicViewportHeight2 = [
  ["min-h-dvh", { "min-height": "100dvh" }],
  ["min-h-svh", { "min-height": "100svh" }],
  ["min-h-lvh", { "min-height": "100lvh" }],
  ["h-dvh", { height: "100dvh" }],
  ["h-svh", { height: "100svh" }],
  ["h-lvh", { height: "100lvh" }],
  ["max-h-dvh", { "max-height": "100dvh" }],
  ["max-h-svh", { "max-height": "100svh" }],
  ["max-h-lvh", { "max-height": "100lvh" }]
];
var accessibility = [["forced-color-adjust-auto", { "forced-color-adjust": "auto" }], ["forced-color-adjust-none", { "forced-color-adjust": "none" }]];
var fieldSizing2 = [["field-sizing-fixed", { "field-sizing": "fixed" }], ["field-sizing-content", { "field-sizing": "content" }]];
var svgUtilities2 = [
  [
    /^fill-(.+)$/,
    colorResolver2("fill", "fill"),
    { autocomplete: "fill-$colors" }
  ],
  [
    /^fill-op(?:acity)?-?(.+)$/,
    ([, opacity$1]) => ({ "--un-fill-opacity": h2.bracket.percent.cssvar(opacity$1) }),
    { autocomplete: "fill-(op|opacity)-<percent>" }
  ],
  ["fill-none", { fill: "none" }],
  [/^stroke-(?:width-|size-)?(.+)$/, handleWidth2],
  [
    /^stroke-dash-(.+)$/,
    ([, s]) => ({ "stroke-dasharray": h2.bracket.cssvar.number(s) }),
    { autocomplete: "stroke-dash-<num>" }
  ],
  [/^stroke-offset-(.+)$/, ([, s]) => ({ "stroke-dashoffset": h2.bracket.cssvar.px.numberWithUnit(s) })],
  [
    /^stroke-(.+)$/,
    handleColorOrWidth2,
    { autocomplete: "stroke-$colors" }
  ],
  [
    /^stroke-op(?:acity)?-?(.+)$/,
    ([, opacity$1]) => ({ "--un-stroke-opacity": h2.bracket.percent.cssvar(opacity$1) }),
    { autocomplete: "stroke-(op|opacity)-<percent>" }
  ],
  ["stroke-cap-square", { "stroke-linecap": "square" }],
  ["stroke-cap-round", { "stroke-linecap": "round" }],
  ["stroke-cap-auto", { "stroke-linecap": "butt" }],
  ["stroke-join-arcs", { "stroke-linejoin": "arcs" }],
  ["stroke-join-bevel", { "stroke-linejoin": "bevel" }],
  ["stroke-join-clip", { "stroke-linejoin": "miter-clip" }],
  ["stroke-join-round", { "stroke-linejoin": "round" }],
  ["stroke-join-auto", { "stroke-linejoin": "miter" }],
  ["stroke-none", { stroke: "none" }]
];
function handleWidth2([, b]) {
  return { "stroke-width": h2.bracket.cssvar.fraction.px.number(b) };
}
function handleColorOrWidth2(match, ctx) {
  if (isCSSMathFn2(h2.bracket(match[1]))) return handleWidth2(match);
  return colorResolver2("stroke", "stroke")(match, ctx);
}
var tables2 = [
  ["inline-table", { display: "inline-table" }],
  ["table", { display: "table" }],
  ["table-caption", { display: "table-caption" }],
  ["table-cell", { display: "table-cell" }],
  ["table-column", { display: "table-column" }],
  ["table-column-group", { display: "table-column-group" }],
  ["table-footer-group", { display: "table-footer-group" }],
  ["table-header-group", { display: "table-header-group" }],
  ["table-row", { display: "table-row" }],
  ["table-row-group", { display: "table-row-group" }],
  ["border-collapse", { "border-collapse": "collapse" }],
  ["border-separate", { "border-collapse": "separate" }],
  [
    /^border-spacing-(.+)$/,
    function* ([, s], { theme: theme4 }) {
      const v = resolveValue(s, theme4);
      if (v != null) {
        yield {
          "--un-border-spacing-x": v,
          "--un-border-spacing-y": v,
          "border-spacing": "var(--un-border-spacing-x) var(--un-border-spacing-y)"
        };
        for (const d of ["x", "y"]) yield defineProperty(`--un-border-spacing-${d}`, {
          syntax: "<length>",
          initialValue: "0"
        });
      }
    },
    { autocomplete: ["border-spacing", "border-spacing-$spacing"] }
  ],
  [
    /^border-spacing-([xy])-(.+)$/,
    function* ([, d, s], { theme: theme4 }) {
      const v = resolveValue(s, theme4);
      if (v != null) {
        yield {
          [`--un-border-spacing-${d}`]: v,
          "border-spacing": "var(--un-border-spacing-x) var(--un-border-spacing-y)"
        };
        for (const d$1 of ["x", "y"]) yield defineProperty(`--un-border-spacing-${d$1}`, {
          syntax: "<length>",
          initialValue: "0"
        });
      }
    },
    { autocomplete: ["border-spacing-(x|y)", "border-spacing-(x|y)-$spacing"] }
  ],
  ["caption-top", { "caption-side": "top" }],
  ["caption-bottom", { "caption-side": "bottom" }],
  ["table-auto", { "table-layout": "auto" }],
  ["table-fixed", { "table-layout": "fixed" }],
  ["table-empty-cells-visible", { "empty-cells": "show" }],
  ["table-empty-cells-hidden", { "empty-cells": "hide" }]
];
function resolveValue(s, theme4) {
  var _a;
  let v = (_a = theme4.spacing) == null ? void 0 : _a[s];
  if (!v) {
    const num = numberResolver(s);
    if (num != null) {
      themeTracking(`spacing`);
      v = `calc(var(--spacing) * ${num})`;
    } else v = h2.bracket.cssvar.global.auto.fraction.rem(s);
  }
  return v;
}
var touchActionValue = "var(--un-pan-x) var(--un-pan-y) var(--un-pinch-zoom)";
var touchActionProperties = [
  "pan-x",
  "pan-y",
  "pinch-zoom"
].map((d) => defineProperty(`--un-${d}`));
var touchActions2 = [
  [
    /^touch-pan-(x|left|right)$/,
    function* ([, d]) {
      yield {
        "--un-pan-x": `pan-${d}`,
        "touch-action": touchActionValue
      };
      for (const p of touchActionProperties) yield p;
    },
    { autocomplete: ["touch-pan", "touch-pan-(x|left|right|y|up|down)"] }
  ],
  [/^touch-pan-(y|up|down)$/, function* ([, d]) {
    yield {
      "--un-pan-y": `pan-${d}`,
      "touch-action": touchActionValue
    };
    for (const p of touchActionProperties) yield p;
  }],
  [/^touch-pinch-zoom$/, function* () {
    yield {
      "--un-pinch-zoom": "pinch-zoom",
      "touch-action": touchActionValue
    };
    for (const p of touchActionProperties) yield p;
  }],
  ["touch-auto", { "touch-action": "auto" }],
  ["touch-manipulation", { "touch-action": "manipulation" }],
  ["touch-none", { "touch-action": "none" }],
  ...makeGlobalStaticRules2("touch", "touch-action")
];
var transformValues2 = [
  "translate",
  "rotate",
  "scale"
];
var transformCpu2 = [
  "var(--un-rotate-x)",
  "var(--un-rotate-y)",
  "var(--un-rotate-z)",
  "var(--un-skew-x)",
  "var(--un-skew-y)"
].join(" ");
var transform2 = transformCpu2;
var transformGpu2 = ["translateZ(0)", transformCpu2].join(" ");
var transforms2 = [
  [
    /^(?:transform-)?origin-(.+)$/,
    ([, s]) => ({ "transform-origin": positionMap2[s] ?? h2.bracket.cssvar(s) }),
    { autocomplete: [`transform-origin-(${Object.keys(positionMap2).join("|")})`, `origin-(${Object.keys(positionMap2).join("|")})`] }
  ],
  [
    /^(?:transform-)?perspect(?:ive)?-(.+)$/,
    ([, s], { theme: theme4 }) => {
      var _a;
      let v;
      if ((_a = theme4.perspective) == null ? void 0 : _a[s]) {
        themeTracking(`perspective`, s);
        v = generateThemeVariable("perspective", s);
      } else v = h2.bracket.cssvar.px.numberWithUnit(s);
      if (v != null) return { perspective: v };
    },
    { autocomplete: [
      `transform-perspective-<num>`,
      `perspective-<num>`,
      `perspective-$perspective`
    ] }
  ],
  [/^(?:transform-)?perspect(?:ive)?-origin-(.+)$/, ([, s]) => {
    const v = h2.bracket.cssvar(s) ?? (s.length >= 3 ? positionMap2[s] : void 0);
    if (v != null) return { "perspective-origin": v };
  }],
  [/^(?:transform-)?translate-()(.+)$/, handleTranslate2],
  [/^(?:transform-)?translate-([xyz])-(.+)$/, handleTranslate2],
  [/^(?:transform-)?rotate-()(.+)$/, handleRotate2],
  [/^(?:transform-)?rotate-([xyz])-(.+)$/, handleRotate2],
  [/^(?:transform-)?skew-()(.+)$/, handleSkew2],
  [
    /^(?:transform-)?skew-([xy])-(.+)$/,
    handleSkew2,
    { autocomplete: ["transform-skew-(x|y)-<percent>", "skew-(x|y)-<percent>"] }
  ],
  [/^(?:transform-)?scale-()(.+)$/, handleScale2],
  [
    /^(?:transform-)?scale-([xyz])-(.+)$/,
    handleScale2,
    { autocomplete: [
      `transform-(${transformValues2.join("|")})-<percent>`,
      `transform-(${transformValues2.join("|")})-(x|y|z)-<percent>`,
      `(${transformValues2.join("|")})-<percent>`,
      `(${transformValues2.join("|")})-(x|y|z)-<percent>`
    ] }
  ],
  ["transform-3d", { "transform-style": "preserve-3d" }],
  ["transform-flat", { "transform-style": "flat" }],
  [/^transform-(border|content|fill|stroke|view)$/, ([, d]) => ({ "transform-box": `${d}-box` })],
  ["transform", { transform: transform2 }],
  ["transform-cpu", { transform: transformCpu2 }],
  ["transform-gpu", { transform: transformGpu2 }],
  ["transform-none", { transform: "none" }],
  ...makeGlobalStaticRules2("transform")
];
function handleTranslate2([, d, b]) {
  const v = numberResolver(b) ?? h2.bracket.cssvar.none.fraction.rem(b);
  if (v != null) {
    if (v === "none") return { translate: "none" };
    themeTracking(`spacing`);
    return [[...transformXYZ2(d, typeof v === "number" ? `calc(var(--spacing) * ${v})` : v, "translate"), [
      "translate",
      `var(--un-translate-x) var(--un-translate-y)${d === "z" ? " var(--un-translate-z)" : ""}`,
      CONTROL_NO_NEGATIVE
    ]], ...[
      "x",
      "y",
      "z"
    ].map((d$1) => defineProperty(`--un-translate-${d$1}`, { initialValue: 0 }))];
  }
}
function handleScale2([, d, b]) {
  const v = h2.bracket.cssvar.none.fraction.percent(b);
  if (v != null) {
    if (v === "none") return { scale: "none" };
    return [[...transformXYZ2(d, v, "scale"), ["scale", `var(--un-scale-x) var(--un-scale-y)${d === "z" ? " var(--un-scale-z)" : ""}`]], ...[
      "x",
      "y",
      "z"
    ].map((d$1) => defineProperty(`--un-scale-${d$1}`, { initialValue: 1 }))];
  }
}
function handleRotate2([, d = "", b]) {
  const v = h2.bracket.cssvar.none.degree(b);
  if (v != null) {
    if (v === "none") return { rotate: "none" };
    if (d) return [
      [...transformXYZ2(d, v.endsWith("deg") ? `rotate${d.toUpperCase()}(${v})` : v, "rotate"), ["transform", transform2]],
      ...[
        "x",
        "y",
        "z"
      ].map((d$1) => defineProperty(`--un-rotate-${d$1}`, { initialValue: `rotate${d$1.toUpperCase()}(0)` })),
      ...["x", "y"].map((d$1) => defineProperty(`--un-skew-${d$1}`, { initialValue: `skew${d$1.toUpperCase()}(0)` }))
    ];
    else return { rotate: h2.bracket.cssvar.degree(b) };
  }
}
function handleSkew2([, d, b]) {
  const v = h2.bracket.cssvar.degree(b);
  const ds = xyzMap2[d];
  if (v != null && ds) return [
    [...ds.map((_d) => [`--un-skew${_d}`, v.endsWith("deg") ? `skew${_d.slice(1).toUpperCase()}(${v})` : v]), ["transform", transform2]],
    ...[
      "x",
      "y",
      "z"
    ].map((d$1) => defineProperty(`--un-rotate-${d$1}`, { initialValue: `rotate${d$1.toUpperCase()}(0)` })),
    ...["x", "y"].map((d$1) => defineProperty(`--un-skew-${d$1}`, { initialValue: `skew${d$1.toUpperCase()}(0)` }))
  ];
}
function transformXYZ2(d, v, name50) {
  const values = v.split(splitComma2);
  if (d || !d && values.length === 1) return xyzMap2[d].map((i) => [`--un-${name50}${i}`, v]);
  return values.map((v$1, i) => [`--un-${name50}-${xyzArray2[i]}`, v$1]);
}
function resolveTransitionProperty2(prop, theme4) {
  let p;
  if (h2.cssvar(prop) != null) p = h2.cssvar(prop);
  else {
    if (prop.startsWith("[") && prop.endsWith("]")) prop = prop.slice(1, -1);
    const props = prop.split(",").map((p$1) => {
      var _a;
      return ((_a = theme4.property) == null ? void 0 : _a[p$1]) ?? h2.properties(p$1);
    });
    if (props.every(Boolean)) p = props.join(",");
  }
  return p;
}
var transitions2 = [
  [/^transition(?:-(\D+?))?(?:-(\d+))?$/, ([, prop, d], { theme: theme4 }) => {
    var _a;
    themeTracking("default", ["transition", "timingFunction"]);
    themeTracking("default", ["transition", "duration"]);
    const defaultTransition = {
      "transition-property": (_a = theme4.property) == null ? void 0 : _a.DEFAULT,
      "transition-timing-function": `var(--un-ease, ${generateThemeVariable("default", ["transition", "timingFunction"])})`,
      "transition-duration": `var(--un-duration, ${generateThemeVariable("default", ["transition", "duration"])})`
    };
    if (!prop && !d) return { ...defaultTransition };
    else if (prop != null) {
      const p = resolveTransitionProperty2(prop, theme4);
      if (p) return {
        "--un-duration": d && h2.time(d),
        ...defaultTransition,
        "transition-property": p
      };
    } else if (d != null) return {
      "--un-duration": h2.time(d),
      ...defaultTransition
    };
  }],
  [/^(?:transition-)?duration-(.+)$/, ([, d]) => ({
    "--un-duration": h2.bracket.cssvar.time(d),
    "transition-duration": h2.bracket.cssvar.time(d)
  })],
  [/^(?:transition-)?delay-(.+)$/, ([, d]) => ({ "transition-delay": h2.bracket.cssvar.time(d) })],
  [
    /^(?:transition-)?ease(?:-(.+))?$/,
    ([, d = "DEFAULT"], { theme: theme4 }) => {
      var _a;
      let v;
      if ((_a = theme4.ease) == null ? void 0 : _a[d]) {
        themeTracking("ease", d);
        v = generateThemeVariable("ease", d);
      } else v = h2.bracket.cssvar(d);
      return [{
        "--un-ease": v,
        "transition-timing-function": v
      }, defineProperty("--un-ease")];
    },
    { autocomplete: ["transition-ease-(linear|in|out|in-out)", "ease-(linear|in|out|in-out)"] }
  ],
  [
    /^(?:transition-)?property-(.+)$/,
    ([, v], { theme: theme4 }) => {
      const p = h2.global(v) || resolveTransitionProperty2(v, theme4);
      if (p) return { "transition-property": p };
    },
    { autocomplete: [`transition-property-(${[...globalKeywords2].join("|")})`] }
  ],
  ["transition-none", { transition: "none" }],
  ...makeGlobalStaticRules2("transition"),
  ["transition-discrete", { "transition-behavior": "allow-discrete" }],
  ["transition-normal", { "transition-behavior": "normal" }]
];
var fonts2 = [
  [
    /^text-(.+)$/,
    handleText2,
    { autocomplete: "text-$text" }
  ],
  [
    /^(?:text|font)-size-(.+)$/,
    handleSize2,
    { autocomplete: "text-size-$text" }
  ],
  [
    /^text-(?:color-)?(.+)$/,
    handlerColorOrSize2,
    { autocomplete: "text-$colors" }
  ],
  [/^(?:color|c)-(.+)$/, colorResolver2("color", "text")],
  [
    /^(?:text|color|c)-(.+)$/,
    ([, v]) => globalKeywords2.includes(v) ? { color: v } : void 0,
    { autocomplete: `(text|color|c)-(${globalKeywords2.join("|")})` }
  ],
  [
    /^(?:text|color|c)-op(?:acity)?-?(.+)$/,
    ([, opacity$1]) => ({ "--un-text-opacity": h2.bracket.percent.cssvar(opacity$1) }),
    { autocomplete: "(text|color|c)-(op|opacity)-<percent>" }
  ],
  [
    /^fw-?([^-]+)$/,
    ([, s], { theme: theme4 }) => {
      var _a;
      let v;
      if ((_a = theme4.fontWeight) == null ? void 0 : _a[s]) {
        themeTracking(`fontWeight`, s);
        v = generateThemeVariable("fontWeight", s);
      } else v = h2.bracket.cssvar.global.number(s);
      return {
        "--un-font-weight": v,
        "font-weight": v
      };
    },
    { autocomplete: ["(font|fw)-(100|200|300|400|500|600|700|800|900)", "(font|fw)-$fontWeight"] }
  ],
  [
    /^(?:font-)?(?:leading|lh|line-height)-(.+)$/,
    ([, s], { theme: theme4 }) => {
      var _a;
      let v;
      if ((_a = theme4.leading) == null ? void 0 : _a[s]) {
        themeTracking("leading", s);
        v = generateThemeVariable("leading", s);
      } else if (numberResolver(s)) {
        themeTracking("spacing");
        v = `calc(var(--spacing) * ${numberResolver(s)})`;
      } else v = h2.bracket.cssvar.global.rem(s);
      if (v != null) return [{
        "--un-leading": v,
        "line-height": v
      }, defineProperty("--un-leading")];
    },
    { autocomplete: "(leading|lh|line-height)-$leading" }
  ],
  ["font-synthesis-weight", { "font-synthesis": "weight" }],
  ["font-synthesis-style", { "font-synthesis": "style" }],
  ["font-synthesis-small-caps", { "font-synthesis": "small-caps" }],
  ["font-synthesis-none", { "font-synthesis": "none" }],
  [/^font-synthesis-(.+)$/, ([, s]) => ({ "font-synthesis": h2.bracket.cssvar.global(s) })],
  [
    /^(?:font-)?tracking-(.+)$/,
    ([, s], { theme: theme4 }) => {
      var _a;
      let v;
      if ((_a = theme4.tracking) == null ? void 0 : _a[s]) {
        themeTracking(`tracking`, s);
        v = generateThemeVariable("tracking", s);
      } else v = h2.bracket.cssvar.global.rem(s);
      return {
        "--un-tracking": v,
        "letter-spacing": v
      };
    },
    { autocomplete: "tracking-$tracking" }
  ],
  [
    /^(?:font-)?word-spacing-(.+)$/,
    ([, s], { theme: theme4 }) => {
      var _a;
      const v = ((_a = theme4.tracking) == null ? void 0 : _a[s]) ? generateThemeVariable("tracking", s) : h2.bracket.cssvar.global.rem(s);
      return {
        "--un-word-spacing": v,
        "word-spacing": v
      };
    },
    { autocomplete: "word-spacing-$spacing" }
  ],
  ["font-stretch-normal", { "font-stretch": "normal" }],
  ["font-stretch-ultra-condensed", { "font-stretch": "ultra-condensed" }],
  ["font-stretch-extra-condensed", { "font-stretch": "extra-condensed" }],
  ["font-stretch-condensed", { "font-stretch": "condensed" }],
  ["font-stretch-semi-condensed", { "font-stretch": "semi-condensed" }],
  ["font-stretch-semi-expanded", { "font-stretch": "semi-expanded" }],
  ["font-stretch-expanded", { "font-stretch": "expanded" }],
  ["font-stretch-extra-expanded", { "font-stretch": "extra-expanded" }],
  ["font-stretch-ultra-expanded", { "font-stretch": "ultra-expanded" }],
  [
    /^font-stretch-(.+)$/,
    ([, s]) => ({ "font-stretch": h2.bracket.cssvar.fraction.global(s) }),
    { autocomplete: "font-stretch-<percentage>" }
  ],
  [
    /^font-(.+)$/,
    ([, d], { theme: theme4 }) => {
      var _a, _b;
      let v;
      if ((_a = theme4.font) == null ? void 0 : _a[d]) {
        themeTracking("font", d);
        v = generateThemeVariable("font", d);
        return { "font-family": v };
      }
      if ((_b = theme4.fontWeight) == null ? void 0 : _b[d]) {
        themeTracking("fontWeight", d);
        v = generateThemeVariable("fontWeight", d);
        return {
          "--un-font-weight": v,
          "font-weight": v
        };
      }
      v = h2.number(d);
      if (v != null) return {
        "--un-font-weight": v,
        "font-weight": v
      };
      v = h2.bracketOfFamily(d);
      if (v != null && h2.number(v) == null) {
        v = h2.cssvar(v) ?? v;
        return { "font-family": v };
      }
      v = h2.bracketOfNumber(d);
      if (v != null) {
        v = h2.cssvar.number(v);
        return {
          "--un-font-weight": v,
          "font-weight": v
        };
      }
      v = h2.bracket(d);
      if (v != null && h2.number(v) != null) {
        const num = h2.number(v);
        return {
          "--un-font-weight": num,
          "font-weight": num
        };
      }
      v = h2.bracket.cssvar.global(d);
      if (v != null) return { "font-family": v };
    },
    { autocomplete: ["font-$font", "font-$fontWeight"] }
  ]
];
var tabSizes2 = [[/^tab(?:-(.+))?$/, ([, s]) => {
  const v = h2.bracket.cssvar.global.number(s || "4");
  if (v != null) return {
    "-moz-tab-size": v,
    "-o-tab-size": v,
    "tab-size": v
  };
}]];
var textIndents2 = [[/^indent-(.+)$/, ([, s]) => {
  let v = numberResolver(s);
  if (v != null) {
    themeTracking(`spacing`);
    return { "text-indent": `calc(var(--spacing) * ${v})` };
  }
  v = h2.bracket.cssvar.auto.global.rem(s);
  if (v != null) return { "text-indent": v };
}]];
var textStrokes2 = [
  [
    /^text-stroke(?:-(.+))?$/,
    ([, s = "DEFAULT"], { theme: theme4 }) => {
      var _a, _b;
      if ((_a = theme4.textStrokeWidth) == null ? void 0 : _a[s]) themeTracking(`textStrokeWidth`, s);
      return { "-webkit-text-stroke-width": ((_b = theme4.textStrokeWidth) == null ? void 0 : _b[s]) ? generateThemeVariable("textStrokeWidth", s) : h2.bracket.cssvar.px(s) };
    },
    { autocomplete: "text-stroke-$textStrokeWidth" }
  ],
  [
    /^text-stroke-(.+)$/,
    colorResolver2("-webkit-text-stroke-color", "text-stroke"),
    { autocomplete: "text-stroke-$colors" }
  ],
  [
    /^text-stroke-op(?:acity)?-?(.+)$/,
    ([, opacity$1]) => ({ "--un-text-stroke-opacity": h2.bracket.percent.cssvar(opacity$1) }),
    { autocomplete: "text-stroke-(op|opacity)-<percent>" }
  ]
];
function handleTextShadow(match, ctx) {
  var _a;
  const [, s] = match;
  const { theme: theme4 } = ctx;
  let res = [];
  if (s) res = getStringComponents(s, "/", 2) ?? [];
  const v = (_a = theme4.textShadow) == null ? void 0 : _a[res[0]];
  const c = s ? h2.bracket.cssvar(s) : void 0;
  if ((v != null || c != null) && !hasParseableColor2(c, theme4)) {
    const alpha = res[1] ? h2.bracket.percent.cssvar(res[1]) : void 0;
    return {
      "--un-text-shadow-opacity": alpha,
      "--un-text-shadow": colorableShadows2(v || c, "--un-text-shadow-color", alpha).join(","),
      "text-shadow": "var(--un-text-shadow)"
    };
  }
  return colorResolver2("--un-text-shadow-color", "text-shadow")(match, ctx) ?? { "text-shadow": h2.bracket.cssvar.global(s) };
}
var textShadows2 = [
  [
    /^text-shadow-(.+)$/,
    handleTextShadow,
    { autocomplete: [
      "text-shadow-$textShadow",
      "text-shadow(-color)?-$colors",
      "text-shadow(-color)?-(op|opacity)-<percent>"
    ] }
  ],
  [
    /^text-shadow-color-(.+)$/,
    colorResolver2("--un-text-shadow-color", "text-shadow"),
    { autocomplete: "text-shadow-color-$colors" }
  ],
  [
    /^text-shadow(?:-color)?-op(?:acity)?-?(.+)$/,
    ([, opacity$1]) => ({ "--un-text-shadow-opacity": h2.bracket.percent.cssvar(opacity$1) }),
    { autocomplete: "text-shadow(-color)?-(op|opacity)-<percent>" }
  ]
];
var fontVariantNumericProperties = [
  defineProperty("--un-ordinal"),
  defineProperty("--un-slashed-zero"),
  defineProperty("--un-numeric-figure"),
  defineProperty("--un-numeric-spacing"),
  defineProperty("--un-numeric-fraction")
];
var baseFontVariantNumeric = { "font-variant-numeric": "var(--un-ordinal,) var(--un-slashed-zero,) var(--un-numeric-figure,) var(--un-numeric-spacing,) var(--un-numeric-fraction,)" };
var fontVariantNumeric2 = [
  ["ordinal", [{
    "--un-ordinal": "ordinal",
    ...baseFontVariantNumeric
  }, ...fontVariantNumericProperties]],
  ["slashed-zero", [{
    "--un-slashed-zero": "slashed-zero",
    ...baseFontVariantNumeric
  }, ...fontVariantNumericProperties]],
  ["lining-nums", [{
    "--un-numeric-figure": "lining-nums",
    ...baseFontVariantNumeric
  }, ...fontVariantNumericProperties]],
  ["oldstyle-nums", [{
    "--un-numeric-figure": "oldstyle-nums",
    ...baseFontVariantNumeric
  }, ...fontVariantNumericProperties]],
  ["proportional-nums", [{
    "--un-numeric-spacing": "proportional-nums",
    ...baseFontVariantNumeric
  }, ...fontVariantNumericProperties]],
  ["tabular-nums", [{
    "--un-numeric-spacing": "tabular-nums",
    ...baseFontVariantNumeric
  }, ...fontVariantNumericProperties]],
  ["diagonal-fractions", [{
    "--un-numeric-fraction": "diagonal-fractions",
    ...baseFontVariantNumeric
  }, ...fontVariantNumericProperties]],
  ["stacked-fractions", [{
    "--un-numeric-fraction": "stacked-fractions",
    ...baseFontVariantNumeric
  }, ...fontVariantNumericProperties]],
  ["normal-nums", [{ "font-variant-numeric": "normal" }]]
];
function handleText2([, s = "base"], { theme: theme4 }) {
  var _a, _b;
  const split = splitShorthand3(s, "length");
  if (!split) return;
  const [size, leading2] = split;
  const sizePairs = (_a = theme4.text) == null ? void 0 : _a[size];
  let lineHeight2;
  if (leading2) if ((_b = theme4.leading) == null ? void 0 : _b[leading2]) {
    themeTracking(`leading`, leading2);
    lineHeight2 = generateThemeVariable("leading", leading2);
  } else lineHeight2 = h2.bracket.cssvar.global.rem(leading2);
  if (sizePairs) {
    themeTracking(`text`, [size, "fontSize"]);
    themeTracking(`text`, [size, "lineHeight"]);
    if (sizePairs.letterSpacing) themeTracking(`text`, [size, "letterSpacing"]);
    return {
      "font-size": generateThemeVariable("text", [size, "fontSize"]),
      "line-height": lineHeight2 ?? `var(--un-leading, ${generateThemeVariable("text", [size, "lineHeight"])})`,
      "letter-spacing": sizePairs.letterSpacing ? generateThemeVariable("text", [size, "letterSpacing"]) : void 0
    };
  }
  const fontSize2 = h2.bracketOfLength.rem(size);
  if (lineHeight2 && fontSize2) return {
    "font-size": fontSize2,
    "line-height": lineHeight2
  };
  return { "font-size": h2.bracketOfLength.rem(s) };
}
function handleSize2([, s], { theme: theme4 }) {
  var _a;
  if (((_a = theme4.text) == null ? void 0 : _a[s]) != null) {
    themeTracking(`text`, [s, "fontSize"]);
    themeTracking(`text`, [s, "lineHeight"]);
    return {
      "font-size": generateThemeVariable("text", [s, "fontSize"]),
      "line-height": `var(--un-leading, ${generateThemeVariable("text", [s, "lineHeight"])})`
    };
  } else {
    const d = h2.bracket.cssvar.global.rem(s);
    if (d) return { "font-size": d };
  }
}
function handlerColorOrSize2(match, ctx) {
  if (isCSSMathFn2(h2.bracket(match[1]))) return handleSize2(match, ctx);
  return colorResolver2("color", "text")(match, ctx);
}
function splitShorthand3(body, type) {
  const [front, rest] = getStringComponent(body, "[", "]", ["/", ":"]) ?? [];
  if (front != null) {
    const match = (front.match(bracketTypeRe2) ?? [])[1];
    if (match == null || match === type) return [front, rest];
  }
}
var variablesAbbrMap3 = {
  "backface": "backface-visibility",
  "break": "word-break",
  "case": "text-transform",
  "content": "align-content",
  "fw": "font-weight",
  "items": "align-items",
  "justify": "justify-content",
  "select": "user-select",
  "self": "align-self",
  "vertical": "vertical-align",
  "visible": "visibility",
  "whitespace": "white-space",
  "ws": "white-space",
  "bg-blend": "background-blend-mode",
  "bg-clip": "-webkit-background-clip",
  "bg-image": "background-image",
  "bg-origin": "background-origin",
  "bg-position": "background-position",
  "bg-repeat": "background-repeat",
  "bg-size": "background-size",
  "mix-blend": "mix-blend-mode",
  "object": "object-fit",
  "object-position": "object-position",
  "write": "writing-mode",
  "write-orient": "text-orientation"
};
var cssVariables3 = [[/^(.+?)-(\$.+)$/, ([, name50, varname]) => {
  const prop = variablesAbbrMap3[name50];
  if (prop) return { [prop]: h2.cssvar(varname) };
}]];
var cssProperty2 = [[/^\[(.*)\]$/, ([_, body], { theme: theme4 }) => {
  if (!body.includes(":")) return;
  const [prop, ...rest] = body.split(":");
  const value = rest.join(":");
  if (!isURI2(body) && /^[\w-]+$/.test(prop) && isValidCSSBody2(value)) {
    const parsed = h2.bracket(`[${value}]`, theme4);
    if (parsed) return { [prop]: parsed };
  }
}]];
function isValidCSSBody2(body) {
  let i = 0;
  function findUntil(c) {
    while (i < body.length) {
      i += 1;
      if (body[i] === c) return true;
    }
    return false;
  }
  for (i = 0; i < body.length; i++) {
    const c = body[i];
    if ("\"`'".includes(c)) {
      if (!findUntil(c)) return false;
    } else if (c === "(") {
      if (!findUntil(")")) return false;
    } else if ("[]{}:".includes(c)) return false;
  }
  return true;
}
function isURI2(declaration) {
  if (!declaration.includes("://")) return false;
  try {
    return new URL(declaration).host !== "";
  } catch {
    return false;
  }
}
var viewTransition2 = [[/^view-transition-([\w-]+)$/, ([, name50]) => {
  return { "view-transition-name": name50 };
}]];
var rules3 = [
  fonts2,
  tabSizes2,
  textIndents2,
  textStrokes2,
  textShadows2,
  margins2,
  paddings2,
  textAligns2,
  verticalAligns2,
  appearance2,
  outline2,
  willChange2,
  listStyle2,
  accents2,
  carets2,
  imageRenderings2,
  overscrolls2,
  outline2,
  scrollBehaviors2,
  willChange2,
  borders2,
  bgColors2,
  opacity2,
  colorScheme2,
  container2,
  containerParent2,
  textDecorations2,
  flex2,
  gaps2,
  grids2,
  sizes2,
  aspectRatio2,
  displays2,
  appearances2,
  cursors2,
  contains2,
  pointerEvents2,
  resizes2,
  userSelects2,
  whitespaces2,
  contentVisibility2,
  contents2,
  breaks2,
  textWraps2,
  textOverflows2,
  textTransforms3,
  fontStyles2,
  fontSmoothings2,
  rings2,
  boxShadows2,
  transforms2,
  transitions2,
  cssVariables3,
  cssProperty2,
  alignments2,
  boxSizing2,
  flexGridJustifiesAlignments2,
  floats2,
  insets2,
  justifies2,
  orders2,
  placements2,
  positions2,
  zIndexes2,
  overflows2,
  svgUtilities2,
  animations2,
  backgroundStyles2,
  hyphens2,
  writingModes2,
  writingOrientations2,
  accessibility,
  screenReadersAccess2,
  isolations2,
  objectPositions2,
  backgroundBlendModes2,
  mixBlendModes2,
  dynamicViewportHeight2,
  masks,
  columns2,
  filters2,
  lineClamps2,
  placeholders2,
  scrolls2,
  tables2,
  touchActions2,
  fontVariantNumeric2,
  viewTransition2,
  spaces2,
  divides2,
  fieldSizing2,
  questionMark2
].flat();

// node_modules/@unocss/preset-wind4/dist/shortcuts.mjs
var shortcuts2 = [...containerShortcuts2];

// node_modules/@unocss/preset-wind4/dist/colors-hDdKuL6f.mjs
var colors2 = {
  black: "#000",
  white: "#fff",
  slate: {
    50: "oklch(98.4% 0.003 247.858)",
    100: "oklch(96.8% 0.007 247.896)",
    200: "oklch(92.9% 0.013 255.508)",
    300: "oklch(86.9% 0.022 252.894)",
    400: "oklch(70.4% 0.04 256.788)",
    500: "oklch(55.4% 0.046 257.417)",
    600: "oklch(44.6% 0.043 257.281)",
    700: "oklch(37.2% 0.044 257.287)",
    800: "oklch(27.9% 0.041 260.031)",
    900: "oklch(20.8% 0.042 265.755)",
    950: "oklch(12.9% 0.042 264.695)"
  },
  gray: {
    50: "oklch(98.5% 0.002 247.839)",
    100: "oklch(96.7% 0.003 264.542)",
    200: "oklch(92.8% 0.006 264.531)",
    300: "oklch(87.2% 0.01 258.338)",
    400: "oklch(70.7% 0.022 261.325)",
    500: "oklch(55.1% 0.027 264.364)",
    600: "oklch(44.6% 0.03 256.802)",
    700: "oklch(37.3% 0.034 259.733)",
    800: "oklch(27.8% 0.033 256.848)",
    900: "oklch(21% 0.034 264.665)",
    950: "oklch(13% 0.028 261.692)"
  },
  zinc: {
    50: "oklch(98.5% 0 0)",
    100: "oklch(96.7% 0.001 286.375)",
    200: "oklch(92% 0.004 286.32)",
    300: "oklch(87.1% 0.006 286.286)",
    400: "oklch(70.5% 0.015 286.067)",
    500: "oklch(55.2% 0.016 285.938)",
    600: "oklch(44.2% 0.017 285.786)",
    700: "oklch(37% 0.013 285.805)",
    800: "oklch(27.4% 0.006 286.033)",
    900: "oklch(21% 0.006 285.885)",
    950: "oklch(14.1% 0.005 285.823)"
  },
  neutral: {
    50: "oklch(98.5% 0 0)",
    100: "oklch(97% 0 0)",
    200: "oklch(92.2% 0 0)",
    300: "oklch(87% 0 0)",
    400: "oklch(70.8% 0 0)",
    500: "oklch(55.6% 0 0)",
    600: "oklch(43.9% 0 0)",
    700: "oklch(37.1% 0 0)",
    800: "oklch(26.9% 0 0)",
    900: "oklch(20.5% 0 0)",
    950: "oklch(14.5% 0 0)"
  },
  stone: {
    50: "oklch(98.5% 0.001 106.423)",
    100: "oklch(97% 0.001 106.424)",
    200: "oklch(92.3% 0.003 48.717)",
    300: "oklch(86.9% 0.005 56.366)",
    400: "oklch(70.9% 0.01 56.259)",
    500: "oklch(55.3% 0.013 58.071)",
    600: "oklch(44.4% 0.011 73.639)",
    700: "oklch(37.4% 0.01 67.558)",
    800: "oklch(26.8% 0.007 34.298)",
    900: "oklch(21.6% 0.006 56.043)",
    950: "oklch(14.7% 0.004 49.25)"
  },
  red: {
    50: "oklch(97.1% 0.013 17.38)",
    100: "oklch(93.6% 0.032 17.717)",
    200: "oklch(88.5% 0.062 18.334)",
    300: "oklch(80.8% 0.114 19.571)",
    400: "oklch(70.4% 0.191 22.216)",
    500: "oklch(63.7% 0.237 25.331)",
    600: "oklch(57.7% 0.245 27.325)",
    700: "oklch(50.5% 0.213 27.518)",
    800: "oklch(44.4% 0.177 26.899)",
    900: "oklch(39.6% 0.141 25.723)",
    950: "oklch(25.8% 0.092 26.042)"
  },
  orange: {
    50: "oklch(98% 0.016 73.684)",
    100: "oklch(95.4% 0.038 75.164)",
    200: "oklch(90.1% 0.076 70.697)",
    300: "oklch(83.7% 0.128 66.29)",
    400: "oklch(75% 0.183 55.934)",
    500: "oklch(70.5% 0.213 47.604)",
    600: "oklch(64.6% 0.222 41.116)",
    700: "oklch(55.3% 0.195 38.402)",
    800: "oklch(47% 0.157 37.304)",
    900: "oklch(40.8% 0.123 38.172)",
    950: "oklch(26.6% 0.079 36.259)"
  },
  amber: {
    50: "oklch(98.7% 0.022 95.277)",
    100: "oklch(96.2% 0.059 95.617)",
    200: "oklch(92.4% 0.12 95.746)",
    300: "oklch(87.9% 0.169 91.605)",
    400: "oklch(82.8% 0.189 84.429)",
    500: "oklch(76.9% 0.188 70.08)",
    600: "oklch(66.6% 0.179 58.318)",
    700: "oklch(55.5% 0.163 48.998)",
    800: "oklch(47.3% 0.137 46.201)",
    900: "oklch(41.4% 0.112 45.904)",
    950: "oklch(27.9% 0.077 45.635)"
  },
  yellow: {
    50: "oklch(98.7% 0.026 102.212)",
    100: "oklch(97.3% 0.071 103.193)",
    200: "oklch(94.5% 0.129 101.54)",
    300: "oklch(90.5% 0.182 98.111)",
    400: "oklch(85.2% 0.199 91.936)",
    500: "oklch(79.5% 0.184 86.047)",
    600: "oklch(68.1% 0.162 75.834)",
    700: "oklch(55.4% 0.135 66.442)",
    800: "oklch(47.6% 0.114 61.907)",
    900: "oklch(42.1% 0.095 57.708)",
    950: "oklch(28.6% 0.066 53.813)"
  },
  lime: {
    50: "oklch(98.6% 0.031 120.757)",
    100: "oklch(96.7% 0.067 122.328)",
    200: "oklch(93.8% 0.127 124.321)",
    300: "oklch(89.7% 0.196 126.665)",
    400: "oklch(84.1% 0.238 128.85)",
    500: "oklch(76.8% 0.233 130.85)",
    600: "oklch(64.8% 0.2 131.684)",
    700: "oklch(53.2% 0.157 131.589)",
    800: "oklch(45.3% 0.124 130.933)",
    900: "oklch(40.5% 0.101 131.063)",
    950: "oklch(27.4% 0.072 132.109)"
  },
  green: {
    50: "oklch(98.2% 0.018 155.826)",
    100: "oklch(96.2% 0.044 156.743)",
    200: "oklch(92.5% 0.084 155.995)",
    300: "oklch(87.1% 0.15 154.449)",
    400: "oklch(79.2% 0.209 151.711)",
    500: "oklch(72.3% 0.219 149.579)",
    600: "oklch(62.7% 0.194 149.214)",
    700: "oklch(52.7% 0.154 150.069)",
    800: "oklch(44.8% 0.119 151.328)",
    900: "oklch(39.3% 0.095 152.535)",
    950: "oklch(26.6% 0.065 152.934)"
  },
  emerald: {
    50: "oklch(97.9% 0.021 166.113)",
    100: "oklch(95% 0.052 163.051)",
    200: "oklch(90.5% 0.093 164.15)",
    300: "oklch(84.5% 0.143 164.978)",
    400: "oklch(76.5% 0.177 163.223)",
    500: "oklch(69.6% 0.17 162.48)",
    600: "oklch(59.6% 0.145 163.225)",
    700: "oklch(50.8% 0.118 165.612)",
    800: "oklch(43.2% 0.095 166.913)",
    900: "oklch(37.8% 0.077 168.94)",
    950: "oklch(26.2% 0.051 172.552)"
  },
  teal: {
    50: "oklch(98.4% 0.014 180.72)",
    100: "oklch(95.3% 0.051 180.801)",
    200: "oklch(91% 0.096 180.426)",
    300: "oklch(85.5% 0.138 181.071)",
    400: "oklch(77.7% 0.152 181.912)",
    500: "oklch(70.4% 0.14 182.503)",
    600: "oklch(60% 0.118 184.704)",
    700: "oklch(51.1% 0.096 186.391)",
    800: "oklch(43.7% 0.078 188.216)",
    900: "oklch(38.6% 0.063 188.416)",
    950: "oklch(27.7% 0.046 192.524)"
  },
  cyan: {
    50: "oklch(98.4% 0.019 200.873)",
    100: "oklch(95.6% 0.045 203.388)",
    200: "oklch(91.7% 0.08 205.041)",
    300: "oklch(86.5% 0.127 207.078)",
    400: "oklch(78.9% 0.154 211.53)",
    500: "oklch(71.5% 0.143 215.221)",
    600: "oklch(60.9% 0.126 221.723)",
    700: "oklch(52% 0.105 223.128)",
    800: "oklch(45% 0.085 224.283)",
    900: "oklch(39.8% 0.07 227.392)",
    950: "oklch(30.2% 0.056 229.695)"
  },
  sky: {
    50: "oklch(97.7% 0.013 236.62)",
    100: "oklch(95.1% 0.026 236.824)",
    200: "oklch(90.1% 0.058 230.902)",
    300: "oklch(82.8% 0.111 230.318)",
    400: "oklch(74.6% 0.16 232.661)",
    500: "oklch(68.5% 0.169 237.323)",
    600: "oklch(58.8% 0.158 241.966)",
    700: "oklch(50% 0.134 242.749)",
    800: "oklch(44.3% 0.11 240.79)",
    900: "oklch(39.1% 0.09 240.876)",
    950: "oklch(29.3% 0.066 243.157)"
  },
  blue: {
    50: "oklch(97% 0.014 254.604)",
    100: "oklch(93.2% 0.032 255.585)",
    200: "oklch(88.2% 0.059 254.128)",
    300: "oklch(80.9% 0.105 251.813)",
    400: "oklch(70.7% 0.165 254.624)",
    500: "oklch(62.3% 0.214 259.815)",
    600: "oklch(54.6% 0.245 262.881)",
    700: "oklch(48.8% 0.243 264.376)",
    800: "oklch(42.4% 0.199 265.638)",
    900: "oklch(37.9% 0.146 265.522)",
    950: "oklch(28.2% 0.091 267.935)"
  },
  indigo: {
    50: "oklch(96.2% 0.018 272.314)",
    100: "oklch(93% 0.034 272.788)",
    200: "oklch(87% 0.065 274.039)",
    300: "oklch(78.5% 0.115 274.713)",
    400: "oklch(67.3% 0.182 276.935)",
    500: "oklch(58.5% 0.233 277.117)",
    600: "oklch(51.1% 0.262 276.966)",
    700: "oklch(45.7% 0.24 277.023)",
    800: "oklch(39.8% 0.195 277.366)",
    900: "oklch(35.9% 0.144 278.697)",
    950: "oklch(25.7% 0.09 281.288)"
  },
  violet: {
    50: "oklch(96.9% 0.016 293.756)",
    100: "oklch(94.3% 0.029 294.588)",
    200: "oklch(89.4% 0.057 293.283)",
    300: "oklch(81.1% 0.111 293.571)",
    400: "oklch(70.2% 0.183 293.541)",
    500: "oklch(60.6% 0.25 292.717)",
    600: "oklch(54.1% 0.281 293.009)",
    700: "oklch(49.1% 0.27 292.581)",
    800: "oklch(43.2% 0.232 292.759)",
    900: "oklch(38% 0.189 293.745)",
    950: "oklch(28.3% 0.141 291.089)"
  },
  purple: {
    50: "oklch(97.7% 0.014 308.299)",
    100: "oklch(94.6% 0.033 307.174)",
    200: "oklch(90.2% 0.063 306.703)",
    300: "oklch(82.7% 0.119 306.383)",
    400: "oklch(71.4% 0.203 305.504)",
    500: "oklch(62.7% 0.265 303.9)",
    600: "oklch(55.8% 0.288 302.321)",
    700: "oklch(49.6% 0.265 301.924)",
    800: "oklch(43.8% 0.218 303.724)",
    900: "oklch(38.1% 0.176 304.987)",
    950: "oklch(29.1% 0.149 302.717)"
  },
  fuchsia: {
    50: "oklch(97.7% 0.017 320.058)",
    100: "oklch(95.2% 0.037 318.852)",
    200: "oklch(90.3% 0.076 319.62)",
    300: "oklch(83.3% 0.145 321.434)",
    400: "oklch(74% 0.238 322.16)",
    500: "oklch(66.7% 0.295 322.15)",
    600: "oklch(59.1% 0.293 322.896)",
    700: "oklch(51.8% 0.253 323.949)",
    800: "oklch(45.2% 0.211 324.591)",
    900: "oklch(40.1% 0.17 325.612)",
    950: "oklch(29.3% 0.136 325.661)"
  },
  pink: {
    50: "oklch(97.1% 0.014 343.198)",
    100: "oklch(94.8% 0.028 342.258)",
    200: "oklch(89.9% 0.061 343.231)",
    300: "oklch(82.3% 0.12 346.018)",
    400: "oklch(71.8% 0.202 349.761)",
    500: "oklch(65.6% 0.241 354.308)",
    600: "oklch(59.2% 0.249 0.584)",
    700: "oklch(52.5% 0.223 3.958)",
    800: "oklch(45.9% 0.187 3.815)",
    900: "oklch(40.8% 0.153 2.432)",
    950: "oklch(28.4% 0.109 3.907)"
  },
  rose: {
    50: "oklch(96.9% 0.015 12.422)",
    100: "oklch(94.1% 0.03 12.58)",
    200: "oklch(89.2% 0.058 10.001)",
    300: "oklch(81% 0.117 11.638)",
    400: "oklch(71.2% 0.194 13.428)",
    500: "oklch(64.5% 0.246 16.439)",
    600: "oklch(58.6% 0.253 17.585)",
    700: "oklch(51.4% 0.222 16.935)",
    800: "oklch(45.5% 0.188 13.697)",
    900: "oklch(41% 0.159 10.272)",
    950: "oklch(27.1% 0.105 12.094)"
  },
  light: {
    50: "oklch(99.4% 0 0)",
    100: "oklch(99.11% 0 0)",
    200: "oklch(98.51% 0 0)",
    300: "oklch(98.16% 0.0017 247.84)",
    400: "oklch(97.31% 0 0)",
    500: "oklch(96.12% 0 0)",
    600: "oklch(96.32% 0.0034 247.86)",
    700: "oklch(94.17% 0.0052 247.88)",
    800: "oklch(91.09% 0.007 247.9)",
    900: "oklch(90.72% 0.0051 228.82)",
    950: "oklch(89.23% 0.006 239.83)"
  },
  dark: {
    50: "oklch(40.91% 0 0)",
    100: "oklch(35.62% 0 0)",
    200: "oklch(31.71% 0 0)",
    300: "oklch(29.72% 0 0)",
    400: "oklch(25.2% 0 0)",
    500: "oklch(23.93% 0 0)",
    600: "oklch(22.73% 0.0038 286.09)",
    700: "oklch(22.21% 0 0)",
    800: "oklch(20.9% 0 0)",
    900: "oklch(16.84% 0 0)",
    950: "oklch(13.44% 0 0)"
  }
};
Object.values(colors2).forEach((color) => {
  if (typeof color !== "string" && color !== void 0) color.DEFAULT = color.DEFAULT || color[400];
});

// node_modules/@unocss/preset-wind4/dist/theme.mjs
var animation = {
  keyframes: {
    "pulse": "{0%, 100% {opacity:1} 50% {opacity:.5}}",
    "bounce": "{0%, 100% {transform:translateY(-25%);animation-timing-function:cubic-bezier(0.8,0,1,1)} 50% {transform:translateY(0);animation-timing-function:cubic-bezier(0,0,0.2,1)}}",
    "spin": "{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}",
    "ping": "{0%{transform:scale(1);opacity:1}75%,100%{transform:scale(2);opacity:0}}",
    "bounce-alt": "{from,20%,53%,80%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1);transform:translate3d(0,0,0)}40%,43%{animation-timing-function:cubic-bezier(0.755,0.05,0.855,0.06);transform:translate3d(0,-30px,0)}70%{animation-timing-function:cubic-bezier(0.755,0.05,0.855,0.06);transform:translate3d(0,-15px,0)}90%{transform:translate3d(0,-4px,0)}}",
    "flash": "{from,50%,to{opacity:1}25%,75%{opacity:0}}",
    "pulse-alt": "{from{transform:scale3d(1,1,1)}50%{transform:scale3d(1.05,1.05,1.05)}to{transform:scale3d(1,1,1)}}",
    "rubber-band": "{from{transform:scale3d(1,1,1)}30%{transform:scale3d(1.25,0.75,1)}40%{transform:scale3d(0.75,1.25,1)}50%{transform:scale3d(1.15,0.85,1)}65%{transform:scale3d(0.95,1.05,1)}75%{transform:scale3d(1.05,0.95,1)}to{transform:scale3d(1,1,1)}}",
    "shake-x": "{from,to{transform:translate3d(0,0,0)}10%,30%,50%,70%,90%{transform:translate3d(-10px,0,0)}20%,40%,60%,80%{transform:translate3d(10px,0,0)}}",
    "shake-y": "{from,to{transform:translate3d(0,0,0)}10%,30%,50%,70%,90%{transform:translate3d(0,-10px,0)}20%,40%,60%,80%{transform:translate3d(0,10px,0)}}",
    "head-shake": "{0%{transform:translateX(0)}6.5%{transform:translateX(-6px) rotateY(-9deg)}18.5%{transform:translateX(5px) rotateY(7deg)}31.5%{transform:translateX(-3px) rotateY(-5deg)}43.5%{transform:translateX(2px) rotateY(3deg)}50%{transform:translateX(0)}}",
    "swing": "{20%{transform:rotate3d(0,0,1,15deg)}40%{transform:rotate3d(0,0,1,-10deg)}60%{transform:rotate3d(0,0,1,5deg)}80%{transform:rotate3d(0,0,1,-5deg)}to{transform:rotate3d(0,0,1,0deg)}}",
    "tada": "{from{transform:scale3d(1,1,1)}10%,20%{transform:scale3d(0.9,0.9,0.9) rotate3d(0,0,1,-3deg)}30%,50%,70%,90%{transform:scale3d(1.1,1.1,1.1) rotate3d(0,0,1,3deg)}40%,60%,80%{transform:scale3d(1.1,1.1,1.1) rotate3d(0,0,1,-3deg)}to{transform:scale3d(1,1,1)}}",
    "wobble": "{from{transform:translate3d(0,0,0)}15%{transform:translate3d(-25%,0,0) rotate3d(0,0,1,-5deg)}30%{transform:translate3d(20%,0,0) rotate3d(0,0,1,3deg)}45%{transform:translate3d(-15%,0,0) rotate3d(0,0,1,-3deg)}60%{transform:translate3d(10%,0,0) rotate3d(0,0,1,2deg)}75%{transform:translate3d(-5%,0,0) rotate3d(0,0,1,-1deg)}to{transform:translate3d(0,0,0)}}",
    "jello": "{from,11.1%,to{transform:translate3d(0,0,0)}22.2%{transform:skewX(-12.5deg) skewY(-12.5deg)}33.3%{transform:skewX(6.25deg) skewY(6.25deg)}44.4%{transform:skewX(-3.125deg)skewY(-3.125deg)}55.5%{transform:skewX(1.5625deg) skewY(1.5625deg)}66.6%{transform:skewX(-0.78125deg) skewY(-0.78125deg)}77.7%{transform:skewX(0.390625deg) skewY(0.390625deg)}88.8%{transform:skewX(-0.1953125deg) skewY(-0.1953125deg)}}",
    "heart-beat": "{0%{transform:scale(1)}14%{transform:scale(1.3)}28%{transform:scale(1)}42%{transform:scale(1.3)}70%{transform:scale(1)}}",
    "hinge": "{0%{transform-origin:top left;animation-timing-function:ease-in-out}20%,60%{transform:rotate3d(0,0,1,80deg);transform-origin:top left;animation-timing-function:ease-in-out}40%,80%{transform:rotate3d(0,0,1,60deg);transform-origin:top left;animation-timing-function:ease-in-out}to{transform:translate3d(0,700px,0);opacity:0}}",
    "jack-in-the-box": "{from{opacity:0;transform-origin:center bottom;transform:scale(0.1) rotate(30deg)}50%{transform:rotate(-10deg)}70%{transform:rotate(3deg)}to{transform:scale(1)}}",
    "light-speed-in-left": "{from{opacity:0;transform:translate3d(-100%,0,0) skewX(-30deg)}60%{opacity:1;transform:skewX(20deg)}80%{transform:skewX(-5deg)}to{transform:translate3d(0,0,0)}}",
    "light-speed-in-right": "{from{opacity:0;transform:translate3d(100%,0,0) skewX(-30deg)}60%{opacity:1;transform:skewX(20deg)}80%{transform:skewX(-5deg)}to{transform:translate3d(0,0,0)}}",
    "light-speed-out-left": "{from{opacity:1}to{opacity:0;transform:translate3d(-100%,0,0) skewX(30deg)}}",
    "light-speed-out-right": "{from{opacity:1}to{opacity:0;transform:translate3d(100%,0,0) skewX(30deg)}}",
    "flip": "{from{transform:perspective(400px) scale3d(1,1,1) translate3d(0,0,0) rotate3d(0,1,0,-360deg);animation-timing-function:ease-out}40%{transform:perspective(400px) scale3d(1,1,1) translate3d(0,0,150px) rotate3d(0,1,0,-190deg);animation-timing-function:ease-out}50%{transform:perspective(400px) scale3d(1,1,1) translate3d(0,0,150px) rotate3d(0,1,0,-170deg);animation-timing-function:ease-in}80%{transform:perspective(400px) scale3d(0.95,0.95,0.95) translate3d(0,0,0) rotate3d(0,1,0,0deg);animation-timing-function:ease-in}to{transform:perspective(400px) scale3d(1,1,1) translate3d(0,0,0) rotate3d(0,1,0,0deg);animation-timing-function:ease-in}}",
    "flip-in-x": "{from{transform:perspective(400px) rotate3d(1,0,0,90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotate3d(1,0,0,-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotate3d(1,0,0,10deg);opacity:1}80%{transform:perspective(400px) rotate3d(1,0,0,-5deg)}to{transform:perspective(400px)}}",
    "flip-in-y": "{from{transform:perspective(400px) rotate3d(0,1,0,90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotate3d(0,1,0,-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotate3d(0,1,0,10deg);opacity:1}80%{transform:perspective(400px) rotate3d(0,1,0,-5deg)}to{transform:perspective(400px)}}",
    "flip-out-x": "{from{transform:perspective(400px)}30%{transform:perspective(400px) rotate3d(1,0,0,-20deg);opacity:1}to{transform:perspective(400px) rotate3d(1,0,0,90deg);opacity:0}}",
    "flip-out-y": "{from{transform:perspective(400px)}30%{transform:perspective(400px) rotate3d(0,1,0,-15deg);opacity:1}to{transform:perspective(400px) rotate3d(0,1,0,90deg);opacity:0}}",
    "rotate-in": "{from{transform-origin:center;transform:rotate3d(0,0,1,-200deg);opacity:0}to{transform-origin:center;transform:translate3d(0,0,0);opacity:1}}",
    "rotate-in-down-left": "{from{transform-origin:left bottom;transform:rotate3d(0,0,1,-45deg);opacity:0}to{transform-origin:left bottom;transform:translate3d(0,0,0);opacity:1}}",
    "rotate-in-down-right": "{from{transform-origin:right bottom;transform:rotate3d(0,0,1,45deg);opacity:0}to{transform-origin:right bottom;transform:translate3d(0,0,0);opacity:1}}",
    "rotate-in-up-left": "{from{transform-origin:left top;transform:rotate3d(0,0,1,45deg);opacity:0}to{transform-origin:left top;transform:translate3d(0,0,0);opacity:1}}",
    "rotate-in-up-right": "{from{transform-origin:right bottom;transform:rotate3d(0,0,1,-90deg);opacity:0}to{transform-origin:right bottom;transform:translate3d(0,0,0);opacity:1}}",
    "rotate-out": "{from{transform-origin:center;opacity:1}to{transform-origin:center;transform:rotate3d(0,0,1,200deg);opacity:0}}",
    "rotate-out-down-left": "{from{transform-origin:left bottom;opacity:1}to{transform-origin:left bottom;transform:rotate3d(0,0,1,45deg);opacity:0}}",
    "rotate-out-down-right": "{from{transform-origin:right bottom;opacity:1}to{transform-origin:right bottom;transform:rotate3d(0,0,1,-45deg);opacity:0}}",
    "rotate-out-up-left": "{from{transform-origin:left bottom;opacity:1}to{transform-origin:left bottom;transform:rotate3d(0,0,1,-45deg);opacity:0}}",
    "rotate-out-up-right": "{from{transform-origin:right bottom;opacity:1}to{transform-origin:left bottom;transform:rotate3d(0,0,1,90deg);opacity:0}}",
    "roll-in": "{from{opacity:0;transform:translate3d(-100%,0,0) rotate3d(0,0,1,-120deg)}to{opacity:1;transform:translate3d(0,0,0)}}",
    "roll-out": "{from{opacity:1}to{opacity:0;transform:translate3d(100%,0,0) rotate3d(0,0,1,120deg)}}",
    "zoom-in": "{from{opacity:0;transform:scale3d(0.3,0.3,0.3)}50%{opacity:1}}",
    "zoom-in-down": "{from{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(0,-1000px,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}60%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(0,60px,0);animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
    "zoom-in-left": "{from{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(-1000px,0,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}60%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(10px,0,0);animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
    "zoom-in-right": "{from{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(1000px,0,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}60%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(-10px,0,0);animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
    "zoom-in-up": "{from{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(0,1000px,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}60%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(0,-60px,0);animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
    "zoom-out": "{from{opacity:1}50%{opacity:0;transform:scale3d(0.3,0.3,0.3)}to{opacity:0}}",
    "zoom-out-down": "{40%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(0,-60px,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}to{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(0,2000px,0);transform-origin:center bottom;animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
    "zoom-out-left": "{40%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(42px,0,0)}to{opacity:0;transform:scale(0.1) translate3d(-2000px,0,0);transform-origin:left center}}",
    "zoom-out-right": "{40%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(-42px,0,0)}to{opacity:0;transform:scale(0.1) translate3d(2000px,0,0);transform-origin:right center}}",
    "zoom-out-up": "{40%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(0,60px,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}to{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(0,-2000px,0);transform-origin:center bottom;animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
    "bounce-in": "{from,20%,40%,60%,80%,to{animation-timing-function:ease-in-out}0%{opacity:0;transform:scale3d(0.3,0.3,0.3)}20%{transform:scale3d(1.1,1.1,1.1)}40%{transform:scale3d(0.9,0.9,0.9)}60%{transform:scale3d(1.03,1.03,1.03);opacity:1}80%{transform:scale3d(0.97,0.97,0.97)}to{opacity:1;transform:scale3d(1,1,1)}}",
    "bounce-in-down": "{from,60%,75%,90%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1)}0%{opacity:0;transform:translate3d(0,-3000px,0)}60%{opacity:1;transform:translate3d(0,25px,0)}75%{transform:translate3d(0,-10px,0)}90%{transform:translate3d(0,5px,0)}to{transform:translate3d(0,0,0)}}",
    "bounce-in-left": "{from,60%,75%,90%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1)}0%{opacity:0;transform:translate3d(-3000px,0,0)}60%{opacity:1;transform:translate3d(25px,0,0)}75%{transform:translate3d(-10px,0,0)}90%{transform:translate3d(5px,0,0)}to{transform:translate3d(0,0,0)}}",
    "bounce-in-right": "{from,60%,75%,90%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1)}0%{opacity:0;transform:translate3d(3000px,0,0)}60%{opacity:1;transform:translate3d(-25px,0,0)}75%{transform:translate3d(10px,0,0)}90%{transform:translate3d(-5px,0,0)}to{transform:translate3d(0,0,0)}}",
    "bounce-in-up": "{from,60%,75%,90%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1)}0%{opacity:0;transform:translate3d(0,3000px,0)}60%{opacity:1;transform:translate3d(0,-20px,0)}75%{transform:translate3d(0,10px,0)}90%{transform:translate3d(0,-5px,0)}to{transform:translate3d(0,0,0)}}",
    "bounce-out": "{20%{transform:scale3d(0.9,0.9,0.9)}50%,55%{opacity:1;transform:scale3d(1.1,1.1,1.1)}to{opacity:0;transform:scale3d(0.3,0.3,0.3)}}",
    "bounce-out-down": "{20%{transform:translate3d(0,10px,0)}40%,45%{opacity:1;transform:translate3d(0,-20px,0)}to{opacity:0;transform:translate3d(0,2000px,0)}}",
    "bounce-out-left": "{20%{opacity:1;transform:translate3d(20px,0,0)}to{opacity:0;transform:translate3d(-2000px,0,0)}}",
    "bounce-out-right": "{20%{opacity:1;transform:translate3d(-20px,0,0)}to{opacity:0;transform:translate3d(2000px,0,0)}}",
    "bounce-out-up": "{20%{transform:translate3d(0,-10px,0)}40%,45%{opacity:1;transform:translate3d(0,20px,0)}to{opacity:0;transform:translate3d(0,-2000px,0)}}",
    "slide-in-down": "{from{transform:translate3d(0,-100%,0);visibility:visible}to{transform:translate3d(0,0,0)}}",
    "slide-in-left": "{from{transform:translate3d(-100%,0,0);visibility:visible}to{transform:translate3d(0,0,0)}}",
    "slide-in-right": "{from{transform:translate3d(100%,0,0);visibility:visible}to{transform:translate3d(0,0,0)}}",
    "slide-in-up": "{from{transform:translate3d(0,100%,0);visibility:visible}to{transform:translate3d(0,0,0)}}",
    "slide-out-down": "{from{transform:translate3d(0,0,0)}to{visibility:hidden;transform:translate3d(0,100%,0)}}",
    "slide-out-left": "{from{transform:translate3d(0,0,0)}to{visibility:hidden;transform:translate3d(-100%,0,0)}}",
    "slide-out-right": "{from{transform:translate3d(0,0,0)}to{visibility:hidden;transform:translate3d(100%,0,0)}}",
    "slide-out-up": "{from{transform:translate3d(0,0,0)}to{visibility:hidden;transform:translate3d(0,-100%,0)}}",
    "fade-in": "{from{opacity:0}to{opacity:1}}",
    "fade-in-down": "{from{opacity:0;transform:translate3d(0,-100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
    "fade-in-down-big": "{from{opacity:0;transform:translate3d(0,-2000px,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
    "fade-in-left": "{from{opacity:0;transform:translate3d(-100%,0,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
    "fade-in-left-big": "{from{opacity:0;transform:translate3d(-2000px,0,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
    "fade-in-right": "{from{opacity:0;transform:translate3d(100%,0,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
    "fade-in-right-big": "{from{opacity:0;transform:translate3d(2000px,0,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
    "fade-in-up": "{from{opacity:0;transform:translate3d(0,100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
    "fade-in-up-big": "{from{opacity:0;transform:translate3d(0,2000px,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
    "fade-in-top-left": "{from{opacity:0;transform:translate3d(-100%,-100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
    "fade-in-top-right": "{from{opacity:0;transform:translate3d(100%,-100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
    "fade-in-bottom-left": "{from{opacity:0;transform:translate3d(-100%,100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
    "fade-in-bottom-right": "{from{opacity:0;transform:translate3d(100%,100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
    "fade-out": "{from{opacity:1}to{opacity:0}}",
    "fade-out-down": "{from{opacity:1}to{opacity:0;transform:translate3d(0,100%,0)}}",
    "fade-out-down-big": "{from{opacity:1}to{opacity:0;transform:translate3d(0,2000px,0)}}",
    "fade-out-left": "{from{opacity:1}to{opacity:0;transform:translate3d(-100%,0,0)}}",
    "fade-out-left-big": "{from{opacity:1}to{opacity:0;transform:translate3d(-2000px,0,0)}}",
    "fade-out-right": "{from{opacity:1}to{opacity:0;transform:translate3d(100%,0,0)}}",
    "fade-out-right-big": "{from{opacity:1}to{opacity:0;transform:translate3d(2000px,0,0)}}",
    "fade-out-up": "{from{opacity:1}to{opacity:0;transform:translate3d(0,-100%,0)}}",
    "fade-out-up-big": "{from{opacity:1}to{opacity:0;transform:translate3d(0,-2000px,0)}}",
    "fade-out-top-left": "{from{opacity:1;transform:translate3d(0,0,0)}to{opacity:0;transform:translate3d(-100%,-100%,0)}}",
    "fade-out-top-right": "{from{opacity:1;transform:translate3d(0,0,0)}to{opacity:0;transform:translate3d(100%,-100%,0)}}",
    "fade-out-bottom-left": "{from{opacity:1;transform:translate3d(0,0,0)}to{opacity:0;transform:translate3d(-100%,100%,0)}}",
    "fade-out-bottom-right": "{from{opacity:1;transform:translate3d(0,0,0)}to{opacity:0;transform:translate3d(100%,100%,0)}}",
    "back-in-up": "{0%{opacity:0.7;transform:translateY(1200px) scale(0.7)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:1;transform:scale(1)}}",
    "back-in-down": "{0%{opacity:0.7;transform:translateY(-1200px) scale(0.7)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:1;transform:scale(1)}}",
    "back-in-right": "{0%{opacity:0.7;transform:translateX(2000px) scale(0.7)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:1;transform:scale(1)}}",
    "back-in-left": "{0%{opacity:0.7;transform:translateX(-2000px) scale(0.7)}80%{opacity:0.7;transform:translateX(0px) scale(0.7)}100%{opacity:1;transform:scale(1)}}",
    "back-out-up": "{0%{opacity:1;transform:scale(1)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:0.7;transform:translateY(-700px) scale(0.7)}}",
    "back-out-down": "{0%{opacity:1;transform:scale(1)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:0.7;transform:translateY(700px) scale(0.7)}}",
    "back-out-right": "{0%{opacity:1;transform:scale(1)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:0.7;transform:translateX(2000px) scale(0.7)}}",
    "back-out-left": "{0%{opacity:1;transform:scale(1)}80%{opacity:0.7;transform:translateX(-2000px) scale(0.7)}100%{opacity:0.7;transform:translateY(-700px) scale(0.7)}}"
  },
  durations: {
    "pulse": "2s",
    "heart-beat": "1.3s",
    "bounce-in": "0.75s",
    "bounce-out": "0.75s",
    "flip-out-x": "0.75s",
    "flip-out-y": "0.75s",
    "hinge": "2s"
  },
  timingFns: {
    "pulse": "cubic-bezier(0.4,0,.6,1)",
    "ping": "cubic-bezier(0,0,.2,1)",
    "head-shake": "ease-in-out",
    "heart-beat": "ease-in-out",
    "pulse-alt": "ease-in-out",
    "light-speed-in-left": "ease-out",
    "light-speed-in-right": "ease-out",
    "light-speed-out-left": "ease-in",
    "light-speed-out-right": "ease-in"
  },
  properties: {
    "bounce-alt": { "transform-origin": "center bottom" },
    "jello": { "transform-origin": "center" },
    "swing": { "transform-origin": "top center" },
    "flip": { "backface-visibility": "visible" },
    "flip-in-x": { "backface-visibility": "visible !important" },
    "flip-in-y": { "backface-visibility": "visible !important" },
    "flip-out-x": { "backface-visibility": "visible !important" },
    "flip-out-y": { "backface-visibility": "visible !important" },
    "rotate-in": { "transform-origin": "center" },
    "rotate-in-down-left": { "transform-origin": "left bottom" },
    "rotate-in-down-right": { "transform-origin": "right bottom" },
    "rotate-in-up-left": { "transform-origin": "left bottom" },
    "rotate-in-up-right": { "transform-origin": "right bottom" },
    "rotate-out": { "transform-origin": "center" },
    "rotate-out-down-left": { "transform-origin": "left bottom" },
    "rotate-out-down-right": { "transform-origin": "right bottom" },
    "rotate-out-up-left": { "transform-origin": "left bottom" },
    "rotate-out-up-right": { "transform-origin": "right bottom" },
    "hinge": { "transform-origin": "top left" },
    "zoom-out-down": { "transform-origin": "center bottom" },
    "zoom-out-left": { "transform-origin": "left center" },
    "zoom-out-right": { "transform-origin": "right center" },
    "zoom-out-up": { "transform-origin": "center bottom" }
  },
  counts: {
    "spin": "infinite",
    "ping": "infinite",
    "pulse": "infinite",
    "pulse-alt": "infinite",
    "bounce": "infinite",
    "bounce-alt": "infinite"
  },
  category: {
    "pulse": "Attention Seekers",
    "bounce": "Attention Seekers",
    "spin": "Attention Seekers",
    "ping": "Attention Seekers",
    "bounce-alt": "Attention Seekers",
    "flash": "Attention Seekers",
    "pulse-alt": "Attention Seekers",
    "rubber-band": "Attention Seekers",
    "shake-x": "Attention Seekers",
    "shake-y": "Attention Seekers",
    "head-shake": "Attention Seekers",
    "swing": "Attention Seekers",
    "tada": "Attention Seekers",
    "wobble": "Attention Seekers",
    "jello": "Attention Seekers",
    "heart-beat": "Attention Seekers",
    "hinge": "Specials",
    "jack-in-the-box": "Specials",
    "light-speed-in-left": "Lightspeed",
    "light-speed-in-right": "Lightspeed",
    "light-speed-out-left": "Lightspeed",
    "light-speed-out-right": "Lightspeed",
    "flip": "Flippers",
    "flip-in-x": "Flippers",
    "flip-in-y": "Flippers",
    "flip-out-x": "Flippers",
    "flip-out-y": "Flippers",
    "rotate-in": "Rotating Entrances",
    "rotate-in-down-left": "Rotating Entrances",
    "rotate-in-down-right": "Rotating Entrances",
    "rotate-in-up-left": "Rotating Entrances",
    "rotate-in-up-right": "Rotating Entrances",
    "rotate-out": "Rotating Exits",
    "rotate-out-down-left": "Rotating Exits",
    "rotate-out-down-right": "Rotating Exits",
    "rotate-out-up-left": "Rotating Exits",
    "rotate-out-up-right": "Rotating Exits",
    "roll-in": "Specials",
    "roll-out": "Specials",
    "zoom-in": "Zooming Entrances",
    "zoom-in-down": "Zooming Entrances",
    "zoom-in-left": "Zooming Entrances",
    "zoom-in-right": "Zooming Entrances",
    "zoom-in-up": "Zooming Entrances",
    "zoom-out": "Zooming Exits",
    "zoom-out-down": "Zooming Exits",
    "zoom-out-left": "Zooming Exits",
    "zoom-out-right": "Zooming Exits",
    "zoom-out-up": "Zooming Exits",
    "bounce-in": "Bouncing Entrances",
    "bounce-in-down": "Bouncing Entrances",
    "bounce-in-left": "Bouncing Entrances",
    "bounce-in-right": "Bouncing Entrances",
    "bounce-in-up": "Bouncing Entrances",
    "bounce-out": "Bouncing Exits",
    "bounce-out-down": "Bouncing Exits",
    "bounce-out-left": "Bouncing Exits",
    "bounce-out-right": "Bouncing Exits",
    "bounce-out-up": "Bouncing Exits",
    "slide-in-down": "Sliding Entrances",
    "slide-in-left": "Sliding Entrances",
    "slide-in-right": "Sliding Entrances",
    "slide-in-up": "Sliding Entrances",
    "slide-out-down": "Sliding Exits",
    "slide-out-left": "Sliding Exits",
    "slide-out-right": "Sliding Exits",
    "slide-out-up": "Sliding Exits",
    "fade-in": "Fading Entrances",
    "fade-in-down": "Fading Entrances",
    "fade-in-down-big": "Fading Entrances",
    "fade-in-left": "Fading Entrances",
    "fade-in-left-big": "Fading Entrances",
    "fade-in-right": "Fading Entrances",
    "fade-in-right-big": "Fading Entrances",
    "fade-in-up": "Fading Entrances",
    "fade-in-up-big": "Fading Entrances",
    "fade-in-top-left": "Fading Entrances",
    "fade-in-top-right": "Fading Entrances",
    "fade-in-bottom-left": "Fading Entrances",
    "fade-in-bottom-right": "Fading Entrances",
    "fade-out": "Fading Exits",
    "fade-out-down": "Fading Exits",
    "fade-out-down-big": "Fading Exits",
    "fade-out-left": "Fading Exits",
    "fade-out-left-big": "Fading Exits",
    "fade-out-right": "Fading Exits",
    "fade-out-right-big": "Fading Exits",
    "fade-out-up": "Fading Exits",
    "fade-out-up-big": "Fading Exits",
    "fade-out-top-left": "Fading Exits",
    "fade-out-top-right": "Fading Exits",
    "fade-out-bottom-left": "Fading Exits",
    "fade-out-bottom-right": "Fading Exits",
    "back-in-up": "Back Entrances",
    "back-in-down": "Back Entrances",
    "back-in-right": "Back Entrances",
    "back-in-left": "Back Entrances",
    "back-out-up": "Back Exits",
    "back-out-down": "Back Exits",
    "back-out-right": "Back Exits",
    "back-out-left": "Back Exits"
  }
};
var aria = {
  busy: 'busy="true"',
  checked: 'checked="true"',
  disabled: 'disabled="true"',
  expanded: 'expanded="true"',
  hidden: 'hidden="true"',
  pressed: 'pressed="true"',
  readonly: 'readonly="true"',
  required: 'required="true"',
  selected: 'selected="true"'
};
var blur2 = {
  "DEFAULT": "8px",
  "xs": "4px",
  "sm": "8px",
  "md": "12px",
  "lg": "16px",
  "xl": "24px",
  "2xl": "40px",
  "3xl": "64px"
};
var font = {
  sans: [
    "ui-sans-serif",
    "system-ui",
    "-apple-system",
    "BlinkMacSystemFont",
    '"Segoe UI"',
    "Roboto",
    '"Helvetica Neue"',
    "Arial",
    '"Noto Sans"',
    "sans-serif",
    '"Apple Color Emoji"',
    '"Segoe UI Emoji"',
    '"Segoe UI Symbol"',
    '"Noto Color Emoji"'
  ].join(","),
  serif: [
    "ui-serif",
    "Georgia",
    "Cambria",
    '"Times New Roman"',
    "Times",
    "serif"
  ].join(","),
  mono: [
    "ui-monospace",
    "SFMono-Regular",
    "Menlo",
    "Monaco",
    "Consolas",
    '"Liberation Mono"',
    '"Courier New"',
    "monospace"
  ].join(",")
};
var text = {
  "xs": {
    fontSize: "0.75rem",
    lineHeight: "1rem"
  },
  "sm": {
    fontSize: "0.875rem",
    lineHeight: "1.25rem"
  },
  "base": {
    fontSize: "1rem",
    lineHeight: "1.5rem"
  },
  "lg": {
    fontSize: "1.125rem",
    lineHeight: "1.75rem"
  },
  "xl": {
    fontSize: "1.25rem",
    lineHeight: "1.75rem"
  },
  "2xl": {
    fontSize: "1.5rem",
    lineHeight: "2rem"
  },
  "3xl": {
    fontSize: "1.875rem",
    lineHeight: "2.25rem"
  },
  "4xl": {
    fontSize: "2.25rem",
    lineHeight: "2.5rem"
  },
  "5xl": {
    fontSize: "3rem",
    lineHeight: "1"
  },
  "6xl": {
    fontSize: "3.75rem",
    lineHeight: "1"
  },
  "7xl": {
    fontSize: "4.5rem",
    lineHeight: "1"
  },
  "8xl": {
    fontSize: "6rem",
    lineHeight: "1"
  },
  "9xl": {
    fontSize: "8rem",
    lineHeight: "1"
  }
};
var fontWeight2 = {
  thin: "100",
  extralight: "200",
  light: "300",
  normal: "400",
  medium: "500",
  semibold: "600",
  bold: "700",
  extrabold: "800",
  black: "900"
};
var tracking = {
  tighter: "-0.05em",
  tight: "-0.025em",
  normal: "0em",
  wide: "0.025em",
  wider: "0.05em",
  widest: "0.1em"
};
var leading = {
  none: "1",
  tight: "1.25",
  snug: "1.375",
  normal: "1.5",
  relaxed: "1.625",
  loose: "2"
};
var textStrokeWidth2 = {
  DEFAULT: "1.5rem",
  none: "0",
  sm: "thin",
  md: "medium",
  lg: "thick"
};
var media2 = {
  portrait: "(orientation: portrait)",
  landscape: "(orientation: landscape)",
  os_dark: "(prefers-color-scheme: dark)",
  os_light: "(prefers-color-scheme: light)",
  motion_ok: "(prefers-reduced-motion: no-preference)",
  motion_not_ok: "(prefers-reduced-motion: reduce)",
  high_contrast: "(prefers-contrast: high)",
  low_contrast: "(prefers-contrast: low)",
  opacity_ok: "(prefers-reduced-transparency: no-preference)",
  opacity_not_ok: "(prefers-reduced-transparency: reduce)",
  use_data_ok: "(prefers-reduced-data: no-preference)",
  use_data_not_ok: "(prefers-reduced-data: reduce)",
  touch: "(hover: none) and (pointer: coarse)",
  stylus: "(hover: none) and (pointer: fine)",
  pointer: "(hover) and (pointer: coarse)",
  mouse: "(hover) and (pointer: fine)",
  hd_color: "(dynamic-range: high)"
};
var spacing2 = {
  "DEFAULT": "0.25rem",
  "xs": "0.75rem",
  "sm": "0.875rem",
  "lg": "1.125rem",
  "xl": "1.25rem",
  "2xl": "1.5rem",
  "3xl": "1.875rem",
  "4xl": "2.25rem",
  "5xl": "3rem",
  "6xl": "3.75rem",
  "7xl": "4.5rem",
  "8xl": "6rem",
  "9xl": "8rem"
};
var radius = {
  "DEFAULT": "0.25rem",
  "none": "0",
  "xs": "0.125rem",
  "sm": "0.25rem",
  "md": "0.375rem",
  "lg": "0.5rem",
  "xl": "0.75rem",
  "2xl": "1rem",
  "3xl": "1.5rem",
  "4xl": "2rem"
};
var shadow = {
  "DEFAULT": [`0 1px 3px 0 rgb(0 0 0 / 0.1)`, `0 1px 2px -1px rgb(0 0 0 / 0.1)`],
  "2xs": `0 1px rgb(0 0 0 / 0.05)`,
  "xs": `0 1px 2px 0 rgb(0 0 0 / 0.05)`,
  "sm": [`0 1px 3px 0 rgb(0 0 0 / 0.1)`, `0 1px 2px -1px rgb(0 0 0 / 0.1)`],
  "md": [`0 4px 6px -1px rgb(0 0 0 / 0.1)`, `0 2px 4px -2px rgb(0 0 0 / 0.1)`],
  "lg": [`0 10px 15px -3px rgb(0 0 0 / 0.1)`, `0 4px 6px -4px rgb(0 0 0 / 0.1)`],
  "xl": [`0 20px 25px -5px rgb(0 0 0 / 0.1)`, `0 8px 10px -6px rgb(0 0 0 / 0.1)`],
  "2xl": `0 25px 50px -12px rgb(0 0 0 / 0.25)`,
  "none": "0 0 rgb(0 0 0 / 0)",
  "inner": "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)"
};
var insetShadow = {
  "2xs": "inset 0 1px rgb(0 0 0 / 0.05)",
  "xs": "inset 0 1px 1px rgb(0 0 0 / 0.05)",
  "sm": "inset 0 2px 4px rgb(0 0 0 / 0.05)",
  "none": "0 0 rgb(0 0 0 / 0)"
};
var dropShadow2 = {
  "DEFAULT": ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
  "xs": "0 1px 1px rgb(0 0 0 / 0.05)",
  "sm": "0 1px 2px rgb(0 0 0 / 0.15)",
  "md": "0 3px 3px rgb(0 0 0 / 0.12)",
  "lg": "0 4px 4px rgb(0 0 0 / 0.15)",
  "xl": "0 9px 7px rgb(0 0 0 / 0.1)",
  "2xl": "0 25px 25px rgb(0 0 0 / 0.15)"
};
var textShadow2 = {
  "none": "0 0 rgb(0 0 0 / 0)",
  "2xs": "0 1px 0 rgb(0 0 0 / 0.15)",
  "xs": "0 1px 1px rgb(0 0 0 / 0.2)",
  "sm": [
    "0 1px 0 rgb(0 0 0 / 0.075)",
    "0 1px 1px rgb(0 0 0 / 0.075)",
    "0 2px 2px rgb(0 0 0 / 0.075)"
  ],
  "md": [
    "0 1px 1px rgb(0 0 0 / 0.1)",
    "0 1px 2px rgb(0 0 0 / 0.1)",
    "0 2px 4px rgb(0 0 0 / 0.1)"
  ],
  "lg": [
    "0 1px 2px rgb(0 0 0 / 0.1)",
    "0 3px 2px rgb(0 0 0 / 0.1)",
    "0 4px 8px rgb(0 0 0 / 0.1)"
  ]
};
var perspective = {
  dramatic: "100px",
  near: "300px",
  normal: "500px",
  midrange: "800px",
  distant: "1200px"
};
var defaults = {
  transition: {
    duration: "150ms",
    timingFunction: "cubic-bezier(0.4, 0, 0.2, 1)"
  },
  font: {
    family: "var(--font-sans)",
    featureSettings: "var(--font-sans--font-feature-settings)",
    variationSettings: "var(--font-sans--font-variation-settings)"
  },
  monoFont: {
    family: "var(--font-mono)",
    featureSettings: "var(--font-mono--font-feature-settings)",
    variationSettings: "var(--font-mono--font-variation-settings)"
  }
};
var container3 = {
  "3xs": "16rem",
  "2xs": "18rem",
  "xs": "20rem",
  "sm": "24rem",
  "md": "28rem",
  "lg": "32rem",
  "xl": "36rem",
  "2xl": "42rem",
  "3xl": "48rem",
  "4xl": "56rem",
  "5xl": "64rem",
  "6xl": "72rem",
  "7xl": "80rem",
  "prose": "65ch"
};
var breakpoint = {
  "sm": "40rem",
  "md": "48rem",
  "lg": "64rem",
  "xl": "80rem",
  "2xl": "96rem"
};
var verticalBreakpoint = { ...breakpoint };
var supports = { grid: "(display: grid)" };
var ease = {
  "linear": "linear",
  "in": "cubic-bezier(0.4, 0, 1, 1)",
  "out": "cubic-bezier(0, 0, 0.2, 1)",
  "in-out": "cubic-bezier(0.4, 0, 0.2, 1)",
  "DEFAULT": "cubic-bezier(0.4, 0, 0.2, 1)"
};
var property = {
  none: "none",
  all: "all",
  colors: [
    "color",
    "background-color",
    "border-color",
    "text-decoration-color",
    "fill",
    "stroke",
    "--un-gradient-from",
    "--un-gradient-via",
    "--un-gradient-to"
  ].join(","),
  opacity: "opacity",
  shadow: "box-shadow",
  transform: [
    "transform",
    "translate",
    "scale",
    "rotate"
  ].join(","),
  get DEFAULT() {
    return [
      this.colors,
      this.opacity,
      this.shadow,
      this.transform,
      "filter",
      "-webkit-backdrop-filter",
      "backdrop-filter"
    ].join(",");
  }
};
var theme3 = {
  font,
  colors: colors2,
  spacing: spacing2,
  breakpoint,
  verticalBreakpoint,
  text,
  fontWeight: fontWeight2,
  tracking,
  leading,
  textStrokeWidth: textStrokeWidth2,
  radius,
  shadow,
  insetShadow,
  dropShadow: dropShadow2,
  textShadow: textShadow2,
  ease,
  animation,
  blur: blur2,
  perspective,
  property,
  default: defaults,
  container: container3,
  aria,
  media: media2,
  supports
};

// node_modules/@unocss/preset-wind4/dist/variants-jhZqwv4U.mjs
var variantAria2 = {
  name: "aria",
  match(matcher, ctx) {
    var _a;
    const variant = variantGetParameter("aria-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const aria2 = h2.bracket(match) ?? ((_a = ctx.theme.aria) == null ? void 0 : _a[match]) ?? "";
      if (aria2) return {
        matcher: rest,
        selector: (s) => `${s}[aria-${aria2}]`
      };
    }
  },
  multiPass: true,
  autocomplete: "aria-$aria"
};
function taggedAria2(tagName) {
  return {
    name: `${tagName}-aria`,
    match(matcher, ctx) {
      var _a;
      const variant = variantGetParameter(`${tagName}-aria-`, matcher, ctx.generator.config.separators);
      if (variant) {
        const [match, rest, label] = variant;
        const ariaAttribute = h2.bracket(match) ?? ((_a = ctx.theme.aria) == null ? void 0 : _a[match]) ?? "";
        if (ariaAttribute) {
          const tagSelectorMap = {
            group: `&:is(:where(.group${label ? `\\/${label}` : ""})[aria-${ariaAttribute}] *)`,
            peer: `&:is(:where(.peer${label ? `\\/${label}` : ""})[aria-${ariaAttribute}] ~ *)`,
            previous: `:where(*[aria-${ariaAttribute}] + &)`,
            parent: `:where(*[aria-${ariaAttribute}] > &)`,
            has: `&:has(*[aria-${ariaAttribute}])`,
            in: `:where(*[aria-${ariaAttribute}]) &`
          };
          return {
            matcher: rest,
            handle: (input, next) => next({
              ...input,
              parent: `${input.parent ? `${input.parent} $$ ` : ""}${input.selector}`,
              selector: tagSelectorMap[tagName]
            })
          };
        }
      }
    },
    multiPass: true
  };
}
var variantTaggedAriaAttributes2 = [
  taggedAria2("group"),
  taggedAria2("peer"),
  taggedAria2("parent"),
  taggedAria2("previous"),
  taggedAria2("has"),
  taggedAria2("in")
];
var sizePseudo2 = /(max|min)-\[([^\]]*)\]:/;
function variantBreakpoints2() {
  const regexCache2 = {};
  return {
    name: "breakpoints",
    match(matcher, context) {
      if (sizePseudo2.test(matcher)) {
        const match = matcher.match(sizePseudo2);
        return {
          matcher: matcher.replace(match[0], ""),
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (${match[1]}-width: ${match[2]})`
          })
        };
      }
      const variantEntries = (resolveBreakpoints2(context) ?? []).map(({ point, size }, idx) => [
        point,
        size,
        idx
      ]);
      for (const [point, size, idx] of variantEntries) {
        if (!regexCache2[point]) regexCache2[point] = new RegExp(`^((?:([al]t-|[<~]|max-))?${point}(?:${context.generator.config.separators.join("|")}))`);
        const match = matcher.match(regexCache2[point]);
        if (!match) continue;
        const [, pre] = match;
        const m = matcher.slice(pre.length);
        if (m === "container") continue;
        const isLtPrefix = pre.startsWith("lt-") || pre.startsWith("<") || pre.startsWith("max-");
        const isAtPrefix = pre.startsWith("at-") || pre.startsWith("~");
        let order = 3e3;
        if (isLtPrefix) {
          order -= idx + 1;
          return {
            matcher: m,
            handle: (input, next) => next({
              ...input,
              parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (max-width: ${calcMaxWidthBySize(size)})`,
              parentOrder: order
            })
          };
        }
        order += idx + 1;
        if (isAtPrefix && idx < variantEntries.length - 1) return {
          matcher: m,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (min-width: ${size}) and (max-width: ${calcMaxWidthBySize(variantEntries[idx + 1][1])})`,
            parentOrder: order
          })
        };
        return {
          matcher: m,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (min-width: ${size})`,
            parentOrder: order
          })
        };
      }
    },
    multiPass: true,
    autocomplete: "(at-|lt-|max-|)$breakpoint:"
  };
}
var variantChildren2 = [variantMatcher("*", (input) => ({ selector: `${input.selector} > *` }), { order: -1 }), variantMatcher("**", (input) => ({ selector: `${input.selector} *` }), { order: -1 })];
function scopeMatcher2(name50, combinator) {
  return {
    name: `combinator:${name50}`,
    match(matcher, ctx) {
      if (!matcher.startsWith(name50)) return;
      const separators = ctx.generator.config.separators;
      let body = variantGetBracket(`${name50}-`, matcher, separators);
      if (!body) {
        for (const separator of separators) if (matcher.startsWith(`${name50}${separator}`)) {
          body = ["", matcher.slice(name50.length + separator.length)];
          break;
        }
        if (!body) return;
      }
      let bracketValue = h2.bracket(body[0]) ?? "";
      if (bracketValue === "") bracketValue = "*";
      return {
        matcher: body[1],
        selector: (s) => `${s}${combinator}${bracketValue}`
      };
    },
    multiPass: true
  };
}
var variantCombinators3 = [
  scopeMatcher2("all", " "),
  scopeMatcher2("children", ">"),
  scopeMatcher2("next", "+"),
  scopeMatcher2("sibling", "+"),
  scopeMatcher2("siblings", "~")
];
var variantSvgCombinators = [variantMatcher("svg", (input) => ({ selector: `${input.selector} svg` }))];
var variantContainerQuery2 = {
  name: "@",
  match(matcher, ctx) {
    var _a;
    if (matcher.startsWith("@container")) return;
    const variant = variantGetParameter("@", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest, label] = variant;
      const unbracket = h2.bracket(match);
      let container4;
      if (unbracket) container4 = h2.numberWithUnit(unbracket);
      else container4 = ((_a = ctx.theme.container) == null ? void 0 : _a[match]) ?? "";
      if (container4) {
        let order = 1e3 + Object.keys(ctx.theme.container ?? {}).indexOf(match);
        if (label) order += 1e3;
        return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@container${label ? ` ${label} ` : " "}(min-width: ${container4})`,
            parentOrder: order
          })
        };
      }
    }
  },
  multiPass: true
};
function variantColorsMediaOrClass2(options = {}) {
  if ((options == null ? void 0 : options.dark) === "class" || typeof options.dark === "object") {
    const { dark = ".dark", light = ".light" } = typeof options.dark === "string" ? {} : options.dark;
    return [variantMatcher("dark", (input) => ({ prefix: `${dark} $$ ${input.prefix}` })), variantMatcher("light", (input) => ({ prefix: `${light} $$ ${input.prefix}` }))];
  }
  return [variantParentMatcher("dark", "@media (prefers-color-scheme: dark)"), variantParentMatcher("light", "@media (prefers-color-scheme: light)")];
}
var variantColorsScheme2 = [
  variantMatcher(".dark", (input) => ({ prefix: `.dark $$ ${input.prefix}` })),
  variantMatcher(".light", (input) => ({ prefix: `.light $$ ${input.prefix}` })),
  variantParentMatcher("@dark", "@media (prefers-color-scheme: dark)"),
  variantParentMatcher("@light", "@media (prefers-color-scheme: light)"),
  variantParentMatcher("not-dark", "@media not (prefers-color-scheme: dark)")
];
var variantDataAttribute2 = {
  name: "data",
  match(matcher, ctx) {
    var _a;
    const variant = variantGetParameter("data-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const dataAttribute = h2.bracket(match) ?? ((_a = ctx.theme.data) == null ? void 0 : _a[match]) ?? "";
      if (dataAttribute) return {
        matcher: rest,
        selector: (s) => `${s}[data-${dataAttribute}]`
      };
    }
  },
  multiPass: true
};
function taggedData2(tagName) {
  return {
    name: `${tagName}-data`,
    match(matcher, ctx) {
      var _a;
      const variant = variantGetParameter(`${tagName}-data-`, matcher, ctx.generator.config.separators);
      if (variant) {
        const [match, rest, label] = variant;
        const dataAttribute = h2.bracket(match) ?? ((_a = ctx.theme.data) == null ? void 0 : _a[match]) ?? "";
        if (dataAttribute) {
          const tagSelectorMap = {
            group: `&:is(:where(.group${label ? `\\/${label}` : ""})[data-${dataAttribute}] *)`,
            peer: `&:is(:where(.peer${label ? `\\/${label}` : ""})[data-${dataAttribute}] ~ *)`,
            previous: `:where(*[data-${dataAttribute}] + &)`,
            parent: `:where(*[data-${dataAttribute}] > &)`,
            has: `&:has(*[data-${dataAttribute}])`,
            in: `:where(*[data-${dataAttribute}]) &`
          };
          return {
            matcher: rest,
            handle: (input, next) => next({
              ...input,
              parent: `${input.parent ? `${input.parent} $$ ` : ""}${input.selector}`,
              selector: tagSelectorMap[tagName]
            })
          };
        }
      }
    },
    multiPass: true
  };
}
var variantTaggedDataAttributes2 = [
  taggedData2("group"),
  taggedData2("peer"),
  taggedData2("parent"),
  taggedData2("previous"),
  taggedData2("has"),
  taggedData2("in")
];
var variantLanguageDirections2 = [variantMatcher("rtl", (input) => ({ prefix: `[dir="rtl"] $$ ${input.prefix}` })), variantMatcher("ltr", (input) => ({ prefix: `[dir="ltr"] $$ ${input.prefix}` }))];
function variantImportant2() {
  let re;
  return {
    name: "important",
    match(matcher, ctx) {
      if (!re) re = new RegExp(`^(important(?:${ctx.generator.config.separators.join("|")})|!)`);
      let base;
      const match = matcher.match(re);
      if (match) base = matcher.slice(match[0].length);
      else if (matcher.endsWith("!")) base = matcher.slice(0, -1);
      if (base) return {
        matcher: base,
        body: (body) => {
          body.forEach((v) => {
            if (v[1] != null) v[1] += " !important";
          });
          return body;
        }
      };
    }
  };
}
var variantInert = variantMatcher("inert", (input) => ({
  parent: `${input.parent ? `${input.parent} $$ ` : ""}${input.selector}`,
  selector: "&:is([inert],[inert] *)"
}));
var variantNoscript = variantParentMatcher("noscript", "@media (scripting: none)");
var variantScripting = {
  name: "scripting",
  match(matcher, ctx) {
    const variant = variantGetParameter(["script-", "scripting-"], matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      if ([
        "none",
        "initial-only",
        "enabled"
      ].includes(match)) return {
        matcher: rest,
        handle: (input, next) => next({
          ...input,
          parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (scripting: ${match})`
        })
      };
    }
  },
  multiPass: true,
  autocomplete: ["(scripting|script)-(none|initial-only|enabled)"]
};
var variantPrint2 = variantParentMatcher("print", "@media print");
var variantCustomMedia2 = {
  name: "media",
  match(matcher, ctx) {
    var _a;
    const variant = variantGetParameter("media-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      let media3 = h2.bracket(match) ?? "";
      if (media3 === "") media3 = ((_a = ctx.theme.media) == null ? void 0 : _a[match]) ?? "";
      if (media3) return {
        matcher: rest,
        handle: (input, next) => next({
          ...input,
          parent: `${input.parent ? `${input.parent} $$ ` : ""}@media ${media3}`
        })
      };
    }
  },
  multiPass: true,
  autocomplete: "media-$media"
};
var variantContrasts2 = [variantParentMatcher("contrast-more", "@media (prefers-contrast: more)"), variantParentMatcher("contrast-less", "@media (prefers-contrast: less)")];
var variantMotions2 = [variantParentMatcher("motion-reduce", "@media (prefers-reduced-motion: reduce)"), variantParentMatcher("motion-safe", "@media (prefers-reduced-motion: no-preference)")];
var variantOrientations2 = [variantParentMatcher("landscape", "@media (orientation: landscape)"), variantParentMatcher("portrait", "@media (orientation: portrait)")];
var variantForcedColors = [variantParentMatcher("forced-colors", "@media (forced-colors: active)")];
var variantSelector2 = {
  name: "selector",
  match(matcher, ctx) {
    const variant = variantGetBracket("selector-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const selector2 = h2.bracket(match);
      if (selector2) return {
        matcher: rest,
        selector: () => selector2
      };
    }
  }
};
var variantCssLayer2 = {
  name: "layer",
  match(matcher, ctx) {
    const variant = variantGetParameter("layer-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const layer = h2.bracket(match) ?? match;
      if (layer) return {
        matcher: rest,
        handle: (input, next) => next({
          ...input,
          parent: `${input.parent ? `${input.parent} $$ ` : ""}@layer ${layer}`
        })
      };
    }
  }
};
var variantInternalLayer2 = {
  name: "uno-layer",
  match(matcher, ctx) {
    const variant = variantGetParameter("uno-layer-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const layer = h2.bracket(match) ?? match;
      if (layer) return {
        matcher: rest,
        layer
      };
    }
  }
};
var variantScope2 = {
  name: "scope",
  match(matcher, ctx) {
    const variant = variantGetBracket("scope-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const scope = h2.bracket(match);
      if (scope) return {
        matcher: rest,
        selector: (s) => `${scope} $$ ${s}`
      };
    }
  }
};
var variantVariables2 = {
  name: "variables",
  match(matcher, ctx) {
    if (!matcher.startsWith("[")) return;
    const [match, rest] = getBracket(matcher, "[", "]") ?? [];
    if (!(match && rest)) return;
    let newMatcher;
    for (const separator of ctx.generator.config.separators) if (rest.startsWith(separator)) {
      newMatcher = rest.slice(separator.length);
      break;
    }
    if (newMatcher == null) return;
    const variant = h2.bracket(match) ?? "";
    const useParent = variant.startsWith("@");
    if (!(useParent || variant.includes("&"))) return;
    return {
      matcher: newMatcher,
      handle(input, next) {
        const updates = useParent ? { parent: `${input.parent ? `${input.parent} $$ ` : ""}${variant}` } : { selector: variant.replace(/&/g, input.selector) };
        return next({
          ...input,
          ...updates
        });
      }
    };
  },
  multiPass: true
};
var variantTheme2 = {
  name: "theme-variables",
  match(matcher, ctx) {
    if (!hasThemeFn(matcher)) return;
    return {
      matcher,
      handle(input, next) {
        return next({
          ...input,
          entries: JSON.parse(transformThemeFn(JSON.stringify(input.entries), ctx.theme))
        });
      }
    };
  }
};
var variantStickyHover2 = [variantMatcher("@hover", (input) => ({
  parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (hover: hover) and (pointer: fine)`,
  selector: `${input.selector || ""}:hover`
}))];
var variantImplicitGroup = {
  name: "implicit-group",
  match(matcher, ctx) {
    const variant = variantGetParameter("in-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const group = h2.bracket(match) ?? match;
      if (group) return {
        matcher: rest,
        handle: (input, next) => next({
          ...input,
          parent: `${input.parent ? `${input.parent} $$ ` : ""}${input.selector}`,
          selector: `:where(*:is(${group})) &`
        })
      };
    }
  }
};
var anchoredNumberRE2 = /^-?[0-9.]+(?:[a-z]+|%)?$/;
var numberRE4 = /-?[0-9.]+(?:[a-z]+|%)?/;
var ignoreProps2 = [/\b(opacity|color|flex|backdrop-filter|^filter|^scale|transform|mask-image)\b/];
function negateMathFunction2(value) {
  const match = value.match(cssMathFnRE2) || value.match(cssVarFnRE2);
  if (match) {
    const [fnBody, rest] = getStringComponent(`(${match[2]})${match[3]}`, "(", ")", " ") ?? [];
    if (fnBody) return `calc(${match[1]}${fnBody} * -1)${rest ? ` ${rest}` : ""}`;
  }
}
var negateFunctionBodyRE2 = /\b(hue-rotate)\s*(\(.*)/;
function negateFunctionBody2(value) {
  const match = value.match(negateFunctionBodyRE2);
  if (match) {
    const [fnBody, rest] = getStringComponent(match[2], "(", ")", " ") ?? [];
    if (fnBody) {
      const body = anchoredNumberRE2.test(fnBody.slice(1, -1)) ? fnBody.replace(numberRE4, (i) => i.startsWith("-") ? i.slice(1) : `-${i}`) : `(calc(${fnBody} * -1))`;
      return `${match[1]}${body}${rest ? ` ${rest}` : ""}`;
    }
  }
}
var variantNegative2 = {
  name: "negative",
  match(matcher) {
    if (!matcher.startsWith("-")) return;
    return {
      matcher: matcher.slice(1),
      body: (body) => {
        if (body.find((v) => v[0] === CONTROL_NO_NEGATIVE)) return;
        let changed = false;
        body.forEach((v) => {
          var _a;
          if (toArray(v[2]).includes(CONTROL_NO_NEGATIVE)) return;
          const value = (_a = v[1]) == null ? void 0 : _a.toString();
          if (!value || value === "0") return;
          if (ignoreProps2.some((i) => i.test(v[0]))) return;
          const negatedFn = negateMathFunction2(value);
          if (negatedFn) {
            v[1] = negatedFn;
            changed = true;
            return;
          }
          const negatedBody = negateFunctionBody2(value);
          if (negatedBody) {
            v[1] = negatedBody;
            changed = true;
            return;
          }
          if (anchoredNumberRE2.test(value)) {
            v[1] = value.replace(numberRE4, (i) => i.startsWith("-") ? i.slice(1) : `-${i}`);
            changed = true;
          }
        });
        if (changed) return body;
        return [];
      }
    };
  }
};
var placeholderModifier2 = (input, { theme: theme4 }) => {
  const m = input.match(/^(.*)\b(placeholder-)(.+)$/);
  if (m) {
    const [, pre = "", p, body] = m;
    if (hasParseableColor2(body, theme4) || hasOpacityValue2(body)) return { matcher: `${pre}placeholder-$ ${p}${body}` };
  }
};
function hasOpacityValue2(body) {
  const match = body.match(/^op(?:acity)?-?(.+)$/);
  if (match && match[1] != null) return h2.bracket.percent(match[1]) != null;
  return false;
}
function variantPseudoClassesAndElements2() {
  return createPseudoClassesAndElements({
    getBracket,
    h: h2,
    variantGetBracket
  });
}
function variantPseudoClassFunctions2() {
  return createPseudoClassFunctions({
    getBracket,
    h: h2,
    variantGetBracket
  });
}
function variantTaggedPseudoClasses2(options = {}) {
  return createTaggedPseudoClasses(options, {
    getBracket,
    h: h2,
    variantGetBracket
  });
}
var variantPartClasses2 = createPartClasses();
var variantStartingStyle2 = {
  name: "starting",
  match(matcher) {
    if (!matcher.startsWith("starting:")) return;
    return {
      matcher: matcher.slice(9),
      handle: (input, next) => next({
        ...input,
        parent: `@starting-style`
      })
    };
  }
};
var variantSupports2 = {
  name: "supports",
  match(matcher, ctx) {
    var _a;
    const variant = variantGetParameter("supports-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      let supports2 = h2.bracket(match) ?? "";
      if (supports2 === "") supports2 = ((_a = ctx.theme.supports) == null ? void 0 : _a[match]) ?? "";
      if (supports2) {
        if (!(supports2.startsWith("(") && supports2.endsWith(")"))) supports2 = `(${supports2})`;
        return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@supports ${supports2}`
          })
        };
      }
    }
  },
  multiPass: true
};
function variants3(options) {
  return [
    variantAria2,
    variantDataAttribute2,
    variantCssLayer2,
    variantSelector2,
    variantInternalLayer2,
    variantNegative2,
    variantStartingStyle2,
    variantImportant2(),
    variantSupports2,
    variantNoscript,
    variantScripting,
    variantPrint2,
    variantCustomMedia2,
    ...variantContrasts2,
    ...variantMotions2,
    ...variantOrientations2,
    ...variantForcedColors,
    variantBreakpoints2(),
    ...variantCombinators3,
    ...variantSvgCombinators,
    placeholderModifier2,
    ...variantPseudoClassesAndElements2(),
    variantPseudoClassFunctions2(),
    ...variantTaggedPseudoClasses2(options),
    variantPartClasses2,
    ...variantColorsMediaOrClass2(options),
    ...variantColorsScheme2,
    ...variantLanguageDirections2,
    variantScope2,
    ...variantChildren2,
    variantInert,
    variantContainerQuery2,
    variantVariables2,
    ...variantTaggedDataAttributes2,
    ...variantTaggedAriaAttributes2,
    variantTheme2,
    ...variantStickyHover2,
    variantImplicitGroup
  ].flat();
}

// node_modules/@unocss/preset-wind4/dist/index.mjs
function property2(options) {
  var _a, _b;
  if (((_a = options.preflights) == null ? void 0 : _a.property) === false) return void 0;
  const propertyConfig = typeof ((_b = options.preflights) == null ? void 0 : _b.property) === "object" ? options.preflights.property : void 0;
  const parentSelector = (propertyConfig == null ? void 0 : propertyConfig.parent) !== void 0 ? propertyConfig.parent : "@supports ((-webkit-hyphens: none) and (not (margin-trim: inline))) or ((-moz-orient: inline) and (not (color:rgb(from red r g b))))";
  const selector2 = (propertyConfig == null ? void 0 : propertyConfig.selector) ?? "*, ::before, ::after, ::backdrop";
  return {
    getCSS: () => {
      if (trackedProperties.size === 0) return;
      const css = Array.from(trackedProperties.entries()).map(([property$1, value]) => `${property$1}:${value};`).join("");
      return parentSelector === false ? `${selector2}{${css}}` : `${parentSelector}{${selector2}{${css}}}`;
    },
    layer: "properties"
  };
}
var resetCSS = `
/*
  1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
  2. Remove default margins and padding
  3. Reset all borders.
*/

*,
::after,
::before,
::backdrop,
::file-selector-button {
  box-sizing: border-box; /* 1 */
  margin: 0; /* 2 */
  padding: 0; /* 2 */
  border: 0 solid; /* 3 */
}

/*
  1. Use a consistent sensible line-height in all browsers.
  2. Prevent adjustments of font size after orientation changes in iOS.
  3. Use a more readable tab size.
  4. Use the user's configured \`sans\` font-family by default.
  5. Use the user's configured \`sans\` font-feature-settings by default.
  6. Use the user's configured \`sans\` font-variation-settings by default.
  7. Disable tap highlights on iOS.
*/

html,
:host {
  line-height: 1.5; /* 1 */
  -webkit-text-size-adjust: 100%; /* 2 */
  tab-size: 4; /* 3 */
  font-family: var(
    --default-font-family,
    ui-sans-serif,
    system-ui,
    sans-serif,
    'Apple Color Emoji',
    'Segoe UI Emoji',
    'Segoe UI Symbol',
    'Noto Color Emoji'
  ); /* 4 */
  font-feature-settings: var(--default-font-featureSettings, normal); /* 5 */
  font-variation-settings: var(--default-font-variationSettings, normal); /* 6 */
  -webkit-tap-highlight-color: transparent; /* 7 */
}

/*
  1. Add the correct height in Firefox.
  2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
  3. Reset the default border style to a 1px solid border.
*/

hr {
  height: 0; /* 1 */
  color: inherit; /* 2 */
  border-top-width: 1px; /* 3 */
}

/*
  Add the correct text decoration in Chrome, Edge, and Safari.
*/

abbr:where([title]) {
  -webkit-text-decoration: underline dotted;
  text-decoration: underline dotted;
}

/*
  Remove the default font size and weight for headings.
*/

h1,
h2,
h3,
h4,
h5,
h6 {
  font-size: inherit;
  font-weight: inherit;
}

/*
  Reset links to optimize for opt-in styling instead of opt-out.
*/

a {
  color: inherit;
  -webkit-text-decoration: inherit;
  text-decoration: inherit;
}

/*
  Add the correct font weight in Edge and Safari.
*/

b,
strong {
  font-weight: bolder;
}

/*
  1. Use the user's configured \`mono\` font-family by default.
  2. Use the user's configured \`mono\` font-feature-settings by default.
  3. Use the user's configured \`mono\` font-variation-settings by default.
  4. Correct the odd \`em\` font sizing in all browsers.
*/

code,
kbd,
samp,
pre {
  font-family: var(
    --default-monoFont-family,
    ui-monospace,
    SFMono-Regular,
    Menlo,
    Monaco,
    Consolas,
    'Liberation Mono',
    'Courier New',
    monospace
  ); /* 1 */
  font-feature-settings: var(--default-monoFont-featureSettings, normal); /* 2 */
  font-variation-settings: var(--default-monoFont-variationSettings, normal); /* 3 */
  font-size: 1em; /* 4 */
}

/*
  Add the correct font size in all browsers.
*/

small {
  font-size: 80%;
}

/*
  Prevent \`sub\` and \`sup\` elements from affecting the line height in all browsers.
*/

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

/*
  1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
  2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
  3. Remove gaps between table borders by default.
*/

table {
  text-indent: 0; /* 1 */
  border-color: inherit; /* 2 */
  border-collapse: collapse; /* 3 */
}

/*
  Use the modern Firefox focus style for all focusable elements.
*/

:-moz-focusring {
  outline: auto;
}

/*
  Add the correct vertical alignment in Chrome and Firefox.
*/

progress {
  vertical-align: baseline;
}

/*
  Add the correct display in Chrome and Safari.
*/

summary {
  display: list-item;
}

/*
  Make lists unstyled by default.
*/

ol,
ul,
menu {
  list-style: none;
}

/*
  1. Make replaced elements \`display: block\` by default. (https://github.com/mozdevs/cssremedy/issues/14)
  2. Add \`vertical-align: middle\` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
      This can trigger a poorly considered lint error in some tools but is included by design.
*/

img,
svg,
video,
canvas,
audio,
iframe,
embed,
object {
  display: block; /* 1 */
  vertical-align: middle; /* 2 */
}

/*
  Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
*/

img,
video {
  max-width: 100%;
  height: auto;
}

/*
  1. Inherit font styles in all browsers.
  2. Remove border radius in all browsers.
  3. Remove background color in all browsers.
  4. Ensure consistent opacity for disabled states in all browsers.
*/

button,
input,
select,
optgroup,
textarea,
::file-selector-button {
  font: inherit; /* 1 */
  font-feature-settings: inherit; /* 1 */
  font-variation-settings: inherit; /* 1 */
  letter-spacing: inherit; /* 1 */
  color: inherit; /* 1 */
  border-radius: 0; /* 2 */
  background-color: transparent; /* 3 */
  opacity: 1; /* 4 */
}

/*
  Restore default font weight.
*/

:where(select:is([multiple], [size])) optgroup {
  font-weight: bolder;
}

/*
  Restore indentation.
*/

:where(select:is([multiple], [size])) optgroup option {
  padding-inline-start: 20px;
}

/*
  Restore space after button.
*/

::file-selector-button {
  margin-inline-end: 4px;
}

/*
  Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
*/

::placeholder {
  opacity: 1;
}

/*
  Set the default placeholder color to a semi-transparent version of the current text color in browsers that do not
  crash when using \`color-mix()\` with \`currentcolor\`. (https://github.com/tailwindlabs/tailwindcss/issues/17194)
*/

@supports (not (-webkit-appearance: -apple-pay-button)) /* Not Safari */ or
  (contain-intrinsic-size: 1px) /* Safari 17+ */ {
  ::placeholder {
    color: color-mix(in oklab, currentcolor 50%, transparent);
  }
}

/*
  Prevent resizing textareas horizontally by default.
*/

textarea {
  resize: vertical;
}

/*
  Remove the inner padding in Chrome and Safari on macOS.
*/

::-webkit-search-decoration {
  -webkit-appearance: none;
}

/*
  1. Ensure date/time inputs have the same height when empty in iOS Safari.
  2. Ensure text alignment can be changed on date/time inputs in iOS Safari.
*/

::-webkit-date-and-time-value {
  min-height: 1lh; /* 1 */
  text-align: inherit; /* 2 */
}

/*
  Prevent height from changing on date/time inputs in macOS Safari when the input is set to \`display: block\`.
*/

::-webkit-datetime-edit {
  display: inline-flex;
}

/*
  Remove excess padding from pseudo-elements in date/time inputs to ensure consistent height across browsers.
*/

::-webkit-datetime-edit-fields-wrapper {
  padding: 0;
}

::-webkit-datetime-edit,
::-webkit-datetime-edit-year-field,
::-webkit-datetime-edit-month-field,
::-webkit-datetime-edit-day-field,
::-webkit-datetime-edit-hour-field,
::-webkit-datetime-edit-minute-field,
::-webkit-datetime-edit-second-field,
::-webkit-datetime-edit-millisecond-field,
::-webkit-datetime-edit-meridiem-field {
  padding-block: 0;
}

/*
  Center dropdown marker shown on inputs with paired \`<datalist>\`s in Chrome. (https://github.com/tailwindlabs/tailwindcss/issues/18499)
*/

::-webkit-calendar-picker-indicator {
  line-height: 1;
}

/*
  Remove the additional \`:invalid\` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
*/

:-moz-ui-invalid {
  box-shadow: none;
}

/*
  Correct the inability to style the border radius in iOS Safari.
*/

button,
input:where([type='button'], [type='reset'], [type='submit']),
::file-selector-button {
  appearance: button;
}

/*
  Correct the cursor style of increment and decrement buttons in Safari.
*/

::-webkit-inner-spin-button,
::-webkit-outer-spin-button {
  height: auto;
}

/*
  Make elements with the HTML hidden attribute stay hidden by default.
*/

[hidden]:where(:not([hidden~='until-found'])) {
  display: none !important;
}
`;
function reset(options) {
  var _a;
  if (((_a = options.preflights) == null ? void 0 : _a.reset) === false) return void 0;
  return {
    getCSS: ({ generator }) => {
      themeTracking("font", "sans");
      themeTracking("font", "mono");
      themeTracking("default", ["font", "family"]);
      themeTracking("default", ["monoFont", "family"]);
      return compressCSS(resetCSS, generator.config.envMode === "dev");
    },
    layer: "base"
  };
}
var ExcludeCssVarKeys = [
  "spacing",
  "breakpoint",
  "verticalBreakpoint",
  "shadow",
  "insetShadow",
  "dropShadow",
  "textShadow",
  "animation",
  "property",
  "aria",
  "media",
  "supports",
  "containers"
];
function getThemeVarsMap(theme$2, keys) {
  const themeMap = /* @__PURE__ */ new Map([["--spacing", theme$2.spacing.DEFAULT]]);
  const normalizeValue = (value) => value.replace(alphaPlaceholdersRE, "1");
  function process2(obj, prefix) {
    for (const key in obj) if (Array.isArray(obj[key])) themeMap.set(`--${prefix}-${key}`, normalizeValue(obj[key].join(",")));
    else if (typeof obj[key] === "object") process2(obj[key], `${prefix}-${key}`);
    else themeMap.set(`--${prefix}-${key}`, normalizeValue(obj[key]));
  }
  for (const key in theme$2) {
    if (!keys.includes(key)) continue;
    process2(theme$2[key], key);
  }
  return themeMap;
}
function theme$1(options) {
  var _a, _b, _c, _d, _e;
  const preflightsTheme = typeof ((_a = options.preflights) == null ? void 0 : _a.theme) === "boolean" || typeof ((_b = options.preflights) == null ? void 0 : _b.theme) === "string" ? { mode: options.preflights.theme ?? "on-demand" } : {
    mode: ((_d = (_c = options.preflights) == null ? void 0 : _c.theme) == null ? void 0 : _d.mode) ?? "on-demand",
    ...(_e = options.preflights) == null ? void 0 : _e.theme
  };
  return {
    layer: "theme",
    getCSS(ctx) {
      const { theme: theme$2, generator } = ctx;
      const safelist = uniq(generator.config.safelist.flatMap((s) => typeof s === "function" ? s(ctx) : s));
      const { mode, process: process2 } = preflightsTheme;
      if (mode === false) return;
      if (safelist.length > 0) for (const s of safelist) {
        const [key, ...prop] = s.trim().split(":");
        if (key in theme$2 && prop.length <= 1) {
          const props = prop.length === 0 ? ["DEFAULT"] : prop[0].split("-");
          const v = getThemeByKey(theme$2, key, props);
          if (typeof v === "string") {
            themeTracking(key, props);
            detectThemeValue(v, theme$2);
          }
        }
      }
      let deps;
      const generateCSS = (deps$1) => {
        if (process2) for (const utility of deps$1) for (const p of toArray(process2)) p(utility, ctx);
        const resolvedDeps = deps$1.map(([key, value]) => key && value ? `${escapeSelector(key)}: ${value};` : void 0).filter(Boolean);
        if (resolvedDeps.length === 0) return;
        return compressCSS(`
:root, :host {
${resolvedDeps.join("\n")}
}`, generator.config.envMode === "dev");
      };
      if (mode === "on-demand") {
        if (trackedTheme.size === 0) return void 0;
        deps = Array.from(trackedTheme).map((k) => {
          const [key, prop] = k.split(":");
          const v = getThemeByKey(theme$2, key, prop.split("-"));
          if (typeof v === "string") return [`--${key}${`${key === "spacing" && prop === "DEFAULT" ? "" : `-${prop}`}`}`, v];
        }).filter(Boolean);
      } else {
        const keys = Object.keys(theme$2).filter((k) => !ExcludeCssVarKeys.includes(k));
        deps = Array.from(getThemeVarsMap(theme$2, keys));
      }
      return generateCSS(deps);
    }
  };
}
var preflights2 = (options) => {
  return [
    reset(options),
    theme$1(options),
    property2(options)
  ].filter(Boolean);
};
var shorthands2 = {
  position: [
    "relative",
    "absolute",
    "fixed",
    "sticky",
    "static"
  ],
  globalKeyword: globalKeywords2
};
var presetWind4 = definePreset((options = {}) => {
  options.dark = options.dark ?? "class";
  options.attributifyPseudo = options.attributifyPseudo ?? false;
  options.variablePrefix = options.variablePrefix ?? "un-";
  options.important = options.important ?? false;
  return {
    name: PRESET_NAME,
    rules: rules3,
    shortcuts: shortcuts2,
    theme: theme3,
    layers: {
      properties: -200,
      theme: -150,
      base: -100
    },
    preflights: preflights2(options),
    variants: variants3(options),
    prefix: options.prefix,
    postprocess: postprocessors2(options),
    extractorDefault: options.arbitraryVariants === false ? void 0 : extractorArbitraryVariants(),
    autocomplete: { shorthands: shorthands2 },
    options,
    configResolved() {
      trackedTheme.clear();
      trackedProperties.clear();
    },
    meta: {
      themeDeps: trackedTheme,
      propertyDeps: trackedProperties
    }
  };
});
var src_default9 = presetWind4;

// node_modules/@unocss/transformer-attributify-jsx/dist/index.mjs
var import_parser = __toESM(require_lib(), 1);
var import_traverse = __toESM(require_lib9(), 1);
function getEnvFlags2() {
  const isNode = typeof process !== "undefined" && process.stdout;
  return {
    isNode,
    isVSCode: isNode && !!process.env.VSCODE_CWD,
    isESLint: isNode && !!process.env.ESLINT
  };
}
var traverse = import_traverse.default.default || import_traverse.default;
async function attributifyJsxBabelResolver(params) {
  var _a;
  const { code: code2, uno, isBlocked } = params;
  const tasks = [];
  const ast = (0, import_parser.parse)(code2.toString(), {
    sourceType: "module",
    plugins: ["jsx", "typescript"]
  });
  if ((_a = ast.errors) == null ? void 0 : _a.length) throw new Error(`Babel parse errors:
${ast.errors.join("\n")}`);
  traverse(ast, { JSXAttribute(path) {
    if (path.node.value === null) {
      const attr = path.node.name.type === "JSXNamespacedName" ? `${path.node.name.namespace.name}:${path.node.name.name.name}` : path.node.name.name;
      if (isBlocked(attr)) return;
      tasks.push(uno.parseToken(attr).then((matched) => {
        if (matched) code2.appendRight(path.node.end, '=""');
      }));
    }
  } });
  await Promise.all(tasks);
}
var elementRE2 = /<([^/?<>0-9$_!][^\s>]*)\s+((?:"[^"]*"|'[^"]*'|(\{[^}]*\})|[^{>])+)>/g;
var attributeRE = new RegExp(`(?<![~\`!$%^&*()_+\\-=[{;':"|,.<>/?])([a-z()#][[?\\w\\-:()#%\\]]*)(?:\\s*=\\s*('[^']*'|"[^"]*"|\\S+))?|\\{[^}]*\\}`, "gi");
var valuedAttributeRE2 = /((?!\d|-{2}|-\d)[\w\u00A0-\uFFFF:!%.~<-]+)=(?:"[^"]*"|'[^']*'|(\{)((?:[`(][^`)]*[`)]|[^}])+)(\}))/g;
async function attributifyJsxRegexResolver(params) {
  var _a, _b;
  const { code: code2, uno, isBlocked } = params;
  const tasks = [];
  const attributifyPrefix = ((_b = (_a = uno.config.presets.find((i) => i.name === "@unocss/preset-attributify")) == null ? void 0 : _a.options) == null ? void 0 : _b.prefix) ?? "un-";
  for (const item of Array.from(code2.original.matchAll(elementRE2))) {
    let attributifyPart = item[2];
    if (valuedAttributeRE2.test(attributifyPart)) attributifyPart = attributifyPart.replace(valuedAttributeRE2, (match, _, dynamicFlagStart) => {
      if (!dynamicFlagStart) return " ".repeat(match.length);
      let preLastModifierIndex = 0;
      let temp = match;
      for (const _item of match.matchAll(elementRE2)) {
        const attrAttributePart = _item[2];
        if (valuedAttributeRE2.test(attrAttributePart)) attrAttributePart.replace(valuedAttributeRE2, (m) => " ".repeat(m.length));
        const pre = temp.slice(0, preLastModifierIndex) + " ".repeat(_item.index + _item[0].indexOf(_item[2]) - preLastModifierIndex) + attrAttributePart;
        temp = pre + " ".repeat(_item.input.length - pre.length);
        preLastModifierIndex = pre.length;
      }
      if (preLastModifierIndex !== 0) return temp;
      return " ".repeat(match.length);
    });
    for (const attr of attributifyPart.matchAll(attributeRE)) {
      const matchedRule = attr[0];
      if (matchedRule.includes("=") || isBlocked(matchedRule)) continue;
      const updatedMatchedRule = matchedRule.startsWith(attributifyPrefix) ? matchedRule.slice(attributifyPrefix.length) : matchedRule;
      tasks.push(uno.parseToken(updatedMatchedRule).then((matched) => {
        if (matched) {
          const startIdx = (item.index || 0) + (attr.index || 0) + item[0].indexOf(item[2]);
          const endIdx = startIdx + matchedRule.length;
          code2.overwrite(startIdx, endIdx, `${matchedRule}=""`);
        }
      }));
    }
  }
  await Promise.all(tasks);
}
function createFilter(include, exclude) {
  const includePattern = toArray(include || []);
  const excludePattern = toArray(exclude || []);
  return (id) => {
    if (excludePattern.some((p) => id.match(p))) return false;
    return includePattern.some((p) => id.match(p));
  };
}
function transformerAttributifyJsx(options = {}) {
  const { blocklist = [] } = options;
  const isBlocked = (matchedRule) => {
    for (const blockedRule of blocklist) if (blockedRule instanceof RegExp) {
      if (blockedRule.test(matchedRule)) return true;
    } else if (matchedRule === blockedRule) return true;
    return false;
  };
  return {
    name: "@unocss/transformer-attributify-jsx",
    enforce: "pre",
    idFilter: createFilter(options.include || [/\.[jt]sx$/, /\.mdx$/], options.exclude || []),
    async transform(code2, id, { uno }) {
      try {
        if (getEnvFlags2().isVSCode) return;
      } catch {
      }
      const params = {
        code: code2,
        id,
        uno,
        isBlocked
      };
      try {
        await attributifyJsxBabelResolver(params);
      } catch (error) {
        console.warn(`[@unocss/transformer-attributify-jsx]: Babel resolver failed for "${id}", falling back to regex resolver:`, error);
        await attributifyJsxRegexResolver(params);
      }
    }
  };
}

// node_modules/@unocss/transformer-compile-class/dist/index.mjs
function transformerCompileClass(options = {}) {
  const { trigger = /(["'`]):uno-?(?<name>\S+)?:\s(.*?)\1/g, classPrefix = "uno-", hashFn = hash2, keepUnknown = true, alwaysHash = false } = options;
  const compiledClass = /* @__PURE__ */ new Set();
  const regexp = typeof trigger === "string" ? new RegExp(`(["'\`])${escapeRegExp(trigger)}\\s([^\\1]*?)\\1`, "g") : trigger;
  return {
    name: "@unocss/transformer-compile-class",
    enforce: "pre",
    async transform(s, _, { uno, tokens, invalidate }) {
      const matches = [...s.original.matchAll(regexp)];
      if (!matches.length) return;
      const size = compiledClass.size;
      for (const match of matches) {
        let body = match.length === 4 && match.groups ? expandVariantGroup(match[3].trim()) : expandVariantGroup(match[2].trim());
        const start = match.index;
        const replacements = [];
        if (keepUnknown) {
          const result = await Promise.all(body.split(/\s+/).filter(Boolean).map(async (i) => [i, !!await uno.parseToken(i)]));
          const known = result.filter(([, matched]) => matched).map(([i]) => i);
          const unknown = result.filter(([, matched]) => !matched).map(([i]) => i);
          replacements.push(...unknown);
          body = known.join(" ");
        }
        if (body) {
          let hash$1;
          let explicitName = false;
          if (match.groups && match.groups.name) {
            hash$1 = match.groups.name;
            if (alwaysHash) hash$1 += `-${hashFn(body)}`;
            explicitName = true;
          } else hash$1 = hashFn(body);
          const className = `${classPrefix}${hash$1}`;
          if (tokens && tokens.has(className) && explicitName) {
            const existing = uno.config.shortcuts.find((i) => i[0] === className);
            if (existing && existing[1] !== body) throw new Error(`Duplicated compile class name "${className}". One is "${body}" and the other is "${existing[1]}". Please choose different class name or set 'alwaysHash' to 'true'.`);
          }
          compiledClass.add(className);
          replacements.unshift(className);
          if (options.layer) uno.config.shortcuts.push([
            className,
            body,
            { layer: options.layer }
          ]);
          else uno.config.shortcuts.push([className, body]);
          if (tokens) tokens.add(className);
        }
        s.overwrite(start + 1, start + match[0].length - 1, replacements.join(" "));
      }
      if (compiledClass.size > size) invalidate();
    }
  };
}
function hash2(str) {
  let i;
  let l;
  let hval = 2166136261;
  for (i = 0, l = str.length; i < l; i++) {
    hval ^= str.charCodeAt(i);
    hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
  }
  return `00000${(hval >>> 0).toString(36)}`.slice(-6);
}

// node_modules/css-tree/lib/tokenizer/types.js
var types_exports = {};
__export(types_exports, {
  AtKeyword: () => AtKeyword,
  BadString: () => BadString,
  BadUrl: () => BadUrl,
  CDC: () => CDC,
  CDO: () => CDO,
  Colon: () => Colon,
  Comma: () => Comma,
  Comment: () => Comment,
  Delim: () => Delim,
  Dimension: () => Dimension,
  EOF: () => EOF,
  Function: () => Function2,
  Hash: () => Hash,
  Ident: () => Ident,
  LeftCurlyBracket: () => LeftCurlyBracket,
  LeftParenthesis: () => LeftParenthesis,
  LeftSquareBracket: () => LeftSquareBracket,
  Number: () => Number2,
  Percentage: () => Percentage,
  RightCurlyBracket: () => RightCurlyBracket,
  RightParenthesis: () => RightParenthesis,
  RightSquareBracket: () => RightSquareBracket,
  Semicolon: () => Semicolon,
  String: () => String2,
  Url: () => Url,
  WhiteSpace: () => WhiteSpace
});
var EOF = 0;
var Ident = 1;
var Function2 = 2;
var AtKeyword = 3;
var Hash = 4;
var String2 = 5;
var BadString = 6;
var Url = 7;
var BadUrl = 8;
var Delim = 9;
var Number2 = 10;
var Percentage = 11;
var Dimension = 12;
var WhiteSpace = 13;
var CDO = 14;
var CDC = 15;
var Colon = 16;
var Semicolon = 17;
var Comma = 18;
var LeftSquareBracket = 19;
var RightSquareBracket = 20;
var LeftParenthesis = 21;
var RightParenthesis = 22;
var LeftCurlyBracket = 23;
var RightCurlyBracket = 24;
var Comment = 25;

// node_modules/css-tree/lib/tokenizer/char-code-definitions.js
var EOF2 = 0;
function isDigit(code2) {
  return code2 >= 48 && code2 <= 57;
}
function isHexDigit(code2) {
  return isDigit(code2) || // 0 .. 9
  code2 >= 65 && code2 <= 70 || // A .. F
  code2 >= 97 && code2 <= 102;
}
function isUppercaseLetter(code2) {
  return code2 >= 65 && code2 <= 90;
}
function isLowercaseLetter(code2) {
  return code2 >= 97 && code2 <= 122;
}
function isLetter(code2) {
  return isUppercaseLetter(code2) || isLowercaseLetter(code2);
}
function isNonAscii(code2) {
  return code2 >= 128;
}
function isNameStart(code2) {
  return isLetter(code2) || isNonAscii(code2) || code2 === 95;
}
function isName(code2) {
  return isNameStart(code2) || isDigit(code2) || code2 === 45;
}
function isNonPrintable(code2) {
  return code2 >= 0 && code2 <= 8 || code2 === 11 || code2 >= 14 && code2 <= 31 || code2 === 127;
}
function isNewline(code2) {
  return code2 === 10 || code2 === 13 || code2 === 12;
}
function isWhiteSpace(code2) {
  return isNewline(code2) || code2 === 32 || code2 === 9;
}
function isValidEscape(first, second) {
  if (first !== 92) {
    return false;
  }
  if (isNewline(second) || second === EOF2) {
    return false;
  }
  return true;
}
function isIdentifierStart(first, second, third) {
  if (first === 45) {
    return isNameStart(second) || second === 45 || isValidEscape(second, third);
  }
  if (isNameStart(first)) {
    return true;
  }
  if (first === 92) {
    return isValidEscape(first, second);
  }
  return false;
}
function isNumberStart(first, second, third) {
  if (first === 43 || first === 45) {
    if (isDigit(second)) {
      return 2;
    }
    return second === 46 && isDigit(third) ? 3 : 0;
  }
  if (first === 46) {
    return isDigit(second) ? 2 : 0;
  }
  if (isDigit(first)) {
    return 1;
  }
  return 0;
}
function isBOM(code2) {
  if (code2 === 65279) {
    return 1;
  }
  if (code2 === 65534) {
    return 1;
  }
  return 0;
}
var CATEGORY = new Array(128);
var EofCategory = 128;
var WhiteSpaceCategory = 130;
var DigitCategory = 131;
var NameStartCategory = 132;
var NonPrintableCategory = 133;
for (let i = 0; i < CATEGORY.length; i++) {
  CATEGORY[i] = isWhiteSpace(i) && WhiteSpaceCategory || isDigit(i) && DigitCategory || isNameStart(i) && NameStartCategory || isNonPrintable(i) && NonPrintableCategory || i || EofCategory;
}
function charCodeCategory(code2) {
  return code2 < 128 ? CATEGORY[code2] : NameStartCategory;
}

// node_modules/css-tree/lib/tokenizer/utils.js
function getCharCode(source, offset) {
  return offset < source.length ? source.charCodeAt(offset) : 0;
}
function getNewlineLength(source, offset, code2) {
  if (code2 === 13 && getCharCode(source, offset + 1) === 10) {
    return 2;
  }
  return 1;
}
function cmpChar(testStr, offset, referenceCode) {
  let code2 = testStr.charCodeAt(offset);
  if (isUppercaseLetter(code2)) {
    code2 = code2 | 32;
  }
  return code2 === referenceCode;
}
function cmpStr(testStr, start, end, referenceStr) {
  if (end - start !== referenceStr.length) {
    return false;
  }
  if (start < 0 || end > testStr.length) {
    return false;
  }
  for (let i = start; i < end; i++) {
    const referenceCode = referenceStr.charCodeAt(i - start);
    let testCode = testStr.charCodeAt(i);
    if (isUppercaseLetter(testCode)) {
      testCode = testCode | 32;
    }
    if (testCode !== referenceCode) {
      return false;
    }
  }
  return true;
}
function findWhiteSpaceStart(source, offset) {
  for (; offset >= 0; offset--) {
    if (!isWhiteSpace(source.charCodeAt(offset))) {
      break;
    }
  }
  return offset + 1;
}
function findWhiteSpaceEnd(source, offset) {
  for (; offset < source.length; offset++) {
    if (!isWhiteSpace(source.charCodeAt(offset))) {
      break;
    }
  }
  return offset;
}
function findDecimalNumberEnd(source, offset) {
  for (; offset < source.length; offset++) {
    if (!isDigit(source.charCodeAt(offset))) {
      break;
    }
  }
  return offset;
}
function consumeEscaped(source, offset) {
  offset += 2;
  if (isHexDigit(getCharCode(source, offset - 1))) {
    for (const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
      if (!isHexDigit(getCharCode(source, offset))) {
        break;
      }
    }
    const code2 = getCharCode(source, offset);
    if (isWhiteSpace(code2)) {
      offset += getNewlineLength(source, offset, code2);
    }
  }
  return offset;
}
function consumeName(source, offset) {
  for (; offset < source.length; offset++) {
    const code2 = source.charCodeAt(offset);
    if (isName(code2)) {
      continue;
    }
    if (isValidEscape(code2, getCharCode(source, offset + 1))) {
      offset = consumeEscaped(source, offset) - 1;
      continue;
    }
    break;
  }
  return offset;
}
function consumeNumber(source, offset) {
  let code2 = source.charCodeAt(offset);
  if (code2 === 43 || code2 === 45) {
    code2 = source.charCodeAt(offset += 1);
  }
  if (isDigit(code2)) {
    offset = findDecimalNumberEnd(source, offset + 1);
    code2 = source.charCodeAt(offset);
  }
  if (code2 === 46 && isDigit(source.charCodeAt(offset + 1))) {
    offset += 2;
    offset = findDecimalNumberEnd(source, offset);
  }
  if (cmpChar(
    source,
    offset,
    101
    /* e */
  )) {
    let sign = 0;
    code2 = source.charCodeAt(offset + 1);
    if (code2 === 45 || code2 === 43) {
      sign = 1;
      code2 = source.charCodeAt(offset + 2);
    }
    if (isDigit(code2)) {
      offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
    }
  }
  return offset;
}
function consumeBadUrlRemnants(source, offset) {
  for (; offset < source.length; offset++) {
    const code2 = source.charCodeAt(offset);
    if (code2 === 41) {
      offset++;
      break;
    }
    if (isValidEscape(code2, getCharCode(source, offset + 1))) {
      offset = consumeEscaped(source, offset);
    }
  }
  return offset;
}
function decodeEscaped(escaped) {
  if (escaped.length === 1 && !isHexDigit(escaped.charCodeAt(0))) {
    return escaped[0];
  }
  let code2 = parseInt(escaped, 16);
  if (code2 === 0 || // If this number is zero,
  code2 >= 55296 && code2 <= 57343 || // or is for a surrogate,
  code2 > 1114111) {
    code2 = 65533;
  }
  return String.fromCodePoint(code2);
}

// node_modules/css-tree/lib/tokenizer/names.js
var names_default = [
  "EOF-token",
  "ident-token",
  "function-token",
  "at-keyword-token",
  "hash-token",
  "string-token",
  "bad-string-token",
  "url-token",
  "bad-url-token",
  "delim-token",
  "number-token",
  "percentage-token",
  "dimension-token",
  "whitespace-token",
  "CDO-token",
  "CDC-token",
  "colon-token",
  "semicolon-token",
  "comma-token",
  "[-token",
  "]-token",
  "(-token",
  ")-token",
  "{-token",
  "}-token",
  "comment-token"
];

// node_modules/css-tree/lib/tokenizer/adopt-buffer.js
var MIN_SIZE = 16 * 1024;
function adoptBuffer(buffer = null, size) {
  if (buffer === null || buffer.length < size) {
    return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
  }
  return buffer;
}

// node_modules/css-tree/lib/tokenizer/OffsetToLocation.js
var N = 10;
var F = 12;
var R = 13;
function computeLinesAndColumns(host) {
  const source = host.source;
  const sourceLength = source.length;
  const startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;
  const lines = adoptBuffer(host.lines, sourceLength);
  const columns3 = adoptBuffer(host.columns, sourceLength);
  let line = host.startLine;
  let column = host.startColumn;
  for (let i = startOffset; i < sourceLength; i++) {
    const code2 = source.charCodeAt(i);
    lines[i] = line;
    columns3[i] = column++;
    if (code2 === N || code2 === R || code2 === F) {
      if (code2 === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
        i++;
        lines[i] = line;
        columns3[i] = column;
      }
      line++;
      column = 1;
    }
  }
  lines[sourceLength] = line;
  columns3[sourceLength] = column;
  host.lines = lines;
  host.columns = columns3;
  host.computed = true;
}
var OffsetToLocation = class {
  constructor(source, startOffset, startLine, startColumn) {
    this.setSource(source, startOffset, startLine, startColumn);
    this.lines = null;
    this.columns = null;
  }
  setSource(source = "", startOffset = 0, startLine = 1, startColumn = 1) {
    this.source = source;
    this.startOffset = startOffset;
    this.startLine = startLine;
    this.startColumn = startColumn;
    this.computed = false;
  }
  getLocation(offset, filename) {
    if (!this.computed) {
      computeLinesAndColumns(this);
    }
    return {
      source: filename,
      offset: this.startOffset + offset,
      line: this.lines[offset],
      column: this.columns[offset]
    };
  }
  getLocationRange(start, end, filename) {
    if (!this.computed) {
      computeLinesAndColumns(this);
    }
    return {
      source: filename,
      start: {
        offset: this.startOffset + start,
        line: this.lines[start],
        column: this.columns[start]
      },
      end: {
        offset: this.startOffset + end,
        line: this.lines[end],
        column: this.columns[end]
      }
    };
  }
};

// node_modules/css-tree/lib/tokenizer/TokenStream.js
var OFFSET_MASK = 16777215;
var TYPE_SHIFT = 24;
var balancePair = new Uint8Array(32);
balancePair[Function2] = RightParenthesis;
balancePair[LeftParenthesis] = RightParenthesis;
balancePair[LeftSquareBracket] = RightSquareBracket;
balancePair[LeftCurlyBracket] = RightCurlyBracket;
function isBlockOpenerToken(tokenType2) {
  return balancePair[tokenType2] !== 0;
}
var TokenStream = class {
  constructor(source, tokenize3) {
    this.setSource(source, tokenize3);
  }
  reset() {
    this.eof = false;
    this.tokenIndex = -1;
    this.tokenType = 0;
    this.tokenStart = this.firstCharOffset;
    this.tokenEnd = this.firstCharOffset;
  }
  setSource(source = "", tokenize3 = () => {
  }) {
    source = String(source || "");
    const sourceLength = source.length;
    const offsetAndType = adoptBuffer(this.offsetAndType, source.length + 1);
    const balance = adoptBuffer(this.balance, source.length + 1);
    let tokenCount = 0;
    let firstCharOffset = -1;
    let balanceCloseType = 0;
    let balanceStart = source.length;
    this.offsetAndType = null;
    this.balance = null;
    balance.fill(0);
    tokenize3(source, (type, start, end) => {
      const index = tokenCount++;
      offsetAndType[index] = type << TYPE_SHIFT | end;
      if (firstCharOffset === -1) {
        firstCharOffset = start;
      }
      balance[index] = balanceStart;
      if (type === balanceCloseType) {
        const prevBalanceStart = balance[balanceStart];
        balance[balanceStart] = index;
        balanceStart = prevBalanceStart;
        balanceCloseType = balancePair[offsetAndType[prevBalanceStart] >> TYPE_SHIFT];
      } else if (isBlockOpenerToken(type)) {
        balanceStart = index;
        balanceCloseType = balancePair[type];
      }
    });
    offsetAndType[tokenCount] = EOF << TYPE_SHIFT | sourceLength;
    balance[tokenCount] = tokenCount;
    for (let i = 0; i < tokenCount; i++) {
      const balanceStart2 = balance[i];
      if (balanceStart2 <= i) {
        const balanceEnd = balance[balanceStart2];
        if (balanceEnd !== i) {
          balance[i] = balanceEnd;
        }
      } else if (balanceStart2 > tokenCount) {
        balance[i] = tokenCount;
      }
    }
    this.source = source;
    this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
    this.tokenCount = tokenCount;
    this.offsetAndType = offsetAndType;
    this.balance = balance;
    this.reset();
    this.next();
  }
  lookupType(offset) {
    offset += this.tokenIndex;
    if (offset < this.tokenCount) {
      return this.offsetAndType[offset] >> TYPE_SHIFT;
    }
    return EOF;
  }
  lookupTypeNonSC(idx) {
    for (let offset = this.tokenIndex; offset < this.tokenCount; offset++) {
      const tokenType2 = this.offsetAndType[offset] >> TYPE_SHIFT;
      if (tokenType2 !== WhiteSpace && tokenType2 !== Comment) {
        if (idx-- === 0) {
          return tokenType2;
        }
      }
    }
    return EOF;
  }
  lookupOffset(offset) {
    offset += this.tokenIndex;
    if (offset < this.tokenCount) {
      return this.offsetAndType[offset - 1] & OFFSET_MASK;
    }
    return this.source.length;
  }
  lookupOffsetNonSC(idx) {
    for (let offset = this.tokenIndex; offset < this.tokenCount; offset++) {
      const tokenType2 = this.offsetAndType[offset] >> TYPE_SHIFT;
      if (tokenType2 !== WhiteSpace && tokenType2 !== Comment) {
        if (idx-- === 0) {
          return offset - this.tokenIndex;
        }
      }
    }
    return EOF;
  }
  lookupValue(offset, referenceStr) {
    offset += this.tokenIndex;
    if (offset < this.tokenCount) {
      return cmpStr(
        this.source,
        this.offsetAndType[offset - 1] & OFFSET_MASK,
        this.offsetAndType[offset] & OFFSET_MASK,
        referenceStr
      );
    }
    return false;
  }
  getTokenStart(tokenIndex) {
    if (tokenIndex === this.tokenIndex) {
      return this.tokenStart;
    }
    if (tokenIndex > 0) {
      return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
    }
    return this.firstCharOffset;
  }
  substrToCursor(start) {
    return this.source.substring(start, this.tokenStart);
  }
  isBalanceEdge(pos) {
    return this.balance[this.tokenIndex] < pos;
  }
  isDelim(code2, offset) {
    if (offset) {
      return this.lookupType(offset) === Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code2;
    }
    return this.tokenType === Delim && this.source.charCodeAt(this.tokenStart) === code2;
  }
  skip(tokenCount) {
    let next = this.tokenIndex + tokenCount;
    if (next < this.tokenCount) {
      this.tokenIndex = next;
      this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
      next = this.offsetAndType[next];
      this.tokenType = next >> TYPE_SHIFT;
      this.tokenEnd = next & OFFSET_MASK;
    } else {
      this.tokenIndex = this.tokenCount;
      this.next();
    }
  }
  next() {
    let next = this.tokenIndex + 1;
    if (next < this.tokenCount) {
      this.tokenIndex = next;
      this.tokenStart = this.tokenEnd;
      next = this.offsetAndType[next];
      this.tokenType = next >> TYPE_SHIFT;
      this.tokenEnd = next & OFFSET_MASK;
    } else {
      this.eof = true;
      this.tokenIndex = this.tokenCount;
      this.tokenType = EOF;
      this.tokenStart = this.tokenEnd = this.source.length;
    }
  }
  skipSC() {
    while (this.tokenType === WhiteSpace || this.tokenType === Comment) {
      this.next();
    }
  }
  skipUntilBalanced(startToken, stopConsume) {
    let cursor = startToken;
    let balanceEnd = 0;
    let offset = 0;
    loop:
      for (; cursor < this.tokenCount; cursor++) {
        balanceEnd = this.balance[cursor];
        if (balanceEnd < startToken) {
          break loop;
        }
        offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;
        switch (stopConsume(this.source.charCodeAt(offset))) {
          case 1:
            break loop;
          case 2:
            cursor++;
            break loop;
          default:
            if (isBlockOpenerToken(this.offsetAndType[cursor] >> TYPE_SHIFT)) {
              cursor = balanceEnd;
            }
        }
      }
    this.skip(cursor - this.tokenIndex);
  }
  forEachToken(fn) {
    for (let i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {
      const start = offset;
      const item = this.offsetAndType[i];
      const end = item & OFFSET_MASK;
      const type = item >> TYPE_SHIFT;
      offset = end;
      fn(type, start, end, i);
    }
  }
  dump() {
    const tokens = new Array(this.tokenCount);
    this.forEachToken((type, start, end, index) => {
      tokens[index] = {
        idx: index,
        type: names_default[type],
        chunk: this.source.substring(start, end),
        balance: this.balance[index]
      };
    });
    return tokens;
  }
};

// node_modules/css-tree/lib/tokenizer/index.js
function tokenize(source, onToken) {
  function getCharCode2(offset2) {
    return offset2 < sourceLength ? source.charCodeAt(offset2) : 0;
  }
  function consumeNumericToken() {
    offset = consumeNumber(source, offset);
    if (isIdentifierStart(getCharCode2(offset), getCharCode2(offset + 1), getCharCode2(offset + 2))) {
      type = Dimension;
      offset = consumeName(source, offset);
      return;
    }
    if (getCharCode2(offset) === 37) {
      type = Percentage;
      offset++;
      return;
    }
    type = Number2;
  }
  function consumeIdentLikeToken() {
    const nameStartOffset = offset;
    offset = consumeName(source, offset);
    if (cmpStr(source, nameStartOffset, offset, "url") && getCharCode2(offset) === 40) {
      offset = findWhiteSpaceEnd(source, offset + 1);
      if (getCharCode2(offset) === 34 || getCharCode2(offset) === 39) {
        type = Function2;
        offset = nameStartOffset + 4;
        return;
      }
      consumeUrlToken();
      return;
    }
    if (getCharCode2(offset) === 40) {
      type = Function2;
      offset++;
      return;
    }
    type = Ident;
  }
  function consumeStringToken(endingCodePoint) {
    if (!endingCodePoint) {
      endingCodePoint = getCharCode2(offset++);
    }
    type = String2;
    for (; offset < source.length; offset++) {
      const code2 = source.charCodeAt(offset);
      switch (charCodeCategory(code2)) {
        case endingCodePoint:
          offset++;
          return;
        case WhiteSpaceCategory:
          if (isNewline(code2)) {
            offset += getNewlineLength(source, offset, code2);
            type = BadString;
            return;
          }
          break;
        case 92:
          if (offset === source.length - 1) {
            break;
          }
          const nextCode = getCharCode2(offset + 1);
          if (isNewline(nextCode)) {
            offset += getNewlineLength(source, offset + 1, nextCode);
          } else if (isValidEscape(code2, nextCode)) {
            offset = consumeEscaped(source, offset) - 1;
          }
          break;
      }
    }
  }
  function consumeUrlToken() {
    type = Url;
    offset = findWhiteSpaceEnd(source, offset);
    for (; offset < source.length; offset++) {
      const code2 = source.charCodeAt(offset);
      switch (charCodeCategory(code2)) {
        case 41:
          offset++;
          return;
        case WhiteSpaceCategory:
          offset = findWhiteSpaceEnd(source, offset);
          if (getCharCode2(offset) === 41 || offset >= source.length) {
            if (offset < source.length) {
              offset++;
            }
            return;
          }
          offset = consumeBadUrlRemnants(source, offset);
          type = BadUrl;
          return;
        case 34:
        case 39:
        case 40:
        case NonPrintableCategory:
          offset = consumeBadUrlRemnants(source, offset);
          type = BadUrl;
          return;
        case 92:
          if (isValidEscape(code2, getCharCode2(offset + 1))) {
            offset = consumeEscaped(source, offset) - 1;
            break;
          }
          offset = consumeBadUrlRemnants(source, offset);
          type = BadUrl;
          return;
      }
    }
  }
  source = String(source || "");
  const sourceLength = source.length;
  let start = isBOM(getCharCode2(0));
  let offset = start;
  let type;
  while (offset < sourceLength) {
    const code2 = source.charCodeAt(offset);
    switch (charCodeCategory(code2)) {
      case WhiteSpaceCategory:
        type = WhiteSpace;
        offset = findWhiteSpaceEnd(source, offset + 1);
        break;
      case 34:
        consumeStringToken();
        break;
      case 35:
        if (isName(getCharCode2(offset + 1)) || isValidEscape(getCharCode2(offset + 1), getCharCode2(offset + 2))) {
          type = Hash;
          offset = consumeName(source, offset + 1);
        } else {
          type = Delim;
          offset++;
        }
        break;
      case 39:
        consumeStringToken();
        break;
      case 40:
        type = LeftParenthesis;
        offset++;
        break;
      case 41:
        type = RightParenthesis;
        offset++;
        break;
      case 43:
        if (isNumberStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
          consumeNumericToken();
        } else {
          type = Delim;
          offset++;
        }
        break;
      case 44:
        type = Comma;
        offset++;
        break;
      case 45:
        if (isNumberStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
          consumeNumericToken();
        } else {
          if (getCharCode2(offset + 1) === 45 && getCharCode2(offset + 2) === 62) {
            type = CDC;
            offset = offset + 3;
          } else {
            if (isIdentifierStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
              consumeIdentLikeToken();
            } else {
              type = Delim;
              offset++;
            }
          }
        }
        break;
      case 46:
        if (isNumberStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
          consumeNumericToken();
        } else {
          type = Delim;
          offset++;
        }
        break;
      case 47:
        if (getCharCode2(offset + 1) === 42) {
          type = Comment;
          offset = source.indexOf("*/", offset + 2);
          offset = offset === -1 ? source.length : offset + 2;
        } else {
          type = Delim;
          offset++;
        }
        break;
      case 58:
        type = Colon;
        offset++;
        break;
      case 59:
        type = Semicolon;
        offset++;
        break;
      case 60:
        if (getCharCode2(offset + 1) === 33 && getCharCode2(offset + 2) === 45 && getCharCode2(offset + 3) === 45) {
          type = CDO;
          offset = offset + 4;
        } else {
          type = Delim;
          offset++;
        }
        break;
      case 64:
        if (isIdentifierStart(getCharCode2(offset + 1), getCharCode2(offset + 2), getCharCode2(offset + 3))) {
          type = AtKeyword;
          offset = consumeName(source, offset + 1);
        } else {
          type = Delim;
          offset++;
        }
        break;
      case 91:
        type = LeftSquareBracket;
        offset++;
        break;
      case 92:
        if (isValidEscape(code2, getCharCode2(offset + 1))) {
          consumeIdentLikeToken();
        } else {
          type = Delim;
          offset++;
        }
        break;
      case 93:
        type = RightSquareBracket;
        offset++;
        break;
      case 123:
        type = LeftCurlyBracket;
        offset++;
        break;
      case 125:
        type = RightCurlyBracket;
        offset++;
        break;
      case DigitCategory:
        consumeNumericToken();
        break;
      case NameStartCategory:
        consumeIdentLikeToken();
        break;
      default:
        type = Delim;
        offset++;
    }
    onToken(type, start, start = offset);
  }
}

// node_modules/css-tree/lib/utils/List.js
var releasedCursors = null;
var List = class _List {
  static createItem(data) {
    return {
      prev: null,
      next: null,
      data
    };
  }
  constructor() {
    this.head = null;
    this.tail = null;
    this.cursor = null;
  }
  createItem(data) {
    return _List.createItem(data);
  }
  // cursor helpers
  allocateCursor(prev, next) {
    let cursor;
    if (releasedCursors !== null) {
      cursor = releasedCursors;
      releasedCursors = releasedCursors.cursor;
      cursor.prev = prev;
      cursor.next = next;
      cursor.cursor = this.cursor;
    } else {
      cursor = {
        prev,
        next,
        cursor: this.cursor
      };
    }
    this.cursor = cursor;
    return cursor;
  }
  releaseCursor() {
    const { cursor } = this;
    this.cursor = cursor.cursor;
    cursor.prev = null;
    cursor.next = null;
    cursor.cursor = releasedCursors;
    releasedCursors = cursor;
  }
  updateCursors(prevOld, prevNew, nextOld, nextNew) {
    let { cursor } = this;
    while (cursor !== null) {
      if (cursor.prev === prevOld) {
        cursor.prev = prevNew;
      }
      if (cursor.next === nextOld) {
        cursor.next = nextNew;
      }
      cursor = cursor.cursor;
    }
  }
  *[Symbol.iterator]() {
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      yield cursor.data;
    }
  }
  // getters
  get size() {
    let size = 0;
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      size++;
    }
    return size;
  }
  get isEmpty() {
    return this.head === null;
  }
  get first() {
    return this.head && this.head.data;
  }
  get last() {
    return this.tail && this.tail.data;
  }
  // convertors
  fromArray(array) {
    let cursor = null;
    this.head = null;
    for (let data of array) {
      const item = _List.createItem(data);
      if (cursor !== null) {
        cursor.next = item;
      } else {
        this.head = item;
      }
      item.prev = cursor;
      cursor = item;
    }
    this.tail = cursor;
    return this;
  }
  toArray() {
    return [...this];
  }
  toJSON() {
    return [...this];
  }
  // array-like methods
  forEach(fn, thisArg = this) {
    const cursor = this.allocateCursor(null, this.head);
    while (cursor.next !== null) {
      const item = cursor.next;
      cursor.next = item.next;
      fn.call(thisArg, item.data, item, this);
    }
    this.releaseCursor();
  }
  forEachRight(fn, thisArg = this) {
    const cursor = this.allocateCursor(this.tail, null);
    while (cursor.prev !== null) {
      const item = cursor.prev;
      cursor.prev = item.prev;
      fn.call(thisArg, item.data, item, this);
    }
    this.releaseCursor();
  }
  reduce(fn, initialValue, thisArg = this) {
    let cursor = this.allocateCursor(null, this.head);
    let acc = initialValue;
    let item;
    while (cursor.next !== null) {
      item = cursor.next;
      cursor.next = item.next;
      acc = fn.call(thisArg, acc, item.data, item, this);
    }
    this.releaseCursor();
    return acc;
  }
  reduceRight(fn, initialValue, thisArg = this) {
    let cursor = this.allocateCursor(this.tail, null);
    let acc = initialValue;
    let item;
    while (cursor.prev !== null) {
      item = cursor.prev;
      cursor.prev = item.prev;
      acc = fn.call(thisArg, acc, item.data, item, this);
    }
    this.releaseCursor();
    return acc;
  }
  some(fn, thisArg = this) {
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      if (fn.call(thisArg, cursor.data, cursor, this)) {
        return true;
      }
    }
    return false;
  }
  map(fn, thisArg = this) {
    const result = new _List();
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      result.appendData(fn.call(thisArg, cursor.data, cursor, this));
    }
    return result;
  }
  filter(fn, thisArg = this) {
    const result = new _List();
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      if (fn.call(thisArg, cursor.data, cursor, this)) {
        result.appendData(cursor.data);
      }
    }
    return result;
  }
  nextUntil(start, fn, thisArg = this) {
    if (start === null) {
      return;
    }
    const cursor = this.allocateCursor(null, start);
    while (cursor.next !== null) {
      const item = cursor.next;
      cursor.next = item.next;
      if (fn.call(thisArg, item.data, item, this)) {
        break;
      }
    }
    this.releaseCursor();
  }
  prevUntil(start, fn, thisArg = this) {
    if (start === null) {
      return;
    }
    const cursor = this.allocateCursor(start, null);
    while (cursor.prev !== null) {
      const item = cursor.prev;
      cursor.prev = item.prev;
      if (fn.call(thisArg, item.data, item, this)) {
        break;
      }
    }
    this.releaseCursor();
  }
  // mutation
  clear() {
    this.head = null;
    this.tail = null;
  }
  copy() {
    const result = new _List();
    for (let data of this) {
      result.appendData(data);
    }
    return result;
  }
  prepend(item) {
    this.updateCursors(null, item, this.head, item);
    if (this.head !== null) {
      this.head.prev = item;
      item.next = this.head;
    } else {
      this.tail = item;
    }
    this.head = item;
    return this;
  }
  prependData(data) {
    return this.prepend(_List.createItem(data));
  }
  append(item) {
    return this.insert(item);
  }
  appendData(data) {
    return this.insert(_List.createItem(data));
  }
  insert(item, before = null) {
    if (before !== null) {
      this.updateCursors(before.prev, item, before, item);
      if (before.prev === null) {
        if (this.head !== before) {
          throw new Error("before doesn't belong to list");
        }
        this.head = item;
        before.prev = item;
        item.next = before;
        this.updateCursors(null, item);
      } else {
        before.prev.next = item;
        item.prev = before.prev;
        before.prev = item;
        item.next = before;
      }
    } else {
      this.updateCursors(this.tail, item, null, item);
      if (this.tail !== null) {
        this.tail.next = item;
        item.prev = this.tail;
      } else {
        this.head = item;
      }
      this.tail = item;
    }
    return this;
  }
  insertData(data, before) {
    return this.insert(_List.createItem(data), before);
  }
  remove(item) {
    this.updateCursors(item, item.prev, item, item.next);
    if (item.prev !== null) {
      item.prev.next = item.next;
    } else {
      if (this.head !== item) {
        throw new Error("item doesn't belong to list");
      }
      this.head = item.next;
    }
    if (item.next !== null) {
      item.next.prev = item.prev;
    } else {
      if (this.tail !== item) {
        throw new Error("item doesn't belong to list");
      }
      this.tail = item.prev;
    }
    item.prev = null;
    item.next = null;
    return item;
  }
  push(data) {
    this.insert(_List.createItem(data));
  }
  pop() {
    return this.tail !== null ? this.remove(this.tail) : null;
  }
  unshift(data) {
    this.prepend(_List.createItem(data));
  }
  shift() {
    return this.head !== null ? this.remove(this.head) : null;
  }
  prependList(list) {
    return this.insertList(list, this.head);
  }
  appendList(list) {
    return this.insertList(list);
  }
  insertList(list, before) {
    if (list.head === null) {
      return this;
    }
    if (before !== void 0 && before !== null) {
      this.updateCursors(before.prev, list.tail, before, list.head);
      if (before.prev !== null) {
        before.prev.next = list.head;
        list.head.prev = before.prev;
      } else {
        this.head = list.head;
      }
      before.prev = list.tail;
      list.tail.next = before;
    } else {
      this.updateCursors(this.tail, list.tail, null, list.head);
      if (this.tail !== null) {
        this.tail.next = list.head;
        list.head.prev = this.tail;
      } else {
        this.head = list.head;
      }
      this.tail = list.tail;
    }
    list.head = null;
    list.tail = null;
    return this;
  }
  replace(oldItem, newItemOrList) {
    if ("head" in newItemOrList) {
      this.insertList(newItemOrList, oldItem);
    } else {
      this.insert(newItemOrList, oldItem);
    }
    this.remove(oldItem);
  }
};

// node_modules/css-tree/lib/utils/create-custom-error.js
function createCustomError(name50, message) {
  const error = Object.create(SyntaxError.prototype);
  const errorStack = new Error();
  return Object.assign(error, {
    name: name50,
    message,
    get stack() {
      return (errorStack.stack || "").replace(/^(.+\n){1,3}/, `${name50}: ${message}
`);
    }
  });
}

// node_modules/css-tree/lib/parser/SyntaxError.js
var MAX_LINE_LENGTH = 100;
var OFFSET_CORRECTION = 60;
var TAB_REPLACEMENT = "    ";
function sourceFragment({ source, line, column, baseLine, baseColumn }, extraLines) {
  function processLines(start, end) {
    return lines.slice(start, end).map(
      (line2, idx) => String(start + idx + 1).padStart(maxNumLength) + " |" + line2
    ).join("\n");
  }
  const prelines = "\n".repeat(Math.max(baseLine - 1, 0));
  const precolumns = " ".repeat(Math.max(baseColumn - 1, 0));
  const lines = (prelines + precolumns + source).split(/\r\n?|\n|\f/);
  const startLine = Math.max(1, line - extraLines) - 1;
  const endLine = Math.min(line + extraLines, lines.length + 1);
  const maxNumLength = Math.max(4, String(endLine).length) + 1;
  let cutLeft = 0;
  column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
  if (column > MAX_LINE_LENGTH) {
    cutLeft = column - OFFSET_CORRECTION + 3;
    column = OFFSET_CORRECTION - 2;
  }
  for (let i = startLine; i <= endLine; i++) {
    if (i >= 0 && i < lines.length) {
      lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
      lines[i] = (cutLeft > 0 && lines[i].length > cutLeft ? "" : "") + lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? "" : "");
    }
  }
  return [
    processLines(startLine, line),
    new Array(column + maxNumLength + 2).join("-") + "^",
    processLines(line, endLine)
  ].filter(Boolean).join("\n").replace(/^(\s+\d+\s+\|\n)+/, "").replace(/\n(\s+\d+\s+\|)+$/, "");
}
function SyntaxError2(message, source, offset, line, column, baseLine = 1, baseColumn = 1) {
  const error = Object.assign(createCustomError("SyntaxError", message), {
    source,
    offset,
    line,
    column,
    sourceFragment(extraLines) {
      return sourceFragment({ source, line, column, baseLine, baseColumn }, isNaN(extraLines) ? 0 : extraLines);
    },
    get formattedMessage() {
      return `Parse error: ${message}
` + sourceFragment({ source, line, column, baseLine, baseColumn }, 2);
    }
  });
  return error;
}

// node_modules/css-tree/lib/parser/sequence.js
function readSequence(recognizer) {
  const children = this.createList();
  let space = false;
  const context = {
    recognizer
  };
  while (!this.eof) {
    switch (this.tokenType) {
      case Comment:
        this.next();
        continue;
      case WhiteSpace:
        space = true;
        this.next();
        continue;
    }
    let child = recognizer.getNode.call(this, context);
    if (child === void 0) {
      break;
    }
    if (space) {
      if (recognizer.onWhiteSpace) {
        recognizer.onWhiteSpace.call(this, child, children, context);
      }
      space = false;
    }
    children.push(child);
  }
  if (space && recognizer.onWhiteSpace) {
    recognizer.onWhiteSpace.call(this, null, children, context);
  }
  return children;
}

// node_modules/css-tree/lib/parser/create.js
var NOOP = () => {
};
var EXCLAMATIONMARK = 33;
var NUMBERSIGN = 35;
var SEMICOLON = 59;
var LEFTCURLYBRACKET = 123;
var NULL = 0;
function createParseContext(name50) {
  return function() {
    return this[name50]();
  };
}
function fetchParseValues(dict) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const name50 of Object.keys(dict)) {
    const item = dict[name50];
    const fn = item.parse || item;
    if (fn) {
      result[name50] = fn;
    }
  }
  return result;
}
function processConfig(config) {
  const parseConfig = {
    context: /* @__PURE__ */ Object.create(null),
    features: Object.assign(/* @__PURE__ */ Object.create(null), config.features),
    scope: Object.assign(/* @__PURE__ */ Object.create(null), config.scope),
    atrule: fetchParseValues(config.atrule),
    pseudo: fetchParseValues(config.pseudo),
    node: fetchParseValues(config.node)
  };
  for (const [name50, context] of Object.entries(config.parseContext)) {
    switch (typeof context) {
      case "function":
        parseConfig.context[name50] = context;
        break;
      case "string":
        parseConfig.context[name50] = createParseContext(context);
        break;
    }
  }
  return {
    config: parseConfig,
    ...parseConfig,
    ...parseConfig.node
  };
}
function createParser(config) {
  let source = "";
  let filename = "<unknown>";
  let needPositions = false;
  let onParseError = NOOP;
  let onParseErrorThrow = false;
  const locationMap = new OffsetToLocation();
  const parser = Object.assign(new TokenStream(), processConfig(config || {}), {
    parseAtrulePrelude: true,
    parseRulePrelude: true,
    parseValue: true,
    parseCustomProperty: false,
    readSequence,
    consumeUntilBalanceEnd: () => 0,
    consumeUntilLeftCurlyBracket(code2) {
      return code2 === LEFTCURLYBRACKET ? 1 : 0;
    },
    consumeUntilLeftCurlyBracketOrSemicolon(code2) {
      return code2 === LEFTCURLYBRACKET || code2 === SEMICOLON ? 1 : 0;
    },
    consumeUntilExclamationMarkOrSemicolon(code2) {
      return code2 === EXCLAMATIONMARK || code2 === SEMICOLON ? 1 : 0;
    },
    consumeUntilSemicolonIncluded(code2) {
      return code2 === SEMICOLON ? 2 : 0;
    },
    createList() {
      return new List();
    },
    createSingleNodeList(node) {
      return new List().appendData(node);
    },
    getFirstListNode(list) {
      return list && list.first;
    },
    getLastListNode(list) {
      return list && list.last;
    },
    parseWithFallback(consumer, fallback) {
      const startIndex = this.tokenIndex;
      try {
        return consumer.call(this);
      } catch (e2) {
        if (onParseErrorThrow) {
          throw e2;
        }
        this.skip(startIndex - this.tokenIndex);
        const fallbackNode = fallback.call(this);
        onParseErrorThrow = true;
        onParseError(e2, fallbackNode);
        onParseErrorThrow = false;
        return fallbackNode;
      }
    },
    lookupNonWSType(offset) {
      let type;
      do {
        type = this.lookupType(offset++);
        if (type !== WhiteSpace && type !== Comment) {
          return type;
        }
      } while (type !== NULL);
      return NULL;
    },
    charCodeAt(offset) {
      return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;
    },
    substring(offsetStart, offsetEnd) {
      return source.substring(offsetStart, offsetEnd);
    },
    substrToCursor(start) {
      return this.source.substring(start, this.tokenStart);
    },
    cmpChar(offset, charCode) {
      return cmpChar(source, offset, charCode);
    },
    cmpStr(offsetStart, offsetEnd, str) {
      return cmpStr(source, offsetStart, offsetEnd, str);
    },
    consume(tokenType2) {
      const start = this.tokenStart;
      this.eat(tokenType2);
      return this.substrToCursor(start);
    },
    consumeFunctionName() {
      const name50 = source.substring(this.tokenStart, this.tokenEnd - 1);
      this.eat(Function2);
      return name50;
    },
    consumeNumber(type) {
      const number4 = source.substring(this.tokenStart, consumeNumber(source, this.tokenStart));
      this.eat(type);
      return number4;
    },
    eat(tokenType2) {
      if (this.tokenType !== tokenType2) {
        const tokenName = names_default[tokenType2].slice(0, -6).replace(/-/g, " ").replace(/^./, (m) => m.toUpperCase());
        let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
        let offset = this.tokenStart;
        switch (tokenType2) {
          case Ident:
            if (this.tokenType === Function2 || this.tokenType === Url) {
              offset = this.tokenEnd - 1;
              message = "Identifier is expected but function found";
            } else {
              message = "Identifier is expected";
            }
            break;
          case Hash:
            if (this.isDelim(NUMBERSIGN)) {
              this.next();
              offset++;
              message = "Name is expected";
            }
            break;
          case Percentage:
            if (this.tokenType === Number2) {
              offset = this.tokenEnd;
              message = "Percent sign is expected";
            }
            break;
        }
        this.error(message, offset);
      }
      this.next();
    },
    eatIdent(name50) {
      if (this.tokenType !== Ident || this.lookupValue(0, name50) === false) {
        this.error(`Identifier "${name50}" is expected`);
      }
      this.next();
    },
    eatDelim(code2) {
      if (!this.isDelim(code2)) {
        this.error(`Delim "${String.fromCharCode(code2)}" is expected`);
      }
      this.next();
    },
    getLocation(start, end) {
      if (needPositions) {
        return locationMap.getLocationRange(
          start,
          end,
          filename
        );
      }
      return null;
    },
    getLocationFromList(list) {
      if (needPositions) {
        const head = this.getFirstListNode(list);
        const tail = this.getLastListNode(list);
        return locationMap.getLocationRange(
          head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart,
          tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart,
          filename
        );
      }
      return null;
    },
    error(message, offset) {
      const location = typeof offset !== "undefined" && offset < source.length ? locationMap.getLocation(offset) : this.eof ? locationMap.getLocation(findWhiteSpaceStart(source, source.length - 1)) : locationMap.getLocation(this.tokenStart);
      throw new SyntaxError2(
        message || "Unexpected input",
        source,
        location.offset,
        location.line,
        location.column,
        locationMap.startLine,
        locationMap.startColumn
      );
    }
  });
  const parse53 = function(source_, options) {
    source = source_;
    options = options || {};
    parser.setSource(source, tokenize);
    locationMap.setSource(
      source,
      options.offset,
      options.line,
      options.column
    );
    filename = options.filename || "<unknown>";
    needPositions = Boolean(options.positions);
    onParseError = typeof options.onParseError === "function" ? options.onParseError : NOOP;
    onParseErrorThrow = false;
    parser.parseAtrulePrelude = "parseAtrulePrelude" in options ? Boolean(options.parseAtrulePrelude) : true;
    parser.parseRulePrelude = "parseRulePrelude" in options ? Boolean(options.parseRulePrelude) : true;
    parser.parseValue = "parseValue" in options ? Boolean(options.parseValue) : true;
    parser.parseCustomProperty = "parseCustomProperty" in options ? Boolean(options.parseCustomProperty) : false;
    const { context = "default", onComment } = options;
    if (context in parser.context === false) {
      throw new Error("Unknown context `" + context + "`");
    }
    if (typeof onComment === "function") {
      parser.forEachToken((type, start, end) => {
        if (type === Comment) {
          const loc = parser.getLocation(start, end);
          const value = cmpStr(source, end - 2, end, "*/") ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);
          onComment(value, loc);
        }
      });
    }
    const ast = parser.context[context].call(parser, options);
    if (!parser.eof) {
      parser.error();
    }
    return ast;
  };
  return Object.assign(parse53, {
    SyntaxError: SyntaxError2,
    config: parser.config
  });
}

// node_modules/css-tree/lib/generator/sourceMap.js
var import_source_map_generator = __toESM(require_source_map_generator(), 1);
var trackNodes = /* @__PURE__ */ new Set(["Atrule", "Selector", "Declaration"]);
function generateSourceMap(handlers) {
  const map = new import_source_map_generator.SourceMapGenerator();
  const generated = {
    line: 1,
    column: 0
  };
  const original = {
    line: 0,
    // should be zero to add first mapping
    column: 0
  };
  const activatedGenerated = {
    line: 1,
    column: 0
  };
  const activatedMapping = {
    generated: activatedGenerated
  };
  let line = 1;
  let column = 0;
  let sourceMappingActive = false;
  const origHandlersNode = handlers.node;
  handlers.node = function(node) {
    if (node.loc && node.loc.start && trackNodes.has(node.type)) {
      const nodeLine = node.loc.start.line;
      const nodeColumn = node.loc.start.column - 1;
      if (original.line !== nodeLine || original.column !== nodeColumn) {
        original.line = nodeLine;
        original.column = nodeColumn;
        generated.line = line;
        generated.column = column;
        if (sourceMappingActive) {
          sourceMappingActive = false;
          if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
            map.addMapping(activatedMapping);
          }
        }
        sourceMappingActive = true;
        map.addMapping({
          source: node.loc.source,
          original,
          generated
        });
      }
    }
    origHandlersNode.call(this, node);
    if (sourceMappingActive && trackNodes.has(node.type)) {
      activatedGenerated.line = line;
      activatedGenerated.column = column;
    }
  };
  const origHandlersEmit = handlers.emit;
  handlers.emit = function(value, type, auto3) {
    for (let i = 0; i < value.length; i++) {
      if (value.charCodeAt(i) === 10) {
        line++;
        column = 0;
      } else {
        column++;
      }
    }
    origHandlersEmit(value, type, auto3);
  };
  const origHandlersResult = handlers.result;
  handlers.result = function() {
    if (sourceMappingActive) {
      map.addMapping(activatedMapping);
    }
    return {
      css: origHandlersResult(),
      map
    };
  };
  return handlers;
}

// node_modules/css-tree/lib/generator/token-before.js
var token_before_exports = {};
__export(token_before_exports, {
  safe: () => safe,
  spec: () => spec
});
var PLUSSIGN = 43;
var HYPHENMINUS = 45;
var code = (type, value) => {
  if (type === Delim) {
    type = value;
  }
  if (typeof type === "string") {
    const charCode = type.charCodeAt(0);
    return charCode > 127 ? 32768 : charCode << 8;
  }
  return type;
};
var specPairs = [
  [Ident, Ident],
  [Ident, Function2],
  [Ident, Url],
  [Ident, BadUrl],
  [Ident, "-"],
  [Ident, Number2],
  [Ident, Percentage],
  [Ident, Dimension],
  [Ident, CDC],
  [Ident, LeftParenthesis],
  [AtKeyword, Ident],
  [AtKeyword, Function2],
  [AtKeyword, Url],
  [AtKeyword, BadUrl],
  [AtKeyword, "-"],
  [AtKeyword, Number2],
  [AtKeyword, Percentage],
  [AtKeyword, Dimension],
  [AtKeyword, CDC],
  [Hash, Ident],
  [Hash, Function2],
  [Hash, Url],
  [Hash, BadUrl],
  [Hash, "-"],
  [Hash, Number2],
  [Hash, Percentage],
  [Hash, Dimension],
  [Hash, CDC],
  [Dimension, Ident],
  [Dimension, Function2],
  [Dimension, Url],
  [Dimension, BadUrl],
  [Dimension, "-"],
  [Dimension, Number2],
  [Dimension, Percentage],
  [Dimension, Dimension],
  [Dimension, CDC],
  ["#", Ident],
  ["#", Function2],
  ["#", Url],
  ["#", BadUrl],
  ["#", "-"],
  ["#", Number2],
  ["#", Percentage],
  ["#", Dimension],
  ["#", CDC],
  // https://github.com/w3c/csswg-drafts/pull/6874
  ["-", Ident],
  ["-", Function2],
  ["-", Url],
  ["-", BadUrl],
  ["-", "-"],
  ["-", Number2],
  ["-", Percentage],
  ["-", Dimension],
  ["-", CDC],
  // https://github.com/w3c/csswg-drafts/pull/6874
  [Number2, Ident],
  [Number2, Function2],
  [Number2, Url],
  [Number2, BadUrl],
  [Number2, Number2],
  [Number2, Percentage],
  [Number2, Dimension],
  [Number2, "%"],
  [Number2, CDC],
  // https://github.com/w3c/csswg-drafts/pull/6874
  ["@", Ident],
  ["@", Function2],
  ["@", Url],
  ["@", BadUrl],
  ["@", "-"],
  ["@", CDC],
  // https://github.com/w3c/csswg-drafts/pull/6874
  [".", Number2],
  [".", Percentage],
  [".", Dimension],
  ["+", Number2],
  ["+", Percentage],
  ["+", Dimension],
  ["/", "*"]
];
var safePairs = specPairs.concat([
  [Ident, Hash],
  [Dimension, Hash],
  [Hash, Hash],
  [AtKeyword, LeftParenthesis],
  [AtKeyword, String2],
  [AtKeyword, Colon],
  [Percentage, Percentage],
  [Percentage, Dimension],
  [Percentage, Function2],
  [Percentage, "-"],
  [RightParenthesis, Ident],
  [RightParenthesis, Function2],
  [RightParenthesis, Percentage],
  [RightParenthesis, Dimension],
  [RightParenthesis, Hash],
  [RightParenthesis, "-"]
]);
function createMap(pairs) {
  const isWhiteSpaceRequired = new Set(
    pairs.map(([prev, next]) => code(prev) << 16 | code(next))
  );
  return function(prevCode, type, value) {
    const nextCode = code(type, value);
    const nextCharCode = value.charCodeAt(0);
    const emitWs = nextCharCode === HYPHENMINUS && type !== Ident && type !== Function2 && type !== CDC || nextCharCode === PLUSSIGN ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8) : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);
    if (emitWs) {
      this.emit(" ", WhiteSpace, true);
    }
    return nextCode;
  };
}
var spec = createMap(specPairs);
var safe = createMap(safePairs);

// node_modules/css-tree/lib/generator/create.js
var REVERSESOLIDUS = 92;
function processChildren(node, delimeter) {
  if (typeof delimeter === "function") {
    let prev = null;
    node.children.forEach((node2) => {
      if (prev !== null) {
        delimeter.call(this, prev);
      }
      this.node(node2);
      prev = node2;
    });
    return;
  }
  node.children.forEach(this.node, this);
}
function processChunk(chunk) {
  tokenize(chunk, (type, start, end) => {
    this.token(type, chunk.slice(start, end));
  });
}
function createGenerator2(config) {
  const types = /* @__PURE__ */ new Map();
  for (let [name50, item] of Object.entries(config.node)) {
    const fn = item.generate || item;
    if (typeof fn === "function") {
      types.set(name50, item.generate || item);
    }
  }
  return function(node, options) {
    let buffer = "";
    let prevCode = 0;
    let handlers = {
      node(node2) {
        if (types.has(node2.type)) {
          types.get(node2.type).call(publicApi, node2);
        } else {
          throw new Error("Unknown node type: " + node2.type);
        }
      },
      tokenBefore: safe,
      token(type, value) {
        prevCode = this.tokenBefore(prevCode, type, value);
        this.emit(value, type, false);
        if (type === Delim && value.charCodeAt(0) === REVERSESOLIDUS) {
          this.emit("\n", WhiteSpace, true);
        }
      },
      emit(value) {
        buffer += value;
      },
      result() {
        return buffer;
      }
    };
    if (options) {
      if (typeof options.decorator === "function") {
        handlers = options.decorator(handlers);
      }
      if (options.sourceMap) {
        handlers = generateSourceMap(handlers);
      }
      if (options.mode in token_before_exports) {
        handlers.tokenBefore = token_before_exports[options.mode];
      }
    }
    const publicApi = {
      node: (node2) => handlers.node(node2),
      children: processChildren,
      token: (type, value) => handlers.token(type, value),
      tokenize: processChunk
    };
    handlers.node(node);
    return handlers.result();
  };
}

// node_modules/css-tree/lib/convertor/create.js
function createConvertor(walk3) {
  return {
    fromPlainObject(ast) {
      walk3(ast, {
        enter(node) {
          if (node.children && node.children instanceof List === false) {
            node.children = new List().fromArray(node.children);
          }
        }
      });
      return ast;
    },
    toPlainObject(ast) {
      walk3(ast, {
        leave(node) {
          if (node.children && node.children instanceof List) {
            node.children = node.children.toArray();
          }
        }
      });
      return ast;
    }
  };
}

// node_modules/css-tree/lib/walker/create.js
var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
var noop2 = function() {
};
function ensureFunction(value) {
  return typeof value === "function" ? value : noop2;
}
function invokeForType(fn, type) {
  return function(node, item, list) {
    if (node.type === type) {
      fn.call(this, node, item, list);
    }
  };
}
function getWalkersFromStructure(name50, nodeType) {
  const structure50 = nodeType.structure;
  const walkers = [];
  for (const key in structure50) {
    if (hasOwnProperty2.call(structure50, key) === false) {
      continue;
    }
    let fieldTypes = structure50[key];
    const walker = {
      name: key,
      type: false,
      nullable: false
    };
    if (!Array.isArray(fieldTypes)) {
      fieldTypes = [fieldTypes];
    }
    for (const fieldType of fieldTypes) {
      if (fieldType === null) {
        walker.nullable = true;
      } else if (typeof fieldType === "string") {
        walker.type = "node";
      } else if (Array.isArray(fieldType)) {
        walker.type = "list";
      }
    }
    if (walker.type) {
      walkers.push(walker);
    }
  }
  if (walkers.length) {
    return {
      context: nodeType.walkContext,
      fields: walkers
    };
  }
  return null;
}
function getTypesFromConfig(config) {
  const types = {};
  for (const name50 in config.node) {
    if (hasOwnProperty2.call(config.node, name50)) {
      const nodeType = config.node[name50];
      if (!nodeType.structure) {
        throw new Error("Missed `structure` field in `" + name50 + "` node type definition");
      }
      types[name50] = getWalkersFromStructure(name50, nodeType);
    }
  }
  return types;
}
function createTypeIterator(config, reverse) {
  const fields = config.fields.slice();
  const contextName = config.context;
  const useContext = typeof contextName === "string";
  if (reverse) {
    fields.reverse();
  }
  return function(node, context, walk3, walkReducer) {
    let prevContextValue;
    if (useContext) {
      prevContextValue = context[contextName];
      context[contextName] = node;
    }
    for (const field of fields) {
      const ref = node[field.name];
      if (!field.nullable || ref) {
        if (field.type === "list") {
          const breakWalk = reverse ? ref.reduceRight(walkReducer, false) : ref.reduce(walkReducer, false);
          if (breakWalk) {
            return true;
          }
        } else if (walk3(ref)) {
          return true;
        }
      }
    }
    if (useContext) {
      context[contextName] = prevContextValue;
    }
  };
}
function createFastTraveralMap({
  StyleSheet,
  Atrule,
  Rule,
  Block,
  DeclarationList
}) {
  return {
    Atrule: {
      StyleSheet,
      Atrule,
      Rule,
      Block
    },
    Rule: {
      StyleSheet,
      Atrule,
      Rule,
      Block
    },
    Declaration: {
      StyleSheet,
      Atrule,
      Rule,
      Block,
      DeclarationList
    }
  };
}
function createWalker(config) {
  const types = getTypesFromConfig(config);
  const iteratorsNatural = {};
  const iteratorsReverse = {};
  const breakWalk = Symbol("break-walk");
  const skipNode = Symbol("skip-node");
  for (const name50 in types) {
    if (hasOwnProperty2.call(types, name50) && types[name50] !== null) {
      iteratorsNatural[name50] = createTypeIterator(types[name50], false);
      iteratorsReverse[name50] = createTypeIterator(types[name50], true);
    }
  }
  const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
  const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);
  const walk3 = function(root, options) {
    function walkNode(node, item, list) {
      const enterRet = enter.call(context, node, item, list);
      if (enterRet === breakWalk) {
        return true;
      }
      if (enterRet === skipNode) {
        return false;
      }
      if (iterators.hasOwnProperty(node.type)) {
        if (iterators[node.type](node, context, walkNode, walkReducer)) {
          return true;
        }
      }
      if (leave.call(context, node, item, list) === breakWalk) {
        return true;
      }
      return false;
    }
    let enter = noop2;
    let leave = noop2;
    let iterators = iteratorsNatural;
    let walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
    const context = {
      break: breakWalk,
      skip: skipNode,
      root,
      stylesheet: null,
      atrule: null,
      atrulePrelude: null,
      rule: null,
      selector: null,
      block: null,
      declaration: null,
      function: null
    };
    if (typeof options === "function") {
      enter = options;
    } else if (options) {
      enter = ensureFunction(options.enter);
      leave = ensureFunction(options.leave);
      if (options.reverse) {
        iterators = iteratorsReverse;
      }
      if (options.visit) {
        if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
          iterators = options.reverse ? fastTraversalIteratorsReverse[options.visit] : fastTraversalIteratorsNatural[options.visit];
        } else if (!types.hasOwnProperty(options.visit)) {
          throw new Error("Bad value `" + options.visit + "` for `visit` option (should be: " + Object.keys(types).sort().join(", ") + ")");
        }
        enter = invokeForType(enter, options.visit);
        leave = invokeForType(leave, options.visit);
      }
    }
    if (enter === noop2 && leave === noop2) {
      throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
    }
    walkNode(root);
  };
  walk3.break = breakWalk;
  walk3.skip = skipNode;
  walk3.find = function(ast, fn) {
    let found = null;
    walk3(ast, function(node, item, list) {
      if (fn.call(this, node, item, list)) {
        found = node;
        return breakWalk;
      }
    });
    return found;
  };
  walk3.findLast = function(ast, fn) {
    let found = null;
    walk3(ast, {
      reverse: true,
      enter(node, item, list) {
        if (fn.call(this, node, item, list)) {
          found = node;
          return breakWalk;
        }
      }
    });
    return found;
  };
  walk3.findAll = function(ast, fn) {
    const found = [];
    walk3(ast, function(node, item, list) {
      if (fn.call(this, node, item, list)) {
        found.push(node);
      }
    });
    return found;
  };
  return walk3;
}

// node_modules/css-tree/lib/definition-syntax/generate.js
function noop3(value) {
  return value;
}
function generateMultiplier(multiplier) {
  const { min, max, comma: comma2 } = multiplier;
  if (min === 0 && max === 0) {
    return comma2 ? "#?" : "*";
  }
  if (min === 0 && max === 1) {
    return "?";
  }
  if (min === 1 && max === 0) {
    return comma2 ? "#" : "+";
  }
  if (min === 1 && max === 1) {
    return "";
  }
  return (comma2 ? "#" : "") + (min === max ? "{" + min + "}" : "{" + min + "," + (max !== 0 ? max : "") + "}");
}
function generateTypeOpts(node) {
  switch (node.type) {
    case "Range":
      return " [" + (node.min === null ? "-" : node.min) + "," + (node.max === null ? "" : node.max) + "]";
    default:
      throw new Error("Unknown node type `" + node.type + "`");
  }
}
function generateSequence(node, decorate, forceBraces, compact) {
  const combinator = node.combinator === " " || compact ? node.combinator : " " + node.combinator + " ";
  const result = node.terms.map((term) => internalGenerate(term, decorate, forceBraces, compact)).join(combinator);
  if (node.explicit || forceBraces) {
    return (compact || result[0] === "," ? "[" : "[ ") + result + (compact ? "]" : " ]");
  }
  return result;
}
function internalGenerate(node, decorate, forceBraces, compact) {
  let result;
  switch (node.type) {
    case "Group":
      result = generateSequence(node, decorate, forceBraces, compact) + (node.disallowEmpty ? "!" : "");
      break;
    case "Multiplier":
      return internalGenerate(node.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node), node);
    case "Boolean":
      result = "<boolean-expr[" + internalGenerate(node.term, decorate, forceBraces, compact) + "]>";
      break;
    case "Type":
      result = "<" + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : "") + ">";
      break;
    case "Property":
      result = "<'" + node.name + "'>";
      break;
    case "Keyword":
      result = node.name;
      break;
    case "AtKeyword":
      result = "@" + node.name;
      break;
    case "Function":
      result = node.name + "(";
      break;
    case "String":
    case "Token":
      result = node.value;
      break;
    case "Comma":
      result = ",";
      break;
    default:
      throw new Error("Unknown node type `" + node.type + "`");
  }
  return decorate(result, node);
}
function generate(node, options) {
  let decorate = noop3;
  let forceBraces = false;
  let compact = false;
  if (typeof options === "function") {
    decorate = options;
  } else if (options) {
    forceBraces = Boolean(options.forceBraces);
    compact = Boolean(options.compact);
    if (typeof options.decorate === "function") {
      decorate = options.decorate;
    }
  }
  return internalGenerate(node, decorate, forceBraces, compact);
}

// node_modules/css-tree/lib/lexer/error.js
var defaultLoc = { offset: 0, line: 1, column: 1 };
function locateMismatch(matchResult, node) {
  const tokens = matchResult.tokens;
  const longestMatch = matchResult.longestMatch;
  const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
  const badNode = mismatchNode !== node ? mismatchNode : null;
  let mismatchOffset = 0;
  let mismatchLength = 0;
  let entries = 0;
  let css = "";
  let start;
  let end;
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i].value;
    if (i === longestMatch) {
      mismatchLength = token.length;
      mismatchOffset = css.length;
    }
    if (badNode !== null && tokens[i].node === badNode) {
      if (i <= longestMatch) {
        entries++;
      } else {
        entries = 0;
      }
    }
    css += token;
  }
  if (longestMatch === tokens.length || entries > 1) {
    start = fromLoc(badNode || node, "end") || buildLoc(defaultLoc, css);
    end = buildLoc(start);
  } else {
    start = fromLoc(badNode, "start") || buildLoc(fromLoc(node, "start") || defaultLoc, css.slice(0, mismatchOffset));
    end = fromLoc(badNode, "end") || buildLoc(start, css.substr(mismatchOffset, mismatchLength));
  }
  return {
    css,
    mismatchOffset,
    mismatchLength,
    start,
    end
  };
}
function fromLoc(node, point) {
  const value = node && node.loc && node.loc[point];
  if (value) {
    return "line" in value ? buildLoc(value) : value;
  }
  return null;
}
function buildLoc({ offset, line, column }, extra) {
  const loc = {
    offset,
    line,
    column
  };
  if (extra) {
    const lines = extra.split(/\n|\r\n?|\f/);
    loc.offset += extra.length;
    loc.line += lines.length - 1;
    loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
  }
  return loc;
}
var SyntaxReferenceError = function(type, referenceName) {
  const error = createCustomError(
    "SyntaxReferenceError",
    type + (referenceName ? " `" + referenceName + "`" : "")
  );
  error.reference = referenceName;
  return error;
};
var SyntaxMatchError = function(message, syntax, node, matchResult) {
  const error = createCustomError("SyntaxMatchError", message);
  const {
    css,
    mismatchOffset,
    mismatchLength,
    start,
    end
  } = locateMismatch(matchResult, node);
  error.rawMessage = message;
  error.syntax = syntax ? generate(syntax) : "<generic>";
  error.css = css;
  error.mismatchOffset = mismatchOffset;
  error.mismatchLength = mismatchLength;
  error.message = message + "\n  syntax: " + error.syntax + "\n   value: " + (css || "<empty string>") + "\n  --------" + new Array(error.mismatchOffset + 1).join("-") + "^";
  Object.assign(error, start);
  error.loc = {
    source: node && node.loc && node.loc.source || "<unknown>",
    start,
    end
  };
  return error;
};

// node_modules/css-tree/lib/utils/names.js
var keywords = /* @__PURE__ */ new Map();
var properties4 = /* @__PURE__ */ new Map();
var HYPHENMINUS2 = 45;
var keyword = getKeywordDescriptor;
var property3 = getPropertyDescriptor;
function isCustomProperty(str, offset) {
  offset = offset || 0;
  return str.length - offset >= 2 && str.charCodeAt(offset) === HYPHENMINUS2 && str.charCodeAt(offset + 1) === HYPHENMINUS2;
}
function getVendorPrefix(str, offset) {
  offset = offset || 0;
  if (str.length - offset >= 3) {
    if (str.charCodeAt(offset) === HYPHENMINUS2 && str.charCodeAt(offset + 1) !== HYPHENMINUS2) {
      const secondDashIndex = str.indexOf("-", offset + 2);
      if (secondDashIndex !== -1) {
        return str.substring(offset, secondDashIndex + 1);
      }
    }
  }
  return "";
}
function getKeywordDescriptor(keyword2) {
  if (keywords.has(keyword2)) {
    return keywords.get(keyword2);
  }
  const name50 = keyword2.toLowerCase();
  let descriptor = keywords.get(name50);
  if (descriptor === void 0) {
    const custom2 = isCustomProperty(name50, 0);
    const vendor = !custom2 ? getVendorPrefix(name50, 0) : "";
    descriptor = Object.freeze({
      basename: name50.substr(vendor.length),
      name: name50,
      prefix: vendor,
      vendor,
      custom: custom2
    });
  }
  keywords.set(keyword2, descriptor);
  return descriptor;
}
function getPropertyDescriptor(property4) {
  if (properties4.has(property4)) {
    return properties4.get(property4);
  }
  let name50 = property4;
  let hack = property4[0];
  if (hack === "/") {
    hack = property4[1] === "/" ? "//" : "/";
  } else if (hack !== "_" && hack !== "*" && hack !== "$" && hack !== "#" && hack !== "+" && hack !== "&") {
    hack = "";
  }
  const custom2 = isCustomProperty(name50, hack.length);
  if (!custom2) {
    name50 = name50.toLowerCase();
    if (properties4.has(name50)) {
      const descriptor2 = properties4.get(name50);
      properties4.set(property4, descriptor2);
      return descriptor2;
    }
  }
  const vendor = !custom2 ? getVendorPrefix(name50, hack.length) : "";
  const prefix = name50.substr(0, hack.length + vendor.length);
  const descriptor = Object.freeze({
    basename: name50.substr(prefix.length),
    name: name50.substr(hack.length),
    hack,
    vendor,
    prefix,
    custom: custom2
  });
  properties4.set(property4, descriptor);
  return descriptor;
}

// node_modules/css-tree/lib/lexer/generic-const.js
var cssWideKeywords = [
  "initial",
  "inherit",
  "unset",
  "revert",
  "revert-layer"
];

// node_modules/css-tree/lib/lexer/generic-an-plus-b.js
var PLUSSIGN2 = 43;
var HYPHENMINUS3 = 45;
var N2 = 110;
var DISALLOW_SIGN = true;
var ALLOW_SIGN = false;
function isDelim(token, code2) {
  return token !== null && token.type === Delim && token.value.charCodeAt(0) === code2;
}
function skipSC(token, offset, getNextToken) {
  while (token !== null && (token.type === WhiteSpace || token.type === Comment)) {
    token = getNextToken(++offset);
  }
  return offset;
}
function checkInteger(token, valueOffset, disallowSign, offset) {
  if (!token) {
    return 0;
  }
  const code2 = token.value.charCodeAt(valueOffset);
  if (code2 === PLUSSIGN2 || code2 === HYPHENMINUS3) {
    if (disallowSign) {
      return 0;
    }
    valueOffset++;
  }
  for (; valueOffset < token.value.length; valueOffset++) {
    if (!isDigit(token.value.charCodeAt(valueOffset))) {
      return 0;
    }
  }
  return offset + 1;
}
function consumeB(token, offset_, getNextToken) {
  let sign = false;
  let offset = skipSC(token, offset_, getNextToken);
  token = getNextToken(offset);
  if (token === null) {
    return offset_;
  }
  if (token.type !== Number2) {
    if (isDelim(token, PLUSSIGN2) || isDelim(token, HYPHENMINUS3)) {
      sign = true;
      offset = skipSC(getNextToken(++offset), offset, getNextToken);
      token = getNextToken(offset);
      if (token === null || token.type !== Number2) {
        return 0;
      }
    } else {
      return offset_;
    }
  }
  if (!sign) {
    const code2 = token.value.charCodeAt(0);
    if (code2 !== PLUSSIGN2 && code2 !== HYPHENMINUS3) {
      return 0;
    }
  }
  return checkInteger(token, sign ? 0 : 1, sign, offset);
}
function anPlusB(token, getNextToken) {
  let offset = 0;
  if (!token) {
    return 0;
  }
  if (token.type === Number2) {
    return checkInteger(token, 0, ALLOW_SIGN, offset);
  } else if (token.type === Ident && token.value.charCodeAt(0) === HYPHENMINUS3) {
    if (!cmpChar(token.value, 1, N2)) {
      return 0;
    }
    switch (token.value.length) {
      case 2:
        return consumeB(getNextToken(++offset), offset, getNextToken);
      case 3:
        if (token.value.charCodeAt(2) !== HYPHENMINUS3) {
          return 0;
        }
        offset = skipSC(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);
        return checkInteger(token, 0, DISALLOW_SIGN, offset);
      default:
        if (token.value.charCodeAt(2) !== HYPHENMINUS3) {
          return 0;
        }
        return checkInteger(token, 3, DISALLOW_SIGN, offset);
    }
  } else if (token.type === Ident || isDelim(token, PLUSSIGN2) && getNextToken(offset + 1).type === Ident) {
    if (token.type !== Ident) {
      token = getNextToken(++offset);
    }
    if (token === null || !cmpChar(token.value, 0, N2)) {
      return 0;
    }
    switch (token.value.length) {
      case 1:
        return consumeB(getNextToken(++offset), offset, getNextToken);
      case 2:
        if (token.value.charCodeAt(1) !== HYPHENMINUS3) {
          return 0;
        }
        offset = skipSC(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);
        return checkInteger(token, 0, DISALLOW_SIGN, offset);
      default:
        if (token.value.charCodeAt(1) !== HYPHENMINUS3) {
          return 0;
        }
        return checkInteger(token, 2, DISALLOW_SIGN, offset);
    }
  } else if (token.type === Dimension) {
    let code2 = token.value.charCodeAt(0);
    let sign = code2 === PLUSSIGN2 || code2 === HYPHENMINUS3 ? 1 : 0;
    let i = sign;
    for (; i < token.value.length; i++) {
      if (!isDigit(token.value.charCodeAt(i))) {
        break;
      }
    }
    if (i === sign) {
      return 0;
    }
    if (!cmpChar(token.value, i, N2)) {
      return 0;
    }
    if (i + 1 === token.value.length) {
      return consumeB(getNextToken(++offset), offset, getNextToken);
    } else {
      if (token.value.charCodeAt(i + 1) !== HYPHENMINUS3) {
        return 0;
      }
      if (i + 2 === token.value.length) {
        offset = skipSC(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);
        return checkInteger(token, 0, DISALLOW_SIGN, offset);
      } else {
        return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
      }
    }
  }
  return 0;
}

// node_modules/css-tree/lib/lexer/generic-urange.js
var PLUSSIGN3 = 43;
var HYPHENMINUS4 = 45;
var QUESTIONMARK = 63;
var U = 117;
function isDelim2(token, code2) {
  return token !== null && token.type === Delim && token.value.charCodeAt(0) === code2;
}
function startsWith(token, code2) {
  return token.value.charCodeAt(0) === code2;
}
function hexSequence(token, offset, allowDash) {
  let hexlen = 0;
  for (let pos = offset; pos < token.value.length; pos++) {
    const code2 = token.value.charCodeAt(pos);
    if (code2 === HYPHENMINUS4 && allowDash && hexlen !== 0) {
      hexSequence(token, offset + hexlen + 1, false);
      return 6;
    }
    if (!isHexDigit(code2)) {
      return 0;
    }
    if (++hexlen > 6) {
      return 0;
    }
    ;
  }
  return hexlen;
}
function withQuestionMarkSequence(consumed, length2, getNextToken) {
  if (!consumed) {
    return 0;
  }
  while (isDelim2(getNextToken(length2), QUESTIONMARK)) {
    if (++consumed > 6) {
      return 0;
    }
    length2++;
  }
  return length2;
}
function urange(token, getNextToken) {
  let length2 = 0;
  if (token === null || token.type !== Ident || !cmpChar(token.value, 0, U)) {
    return 0;
  }
  token = getNextToken(++length2);
  if (token === null) {
    return 0;
  }
  if (isDelim2(token, PLUSSIGN3)) {
    token = getNextToken(++length2);
    if (token === null) {
      return 0;
    }
    if (token.type === Ident) {
      return withQuestionMarkSequence(hexSequence(token, 0, true), ++length2, getNextToken);
    }
    if (isDelim2(token, QUESTIONMARK)) {
      return withQuestionMarkSequence(1, ++length2, getNextToken);
    }
    return 0;
  }
  if (token.type === Number2) {
    const consumedHexLength = hexSequence(token, 1, true);
    if (consumedHexLength === 0) {
      return 0;
    }
    token = getNextToken(++length2);
    if (token === null) {
      return length2;
    }
    if (token.type === Dimension || token.type === Number2) {
      if (!startsWith(token, HYPHENMINUS4) || !hexSequence(token, 1, false)) {
        return 0;
      }
      return length2 + 1;
    }
    return withQuestionMarkSequence(consumedHexLength, length2, getNextToken);
  }
  if (token.type === Dimension) {
    return withQuestionMarkSequence(hexSequence(token, 1, true), ++length2, getNextToken);
  }
  return 0;
}

// node_modules/css-tree/lib/lexer/generic.js
var calcFunctionNames = ["calc(", "-moz-calc(", "-webkit-calc("];
var balancePair2 = /* @__PURE__ */ new Map([
  [Function2, RightParenthesis],
  [LeftParenthesis, RightParenthesis],
  [LeftSquareBracket, RightSquareBracket],
  [LeftCurlyBracket, RightCurlyBracket]
]);
function charCodeAt(str, index) {
  return index < str.length ? str.charCodeAt(index) : 0;
}
function eqStr(actual, expected) {
  return cmpStr(actual, 0, actual.length, expected);
}
function eqStrAny(actual, expected) {
  for (let i = 0; i < expected.length; i++) {
    if (eqStr(actual, expected[i])) {
      return true;
    }
  }
  return false;
}
function isPostfixIeHack(str, offset) {
  if (offset !== str.length - 2) {
    return false;
  }
  return charCodeAt(str, offset) === 92 && // U+005C REVERSE SOLIDUS (\)
  isDigit(charCodeAt(str, offset + 1));
}
function outOfRange(opts, value, numEnd) {
  if (opts && opts.type === "Range") {
    const num = Number(
      numEnd !== void 0 && numEnd !== value.length ? value.substr(0, numEnd) : value
    );
    if (isNaN(num)) {
      return true;
    }
    if (opts.min !== null && num < opts.min && typeof opts.min !== "string") {
      return true;
    }
    if (opts.max !== null && num > opts.max && typeof opts.max !== "string") {
      return true;
    }
  }
  return false;
}
function consumeFunction(token, getNextToken) {
  let balanceCloseType = 0;
  let balanceStash = [];
  let length2 = 0;
  scan:
    do {
      switch (token.type) {
        case RightCurlyBracket:
        case RightParenthesis:
        case RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          if (balanceStash.length === 0) {
            length2++;
            break scan;
          }
          break;
        case Function2:
        case LeftParenthesis:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair2.get(token.type);
          break;
      }
      length2++;
    } while (token = getNextToken(length2));
  return length2;
}
function calc(next) {
  return function(token, getNextToken, opts) {
    if (token === null) {
      return 0;
    }
    if (token.type === Function2 && eqStrAny(token.value, calcFunctionNames)) {
      return consumeFunction(token, getNextToken);
    }
    return next(token, getNextToken, opts);
  };
}
function tokenType(expectedTokenType) {
  return function(token) {
    if (token === null || token.type !== expectedTokenType) {
      return 0;
    }
    return 1;
  };
}
function customIdent(token) {
  if (token === null || token.type !== Ident) {
    return 0;
  }
  const name50 = token.value.toLowerCase();
  if (eqStrAny(name50, cssWideKeywords)) {
    return 0;
  }
  if (eqStr(name50, "default")) {
    return 0;
  }
  return 1;
}
function dashedIdent(token) {
  if (token === null || token.type !== Ident) {
    return 0;
  }
  if (charCodeAt(token.value, 0) !== 45 || charCodeAt(token.value, 1) !== 45) {
    return 0;
  }
  return 1;
}
function customPropertyName(token) {
  if (!dashedIdent(token)) {
    return 0;
  }
  if (token.value === "--") {
    return 0;
  }
  return 1;
}
function hexColor(token) {
  if (token === null || token.type !== Hash) {
    return 0;
  }
  const length2 = token.value.length;
  if (length2 !== 4 && length2 !== 5 && length2 !== 7 && length2 !== 9) {
    return 0;
  }
  for (let i = 1; i < length2; i++) {
    if (!isHexDigit(charCodeAt(token.value, i))) {
      return 0;
    }
  }
  return 1;
}
function idSelector(token) {
  if (token === null || token.type !== Hash) {
    return 0;
  }
  if (!isIdentifierStart(charCodeAt(token.value, 1), charCodeAt(token.value, 2), charCodeAt(token.value, 3))) {
    return 0;
  }
  return 1;
}
function declarationValue(token, getNextToken) {
  if (!token) {
    return 0;
  }
  let balanceCloseType = 0;
  let balanceStash = [];
  let length2 = 0;
  scan:
    do {
      switch (token.type) {
        case BadString:
        case BadUrl:
          break scan;
        case RightCurlyBracket:
        case RightParenthesis:
        case RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          break;
        case Semicolon:
          if (balanceCloseType === 0) {
            break scan;
          }
          break;
        case Delim:
          if (balanceCloseType === 0 && token.value === "!") {
            break scan;
          }
          break;
        case Function2:
        case LeftParenthesis:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair2.get(token.type);
          break;
      }
      length2++;
    } while (token = getNextToken(length2));
  return length2;
}
function anyValue(token, getNextToken) {
  if (!token) {
    return 0;
  }
  let balanceCloseType = 0;
  let balanceStash = [];
  let length2 = 0;
  scan:
    do {
      switch (token.type) {
        case BadString:
        case BadUrl:
          break scan;
        case RightCurlyBracket:
        case RightParenthesis:
        case RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          break;
        case Function2:
        case LeftParenthesis:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair2.get(token.type);
          break;
      }
      length2++;
    } while (token = getNextToken(length2));
  return length2;
}
function dimension(type) {
  if (type) {
    type = new Set(type);
  }
  return function(token, getNextToken, opts) {
    if (token === null || token.type !== Dimension) {
      return 0;
    }
    const numberEnd = consumeNumber(token.value, 0);
    if (type !== null) {
      const reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
      const unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset) ? token.value.substr(numberEnd) : token.value.substring(numberEnd, reverseSolidusOffset);
      if (type.has(unit.toLowerCase()) === false) {
        return 0;
      }
    }
    if (outOfRange(opts, token.value, numberEnd)) {
      return 0;
    }
    return 1;
  };
}
function percentage(token, getNextToken, opts) {
  if (token === null || token.type !== Percentage) {
    return 0;
  }
  if (outOfRange(opts, token.value, token.value.length - 1)) {
    return 0;
  }
  return 1;
}
function zero(next) {
  if (typeof next !== "function") {
    next = function() {
      return 0;
    };
  }
  return function(token, getNextToken, opts) {
    if (token !== null && token.type === Number2) {
      if (Number(token.value) === 0) {
        return 1;
      }
    }
    return next(token, getNextToken, opts);
  };
}
function number3(token, getNextToken, opts) {
  if (token === null) {
    return 0;
  }
  const numberEnd = consumeNumber(token.value, 0);
  const isNumber = numberEnd === token.value.length;
  if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
    return 0;
  }
  if (outOfRange(opts, token.value, numberEnd)) {
    return 0;
  }
  return 1;
}
function integer(token, getNextToken, opts) {
  if (token === null || token.type !== Number2) {
    return 0;
  }
  let i = charCodeAt(token.value, 0) === 43 || // U+002B PLUS SIGN (+)
  charCodeAt(token.value, 0) === 45 ? 1 : 0;
  for (; i < token.value.length; i++) {
    if (!isDigit(charCodeAt(token.value, i))) {
      return 0;
    }
  }
  if (outOfRange(opts, token.value, i)) {
    return 0;
  }
  return 1;
}
var tokenTypes = {
  "ident-token": tokenType(Ident),
  "function-token": tokenType(Function2),
  "at-keyword-token": tokenType(AtKeyword),
  "hash-token": tokenType(Hash),
  "string-token": tokenType(String2),
  "bad-string-token": tokenType(BadString),
  "url-token": tokenType(Url),
  "bad-url-token": tokenType(BadUrl),
  "delim-token": tokenType(Delim),
  "number-token": tokenType(Number2),
  "percentage-token": tokenType(Percentage),
  "dimension-token": tokenType(Dimension),
  "whitespace-token": tokenType(WhiteSpace),
  "CDO-token": tokenType(CDO),
  "CDC-token": tokenType(CDC),
  "colon-token": tokenType(Colon),
  "semicolon-token": tokenType(Semicolon),
  "comma-token": tokenType(Comma),
  "[-token": tokenType(LeftSquareBracket),
  "]-token": tokenType(RightSquareBracket),
  "(-token": tokenType(LeftParenthesis),
  ")-token": tokenType(RightParenthesis),
  "{-token": tokenType(LeftCurlyBracket),
  "}-token": tokenType(RightCurlyBracket)
};
var productionTypes = {
  // token type aliases
  "string": tokenType(String2),
  "ident": tokenType(Ident),
  // percentage
  "percentage": calc(percentage),
  // numeric
  "zero": zero(),
  "number": calc(number3),
  "integer": calc(integer),
  // complex types
  "custom-ident": customIdent,
  "dashed-ident": dashedIdent,
  "custom-property-name": customPropertyName,
  "hex-color": hexColor,
  "id-selector": idSelector,
  // element( <id-selector> )
  "an-plus-b": anPlusB,
  "urange": urange,
  "declaration-value": declarationValue,
  "any-value": anyValue
};
function createDemensionTypes(units) {
  const {
    angle: angle2,
    decibel: decibel2,
    frequency: frequency2,
    flex: flex4,
    length: length2,
    resolution: resolution2,
    semitones: semitones2,
    time: time4
  } = units || {};
  return {
    "dimension": calc(dimension(null)),
    "angle": calc(dimension(angle2)),
    "decibel": calc(dimension(decibel2)),
    "frequency": calc(dimension(frequency2)),
    "flex": calc(dimension(flex4)),
    "length": calc(zero(dimension(length2))),
    "resolution": calc(dimension(resolution2)),
    "semitones": calc(dimension(semitones2)),
    "time": calc(dimension(time4))
  };
}
function createGenericTypes(units) {
  return {
    ...tokenTypes,
    ...productionTypes,
    ...createDemensionTypes(units)
  };
}

// node_modules/css-tree/lib/lexer/units.js
var units_exports = {};
__export(units_exports, {
  angle: () => angle,
  decibel: () => decibel,
  flex: () => flex3,
  frequency: () => frequency,
  length: () => length,
  resolution: () => resolution,
  semitones: () => semitones,
  time: () => time3
});
var length = [
  // absolute length units https://www.w3.org/TR/css-values-3/#lengths
  "cm",
  "mm",
  "q",
  "in",
  "pt",
  "pc",
  "px",
  // font-relative length units https://drafts.csswg.org/css-values-4/#font-relative-lengths
  "em",
  "rem",
  "ex",
  "rex",
  "cap",
  "rcap",
  "ch",
  "rch",
  "ic",
  "ric",
  "lh",
  "rlh",
  // viewport-percentage lengths https://drafts.csswg.org/css-values-4/#viewport-relative-lengths
  "vw",
  "svw",
  "lvw",
  "dvw",
  "vh",
  "svh",
  "lvh",
  "dvh",
  "vi",
  "svi",
  "lvi",
  "dvi",
  "vb",
  "svb",
  "lvb",
  "dvb",
  "vmin",
  "svmin",
  "lvmin",
  "dvmin",
  "vmax",
  "svmax",
  "lvmax",
  "dvmax",
  // container relative lengths https://drafts.csswg.org/css-contain-3/#container-lengths
  "cqw",
  "cqh",
  "cqi",
  "cqb",
  "cqmin",
  "cqmax"
];
var angle = ["deg", "grad", "rad", "turn"];
var time3 = ["s", "ms"];
var frequency = ["hz", "khz"];
var resolution = ["dpi", "dpcm", "dppx", "x"];
var flex3 = ["fr"];
var decibel = ["db"];
var semitones = ["st"];

// node_modules/css-tree/lib/definition-syntax/index.js
var definition_syntax_exports = {};
__export(definition_syntax_exports, {
  SyntaxError: () => SyntaxError3,
  generate: () => generate,
  parse: () => parse2,
  walk: () => walk
});

// node_modules/css-tree/lib/definition-syntax/SyntaxError.js
function SyntaxError3(message, input, offset) {
  return Object.assign(createCustomError("SyntaxError", message), {
    input,
    offset,
    rawMessage: message,
    message: message + "\n  " + input + "\n--" + new Array((offset || input.length) + 1).join("-") + "^"
  });
}

// node_modules/css-tree/lib/definition-syntax/scanner.js
var TAB = 9;
var N3 = 10;
var F2 = 12;
var R2 = 13;
var SPACE = 32;
var NAME_CHAR = new Uint8Array(128).map(
  (_, idx) => /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0
);
var Scanner = class {
  constructor(str) {
    this.str = str;
    this.pos = 0;
  }
  charCodeAt(pos) {
    return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
  }
  charCode() {
    return this.charCodeAt(this.pos);
  }
  isNameCharCode(code2 = this.charCode()) {
    return code2 < 128 && NAME_CHAR[code2] === 1;
  }
  nextCharCode() {
    return this.charCodeAt(this.pos + 1);
  }
  nextNonWsCode(pos) {
    return this.charCodeAt(this.findWsEnd(pos));
  }
  skipWs() {
    this.pos = this.findWsEnd(this.pos);
  }
  findWsEnd(pos) {
    for (; pos < this.str.length; pos++) {
      const code2 = this.str.charCodeAt(pos);
      if (code2 !== R2 && code2 !== N3 && code2 !== F2 && code2 !== SPACE && code2 !== TAB) {
        break;
      }
    }
    return pos;
  }
  substringToPos(end) {
    return this.str.substring(this.pos, this.pos = end);
  }
  eat(code2) {
    if (this.charCode() !== code2) {
      this.error("Expect `" + String.fromCharCode(code2) + "`");
    }
    this.pos++;
  }
  peek() {
    return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
  }
  error(message) {
    throw new SyntaxError3(message, this.str, this.pos);
  }
  scanSpaces() {
    return this.substringToPos(this.findWsEnd(this.pos));
  }
  scanWord() {
    let end = this.pos;
    for (; end < this.str.length; end++) {
      const code2 = this.str.charCodeAt(end);
      if (code2 >= 128 || NAME_CHAR[code2] === 0) {
        break;
      }
    }
    if (this.pos === end) {
      this.error("Expect a keyword");
    }
    return this.substringToPos(end);
  }
  scanNumber() {
    let end = this.pos;
    for (; end < this.str.length; end++) {
      const code2 = this.str.charCodeAt(end);
      if (code2 < 48 || code2 > 57) {
        break;
      }
    }
    if (this.pos === end) {
      this.error("Expect a number");
    }
    return this.substringToPos(end);
  }
  scanString() {
    const end = this.str.indexOf("'", this.pos + 1);
    if (end === -1) {
      this.pos = this.str.length;
      this.error("Expect an apostrophe");
    }
    return this.substringToPos(end + 1);
  }
};

// node_modules/css-tree/lib/definition-syntax/parse.js
var TAB2 = 9;
var N4 = 10;
var F3 = 12;
var R3 = 13;
var SPACE2 = 32;
var EXCLAMATIONMARK2 = 33;
var NUMBERSIGN2 = 35;
var AMPERSAND = 38;
var APOSTROPHE = 39;
var LEFTPARENTHESIS = 40;
var RIGHTPARENTHESIS = 41;
var ASTERISK = 42;
var PLUSSIGN4 = 43;
var COMMA = 44;
var HYPERMINUS = 45;
var LESSTHANSIGN = 60;
var GREATERTHANSIGN = 62;
var QUESTIONMARK2 = 63;
var COMMERCIALAT = 64;
var LEFTSQUAREBRACKET = 91;
var RIGHTSQUAREBRACKET = 93;
var LEFTCURLYBRACKET2 = 123;
var VERTICALLINE = 124;
var RIGHTCURLYBRACKET = 125;
var INFINITY = 8734;
var COMBINATOR_PRECEDENCE = {
  " ": 1,
  "&&": 2,
  "||": 3,
  "|": 4
};
function readMultiplierRange(scanner) {
  let min = null;
  let max = null;
  scanner.eat(LEFTCURLYBRACKET2);
  scanner.skipWs();
  min = scanner.scanNumber(scanner);
  scanner.skipWs();
  if (scanner.charCode() === COMMA) {
    scanner.pos++;
    scanner.skipWs();
    if (scanner.charCode() !== RIGHTCURLYBRACKET) {
      max = scanner.scanNumber(scanner);
      scanner.skipWs();
    }
  } else {
    max = min;
  }
  scanner.eat(RIGHTCURLYBRACKET);
  return {
    min: Number(min),
    max: max ? Number(max) : 0
  };
}
function readMultiplier(scanner) {
  let range = null;
  let comma2 = false;
  switch (scanner.charCode()) {
    case ASTERISK:
      scanner.pos++;
      range = {
        min: 0,
        max: 0
      };
      break;
    case PLUSSIGN4:
      scanner.pos++;
      range = {
        min: 1,
        max: 0
      };
      break;
    case QUESTIONMARK2:
      scanner.pos++;
      range = {
        min: 0,
        max: 1
      };
      break;
    case NUMBERSIGN2:
      scanner.pos++;
      comma2 = true;
      if (scanner.charCode() === LEFTCURLYBRACKET2) {
        range = readMultiplierRange(scanner);
      } else if (scanner.charCode() === QUESTIONMARK2) {
        scanner.pos++;
        range = {
          min: 0,
          max: 0
        };
      } else {
        range = {
          min: 1,
          max: 0
        };
      }
      break;
    case LEFTCURLYBRACKET2:
      range = readMultiplierRange(scanner);
      break;
    default:
      return null;
  }
  return {
    type: "Multiplier",
    comma: comma2,
    min: range.min,
    max: range.max,
    term: null
  };
}
function maybeMultiplied(scanner, node) {
  const multiplier = readMultiplier(scanner);
  if (multiplier !== null) {
    multiplier.term = node;
    if (scanner.charCode() === NUMBERSIGN2 && scanner.charCodeAt(scanner.pos - 1) === PLUSSIGN4) {
      return maybeMultiplied(scanner, multiplier);
    }
    return multiplier;
  }
  return node;
}
function maybeToken(scanner) {
  const ch = scanner.peek();
  if (ch === "") {
    return null;
  }
  return maybeMultiplied(scanner, {
    type: "Token",
    value: ch
  });
}
function readProperty(scanner) {
  let name50;
  scanner.eat(LESSTHANSIGN);
  scanner.eat(APOSTROPHE);
  name50 = scanner.scanWord();
  scanner.eat(APOSTROPHE);
  scanner.eat(GREATERTHANSIGN);
  return maybeMultiplied(scanner, {
    type: "Property",
    name: name50
  });
}
function readTypeRange(scanner) {
  let min = null;
  let max = null;
  let sign = 1;
  scanner.eat(LEFTSQUAREBRACKET);
  if (scanner.charCode() === HYPERMINUS) {
    scanner.peek();
    sign = -1;
  }
  if (sign == -1 && scanner.charCode() === INFINITY) {
    scanner.peek();
  } else {
    min = sign * Number(scanner.scanNumber(scanner));
    if (scanner.isNameCharCode()) {
      min += scanner.scanWord();
    }
  }
  scanner.skipWs();
  scanner.eat(COMMA);
  scanner.skipWs();
  if (scanner.charCode() === INFINITY) {
    scanner.peek();
  } else {
    sign = 1;
    if (scanner.charCode() === HYPERMINUS) {
      scanner.peek();
      sign = -1;
    }
    max = sign * Number(scanner.scanNumber(scanner));
    if (scanner.isNameCharCode()) {
      max += scanner.scanWord();
    }
  }
  scanner.eat(RIGHTSQUAREBRACKET);
  return {
    type: "Range",
    min,
    max
  };
}
function readType(scanner) {
  let name50;
  let opts = null;
  scanner.eat(LESSTHANSIGN);
  name50 = scanner.scanWord();
  if (name50 === "boolean-expr") {
    scanner.eat(LEFTSQUAREBRACKET);
    const implicitGroup = readImplicitGroup(scanner, RIGHTSQUAREBRACKET);
    scanner.eat(RIGHTSQUAREBRACKET);
    scanner.eat(GREATERTHANSIGN);
    return maybeMultiplied(scanner, {
      type: "Boolean",
      term: implicitGroup.terms.length === 1 ? implicitGroup.terms[0] : implicitGroup
    });
  }
  if (scanner.charCode() === LEFTPARENTHESIS && scanner.nextCharCode() === RIGHTPARENTHESIS) {
    scanner.pos += 2;
    name50 += "()";
  }
  if (scanner.charCodeAt(scanner.findWsEnd(scanner.pos)) === LEFTSQUAREBRACKET) {
    scanner.skipWs();
    opts = readTypeRange(scanner);
  }
  scanner.eat(GREATERTHANSIGN);
  return maybeMultiplied(scanner, {
    type: "Type",
    name: name50,
    opts
  });
}
function readKeywordOrFunction(scanner) {
  const name50 = scanner.scanWord();
  if (scanner.charCode() === LEFTPARENTHESIS) {
    scanner.pos++;
    return {
      type: "Function",
      name: name50
    };
  }
  return maybeMultiplied(scanner, {
    type: "Keyword",
    name: name50
  });
}
function regroupTerms(terms, combinators) {
  function createGroup(terms2, combinator2) {
    return {
      type: "Group",
      terms: terms2,
      combinator: combinator2,
      disallowEmpty: false,
      explicit: false
    };
  }
  let combinator;
  combinators = Object.keys(combinators).sort((a, b) => COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b]);
  while (combinators.length > 0) {
    combinator = combinators.shift();
    let i = 0;
    let subgroupStart = 0;
    for (; i < terms.length; i++) {
      const term = terms[i];
      if (term.type === "Combinator") {
        if (term.value === combinator) {
          if (subgroupStart === -1) {
            subgroupStart = i - 1;
          }
          terms.splice(i, 1);
          i--;
        } else {
          if (subgroupStart !== -1 && i - subgroupStart > 1) {
            terms.splice(
              subgroupStart,
              i - subgroupStart,
              createGroup(terms.slice(subgroupStart, i), combinator)
            );
            i = subgroupStart + 1;
          }
          subgroupStart = -1;
        }
      }
    }
    if (subgroupStart !== -1 && combinators.length) {
      terms.splice(
        subgroupStart,
        i - subgroupStart,
        createGroup(terms.slice(subgroupStart, i), combinator)
      );
    }
  }
  return combinator;
}
function readImplicitGroup(scanner, stopCharCode) {
  const combinators = /* @__PURE__ */ Object.create(null);
  const terms = [];
  let token;
  let prevToken = null;
  let prevTokenPos = scanner.pos;
  while (scanner.charCode() !== stopCharCode && (token = peek(scanner, stopCharCode))) {
    if (token.type !== "Spaces") {
      if (token.type === "Combinator") {
        if (prevToken === null || prevToken.type === "Combinator") {
          scanner.pos = prevTokenPos;
          scanner.error("Unexpected combinator");
        }
        combinators[token.value] = true;
      } else if (prevToken !== null && prevToken.type !== "Combinator") {
        combinators[" "] = true;
        terms.push({
          type: "Combinator",
          value: " "
        });
      }
      terms.push(token);
      prevToken = token;
      prevTokenPos = scanner.pos;
    }
  }
  if (prevToken !== null && prevToken.type === "Combinator") {
    scanner.pos -= prevTokenPos;
    scanner.error("Unexpected combinator");
  }
  return {
    type: "Group",
    terms,
    combinator: regroupTerms(terms, combinators) || " ",
    disallowEmpty: false,
    explicit: false
  };
}
function readGroup(scanner, stopCharCode) {
  let result;
  scanner.eat(LEFTSQUAREBRACKET);
  result = readImplicitGroup(scanner, stopCharCode);
  scanner.eat(RIGHTSQUAREBRACKET);
  result.explicit = true;
  if (scanner.charCode() === EXCLAMATIONMARK2) {
    scanner.pos++;
    result.disallowEmpty = true;
  }
  return result;
}
function peek(scanner, stopCharCode) {
  let code2 = scanner.charCode();
  switch (code2) {
    case RIGHTSQUAREBRACKET:
      break;
    case LEFTSQUAREBRACKET:
      return maybeMultiplied(scanner, readGroup(scanner, stopCharCode));
    case LESSTHANSIGN:
      return scanner.nextCharCode() === APOSTROPHE ? readProperty(scanner) : readType(scanner);
    case VERTICALLINE:
      return {
        type: "Combinator",
        value: scanner.substringToPos(
          scanner.pos + (scanner.nextCharCode() === VERTICALLINE ? 2 : 1)
        )
      };
    case AMPERSAND:
      scanner.pos++;
      scanner.eat(AMPERSAND);
      return {
        type: "Combinator",
        value: "&&"
      };
    case COMMA:
      scanner.pos++;
      return {
        type: "Comma"
      };
    case APOSTROPHE:
      return maybeMultiplied(scanner, {
        type: "String",
        value: scanner.scanString()
      });
    case SPACE2:
    case TAB2:
    case N4:
    case R3:
    case F3:
      return {
        type: "Spaces",
        value: scanner.scanSpaces()
      };
    case COMMERCIALAT:
      code2 = scanner.nextCharCode();
      if (scanner.isNameCharCode(code2)) {
        scanner.pos++;
        return {
          type: "AtKeyword",
          name: scanner.scanWord()
        };
      }
      return maybeToken(scanner);
    case ASTERISK:
    case PLUSSIGN4:
    case QUESTIONMARK2:
    case NUMBERSIGN2:
    case EXCLAMATIONMARK2:
      break;
    case LEFTCURLYBRACKET2:
      code2 = scanner.nextCharCode();
      if (code2 < 48 || code2 > 57) {
        return maybeToken(scanner);
      }
      break;
    default:
      if (scanner.isNameCharCode(code2)) {
        return readKeywordOrFunction(scanner);
      }
      return maybeToken(scanner);
  }
}
function parse2(source) {
  const scanner = new Scanner(source);
  const result = readImplicitGroup(scanner);
  if (scanner.pos !== source.length) {
    scanner.error("Unexpected input");
  }
  if (result.terms.length === 1 && result.terms[0].type === "Group") {
    return result.terms[0];
  }
  return result;
}

// node_modules/css-tree/lib/definition-syntax/walk.js
var noop4 = function() {
};
function ensureFunction2(value) {
  return typeof value === "function" ? value : noop4;
}
function walk(node, options, context) {
  function walk3(node2) {
    enter.call(context, node2);
    switch (node2.type) {
      case "Group":
        node2.terms.forEach(walk3);
        break;
      case "Multiplier":
      case "Boolean":
        walk3(node2.term);
        break;
      case "Type":
      case "Property":
      case "Keyword":
      case "AtKeyword":
      case "Function":
      case "String":
      case "Token":
      case "Comma":
        break;
      default:
        throw new Error("Unknown type: " + node2.type);
    }
    leave.call(context, node2);
  }
  let enter = noop4;
  let leave = noop4;
  if (typeof options === "function") {
    enter = options;
  } else if (options) {
    enter = ensureFunction2(options.enter);
    leave = ensureFunction2(options.leave);
  }
  if (enter === noop4 && leave === noop4) {
    throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
  }
  walk3(node, context);
}

// node_modules/css-tree/lib/lexer/prepare-tokens.js
var astToTokens = {
  decorator(handlers) {
    const tokens = [];
    let curNode = null;
    return {
      ...handlers,
      node(node) {
        const tmp = curNode;
        curNode = node;
        handlers.node.call(this, node);
        curNode = tmp;
      },
      emit(value, type, auto3) {
        tokens.push({
          type,
          value,
          node: auto3 ? null : curNode
        });
      },
      result() {
        return tokens;
      }
    };
  }
};
function stringToTokens(str) {
  const tokens = [];
  tokenize(
    str,
    (type, start, end) => tokens.push({
      type,
      value: str.slice(start, end),
      node: null
    })
  );
  return tokens;
}
function prepare_tokens_default(value, syntax) {
  if (typeof value === "string") {
    return stringToTokens(value);
  }
  return syntax.generate(value, astToTokens);
}

// node_modules/css-tree/lib/lexer/match-graph.js
var MATCH = { type: "Match" };
var MISMATCH = { type: "Mismatch" };
var DISALLOW_EMPTY = { type: "DisallowEmpty" };
var LEFTPARENTHESIS2 = 40;
var RIGHTPARENTHESIS2 = 41;
function createCondition(match, thenBranch, elseBranch) {
  if (thenBranch === MATCH && elseBranch === MISMATCH) {
    return match;
  }
  if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
    return match;
  }
  if (match.type === "If" && match.else === MISMATCH && thenBranch === MATCH) {
    thenBranch = match.then;
    match = match.match;
  }
  return {
    type: "If",
    match,
    then: thenBranch,
    else: elseBranch
  };
}
function isFunctionType(name50) {
  return name50.length > 2 && name50.charCodeAt(name50.length - 2) === LEFTPARENTHESIS2 && name50.charCodeAt(name50.length - 1) === RIGHTPARENTHESIS2;
}
function isEnumCapatible(term) {
  return term.type === "Keyword" || term.type === "AtKeyword" || term.type === "Function" || term.type === "Type" && isFunctionType(term.name);
}
function groupNode(terms, combinator = " ", explicit = false) {
  return {
    type: "Group",
    terms,
    combinator,
    disallowEmpty: false,
    explicit
  };
}
function replaceTypeInGraph(node, replacements, visited = /* @__PURE__ */ new Set()) {
  if (!visited.has(node)) {
    visited.add(node);
    switch (node.type) {
      case "If":
        node.match = replaceTypeInGraph(node.match, replacements, visited);
        node.then = replaceTypeInGraph(node.then, replacements, visited);
        node.else = replaceTypeInGraph(node.else, replacements, visited);
        break;
      case "Type":
        return replacements[node.name] || node;
    }
  }
  return node;
}
function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
  switch (combinator) {
    case " ": {
      let result = MATCH;
      for (let i = terms.length - 1; i >= 0; i--) {
        const term = terms[i];
        result = createCondition(
          term,
          result,
          MISMATCH
        );
      }
      ;
      return result;
    }
    case "|": {
      let result = MISMATCH;
      let map = null;
      for (let i = terms.length - 1; i >= 0; i--) {
        let term = terms[i];
        if (isEnumCapatible(term)) {
          if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
            map = /* @__PURE__ */ Object.create(null);
            result = createCondition(
              {
                type: "Enum",
                map
              },
              MATCH,
              result
            );
          }
          if (map !== null) {
            const key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
            if (key in map === false) {
              map[key] = term;
              continue;
            }
          }
        }
        map = null;
        result = createCondition(
          term,
          MATCH,
          result
        );
      }
      ;
      return result;
    }
    case "&&": {
      if (terms.length > 5) {
        return {
          type: "MatchOnce",
          terms,
          all: true
        };
      }
      let result = MISMATCH;
      for (let i = terms.length - 1; i >= 0; i--) {
        const term = terms[i];
        let thenClause;
        if (terms.length > 1) {
          thenClause = buildGroupMatchGraph(
            combinator,
            terms.filter(function(newGroupTerm) {
              return newGroupTerm !== term;
            }),
            false
          );
        } else {
          thenClause = MATCH;
        }
        result = createCondition(
          term,
          thenClause,
          result
        );
      }
      ;
      return result;
    }
    case "||": {
      if (terms.length > 5) {
        return {
          type: "MatchOnce",
          terms,
          all: false
        };
      }
      let result = atLeastOneTermMatched ? MATCH : MISMATCH;
      for (let i = terms.length - 1; i >= 0; i--) {
        const term = terms[i];
        let thenClause;
        if (terms.length > 1) {
          thenClause = buildGroupMatchGraph(
            combinator,
            terms.filter(function(newGroupTerm) {
              return newGroupTerm !== term;
            }),
            true
          );
        } else {
          thenClause = MATCH;
        }
        result = createCondition(
          term,
          thenClause,
          result
        );
      }
      ;
      return result;
    }
  }
}
function buildMultiplierMatchGraph(node) {
  let result = MATCH;
  let matchTerm = buildMatchGraphInternal(node.term);
  if (node.max === 0) {
    matchTerm = createCondition(
      matchTerm,
      DISALLOW_EMPTY,
      MISMATCH
    );
    result = createCondition(
      matchTerm,
      null,
      // will be a loop
      MISMATCH
    );
    result.then = createCondition(
      MATCH,
      MATCH,
      result
      // make a loop
    );
    if (node.comma) {
      result.then.else = createCondition(
        { type: "Comma", syntax: node },
        result,
        MISMATCH
      );
    }
  } else {
    for (let i = node.min || 1; i <= node.max; i++) {
      if (node.comma && result !== MATCH) {
        result = createCondition(
          { type: "Comma", syntax: node },
          result,
          MISMATCH
        );
      }
      result = createCondition(
        matchTerm,
        createCondition(
          MATCH,
          MATCH,
          result
        ),
        MISMATCH
      );
    }
  }
  if (node.min === 0) {
    result = createCondition(
      MATCH,
      MATCH,
      result
    );
  } else {
    for (let i = 0; i < node.min - 1; i++) {
      if (node.comma && result !== MATCH) {
        result = createCondition(
          { type: "Comma", syntax: node },
          result,
          MISMATCH
        );
      }
      result = createCondition(
        matchTerm,
        result,
        MISMATCH
      );
    }
  }
  return result;
}
function buildMatchGraphInternal(node) {
  if (typeof node === "function") {
    return {
      type: "Generic",
      fn: node
    };
  }
  switch (node.type) {
    case "Group": {
      let result = buildGroupMatchGraph(
        node.combinator,
        node.terms.map(buildMatchGraphInternal),
        false
      );
      if (node.disallowEmpty) {
        result = createCondition(
          result,
          DISALLOW_EMPTY,
          MISMATCH
        );
      }
      return result;
    }
    case "Multiplier":
      return buildMultiplierMatchGraph(node);
    case "Boolean": {
      const term = buildMatchGraphInternal(node.term);
      const matchNode = buildMatchGraphInternal(groupNode([
        groupNode([
          { type: "Keyword", name: "not" },
          { type: "Type", name: "!boolean-group" }
        ]),
        groupNode([
          { type: "Type", name: "!boolean-group" },
          groupNode([
            { type: "Multiplier", comma: false, min: 0, max: 0, term: groupNode([
              { type: "Keyword", name: "and" },
              { type: "Type", name: "!boolean-group" }
            ]) },
            { type: "Multiplier", comma: false, min: 0, max: 0, term: groupNode([
              { type: "Keyword", name: "or" },
              { type: "Type", name: "!boolean-group" }
            ]) }
          ], "|")
        ])
      ], "|"));
      const booleanGroup = buildMatchGraphInternal(
        groupNode([
          { type: "Type", name: "!term" },
          groupNode([
            { type: "Token", value: "(" },
            { type: "Type", name: "!self" },
            { type: "Token", value: ")" }
          ]),
          { type: "Type", name: "general-enclosed" }
        ], "|")
      );
      replaceTypeInGraph(booleanGroup, { "!term": term, "!self": matchNode });
      replaceTypeInGraph(matchNode, { "!boolean-group": booleanGroup });
      return matchNode;
    }
    case "Type":
    case "Property":
      return {
        type: node.type,
        name: node.name,
        syntax: node
      };
    case "Keyword":
      return {
        type: node.type,
        name: node.name.toLowerCase(),
        syntax: node
      };
    case "AtKeyword":
      return {
        type: node.type,
        name: "@" + node.name.toLowerCase(),
        syntax: node
      };
    case "Function":
      return {
        type: node.type,
        name: node.name.toLowerCase() + "(",
        syntax: node
      };
    case "String":
      if (node.value.length === 3) {
        return {
          type: "Token",
          value: node.value.charAt(1),
          syntax: node
        };
      }
      return {
        type: node.type,
        value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, "'"),
        syntax: node
      };
    case "Token":
      return {
        type: node.type,
        value: node.value,
        syntax: node
      };
    case "Comma":
      return {
        type: node.type,
        syntax: node
      };
    default:
      throw new Error("Unknown node type:", node.type);
  }
}
function buildMatchGraph(syntaxTree, ref) {
  if (typeof syntaxTree === "string") {
    syntaxTree = parse2(syntaxTree);
  }
  return {
    type: "MatchGraph",
    match: buildMatchGraphInternal(syntaxTree),
    syntax: ref || null,
    source: syntaxTree
  };
}

// node_modules/css-tree/lib/lexer/match.js
var { hasOwnProperty: hasOwnProperty3 } = Object.prototype;
var STUB = 0;
var TOKEN = 1;
var OPEN_SYNTAX = 2;
var CLOSE_SYNTAX = 3;
var EXIT_REASON_MATCH = "Match";
var EXIT_REASON_MISMATCH = "Mismatch";
var EXIT_REASON_ITERATION_LIMIT = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
var ITERATION_LIMIT = 15e3;
var totalIterationCount = 0;
function reverseList(list) {
  let prev = null;
  let next = null;
  let item = list;
  while (item !== null) {
    next = item.prev;
    item.prev = prev;
    prev = item;
    item = next;
  }
  return prev;
}
function areStringsEqualCaseInsensitive(testStr, referenceStr) {
  if (testStr.length !== referenceStr.length) {
    return false;
  }
  for (let i = 0; i < testStr.length; i++) {
    const referenceCode = referenceStr.charCodeAt(i);
    let testCode = testStr.charCodeAt(i);
    if (testCode >= 65 && testCode <= 90) {
      testCode = testCode | 32;
    }
    if (testCode !== referenceCode) {
      return false;
    }
  }
  return true;
}
function isContextEdgeDelim(token) {
  if (token.type !== Delim) {
    return false;
  }
  return token.value !== "?";
}
function isCommaContextStart(token) {
  if (token === null) {
    return true;
  }
  return token.type === Comma || token.type === Function2 || token.type === LeftParenthesis || token.type === LeftSquareBracket || token.type === LeftCurlyBracket || isContextEdgeDelim(token);
}
function isCommaContextEnd(token) {
  if (token === null) {
    return true;
  }
  return token.type === RightParenthesis || token.type === RightSquareBracket || token.type === RightCurlyBracket || token.type === Delim && token.value === "/";
}
function internalMatch(tokens, state, syntaxes) {
  function moveToNextToken() {
    do {
      tokenIndex++;
      token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
    } while (token !== null && (token.type === WhiteSpace || token.type === Comment));
  }
  function getNextToken(offset) {
    const nextIndex = tokenIndex + offset;
    return nextIndex < tokens.length ? tokens[nextIndex] : null;
  }
  function stateSnapshotFromSyntax(nextState, prev) {
    return {
      nextState,
      matchStack,
      syntaxStack,
      thenStack,
      tokenIndex,
      prev
    };
  }
  function pushThenStack(nextState) {
    thenStack = {
      nextState,
      matchStack,
      syntaxStack,
      prev: thenStack
    };
  }
  function pushElseStack(nextState) {
    elseStack = stateSnapshotFromSyntax(nextState, elseStack);
  }
  function addTokenToMatch() {
    matchStack = {
      type: TOKEN,
      syntax: state.syntax,
      token,
      prev: matchStack
    };
    moveToNextToken();
    syntaxStash = null;
    if (tokenIndex > longestMatch) {
      longestMatch = tokenIndex;
    }
  }
  function openSyntax() {
    syntaxStack = {
      syntax: state.syntax,
      opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,
      prev: syntaxStack
    };
    matchStack = {
      type: OPEN_SYNTAX,
      syntax: state.syntax,
      token: matchStack.token,
      prev: matchStack
    };
  }
  function closeSyntax() {
    if (matchStack.type === OPEN_SYNTAX) {
      matchStack = matchStack.prev;
    } else {
      matchStack = {
        type: CLOSE_SYNTAX,
        syntax: syntaxStack.syntax,
        token: matchStack.token,
        prev: matchStack
      };
    }
    syntaxStack = syntaxStack.prev;
  }
  let syntaxStack = null;
  let thenStack = null;
  let elseStack = null;
  let syntaxStash = null;
  let iterationCount = 0;
  let exitReason = null;
  let token = null;
  let tokenIndex = -1;
  let longestMatch = 0;
  let matchStack = {
    type: STUB,
    syntax: null,
    token: null,
    prev: null
  };
  moveToNextToken();
  while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
    switch (state.type) {
      case "Match":
        if (thenStack === null) {
          if (token !== null) {
            if (tokenIndex !== tokens.length - 1 || token.value !== "\\0" && token.value !== "\\9") {
              state = MISMATCH;
              break;
            }
          }
          exitReason = EXIT_REASON_MATCH;
          break;
        }
        state = thenStack.nextState;
        if (state === DISALLOW_EMPTY) {
          if (thenStack.matchStack === matchStack) {
            state = MISMATCH;
            break;
          } else {
            state = MATCH;
          }
        }
        while (thenStack.syntaxStack !== syntaxStack) {
          closeSyntax();
        }
        thenStack = thenStack.prev;
        break;
      case "Mismatch":
        if (syntaxStash !== null && syntaxStash !== false) {
          if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
            elseStack = syntaxStash;
            syntaxStash = false;
          }
        } else if (elseStack === null) {
          exitReason = EXIT_REASON_MISMATCH;
          break;
        }
        state = elseStack.nextState;
        thenStack = elseStack.thenStack;
        syntaxStack = elseStack.syntaxStack;
        matchStack = elseStack.matchStack;
        tokenIndex = elseStack.tokenIndex;
        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
        elseStack = elseStack.prev;
        break;
      case "MatchGraph":
        state = state.match;
        break;
      case "If":
        if (state.else !== MISMATCH) {
          pushElseStack(state.else);
        }
        if (state.then !== MATCH) {
          pushThenStack(state.then);
        }
        state = state.match;
        break;
      case "MatchOnce":
        state = {
          type: "MatchOnceBuffer",
          syntax: state,
          index: 0,
          mask: 0
        };
        break;
      case "MatchOnceBuffer": {
        const terms = state.syntax.terms;
        if (state.index === terms.length) {
          if (state.mask === 0 || state.syntax.all) {
            state = MISMATCH;
            break;
          }
          state = MATCH;
          break;
        }
        if (state.mask === (1 << terms.length) - 1) {
          state = MATCH;
          break;
        }
        for (; state.index < terms.length; state.index++) {
          const matchFlag = 1 << state.index;
          if ((state.mask & matchFlag) === 0) {
            pushElseStack(state);
            pushThenStack({
              type: "AddMatchOnce",
              syntax: state.syntax,
              mask: state.mask | matchFlag
            });
            state = terms[state.index++];
            break;
          }
        }
        break;
      }
      case "AddMatchOnce":
        state = {
          type: "MatchOnceBuffer",
          syntax: state.syntax,
          index: 0,
          mask: state.mask
        };
        break;
      case "Enum":
        if (token !== null) {
          let name50 = token.value.toLowerCase();
          if (name50.indexOf("\\") !== -1) {
            name50 = name50.replace(/\\[09].*$/, "");
          }
          if (hasOwnProperty3.call(state.map, name50)) {
            state = state.map[name50];
            break;
          }
        }
        state = MISMATCH;
        break;
      case "Generic": {
        const opts = syntaxStack !== null ? syntaxStack.opts : null;
        const lastTokenIndex2 = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));
        if (!isNaN(lastTokenIndex2) && lastTokenIndex2 > tokenIndex) {
          while (tokenIndex < lastTokenIndex2) {
            addTokenToMatch();
          }
          state = MATCH;
        } else {
          state = MISMATCH;
        }
        break;
      }
      case "Type":
      case "Property": {
        const syntaxDict = state.type === "Type" ? "types" : "properties";
        const dictSyntax = hasOwnProperty3.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;
        if (!dictSyntax || !dictSyntax.match) {
          throw new Error(
            "Bad syntax reference: " + (state.type === "Type" ? "<" + state.name + ">" : "<'" + state.name + "'>")
          );
        }
        if (syntaxStash !== false && token !== null && state.type === "Type") {
          const lowPriorityMatching = (
            // https://drafts.csswg.org/css-values-4/#custom-idents
            // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
            // can only claim the keyword if no other unfulfilled production can claim it.
            state.name === "custom-ident" && token.type === Ident || // https://drafts.csswg.org/css-values-4/#lengths
            // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
            // it must parse as a <number>
            state.name === "length" && token.value === "0"
          );
          if (lowPriorityMatching) {
            if (syntaxStash === null) {
              syntaxStash = stateSnapshotFromSyntax(state, elseStack);
            }
            state = MISMATCH;
            break;
          }
        }
        openSyntax();
        state = dictSyntax.matchRef || dictSyntax.match;
        break;
      }
      case "Keyword": {
        const name50 = state.name;
        if (token !== null) {
          let keywordName = token.value;
          if (keywordName.indexOf("\\") !== -1) {
            keywordName = keywordName.replace(/\\[09].*$/, "");
          }
          if (areStringsEqualCaseInsensitive(keywordName, name50)) {
            addTokenToMatch();
            state = MATCH;
            break;
          }
        }
        state = MISMATCH;
        break;
      }
      case "AtKeyword":
      case "Function":
        if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
          addTokenToMatch();
          state = MATCH;
          break;
        }
        state = MISMATCH;
        break;
      case "Token":
        if (token !== null && token.value === state.value) {
          addTokenToMatch();
          state = MATCH;
          break;
        }
        state = MISMATCH;
        break;
      case "Comma":
        if (token !== null && token.type === Comma) {
          if (isCommaContextStart(matchStack.token)) {
            state = MISMATCH;
          } else {
            addTokenToMatch();
            state = isCommaContextEnd(token) ? MISMATCH : MATCH;
          }
        } else {
          state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
        }
        break;
      case "String":
        let string = "";
        let lastTokenIndex = tokenIndex;
        for (; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
          string += tokens[lastTokenIndex].value;
        }
        if (areStringsEqualCaseInsensitive(string, state.value)) {
          while (tokenIndex < lastTokenIndex) {
            addTokenToMatch();
          }
          state = MATCH;
        } else {
          state = MISMATCH;
        }
        break;
      default:
        throw new Error("Unknown node type: " + state.type);
    }
  }
  totalIterationCount += iterationCount;
  switch (exitReason) {
    case null:
      console.warn("[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations");
      exitReason = EXIT_REASON_ITERATION_LIMIT;
      matchStack = null;
      break;
    case EXIT_REASON_MATCH:
      while (syntaxStack !== null) {
        closeSyntax();
      }
      break;
    default:
      matchStack = null;
  }
  return {
    tokens,
    reason: exitReason,
    iterations: iterationCount,
    match: matchStack,
    longestMatch
  };
}
function matchAsTree(tokens, matchGraph, syntaxes) {
  const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});
  if (matchResult.match === null) {
    return matchResult;
  }
  let item = matchResult.match;
  let host = matchResult.match = {
    syntax: matchGraph.syntax || null,
    match: []
  };
  const hostStack = [host];
  item = reverseList(item).prev;
  while (item !== null) {
    switch (item.type) {
      case OPEN_SYNTAX:
        host.match.push(host = {
          syntax: item.syntax,
          match: []
        });
        hostStack.push(host);
        break;
      case CLOSE_SYNTAX:
        hostStack.pop();
        host = hostStack[hostStack.length - 1];
        break;
      default:
        host.match.push({
          syntax: item.syntax || null,
          token: item.token.value,
          node: item.token.node
        });
    }
    item = item.prev;
  }
  return matchResult;
}

// node_modules/css-tree/lib/lexer/trace.js
var trace_exports = {};
__export(trace_exports, {
  getTrace: () => getTrace,
  isKeyword: () => isKeyword,
  isProperty: () => isProperty,
  isType: () => isType
});
function getTrace(node) {
  function shouldPutToTrace(syntax) {
    if (syntax === null) {
      return false;
    }
    return syntax.type === "Type" || syntax.type === "Property" || syntax.type === "Keyword";
  }
  function hasMatch(matchNode) {
    if (Array.isArray(matchNode.match)) {
      for (let i = 0; i < matchNode.match.length; i++) {
        if (hasMatch(matchNode.match[i])) {
          if (shouldPutToTrace(matchNode.syntax)) {
            result.unshift(matchNode.syntax);
          }
          return true;
        }
      }
    } else if (matchNode.node === node) {
      result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];
      return true;
    }
    return false;
  }
  let result = null;
  if (this.matched !== null) {
    hasMatch(this.matched);
  }
  return result;
}
function isType(node, type) {
  return testNode(this, node, (match) => match.type === "Type" && match.name === type);
}
function isProperty(node, property4) {
  return testNode(this, node, (match) => match.type === "Property" && match.name === property4);
}
function isKeyword(node) {
  return testNode(this, node, (match) => match.type === "Keyword");
}
function testNode(match, node, fn) {
  const trace = getTrace.call(match, node);
  if (trace === null) {
    return false;
  }
  return trace.some(fn);
}

// node_modules/css-tree/lib/lexer/search.js
function getFirstMatchNode(matchNode) {
  if ("node" in matchNode) {
    return matchNode.node;
  }
  return getFirstMatchNode(matchNode.match[0]);
}
function getLastMatchNode(matchNode) {
  if ("node" in matchNode) {
    return matchNode.node;
  }
  return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
}
function matchFragments(lexer2, ast, match, type, name50) {
  function findFragments(matchNode) {
    if (matchNode.syntax !== null && matchNode.syntax.type === type && matchNode.syntax.name === name50) {
      const start = getFirstMatchNode(matchNode);
      const end = getLastMatchNode(matchNode);
      lexer2.syntax.walk(ast, function(node, item, list) {
        if (node === start) {
          const nodes = new List();
          do {
            nodes.appendData(item.data);
            if (item.data === end) {
              break;
            }
            item = item.next;
          } while (item !== null);
          fragments.push({
            parent: list,
            nodes
          });
        }
      });
    }
    if (Array.isArray(matchNode.match)) {
      matchNode.match.forEach(findFragments);
    }
  }
  const fragments = [];
  if (match.matched !== null) {
    findFragments(match.matched);
  }
  return fragments;
}

// node_modules/css-tree/lib/lexer/structure.js
var { hasOwnProperty: hasOwnProperty4 } = Object.prototype;
function isValidNumber(value) {
  return typeof value === "number" && isFinite(value) && Math.floor(value) === value && value >= 0;
}
function isValidLocation(loc) {
  return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);
}
function createNodeStructureChecker(type, fields) {
  return function checkNode(node, warn) {
    if (!node || node.constructor !== Object) {
      return warn(node, "Type of node should be an Object");
    }
    for (let key in node) {
      let valid = true;
      if (hasOwnProperty4.call(node, key) === false) {
        continue;
      }
      if (key === "type") {
        if (node.type !== type) {
          warn(node, "Wrong node type `" + node.type + "`, expected `" + type + "`");
        }
      } else if (key === "loc") {
        if (node.loc === null) {
          continue;
        } else if (node.loc && node.loc.constructor === Object) {
          if (typeof node.loc.source !== "string") {
            key += ".source";
          } else if (!isValidLocation(node.loc.start)) {
            key += ".start";
          } else if (!isValidLocation(node.loc.end)) {
            key += ".end";
          } else {
            continue;
          }
        }
        valid = false;
      } else if (fields.hasOwnProperty(key)) {
        valid = false;
        for (let i = 0; !valid && i < fields[key].length; i++) {
          const fieldType = fields[key][i];
          switch (fieldType) {
            case String:
              valid = typeof node[key] === "string";
              break;
            case Boolean:
              valid = typeof node[key] === "boolean";
              break;
            case null:
              valid = node[key] === null;
              break;
            default:
              if (typeof fieldType === "string") {
                valid = node[key] && node[key].type === fieldType;
              } else if (Array.isArray(fieldType)) {
                valid = node[key] instanceof List;
              }
          }
        }
      } else {
        warn(node, "Unknown field `" + key + "` for " + type + " node type");
      }
      if (!valid) {
        warn(node, "Bad value for `" + type + "." + key + "`");
      }
    }
    for (const key in fields) {
      if (hasOwnProperty4.call(fields, key) && hasOwnProperty4.call(node, key) === false) {
        warn(node, "Field `" + type + "." + key + "` is missed");
      }
    }
  };
}
function genTypesList(fieldTypes, path) {
  const docsTypes = [];
  for (let i = 0; i < fieldTypes.length; i++) {
    const fieldType = fieldTypes[i];
    if (fieldType === String || fieldType === Boolean) {
      docsTypes.push(fieldType.name.toLowerCase());
    } else if (fieldType === null) {
      docsTypes.push("null");
    } else if (typeof fieldType === "string") {
      docsTypes.push(fieldType);
    } else if (Array.isArray(fieldType)) {
      docsTypes.push("List<" + (genTypesList(fieldType, path) || "any") + ">");
    } else {
      throw new Error("Wrong value `" + fieldType + "` in `" + path + "` structure definition");
    }
  }
  return docsTypes.join(" | ");
}
function processStructure(name50, nodeType) {
  const structure50 = nodeType.structure;
  const fields = {
    type: String,
    loc: true
  };
  const docs = {
    type: '"' + name50 + '"'
  };
  for (const key in structure50) {
    if (hasOwnProperty4.call(structure50, key) === false) {
      continue;
    }
    const fieldTypes = fields[key] = Array.isArray(structure50[key]) ? structure50[key].slice() : [structure50[key]];
    docs[key] = genTypesList(fieldTypes, name50 + "." + key);
  }
  return {
    docs,
    check: createNodeStructureChecker(name50, fields)
  };
}
function getStructureFromConfig(config) {
  const structure50 = {};
  if (config.node) {
    for (const name50 in config.node) {
      if (hasOwnProperty4.call(config.node, name50)) {
        const nodeType = config.node[name50];
        if (nodeType.structure) {
          structure50[name50] = processStructure(name50, nodeType);
        } else {
          throw new Error("Missed `structure` field in `" + name50 + "` node type definition");
        }
      }
    }
  }
  return structure50;
}

// node_modules/css-tree/lib/lexer/Lexer.js
function dumpMapSyntax(map, compact, syntaxAsAst) {
  const result = {};
  for (const name50 in map) {
    if (map[name50].syntax) {
      result[name50] = syntaxAsAst ? map[name50].syntax : generate(map[name50].syntax, { compact });
    }
  }
  return result;
}
function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
  const result = {};
  for (const [name50, atrule] of Object.entries(map)) {
    result[name50] = {
      prelude: atrule.prelude && (syntaxAsAst ? atrule.prelude.syntax : generate(atrule.prelude.syntax, { compact })),
      descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
    };
  }
  return result;
}
function valueHasVar(tokens) {
  for (let i = 0; i < tokens.length; i++) {
    if (tokens[i].value.toLowerCase() === "var(") {
      return true;
    }
  }
  return false;
}
function syntaxHasTopLevelCommaMultiplier(syntax) {
  const singleTerm = syntax.terms[0];
  return syntax.explicit === false && syntax.terms.length === 1 && singleTerm.type === "Multiplier" && singleTerm.comma === true;
}
function buildMatchResult(matched, error, iterations) {
  return {
    matched,
    iterations,
    error,
    ...trace_exports
  };
}
function matchSyntax(lexer2, syntax, value, useCssWideKeywords) {
  const tokens = prepare_tokens_default(value, lexer2.syntax);
  let result;
  if (valueHasVar(tokens)) {
    return buildMatchResult(null, new Error("Matching for a tree with var() is not supported"));
  }
  if (useCssWideKeywords) {
    result = matchAsTree(tokens, lexer2.cssWideKeywordsSyntax, lexer2);
  }
  if (!useCssWideKeywords || !result.match) {
    result = matchAsTree(tokens, syntax.match, lexer2);
    if (!result.match) {
      return buildMatchResult(
        null,
        new SyntaxMatchError(result.reason, syntax.syntax, value, result),
        result.iterations
      );
    }
  }
  return buildMatchResult(result.match, null, result.iterations);
}
var Lexer = class {
  constructor(config, syntax, structure50) {
    this.cssWideKeywords = cssWideKeywords;
    this.syntax = syntax;
    this.generic = false;
    this.units = { ...units_exports };
    this.atrules = /* @__PURE__ */ Object.create(null);
    this.properties = /* @__PURE__ */ Object.create(null);
    this.types = /* @__PURE__ */ Object.create(null);
    this.structure = structure50 || getStructureFromConfig(config);
    if (config) {
      if (config.cssWideKeywords) {
        this.cssWideKeywords = config.cssWideKeywords;
      }
      if (config.units) {
        for (const group of Object.keys(units_exports)) {
          if (Array.isArray(config.units[group])) {
            this.units[group] = config.units[group];
          }
        }
      }
      if (config.types) {
        for (const [name50, type] of Object.entries(config.types)) {
          this.addType_(name50, type);
        }
      }
      if (config.generic) {
        this.generic = true;
        for (const [name50, value] of Object.entries(createGenericTypes(this.units))) {
          this.addType_(name50, value);
        }
      }
      if (config.atrules) {
        for (const [name50, atrule] of Object.entries(config.atrules)) {
          this.addAtrule_(name50, atrule);
        }
      }
      if (config.properties) {
        for (const [name50, property4] of Object.entries(config.properties)) {
          this.addProperty_(name50, property4);
        }
      }
    }
    this.cssWideKeywordsSyntax = buildMatchGraph(this.cssWideKeywords.join(" |  "));
  }
  checkStructure(ast) {
    function collectWarning(node, message) {
      warns.push({ node, message });
    }
    const structure50 = this.structure;
    const warns = [];
    this.syntax.walk(ast, function(node) {
      if (structure50.hasOwnProperty(node.type)) {
        structure50[node.type].check(node, collectWarning);
      } else {
        collectWarning(node, "Unknown node type `" + node.type + "`");
      }
    });
    return warns.length ? warns : false;
  }
  createDescriptor(syntax, type, name50, parent = null) {
    const ref = {
      type,
      name: name50
    };
    const descriptor = {
      type,
      name: name50,
      parent,
      serializable: typeof syntax === "string" || syntax && typeof syntax.type === "string",
      syntax: null,
      match: null,
      matchRef: null
      // used for properties when a syntax referenced as <'property'> in other syntax definitions
    };
    if (typeof syntax === "function") {
      descriptor.match = buildMatchGraph(syntax, ref);
    } else {
      if (typeof syntax === "string") {
        Object.defineProperty(descriptor, "syntax", {
          get() {
            Object.defineProperty(descriptor, "syntax", {
              value: parse2(syntax)
            });
            return descriptor.syntax;
          }
        });
      } else {
        descriptor.syntax = syntax;
      }
      Object.defineProperty(descriptor, "match", {
        get() {
          Object.defineProperty(descriptor, "match", {
            value: buildMatchGraph(descriptor.syntax, ref)
          });
          return descriptor.match;
        }
      });
      if (type === "Property") {
        Object.defineProperty(descriptor, "matchRef", {
          get() {
            const syntax2 = descriptor.syntax;
            const value = syntaxHasTopLevelCommaMultiplier(syntax2) ? buildMatchGraph({
              ...syntax2,
              terms: [syntax2.terms[0].term]
            }, ref) : null;
            Object.defineProperty(descriptor, "matchRef", {
              value
            });
            return value;
          }
        });
      }
    }
    return descriptor;
  }
  addAtrule_(name50, syntax) {
    if (!syntax) {
      return;
    }
    this.atrules[name50] = {
      type: "Atrule",
      name: name50,
      prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, "AtrulePrelude", name50) : null,
      descriptors: syntax.descriptors ? Object.keys(syntax.descriptors).reduce(
        (map, descName) => {
          map[descName] = this.createDescriptor(syntax.descriptors[descName], "AtruleDescriptor", descName, name50);
          return map;
        },
        /* @__PURE__ */ Object.create(null)
      ) : null
    };
  }
  addProperty_(name50, syntax) {
    if (!syntax) {
      return;
    }
    this.properties[name50] = this.createDescriptor(syntax, "Property", name50);
  }
  addType_(name50, syntax) {
    if (!syntax) {
      return;
    }
    this.types[name50] = this.createDescriptor(syntax, "Type", name50);
  }
  checkAtruleName(atruleName) {
    if (!this.getAtrule(atruleName)) {
      return new SyntaxReferenceError("Unknown at-rule", "@" + atruleName);
    }
  }
  checkAtrulePrelude(atruleName, prelude) {
    const error = this.checkAtruleName(atruleName);
    if (error) {
      return error;
    }
    const atrule = this.getAtrule(atruleName);
    if (!atrule.prelude && prelude) {
      return new SyntaxError("At-rule `@" + atruleName + "` should not contain a prelude");
    }
    if (atrule.prelude && !prelude) {
      if (!matchSyntax(this, atrule.prelude, "", false).matched) {
        return new SyntaxError("At-rule `@" + atruleName + "` should contain a prelude");
      }
    }
  }
  checkAtruleDescriptorName(atruleName, descriptorName) {
    const error = this.checkAtruleName(atruleName);
    if (error) {
      return error;
    }
    const atrule = this.getAtrule(atruleName);
    const descriptor = keyword(descriptorName);
    if (!atrule.descriptors) {
      return new SyntaxError("At-rule `@" + atruleName + "` has no known descriptors");
    }
    if (!atrule.descriptors[descriptor.name] && !atrule.descriptors[descriptor.basename]) {
      return new SyntaxReferenceError("Unknown at-rule descriptor", descriptorName);
    }
  }
  checkPropertyName(propertyName) {
    if (!this.getProperty(propertyName)) {
      return new SyntaxReferenceError("Unknown property", propertyName);
    }
  }
  matchAtrulePrelude(atruleName, prelude) {
    const error = this.checkAtrulePrelude(atruleName, prelude);
    if (error) {
      return buildMatchResult(null, error);
    }
    const atrule = this.getAtrule(atruleName);
    if (!atrule.prelude) {
      return buildMatchResult(null, null);
    }
    return matchSyntax(this, atrule.prelude, prelude || "", false);
  }
  matchAtruleDescriptor(atruleName, descriptorName, value) {
    const error = this.checkAtruleDescriptorName(atruleName, descriptorName);
    if (error) {
      return buildMatchResult(null, error);
    }
    const atrule = this.getAtrule(atruleName);
    const descriptor = keyword(descriptorName);
    return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
  }
  matchDeclaration(node) {
    if (node.type !== "Declaration") {
      return buildMatchResult(null, new Error("Not a Declaration node"));
    }
    return this.matchProperty(node.property, node.value);
  }
  matchProperty(propertyName, value) {
    if (property3(propertyName).custom) {
      return buildMatchResult(null, new Error("Lexer matching doesn't applicable for custom properties"));
    }
    const error = this.checkPropertyName(propertyName);
    if (error) {
      return buildMatchResult(null, error);
    }
    return matchSyntax(this, this.getProperty(propertyName), value, true);
  }
  matchType(typeName, value) {
    const typeSyntax = this.getType(typeName);
    if (!typeSyntax) {
      return buildMatchResult(null, new SyntaxReferenceError("Unknown type", typeName));
    }
    return matchSyntax(this, typeSyntax, value, false);
  }
  match(syntax, value) {
    if (typeof syntax !== "string" && (!syntax || !syntax.type)) {
      return buildMatchResult(null, new SyntaxReferenceError("Bad syntax"));
    }
    if (typeof syntax === "string" || !syntax.match) {
      syntax = this.createDescriptor(syntax, "Type", "anonymous");
    }
    return matchSyntax(this, syntax, value, false);
  }
  findValueFragments(propertyName, value, type, name50) {
    return matchFragments(this, value, this.matchProperty(propertyName, value), type, name50);
  }
  findDeclarationValueFragments(declaration, type, name50) {
    return matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name50);
  }
  findAllFragments(ast, type, name50) {
    const result = [];
    this.syntax.walk(ast, {
      visit: "Declaration",
      enter: (declaration) => {
        result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name50));
      }
    });
    return result;
  }
  getAtrule(atruleName, fallbackBasename = true) {
    const atrule = keyword(atruleName);
    const atruleEntry = atrule.vendor && fallbackBasename ? this.atrules[atrule.name] || this.atrules[atrule.basename] : this.atrules[atrule.name];
    return atruleEntry || null;
  }
  getAtrulePrelude(atruleName, fallbackBasename = true) {
    const atrule = this.getAtrule(atruleName, fallbackBasename);
    return atrule && atrule.prelude || null;
  }
  getAtruleDescriptor(atruleName, name50) {
    return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name50] || null : null;
  }
  getProperty(propertyName, fallbackBasename = true) {
    const property4 = property3(propertyName);
    const propertyEntry = property4.vendor && fallbackBasename ? this.properties[property4.name] || this.properties[property4.basename] : this.properties[property4.name];
    return propertyEntry || null;
  }
  getType(name50) {
    return hasOwnProperty.call(this.types, name50) ? this.types[name50] : null;
  }
  validate() {
    function syntaxRef(name50, isType2) {
      return isType2 ? `<${name50}>` : `<'${name50}'>`;
    }
    function validate(syntax, name50, broken, descriptor) {
      if (broken.has(name50)) {
        return broken.get(name50);
      }
      broken.set(name50, false);
      if (descriptor.syntax !== null) {
        walk(descriptor.syntax, function(node) {
          if (node.type !== "Type" && node.type !== "Property") {
            return;
          }
          const map = node.type === "Type" ? syntax.types : syntax.properties;
          const brokenMap = node.type === "Type" ? brokenTypes : brokenProperties;
          if (!hasOwnProperty.call(map, node.name)) {
            errors.push(`${syntaxRef(name50, broken === brokenTypes)} used missed syntax definition ${syntaxRef(node.name, node.type === "Type")}`);
            broken.set(name50, true);
          } else if (validate(syntax, node.name, brokenMap, map[node.name])) {
            errors.push(`${syntaxRef(name50, broken === brokenTypes)} used broken syntax definition ${syntaxRef(node.name, node.type === "Type")}`);
            broken.set(name50, true);
          }
        }, this);
      }
    }
    const errors = [];
    let brokenTypes = /* @__PURE__ */ new Map();
    let brokenProperties = /* @__PURE__ */ new Map();
    for (const key in this.types) {
      validate(this, key, brokenTypes, this.types[key]);
    }
    for (const key in this.properties) {
      validate(this, key, brokenProperties, this.properties[key]);
    }
    const brokenTypesArray = [...brokenTypes.keys()].filter((name50) => brokenTypes.get(name50));
    const brokenPropertiesArray = [...brokenProperties.keys()].filter((name50) => brokenProperties.get(name50));
    if (brokenTypesArray.length || brokenPropertiesArray.length) {
      return {
        errors,
        types: brokenTypesArray,
        properties: brokenPropertiesArray
      };
    }
    return null;
  }
  dump(syntaxAsAst, pretty) {
    return {
      generic: this.generic,
      cssWideKeywords: this.cssWideKeywords,
      units: this.units,
      types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
      properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
      atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
    };
  }
  toString() {
    return JSON.stringify(this.dump());
  }
};

// node_modules/css-tree/lib/syntax/config/mix.js
function appendOrSet(a, b) {
  if (typeof b === "string" && /^\s*\|/.test(b)) {
    return typeof a === "string" ? a + b : b.replace(/^\s*\|\s*/, "");
  }
  return b || null;
}
function sliceProps(obj, props) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    if (value) {
      result[key] = {};
      for (const prop of Object.keys(value)) {
        if (props.includes(prop)) {
          result[key][prop] = value[prop];
        }
      }
    }
  }
  return result;
}
function mix(dest, src) {
  const result = { ...dest };
  for (const [prop, value] of Object.entries(src)) {
    switch (prop) {
      case "generic":
        result[prop] = Boolean(value);
        break;
      case "cssWideKeywords":
        result[prop] = dest[prop] ? [...dest[prop], ...value] : value || [];
        break;
      case "units":
        result[prop] = { ...dest[prop] };
        for (const [name50, patch] of Object.entries(value)) {
          result[prop][name50] = Array.isArray(patch) ? patch : [];
        }
        break;
      case "atrules":
        result[prop] = { ...dest[prop] };
        for (const [name50, atrule] of Object.entries(value)) {
          const exists = result[prop][name50] || {};
          const current = result[prop][name50] = {
            prelude: exists.prelude || null,
            descriptors: {
              ...exists.descriptors
            }
          };
          if (!atrule) {
            continue;
          }
          current.prelude = atrule.prelude ? appendOrSet(current.prelude, atrule.prelude) : current.prelude || null;
          for (const [descriptorName, descriptorValue] of Object.entries(atrule.descriptors || {})) {
            current.descriptors[descriptorName] = descriptorValue ? appendOrSet(current.descriptors[descriptorName], descriptorValue) : null;
          }
          if (!Object.keys(current.descriptors).length) {
            current.descriptors = null;
          }
        }
        break;
      case "types":
      case "properties":
        result[prop] = { ...dest[prop] };
        for (const [name50, syntax] of Object.entries(value)) {
          result[prop][name50] = appendOrSet(result[prop][name50], syntax);
        }
        break;
      case "scope":
      case "features":
        result[prop] = { ...dest[prop] };
        for (const [name50, props] of Object.entries(value)) {
          result[prop][name50] = { ...result[prop][name50], ...props };
        }
        break;
      case "parseContext":
        result[prop] = {
          ...dest[prop],
          ...value
        };
        break;
      case "atrule":
      case "pseudo":
        result[prop] = {
          ...dest[prop],
          ...sliceProps(value, ["parse"])
        };
        break;
      case "node":
        result[prop] = {
          ...dest[prop],
          ...sliceProps(value, ["name", "structure", "parse", "generate", "walkContext"])
        };
        break;
    }
  }
  return result;
}

// node_modules/css-tree/lib/syntax/create.js
function createSyntax(config) {
  const parse53 = createParser(config);
  const walk3 = createWalker(config);
  const generate52 = createGenerator2(config);
  const { fromPlainObject: fromPlainObject2, toPlainObject: toPlainObject2 } = createConvertor(walk3);
  const syntax = {
    lexer: null,
    createLexer: (config2) => new Lexer(config2, syntax, syntax.lexer.structure),
    tokenize,
    parse: parse53,
    generate: generate52,
    walk: walk3,
    find: walk3.find,
    findLast: walk3.findLast,
    findAll: walk3.findAll,
    fromPlainObject: fromPlainObject2,
    toPlainObject: toPlainObject2,
    fork(extension) {
      const base = mix({}, config);
      return createSyntax(
        typeof extension === "function" ? extension(base) : mix(base, extension)
      );
    }
  };
  syntax.lexer = new Lexer({
    generic: config.generic,
    cssWideKeywords: config.cssWideKeywords,
    units: config.units,
    types: config.types,
    atrules: config.atrules,
    properties: config.properties,
    node: config.node
  }, syntax);
  return syntax;
}
var create_default = (config) => createSyntax(mix({}, config));

// node_modules/css-tree/dist/data.js
var data_default = {
  "generic": true,
  "cssWideKeywords": [
    "initial",
    "inherit",
    "unset",
    "revert",
    "revert-layer"
  ],
  "units": {
    "angle": [
      "deg",
      "grad",
      "rad",
      "turn"
    ],
    "decibel": [
      "db"
    ],
    "flex": [
      "fr"
    ],
    "frequency": [
      "hz",
      "khz"
    ],
    "length": [
      "cm",
      "mm",
      "q",
      "in",
      "pt",
      "pc",
      "px",
      "em",
      "rem",
      "ex",
      "rex",
      "cap",
      "rcap",
      "ch",
      "rch",
      "ic",
      "ric",
      "lh",
      "rlh",
      "vw",
      "svw",
      "lvw",
      "dvw",
      "vh",
      "svh",
      "lvh",
      "dvh",
      "vi",
      "svi",
      "lvi",
      "dvi",
      "vb",
      "svb",
      "lvb",
      "dvb",
      "vmin",
      "svmin",
      "lvmin",
      "dvmin",
      "vmax",
      "svmax",
      "lvmax",
      "dvmax",
      "cqw",
      "cqh",
      "cqi",
      "cqb",
      "cqmin",
      "cqmax"
    ],
    "resolution": [
      "dpi",
      "dpcm",
      "dppx",
      "x"
    ],
    "semitones": [
      "st"
    ],
    "time": [
      "s",
      "ms"
    ]
  },
  "types": {
    "abs()": "abs( <calc-sum> )",
    "absolute-size": "xx-small|x-small|small|medium|large|x-large|xx-large|xxx-large",
    "acos()": "acos( <calc-sum> )",
    "alpha-value": "<number>|<percentage>",
    "angle-percentage": "<angle>|<percentage>",
    "angular-color-hint": "<angle-percentage>",
    "angular-color-stop": "<color>&&<color-stop-angle>?",
    "angular-color-stop-list": "[<angular-color-stop> [, <angular-color-hint>]?]# , <angular-color-stop>",
    "animateable-feature": "scroll-position|contents|<custom-ident>",
    "asin()": "asin( <calc-sum> )",
    "atan()": "atan( <calc-sum> )",
    "atan2()": "atan2( <calc-sum> , <calc-sum> )",
    "attachment": "scroll|fixed|local",
    "attr()": "attr( <attr-name> <type-or-unit>? [, <attr-fallback>]? )",
    "attr-matcher": "['~'|'|'|'^'|'$'|'*']? '='",
    "attr-modifier": "i|s",
    "attribute-selector": "'[' <wq-name> ']'|'[' <wq-name> <attr-matcher> [<string-token>|<ident-token>] <attr-modifier>? ']'",
    "auto-repeat": "repeat( [auto-fill|auto-fit] , [<line-names>? <fixed-size>]+ <line-names>? )",
    "auto-track-list": "[<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>? <auto-repeat> [<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>?",
    "axis": "block|inline|x|y",
    "baseline-position": "[first|last]? baseline",
    "basic-shape": "<inset()>|<xywh()>|<rect()>|<circle()>|<ellipse()>|<polygon()>|<path()>",
    "bg-image": "none|<image>",
    "bg-layer": "<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
    "bg-position": "[[left|center|right|top|bottom|<length-percentage>]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]|[center|[left|right] <length-percentage>?]&&[center|[top|bottom] <length-percentage>?]]",
    "bg-size": "[<length-percentage>|auto]{1,2}|cover|contain",
    "blur()": "blur( <length> )",
    "blend-mode": "normal|multiply|screen|overlay|darken|lighten|color-dodge|color-burn|hard-light|soft-light|difference|exclusion|hue|saturation|color|luminosity",
    "box": "border-box|padding-box|content-box",
    "brightness()": "brightness( <number-percentage> )",
    "calc()": "calc( <calc-sum> )",
    "calc-sum": "<calc-product> [['+'|'-'] <calc-product>]*",
    "calc-product": "<calc-value> ['*' <calc-value>|'/' <number>]*",
    "calc-value": "<number>|<dimension>|<percentage>|<calc-constant>|( <calc-sum> )",
    "calc-constant": "e|pi|infinity|-infinity|NaN",
    "cf-final-image": "<image>|<color>",
    "cf-mixing-image": "<percentage>?&&<image>",
    "circle()": "circle( [<shape-radius>]? [at <position>]? )",
    "clamp()": "clamp( <calc-sum>#{3} )",
    "class-selector": "'.' <ident-token>",
    "clip-source": "<url>",
    "color": "<color-base>|currentColor|<system-color>|<device-cmyk()>|<light-dark()>|<-non-standard-color>",
    "color-stop": "<color-stop-length>|<color-stop-angle>",
    "color-stop-angle": "<angle-percentage>{1,2}",
    "color-stop-length": "<length-percentage>{1,2}",
    "color-stop-list": "[<linear-color-stop> [, <linear-color-hint>]?]# , <linear-color-stop>",
    "color-interpolation-method": "in [<rectangular-color-space>|<polar-color-space> <hue-interpolation-method>?|<custom-color-space>]",
    "combinator": "'>'|'+'|'~'|['|' '|']",
    "common-lig-values": "[common-ligatures|no-common-ligatures]",
    "compat-auto": "searchfield|textarea|push-button|slider-horizontal|checkbox|radio|square-button|menulist|listbox|meter|progress-bar|button",
    "composite-style": "clear|copy|source-over|source-in|source-out|source-atop|destination-over|destination-in|destination-out|destination-atop|xor",
    "compositing-operator": "add|subtract|intersect|exclude",
    "compound-selector": "[<type-selector>? <subclass-selector>*]!",
    "compound-selector-list": "<compound-selector>#",
    "complex-selector": "<complex-selector-unit> [<combinator>? <complex-selector-unit>]*",
    "complex-selector-list": "<complex-selector>#",
    "conic-gradient()": "conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
    "contextual-alt-values": "[contextual|no-contextual]",
    "content-distribution": "space-between|space-around|space-evenly|stretch",
    "content-list": "[<string>|contents|<image>|<counter>|<quote>|<target>|<leader()>|<attr()>]+",
    "content-position": "center|start|end|flex-start|flex-end",
    "content-replacement": "<image>",
    "contrast()": "contrast( [<number-percentage>] )",
    "cos()": "cos( <calc-sum> )",
    "counter": "<counter()>|<counters()>",
    "counter()": "counter( <counter-name> , <counter-style>? )",
    "counter-name": "<custom-ident>",
    "counter-style": "<counter-style-name>|symbols( )",
    "counter-style-name": "<custom-ident>",
    "counters()": "counters( <counter-name> , <string> , <counter-style>? )",
    "cross-fade()": "cross-fade( <cf-mixing-image> , <cf-final-image>? )",
    "cubic-bezier-timing-function": "ease|ease-in|ease-out|ease-in-out|cubic-bezier( <number [0,1]> , <number> , <number [0,1]> , <number> )",
    "deprecated-system-color": "ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText",
    "discretionary-lig-values": "[discretionary-ligatures|no-discretionary-ligatures]",
    "display-box": "contents|none",
    "display-inside": "flow|flow-root|table|flex|grid|ruby",
    "display-internal": "table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption|ruby-base|ruby-text|ruby-base-container|ruby-text-container",
    "display-legacy": "inline-block|inline-list-item|inline-table|inline-flex|inline-grid",
    "display-listitem": "<display-outside>?&&[flow|flow-root]?&&list-item",
    "display-outside": "block|inline|run-in",
    "drop-shadow()": "drop-shadow( <length>{2,3} <color>? )",
    "east-asian-variant-values": "[jis78|jis83|jis90|jis04|simplified|traditional]",
    "east-asian-width-values": "[full-width|proportional-width]",
    "element()": "element( <custom-ident> , [first|start|last|first-except]? )|element( <id-selector> )",
    "ellipse()": "ellipse( [<shape-radius>{2}]? [at <position>]? )",
    "ending-shape": "circle|ellipse",
    "env()": "env( <custom-ident> , <declaration-value>? )",
    "exp()": "exp( <calc-sum> )",
    "explicit-track-list": "[<line-names>? <track-size>]+ <line-names>?",
    "family-name": "<string>|<custom-ident>+",
    "feature-tag-value": "<string> [<integer>|on|off]?",
    "feature-type": "@stylistic|@historical-forms|@styleset|@character-variant|@swash|@ornaments|@annotation",
    "feature-value-block": "<feature-type> '{' <feature-value-declaration-list> '}'",
    "feature-value-block-list": "<feature-value-block>+",
    "feature-value-declaration": "<custom-ident> : <integer>+ ;",
    "feature-value-declaration-list": "<feature-value-declaration>",
    "feature-value-name": "<custom-ident>",
    "fill-rule": "nonzero|evenodd",
    "filter-function": "<blur()>|<brightness()>|<contrast()>|<drop-shadow()>|<grayscale()>|<hue-rotate()>|<invert()>|<opacity()>|<saturate()>|<sepia()>",
    "filter-function-list": "[<filter-function>|<url>]+",
    "final-bg-layer": "<'background-color'>||<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
    "fixed-breadth": "<length-percentage>",
    "fixed-repeat": "repeat( [<integer [1,]>] , [<line-names>? <fixed-size>]+ <line-names>? )",
    "fixed-size": "<fixed-breadth>|minmax( <fixed-breadth> , <track-breadth> )|minmax( <inflexible-breadth> , <fixed-breadth> )",
    "font-stretch-absolute": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded|<percentage>",
    "font-variant-css21": "[normal|small-caps]",
    "font-weight-absolute": "normal|bold|<number [1,1000]>",
    "frequency-percentage": "<frequency>|<percentage>",
    "general-enclosed": "[<function-token> <any-value>? )]|[( <any-value>? )]",
    "generic-family": "<generic-script-specific>|<generic-complete>|<generic-incomplete>|<-non-standard-generic-family>",
    "generic-name": "serif|sans-serif|cursive|fantasy|monospace",
    "geometry-box": "<shape-box>|fill-box|stroke-box|view-box",
    "gradient": "<linear-gradient()>|<repeating-linear-gradient()>|<radial-gradient()>|<repeating-radial-gradient()>|<conic-gradient()>|<repeating-conic-gradient()>|<-legacy-gradient>",
    "grayscale()": "grayscale( <number-percentage> )",
    "grid-line": "auto|<custom-ident>|[<integer>&&<custom-ident>?]|[span&&[<integer>||<custom-ident>]]",
    "historical-lig-values": "[historical-ligatures|no-historical-ligatures]",
    "hsl()": "hsl( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsl( <hue> , <percentage> , <percentage> , <alpha-value>? )",
    "hsla()": "hsla( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsla( <hue> , <percentage> , <percentage> , <alpha-value>? )",
    "hue": "<number>|<angle>",
    "hue-rotate()": "hue-rotate( <angle> )",
    "hue-interpolation-method": "[shorter|longer|increasing|decreasing] hue",
    "hwb()": "hwb( [<hue>|none] [<percentage>|none] [<percentage>|none] [/ [<alpha-value>|none]]? )",
    "hypot()": "hypot( <calc-sum># )",
    "image": "<url>|<image()>|<image-set()>|<element()>|<paint()>|<cross-fade()>|<gradient>",
    "image()": "image( <image-tags>? [<image-src>? , <color>?]! )",
    "image-set()": "image-set( <image-set-option># )",
    "image-set-option": "[<image>|<string>] [<resolution>||type( <string> )]",
    "image-src": "<url>|<string>",
    "image-tags": "ltr|rtl",
    "inflexible-breadth": "<length-percentage>|min-content|max-content|auto",
    "inset()": "inset( <length-percentage>{1,4} [round <'border-radius'>]? )",
    "invert()": "invert( <number-percentage> )",
    "keyframes-name": "<custom-ident>|<string>",
    "keyframe-block": "<keyframe-selector># { <declaration-list> }",
    "keyframe-block-list": "<keyframe-block>+",
    "keyframe-selector": "from|to|<percentage>|<timeline-range-name> <percentage>",
    "lab()": "lab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )",
    "layer()": "layer( <layer-name> )",
    "layer-name": "<ident> ['.' <ident>]*",
    "lch()": "lch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )",
    "leader()": "leader( <leader-type> )",
    "leader-type": "dotted|solid|space|<string>",
    "length-percentage": "<length>|<percentage>",
    "light-dark()": "light-dark( <color> , <color> )",
    "line-names": "'[' <custom-ident>* ']'",
    "line-name-list": "[<line-names>|<name-repeat>]+",
    "line-style": "none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset",
    "line-width": "<length>|thin|medium|thick",
    "linear-color-hint": "<length-percentage>",
    "linear-color-stop": "<color> <color-stop-length>?",
    "linear-gradient()": "linear-gradient( [[<angle>|to <side-or-corner>]||<color-interpolation-method>]? , <color-stop-list> )",
    "log()": "log( <calc-sum> , <calc-sum>? )",
    "mask-layer": "<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||<geometry-box>||[<geometry-box>|no-clip]||<compositing-operator>||<masking-mode>",
    "mask-position": "[<length-percentage>|left|center|right] [<length-percentage>|top|center|bottom]?",
    "mask-reference": "none|<image>|<mask-source>",
    "mask-source": "<url>",
    "masking-mode": "alpha|luminance|match-source",
    "matrix()": "matrix( <number>#{6} )",
    "matrix3d()": "matrix3d( <number>#{16} )",
    "max()": "max( <calc-sum># )",
    "media-and": "<media-in-parens> [and <media-in-parens>]+",
    "media-condition": "<media-not>|<media-and>|<media-or>|<media-in-parens>",
    "media-condition-without-or": "<media-not>|<media-and>|<media-in-parens>",
    "media-feature": "( [<mf-plain>|<mf-boolean>|<mf-range>] )",
    "media-in-parens": "( <media-condition> )|<media-feature>|<general-enclosed>",
    "media-not": "not <media-in-parens>",
    "media-or": "<media-in-parens> [or <media-in-parens>]+",
    "media-query": "<media-condition>|[not|only]? <media-type> [and <media-condition-without-or>]?",
    "media-query-list": "<media-query>#",
    "media-type": "<ident>",
    "mf-boolean": "<mf-name>",
    "mf-name": "<ident>",
    "mf-plain": "<mf-name> : <mf-value>",
    "mf-range": "<mf-name> ['<'|'>']? '='? <mf-value>|<mf-value> ['<'|'>']? '='? <mf-name>|<mf-value> '<' '='? <mf-name> '<' '='? <mf-value>|<mf-value> '>' '='? <mf-name> '>' '='? <mf-value>",
    "mf-value": "<number>|<dimension>|<ident>|<ratio>",
    "min()": "min( <calc-sum># )",
    "minmax()": "minmax( [<length-percentage>|min-content|max-content|auto] , [<length-percentage>|<flex>|min-content|max-content|auto] )",
    "mod()": "mod( <calc-sum> , <calc-sum> )",
    "name-repeat": "repeat( [<integer [1,]>|auto-fill] , <line-names>+ )",
    "named-color": "transparent|aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen",
    "namespace-prefix": "<ident>",
    "ns-prefix": "[<ident-token>|'*']? '|'",
    "number-percentage": "<number>|<percentage>",
    "numeric-figure-values": "[lining-nums|oldstyle-nums]",
    "numeric-fraction-values": "[diagonal-fractions|stacked-fractions]",
    "numeric-spacing-values": "[proportional-nums|tabular-nums]",
    "nth": "<an-plus-b>|even|odd",
    "opacity()": "opacity( [<number-percentage>] )",
    "overflow-position": "unsafe|safe",
    "outline-radius": "<length>|<percentage>",
    "page-body": "<declaration>? [; <page-body>]?|<page-margin-box> <page-body>",
    "page-margin-box": "<page-margin-box-type> '{' <declaration-list> '}'",
    "page-margin-box-type": "@top-left-corner|@top-left|@top-center|@top-right|@top-right-corner|@bottom-left-corner|@bottom-left|@bottom-center|@bottom-right|@bottom-right-corner|@left-top|@left-middle|@left-bottom|@right-top|@right-middle|@right-bottom",
    "page-selector-list": "[<page-selector>#]?",
    "page-selector": "<pseudo-page>+|<ident> <pseudo-page>*",
    "page-size": "A5|A4|A3|B5|B4|JIS-B5|JIS-B4|letter|legal|ledger",
    "path()": "path( [<fill-rule> ,]? <string> )",
    "paint()": "paint( <ident> , <declaration-value>? )",
    "perspective()": "perspective( [<length [0,]>|none] )",
    "polygon()": "polygon( <fill-rule>? , [<length-percentage> <length-percentage>]# )",
    "polar-color-space": "hsl|hwb|lch|oklch",
    "position": "[[left|center|right]||[top|center|bottom]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]?|[[left|right] <length-percentage>]&&[[top|bottom] <length-percentage>]]",
    "pow()": "pow( <calc-sum> , <calc-sum> )",
    "pseudo-class-selector": "':' <ident-token>|':' <function-token> <any-value> ')'",
    "pseudo-element-selector": "':' <pseudo-class-selector>|<legacy-pseudo-element-selector>",
    "pseudo-page": ": [left|right|first|blank]",
    "quote": "open-quote|close-quote|no-open-quote|no-close-quote",
    "radial-gradient()": "radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
    "ratio": "<number [0,]> [/ <number [0,]>]?",
    "ray()": "ray( <angle>&&<ray-size>?&&contain?&&[at <position>]? )",
    "ray-size": "closest-side|closest-corner|farthest-side|farthest-corner|sides",
    "rectangular-color-space": "srgb|srgb-linear|display-p3|a98-rgb|prophoto-rgb|rec2020|lab|oklab|xyz|xyz-d50|xyz-d65",
    "relative-selector": "<combinator>? <complex-selector>",
    "relative-selector-list": "<relative-selector>#",
    "relative-size": "larger|smaller",
    "rem()": "rem( <calc-sum> , <calc-sum> )",
    "repeat-style": "repeat-x|repeat-y|[repeat|space|round|no-repeat]{1,2}",
    "repeating-conic-gradient()": "repeating-conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
    "repeating-linear-gradient()": "repeating-linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
    "repeating-radial-gradient()": "repeating-radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
    "reversed-counter-name": "reversed( <counter-name> )",
    "rgb()": "rgb( <percentage>{3} [/ <alpha-value>]? )|rgb( <number>{3} [/ <alpha-value>]? )|rgb( <percentage>#{3} , <alpha-value>? )|rgb( <number>#{3} , <alpha-value>? )",
    "rgba()": "rgba( <percentage>{3} [/ <alpha-value>]? )|rgba( <number>{3} [/ <alpha-value>]? )|rgba( <percentage>#{3} , <alpha-value>? )|rgba( <number>#{3} , <alpha-value>? )",
    "rotate()": "rotate( [<angle>|<zero>] )",
    "rotate3d()": "rotate3d( <number> , <number> , <number> , [<angle>|<zero>] )",
    "rotateX()": "rotateX( [<angle>|<zero>] )",
    "rotateY()": "rotateY( [<angle>|<zero>] )",
    "rotateZ()": "rotateZ( [<angle>|<zero>] )",
    "round()": "round( <rounding-strategy>? , <calc-sum> , <calc-sum> )",
    "rounding-strategy": "nearest|up|down|to-zero",
    "saturate()": "saturate( <number-percentage> )",
    "scale()": "scale( [<number>|<percentage>]#{1,2} )",
    "scale3d()": "scale3d( [<number>|<percentage>]#{3} )",
    "scaleX()": "scaleX( [<number>|<percentage>] )",
    "scaleY()": "scaleY( [<number>|<percentage>] )",
    "scaleZ()": "scaleZ( [<number>|<percentage>] )",
    "scroll()": "scroll( [<axis>||<scroller>]? )",
    "scroller": "root|nearest|self",
    "self-position": "center|start|end|self-start|self-end|flex-start|flex-end",
    "shape-radius": "<length-percentage>|closest-side|farthest-side",
    "sign()": "sign( <calc-sum> )",
    "skew()": "skew( [<angle>|<zero>] , [<angle>|<zero>]? )",
    "skewX()": "skewX( [<angle>|<zero>] )",
    "skewY()": "skewY( [<angle>|<zero>] )",
    "sepia()": "sepia( <number-percentage> )",
    "shadow": "inset?&&<length>{2,4}&&<color>?",
    "shadow-t": "[<length>{2,3}&&<color>?]",
    "shape": "rect( <top> , <right> , <bottom> , <left> )|rect( <top> <right> <bottom> <left> )",
    "shape-box": "<box>|margin-box",
    "side-or-corner": "[left|right]||[top|bottom]",
    "sin()": "sin( <calc-sum> )",
    "single-animation": "<'animation-duration'>||<easing-function>||<'animation-delay'>||<single-animation-iteration-count>||<single-animation-direction>||<single-animation-fill-mode>||<single-animation-play-state>||[none|<keyframes-name>]||<single-animation-timeline>",
    "single-animation-direction": "normal|reverse|alternate|alternate-reverse",
    "single-animation-fill-mode": "none|forwards|backwards|both",
    "single-animation-iteration-count": "infinite|<number>",
    "single-animation-play-state": "running|paused",
    "single-animation-timeline": "auto|none|<dashed-ident>|<scroll()>|<view()>",
    "single-transition": "[none|<single-transition-property>]||<time>||<easing-function>||<time>||<transition-behavior-value>",
    "single-transition-property": "all|<custom-ident>",
    "size": "closest-side|farthest-side|closest-corner|farthest-corner|<length>|<length-percentage>{2}",
    "sqrt()": "sqrt( <calc-sum> )",
    "step-position": "jump-start|jump-end|jump-none|jump-both|start|end",
    "step-timing-function": "step-start|step-end|steps( <integer> [, <step-position>]? )",
    "subclass-selector": "<id-selector>|<class-selector>|<attribute-selector>|<pseudo-class-selector>",
    "supports-condition": "not <supports-in-parens>|<supports-in-parens> [and <supports-in-parens>]*|<supports-in-parens> [or <supports-in-parens>]*",
    "supports-in-parens": "( <supports-condition> )|<supports-feature>|<general-enclosed>",
    "supports-feature": "<supports-decl>|<supports-selector-fn>",
    "supports-decl": "( <declaration> )",
    "supports-selector-fn": "selector( <complex-selector> )",
    "symbol": "<string>|<image>|<custom-ident>",
    "system-color": "AccentColor|AccentColorText|ActiveText|ButtonBorder|ButtonFace|ButtonText|Canvas|CanvasText|Field|FieldText|GrayText|Highlight|HighlightText|LinkText|Mark|MarkText|SelectedItem|SelectedItemText|VisitedText",
    "tan()": "tan( <calc-sum> )",
    "target": "<target-counter()>|<target-counters()>|<target-text()>",
    "target-counter()": "target-counter( [<string>|<url>] , <custom-ident> , <counter-style>? )",
    "target-counters()": "target-counters( [<string>|<url>] , <custom-ident> , <string> , <counter-style>? )",
    "target-text()": "target-text( [<string>|<url>] , [content|before|after|first-letter]? )",
    "time-percentage": "<time>|<percentage>",
    "timeline-range-name": "cover|contain|entry|exit|entry-crossing|exit-crossing",
    "easing-function": "linear|<cubic-bezier-timing-function>|<step-timing-function>",
    "track-breadth": "<length-percentage>|<flex>|min-content|max-content|auto",
    "track-list": "[<line-names>? [<track-size>|<track-repeat>]]+ <line-names>?",
    "track-repeat": "repeat( [<integer [1,]>] , [<line-names>? <track-size>]+ <line-names>? )",
    "track-size": "<track-breadth>|minmax( <inflexible-breadth> , <track-breadth> )|fit-content( <length-percentage> )",
    "transform-function": "<matrix()>|<translate()>|<translateX()>|<translateY()>|<scale()>|<scaleX()>|<scaleY()>|<rotate()>|<skew()>|<skewX()>|<skewY()>|<matrix3d()>|<translate3d()>|<translateZ()>|<scale3d()>|<scaleZ()>|<rotate3d()>|<rotateX()>|<rotateY()>|<rotateZ()>|<perspective()>",
    "transform-list": "<transform-function>+",
    "transition-behavior-value": "normal|allow-discrete",
    "translate()": "translate( <length-percentage> , <length-percentage>? )",
    "translate3d()": "translate3d( <length-percentage> , <length-percentage> , <length> )",
    "translateX()": "translateX( <length-percentage> )",
    "translateY()": "translateY( <length-percentage> )",
    "translateZ()": "translateZ( <length> )",
    "type-or-unit": "string|color|url|integer|number|length|angle|time|frequency|cap|ch|em|ex|ic|lh|rlh|rem|vb|vi|vw|vh|vmin|vmax|mm|Q|cm|in|pt|pc|px|deg|grad|rad|turn|ms|s|Hz|kHz|%",
    "type-selector": "<wq-name>|<ns-prefix>? '*'",
    "var()": "var( <custom-property-name> , <declaration-value>? )",
    "view()": "view( [<axis>||<'view-timeline-inset'>]? )",
    "viewport-length": "auto|<length-percentage>",
    "visual-box": "content-box|padding-box|border-box",
    "wq-name": "<ns-prefix>? <ident-token>",
    "-legacy-gradient": "<-webkit-gradient()>|<-legacy-linear-gradient>|<-legacy-repeating-linear-gradient>|<-legacy-radial-gradient>|<-legacy-repeating-radial-gradient>",
    "-legacy-linear-gradient": "-moz-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-linear-gradient( <-legacy-linear-gradient-arguments> )",
    "-legacy-repeating-linear-gradient": "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )",
    "-legacy-linear-gradient-arguments": "[<angle>|<side-or-corner>]? , <color-stop-list>",
    "-legacy-radial-gradient": "-moz-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-radial-gradient( <-legacy-radial-gradient-arguments> )",
    "-legacy-repeating-radial-gradient": "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )",
    "-legacy-radial-gradient-arguments": "[<position> ,]? [[[<-legacy-radial-gradient-shape>||<-legacy-radial-gradient-size>]|[<length>|<percentage>]{2}] ,]? <color-stop-list>",
    "-legacy-radial-gradient-size": "closest-side|closest-corner|farthest-side|farthest-corner|contain|cover",
    "-legacy-radial-gradient-shape": "circle|ellipse",
    "-non-standard-font": "-apple-system-body|-apple-system-headline|-apple-system-subheadline|-apple-system-caption1|-apple-system-caption2|-apple-system-footnote|-apple-system-short-body|-apple-system-short-headline|-apple-system-short-subheadline|-apple-system-short-caption1|-apple-system-short-footnote|-apple-system-tall-body",
    "-non-standard-color": "-moz-ButtonDefault|-moz-ButtonHoverFace|-moz-ButtonHoverText|-moz-CellHighlight|-moz-CellHighlightText|-moz-Combobox|-moz-ComboboxText|-moz-Dialog|-moz-DialogText|-moz-dragtargetzone|-moz-EvenTreeRow|-moz-Field|-moz-FieldText|-moz-html-CellHighlight|-moz-html-CellHighlightText|-moz-mac-accentdarkestshadow|-moz-mac-accentdarkshadow|-moz-mac-accentface|-moz-mac-accentlightesthighlight|-moz-mac-accentlightshadow|-moz-mac-accentregularhighlight|-moz-mac-accentregularshadow|-moz-mac-chrome-active|-moz-mac-chrome-inactive|-moz-mac-focusring|-moz-mac-menuselect|-moz-mac-menushadow|-moz-mac-menutextselect|-moz-MenuHover|-moz-MenuHoverText|-moz-MenuBarText|-moz-MenuBarHoverText|-moz-nativehyperlinktext|-moz-OddTreeRow|-moz-win-communicationstext|-moz-win-mediatext|-moz-activehyperlinktext|-moz-default-background-color|-moz-default-color|-moz-hyperlinktext|-moz-visitedhyperlinktext|-webkit-activelink|-webkit-focus-ring-color|-webkit-link|-webkit-text",
    "-non-standard-image-rendering": "optimize-contrast|-moz-crisp-edges|-o-crisp-edges|-webkit-optimize-contrast",
    "-non-standard-overflow": "overlay|-moz-scrollbars-none|-moz-scrollbars-horizontal|-moz-scrollbars-vertical|-moz-hidden-unscrollable",
    "-non-standard-size": "intrinsic|min-intrinsic|-webkit-fill-available|-webkit-fit-content|-webkit-min-content|-webkit-max-content|-moz-available|-moz-fit-content|-moz-min-content|-moz-max-content",
    "-webkit-gradient()": "-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [, <-webkit-gradient-point>|, <-webkit-gradient-radius> , <-webkit-gradient-point>] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )",
    "-webkit-gradient-color-stop": "from( <color> )|color-stop( [<number-zero-one>|<percentage>] , <color> )|to( <color> )",
    "-webkit-gradient-point": "[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]",
    "-webkit-gradient-radius": "<length>|<percentage>",
    "-webkit-gradient-type": "linear|radial",
    "-webkit-mask-box-repeat": "repeat|stretch|round",
    "-ms-filter-function-list": "<-ms-filter-function>+",
    "-ms-filter-function": "<-ms-filter-function-progid>|<-ms-filter-function-legacy>",
    "-ms-filter-function-progid": "'progid:' [<ident-token> '.']* [<ident-token>|<function-token> <any-value>? )]",
    "-ms-filter-function-legacy": "<ident-token>|<function-token> <any-value>? )",
    "absolute-color-base": "<hex-color>|<absolute-color-function>|<named-color>|transparent",
    "absolute-color-function": "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<oklab()>|<oklch()>|<color()>",
    "age": "child|young|old",
    "anchor-name": "<dashed-ident>",
    "attr-name": "<wq-name>",
    "attr-fallback": "<any-value>",
    "bg-clip": "<box>|border|text",
    "bottom": "<length>|auto",
    "container-name": "<custom-ident>",
    "container-condition": "not <query-in-parens>|<query-in-parens> [[and <query-in-parens>]*|[or <query-in-parens>]*]",
    "coord-box": "content-box|padding-box|border-box|fill-box|stroke-box|view-box",
    "generic-voice": "[<age>? <gender> <integer>?]",
    "gender": "male|female|neutral",
    "generic-script-specific": "generic( kai )|generic( fangsong )|generic( nastaliq )",
    "generic-complete": "serif|sans-serif|system-ui|cursive|fantasy|math|monospace",
    "generic-incomplete": "ui-serif|ui-sans-serif|ui-monospace|ui-rounded",
    "-non-standard-generic-family": "-apple-system|BlinkMacSystemFont",
    "left": "<length>|auto",
    "color-base": "<hex-color>|<color-function>|<named-color>|<color-mix()>|transparent",
    "color-function": "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<oklab()>|<oklch()>|<color()>",
    "device-cmyk()": "<legacy-device-cmyk-syntax>|<modern-device-cmyk-syntax>",
    "legacy-device-cmyk-syntax": "device-cmyk( <number>#{4} )",
    "modern-device-cmyk-syntax": "device-cmyk( <cmyk-component>{4} [/ [<alpha-value>|none]]? )",
    "cmyk-component": "<number>|<percentage>|none",
    "color-mix()": "color-mix( <color-interpolation-method> , [<color>&&<percentage [0,100]>?]#{2} )",
    "color-space": "<rectangular-color-space>|<polar-color-space>|<custom-color-space>",
    "custom-color-space": "<dashed-ident>",
    "paint": "none|<color>|<url> [none|<color>]?|context-fill|context-stroke",
    "palette-identifier": "<dashed-ident>",
    "right": "<length>|auto",
    "scope-start": "<forgiving-selector-list>",
    "scope-end": "<forgiving-selector-list>",
    "forgiving-selector-list": "<complex-real-selector-list>",
    "forgiving-relative-selector-list": "<relative-real-selector-list>",
    "selector-list": "<complex-selector-list>",
    "complex-real-selector-list": "<complex-real-selector>#",
    "simple-selector-list": "<simple-selector>#",
    "relative-real-selector-list": "<relative-real-selector>#",
    "complex-selector-unit": "[<compound-selector>? <pseudo-compound-selector>*]!",
    "complex-real-selector": "<compound-selector> [<combinator>? <compound-selector>]*",
    "relative-real-selector": "<combinator>? <complex-real-selector>",
    "pseudo-compound-selector": "<pseudo-element-selector> <pseudo-class-selector>*",
    "simple-selector": "<type-selector>|<subclass-selector>",
    "legacy-pseudo-element-selector": "':' [before|after|first-line|first-letter]",
    "single-animation-composition": "replace|add|accumulate",
    "svg-length": "<percentage>|<length>|<number>",
    "svg-writing-mode": "lr-tb|rl-tb|tb-rl|lr|rl|tb",
    "top": "<length>|auto",
    "x": "<number>",
    "y": "<number>",
    "declaration": "<ident-token> : <declaration-value>? ['!' important]?",
    "declaration-list": "[<declaration>? ';']* <declaration>?",
    "url": "url( <string> <url-modifier>* )|<url-token>",
    "url-modifier": "<ident>|<function-token> <any-value> )",
    "number-zero-one": "<number [0,1]>",
    "number-one-or-greater": "<number [1,]>",
    "color()": "color( <colorspace-params> [/ [<alpha-value>|none]]? )",
    "colorspace-params": "[<predefined-rgb-params>|<xyz-params>]",
    "predefined-rgb-params": "<predefined-rgb> [<number>|<percentage>|none]{3}",
    "predefined-rgb": "srgb|srgb-linear|display-p3|a98-rgb|prophoto-rgb|rec2020",
    "xyz-params": "<xyz-space> [<number>|<percentage>|none]{3}",
    "xyz-space": "xyz|xyz-d50|xyz-d65",
    "oklab()": "oklab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )",
    "oklch()": "oklch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )",
    "offset-path": "<ray()>|<url>|<basic-shape>",
    "rect()": "rect( [<length-percentage>|auto]{4} [round <'border-radius'>]? )",
    "xywh()": "xywh( <length-percentage>{2} <length-percentage [0,]>{2} [round <'border-radius'>]? )",
    "query-in-parens": "( <container-condition> )|( <size-feature> )|style( <style-query> )|<general-enclosed>",
    "size-feature": "<mf-plain>|<mf-boolean>|<mf-range>",
    "style-feature": "<declaration>",
    "style-query": "<style-condition>|<style-feature>",
    "style-condition": "not <style-in-parens>|<style-in-parens> [[and <style-in-parens>]*|[or <style-in-parens>]*]",
    "style-in-parens": "( <style-condition> )|( <style-feature> )|<general-enclosed>",
    "-non-standard-display": "-ms-inline-flexbox|-ms-grid|-ms-inline-grid|-webkit-flex|-webkit-inline-flex|-webkit-box|-webkit-inline-box|-moz-inline-stack|-moz-box|-moz-inline-box",
    "inset-area": "[[left|center|right|span-left|span-right|x-start|x-end|span-x-start|span-x-end|x-self-start|x-self-end|span-x-self-start|span-x-self-end|span-all]||[top|center|bottom|span-top|span-bottom|y-start|y-end|span-y-start|span-y-end|y-self-start|y-self-end|span-y-self-start|span-y-self-end|span-all]|[block-start|center|block-end|span-block-start|span-block-end|span-all]||[inline-start|center|inline-end|span-inline-start|span-inline-end|span-all]|[self-block-start|self-block-end|span-self-block-start|span-self-block-end|span-all]||[self-inline-start|self-inline-end|span-self-inline-start|span-self-inline-end|span-all]|[start|center|end|span-start|span-end|span-all]{1,2}|[self-start|center|self-end|span-self-start|span-self-end|span-all]{1,2}]",
    "position-area": "[[left|center|right|span-left|span-right|x-start|x-end|span-x-start|span-x-end|x-self-start|x-self-end|span-x-self-start|span-x-self-end|span-all]||[top|center|bottom|span-top|span-bottom|y-start|y-end|span-y-start|span-y-end|y-self-start|y-self-end|span-y-self-start|span-y-self-end|span-all]|[block-start|center|block-end|span-block-start|span-block-end|span-all]||[inline-start|center|inline-end|span-inline-start|span-inline-end|span-all]|[self-block-start|center|self-block-end|span-self-block-start|span-self-block-end|span-all]||[self-inline-start|center|self-inline-end|span-self-inline-start|span-self-inline-end|span-all]|[start|center|end|span-start|span-end|span-all]{1,2}|[self-start|center|self-end|span-self-start|span-self-end|span-all]{1,2}]",
    "anchor()": "anchor( <anchor-element>?&&<anchor-side> , <length-percentage>? )",
    "anchor-side": "inside|outside|top|left|right|bottom|start|end|self-start|self-end|<percentage>|center",
    "anchor-size()": "anchor-size( [<anchor-element>||<anchor-size>]? , <length-percentage>? )",
    "anchor-size": "width|height|block|inline|self-block|self-inline",
    "anchor-element": "<dashed-ident>",
    "try-size": "most-width|most-height|most-block-size|most-inline-size",
    "try-tactic": "flip-block||flip-inline||flip-start",
    "font-variant-css2": "normal|small-caps",
    "font-width-css3": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded",
    "system-family-name": "caption|icon|menu|message-box|small-caption|status-bar"
  },
  "properties": {
    "--*": "<declaration-value>",
    "-ms-accelerator": "false|true",
    "-ms-block-progression": "tb|rl|bt|lr",
    "-ms-content-zoom-chaining": "none|chained",
    "-ms-content-zooming": "none|zoom",
    "-ms-content-zoom-limit": "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
    "-ms-content-zoom-limit-max": "<percentage>",
    "-ms-content-zoom-limit-min": "<percentage>",
    "-ms-content-zoom-snap": "<'-ms-content-zoom-snap-type'>||<'-ms-content-zoom-snap-points'>",
    "-ms-content-zoom-snap-points": "snapInterval( <percentage> , <percentage> )|snapList( <percentage># )",
    "-ms-content-zoom-snap-type": "none|proximity|mandatory",
    "-ms-filter": "<string>",
    "-ms-flow-from": "[none|<custom-ident>]#",
    "-ms-flow-into": "[none|<custom-ident>]#",
    "-ms-grid-columns": "none|<track-list>|<auto-track-list>",
    "-ms-grid-rows": "none|<track-list>|<auto-track-list>",
    "-ms-high-contrast-adjust": "auto|none",
    "-ms-hyphenate-limit-chars": "auto|<integer>{1,3}",
    "-ms-hyphenate-limit-lines": "no-limit|<integer>",
    "-ms-hyphenate-limit-zone": "<percentage>|<length>",
    "-ms-ime-align": "auto|after",
    "-ms-overflow-style": "auto|none|scrollbar|-ms-autohiding-scrollbar",
    "-ms-scrollbar-3dlight-color": "<color>",
    "-ms-scrollbar-arrow-color": "<color>",
    "-ms-scrollbar-base-color": "<color>",
    "-ms-scrollbar-darkshadow-color": "<color>",
    "-ms-scrollbar-face-color": "<color>",
    "-ms-scrollbar-highlight-color": "<color>",
    "-ms-scrollbar-shadow-color": "<color>",
    "-ms-scrollbar-track-color": "<color>",
    "-ms-scroll-chaining": "chained|none",
    "-ms-scroll-limit": "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
    "-ms-scroll-limit-x-max": "auto|<length>",
    "-ms-scroll-limit-x-min": "<length>",
    "-ms-scroll-limit-y-max": "auto|<length>",
    "-ms-scroll-limit-y-min": "<length>",
    "-ms-scroll-rails": "none|railed",
    "-ms-scroll-snap-points-x": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
    "-ms-scroll-snap-points-y": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
    "-ms-scroll-snap-type": "none|proximity|mandatory",
    "-ms-scroll-snap-x": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
    "-ms-scroll-snap-y": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
    "-ms-scroll-translation": "none|vertical-to-horizontal",
    "-ms-text-autospace": "none|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space",
    "-ms-touch-select": "grippers|none",
    "-ms-user-select": "none|element|text",
    "-ms-wrap-flow": "auto|both|start|end|maximum|clear",
    "-ms-wrap-margin": "<length>",
    "-ms-wrap-through": "wrap|none",
    "-moz-appearance": "none|button|button-arrow-down|button-arrow-next|button-arrow-previous|button-arrow-up|button-bevel|button-focus|caret|checkbox|checkbox-container|checkbox-label|checkmenuitem|dualbutton|groupbox|listbox|listitem|menuarrow|menubar|menucheckbox|menuimage|menuitem|menuitemtext|menulist|menulist-button|menulist-text|menulist-textfield|menupopup|menuradio|menuseparator|meterbar|meterchunk|progressbar|progressbar-vertical|progresschunk|progresschunk-vertical|radio|radio-container|radio-label|radiomenuitem|range|range-thumb|resizer|resizerpanel|scale-horizontal|scalethumbend|scalethumb-horizontal|scalethumbstart|scalethumbtick|scalethumb-vertical|scale-vertical|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|separator|sheet|spinner|spinner-downbutton|spinner-textfield|spinner-upbutton|splitter|statusbar|statusbarpanel|tab|tabpanel|tabpanels|tab-scroll-arrow-back|tab-scroll-arrow-forward|textfield|textfield-multiline|toolbar|toolbarbutton|toolbarbutton-dropdown|toolbargripper|toolbox|tooltip|treeheader|treeheadercell|treeheadersortarrow|treeitem|treeline|treetwisty|treetwistyopen|treeview|-moz-mac-unified-toolbar|-moz-win-borderless-glass|-moz-win-browsertabbar-toolbox|-moz-win-communicationstext|-moz-win-communications-toolbox|-moz-win-exclude-glass|-moz-win-glass|-moz-win-mediatext|-moz-win-media-toolbox|-moz-window-button-box|-moz-window-button-box-maximized|-moz-window-button-close|-moz-window-button-maximize|-moz-window-button-minimize|-moz-window-button-restore|-moz-window-frame-bottom|-moz-window-frame-left|-moz-window-frame-right|-moz-window-titlebar|-moz-window-titlebar-maximized",
    "-moz-binding": "<url>|none",
    "-moz-border-bottom-colors": "<color>+|none",
    "-moz-border-left-colors": "<color>+|none",
    "-moz-border-right-colors": "<color>+|none",
    "-moz-border-top-colors": "<color>+|none",
    "-moz-context-properties": "none|[fill|fill-opacity|stroke|stroke-opacity]#",
    "-moz-float-edge": "border-box|content-box|margin-box|padding-box",
    "-moz-force-broken-image-icon": "0|1",
    "-moz-image-region": "<shape>|auto",
    "-moz-orient": "inline|block|horizontal|vertical",
    "-moz-outline-radius": "<outline-radius>{1,4} [/ <outline-radius>{1,4}]?",
    "-moz-outline-radius-bottomleft": "<outline-radius>",
    "-moz-outline-radius-bottomright": "<outline-radius>",
    "-moz-outline-radius-topleft": "<outline-radius>",
    "-moz-outline-radius-topright": "<outline-radius>",
    "-moz-stack-sizing": "ignore|stretch-to-fit",
    "-moz-text-blink": "none|blink",
    "-moz-user-focus": "ignore|normal|select-after|select-before|select-menu|select-same|select-all|none",
    "-moz-user-input": "auto|none|enabled|disabled",
    "-moz-user-modify": "read-only|read-write|write-only",
    "-moz-window-dragging": "drag|no-drag",
    "-moz-window-shadow": "default|menu|tooltip|sheet|none",
    "-webkit-appearance": "none|button|button-bevel|caps-lock-indicator|caret|checkbox|default-button|inner-spin-button|listbox|listitem|media-controls-background|media-controls-fullscreen-background|media-current-time-display|media-enter-fullscreen-button|media-exit-fullscreen-button|media-fullscreen-button|media-mute-button|media-overlay-play-button|media-play-button|media-seek-back-button|media-seek-forward-button|media-slider|media-sliderthumb|media-time-remaining-display|media-toggle-closed-captions-button|media-volume-slider|media-volume-slider-container|media-volume-sliderthumb|menulist|menulist-button|menulist-text|menulist-textfield|meter|progress-bar|progress-bar-value|push-button|radio|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbargripper-horizontal|scrollbargripper-vertical|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|searchfield-cancel-button|searchfield-decoration|searchfield-results-button|searchfield-results-decoration|slider-horizontal|slider-vertical|sliderthumb-horizontal|sliderthumb-vertical|square-button|textarea|textfield|-apple-pay-button",
    "-webkit-border-before": "<'border-width'>||<'border-style'>||<color>",
    "-webkit-border-before-color": "<color>",
    "-webkit-border-before-style": "<'border-style'>",
    "-webkit-border-before-width": "<'border-width'>",
    "-webkit-box-reflect": "[above|below|right|left]? <length>? <image>?",
    "-webkit-line-clamp": "none|<integer>",
    "-webkit-mask": "[<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||[<box>|border|padding|content|text]||[<box>|border|padding|content]]#",
    "-webkit-mask-attachment": "<attachment>#",
    "-webkit-mask-clip": "[<box>|border|padding|content|text]#",
    "-webkit-mask-composite": "<composite-style>#",
    "-webkit-mask-image": "<mask-reference>#",
    "-webkit-mask-origin": "[<box>|border|padding|content]#",
    "-webkit-mask-position": "<position>#",
    "-webkit-mask-position-x": "[<length-percentage>|left|center|right]#",
    "-webkit-mask-position-y": "[<length-percentage>|top|center|bottom]#",
    "-webkit-mask-repeat": "<repeat-style>#",
    "-webkit-mask-repeat-x": "repeat|no-repeat|space|round",
    "-webkit-mask-repeat-y": "repeat|no-repeat|space|round",
    "-webkit-mask-size": "<bg-size>#",
    "-webkit-overflow-scrolling": "auto|touch",
    "-webkit-tap-highlight-color": "<color>",
    "-webkit-text-fill-color": "<color>",
    "-webkit-text-stroke": "<length>||<color>",
    "-webkit-text-stroke-color": "<color>",
    "-webkit-text-stroke-width": "<length>",
    "-webkit-touch-callout": "default|none",
    "-webkit-user-modify": "read-only|read-write|read-write-plaintext-only",
    "accent-color": "auto|<color>",
    "align-content": "normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>",
    "align-items": "normal|stretch|<baseline-position>|[<overflow-position>? <self-position>]",
    "align-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? <self-position>",
    "align-tracks": "[normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>]#",
    "all": "initial|inherit|unset|revert|revert-layer",
    "anchor-name": "none|<dashed-ident>#",
    "anchor-scope": "none|all|<dashed-ident>#",
    "animation": "<single-animation>#",
    "animation-composition": "<single-animation-composition>#",
    "animation-delay": "<time>#",
    "animation-direction": "<single-animation-direction>#",
    "animation-duration": "<time>#",
    "animation-fill-mode": "<single-animation-fill-mode>#",
    "animation-iteration-count": "<single-animation-iteration-count>#",
    "animation-name": "[none|<keyframes-name>]#",
    "animation-play-state": "<single-animation-play-state>#",
    "animation-range": "[<'animation-range-start'> <'animation-range-end'>?]#",
    "animation-range-end": "[normal|<length-percentage>|<timeline-range-name> <length-percentage>?]#",
    "animation-range-start": "[normal|<length-percentage>|<timeline-range-name> <length-percentage>?]#",
    "animation-timing-function": "<easing-function>#",
    "animation-timeline": "<single-animation-timeline>#",
    "appearance": "none|auto|textfield|menulist-button|<compat-auto>",
    "aspect-ratio": "auto||<ratio>",
    "azimuth": "<angle>|[[left-side|far-left|left|center-left|center|center-right|right|far-right|right-side]||behind]|leftwards|rightwards",
    "backdrop-filter": "none|<filter-function-list>",
    "backface-visibility": "visible|hidden",
    "background": "[<bg-layer> ,]* <final-bg-layer>",
    "background-attachment": "<attachment>#",
    "background-blend-mode": "<blend-mode>#",
    "background-clip": "<bg-clip>#",
    "background-color": "<color>",
    "background-image": "<bg-image>#",
    "background-origin": "<box>#",
    "background-position": "<bg-position>#",
    "background-position-x": "[center|[[left|right|x-start|x-end]? <length-percentage>?]!]#",
    "background-position-y": "[center|[[top|bottom|y-start|y-end]? <length-percentage>?]!]#",
    "background-repeat": "<repeat-style>#",
    "background-size": "<bg-size>#",
    "block-size": "<'width'>",
    "border": "<line-width>||<line-style>||<color>",
    "border-block": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-block-color": "<'border-top-color'>{1,2}",
    "border-block-style": "<'border-top-style'>",
    "border-block-width": "<'border-top-width'>",
    "border-block-end": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-block-end-color": "<'border-top-color'>",
    "border-block-end-style": "<'border-top-style'>",
    "border-block-end-width": "<'border-top-width'>",
    "border-block-start": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-block-start-color": "<'border-top-color'>",
    "border-block-start-style": "<'border-top-style'>",
    "border-block-start-width": "<'border-top-width'>",
    "border-bottom": "<line-width>||<line-style>||<color>",
    "border-bottom-color": "<'border-top-color'>",
    "border-bottom-left-radius": "<length-percentage>{1,2}",
    "border-bottom-right-radius": "<length-percentage>{1,2}",
    "border-bottom-style": "<line-style>",
    "border-bottom-width": "<line-width>",
    "border-collapse": "collapse|separate",
    "border-color": "<color>{1,4}",
    "border-end-end-radius": "<length-percentage>{1,2}",
    "border-end-start-radius": "<length-percentage>{1,2}",
    "border-image": "<'border-image-source'>||<'border-image-slice'> [/ <'border-image-width'>|/ <'border-image-width'>? / <'border-image-outset'>]?||<'border-image-repeat'>",
    "border-image-outset": "[<length>|<number>]{1,4}",
    "border-image-repeat": "[stretch|repeat|round|space]{1,2}",
    "border-image-slice": "<number-percentage>{1,4}&&fill?",
    "border-image-source": "none|<image>",
    "border-image-width": "[<length-percentage>|<number>|auto]{1,4}",
    "border-inline": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-inline-end": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-inline-color": "<'border-top-color'>{1,2}",
    "border-inline-style": "<'border-top-style'>",
    "border-inline-width": "<'border-top-width'>",
    "border-inline-end-color": "<'border-top-color'>",
    "border-inline-end-style": "<'border-top-style'>",
    "border-inline-end-width": "<'border-top-width'>",
    "border-inline-start": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-inline-start-color": "<'border-top-color'>",
    "border-inline-start-style": "<'border-top-style'>",
    "border-inline-start-width": "<'border-top-width'>",
    "border-left": "<line-width>||<line-style>||<color>",
    "border-left-color": "<color>",
    "border-left-style": "<line-style>",
    "border-left-width": "<line-width>",
    "border-radius": "<length-percentage>{1,4} [/ <length-percentage>{1,4}]?",
    "border-right": "<line-width>||<line-style>||<color>",
    "border-right-color": "<color>",
    "border-right-style": "<line-style>",
    "border-right-width": "<line-width>",
    "border-spacing": "<length> <length>?",
    "border-start-end-radius": "<length-percentage>{1,2}",
    "border-start-start-radius": "<length-percentage>{1,2}",
    "border-style": "<line-style>{1,4}",
    "border-top": "<line-width>||<line-style>||<color>",
    "border-top-color": "<color>",
    "border-top-left-radius": "<length-percentage>{1,2}",
    "border-top-right-radius": "<length-percentage>{1,2}",
    "border-top-style": "<line-style>",
    "border-top-width": "<line-width>",
    "border-width": "<line-width>{1,4}",
    "bottom": "<length>|<percentage>|auto",
    "box-align": "start|center|end|baseline|stretch",
    "box-decoration-break": "slice|clone",
    "box-direction": "normal|reverse|inherit",
    "box-flex": "<number>",
    "box-flex-group": "<integer>",
    "box-lines": "single|multiple",
    "box-ordinal-group": "<integer>",
    "box-orient": "horizontal|vertical|inline-axis|block-axis|inherit",
    "box-pack": "start|center|end|justify",
    "box-shadow": "none|<shadow>#",
    "box-sizing": "content-box|border-box",
    "break-after": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
    "break-before": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
    "break-inside": "auto|avoid|avoid-page|avoid-column|avoid-region",
    "caption-side": "top|bottom|block-start|block-end|inline-start|inline-end",
    "caret": "<'caret-color'>||<'caret-shape'>",
    "caret-color": "auto|<color>",
    "caret-shape": "auto|bar|block|underscore",
    "clear": "none|left|right|both|inline-start|inline-end",
    "clip": "<shape>|auto",
    "clip-path": "<clip-source>|[<basic-shape>||<geometry-box>]|none",
    "clip-rule": "nonzero|evenodd",
    "color": "<color>",
    "color-interpolation-filters": "auto|sRGB|linearRGB",
    "color-scheme": "normal|[light|dark|<custom-ident>]+&&only?",
    "column-count": "<integer>|auto",
    "column-fill": "auto|balance",
    "column-gap": "normal|<length-percentage>",
    "column-rule": "<'column-rule-width'>||<'column-rule-style'>||<'column-rule-color'>",
    "column-rule-color": "<color>",
    "column-rule-style": "<'border-style'>",
    "column-rule-width": "<'border-width'>",
    "column-span": "none|all",
    "column-width": "<length>|auto",
    "columns": "<'column-width'>||<'column-count'>",
    "contain": "none|strict|content|[[size||inline-size]||layout||style||paint]",
    "contain-intrinsic-size": "[auto? [none|<length>]]{1,2}",
    "contain-intrinsic-block-size": "auto? [none|<length>]",
    "contain-intrinsic-height": "auto? [none|<length>]",
    "contain-intrinsic-inline-size": "auto? [none|<length>]",
    "contain-intrinsic-width": "auto? [none|<length>]",
    "container": "<'container-name'> [/ <'container-type'>]?",
    "container-name": "none|<custom-ident>+",
    "container-type": "normal||[size|inline-size]",
    "content": "normal|none|[<content-replacement>|<content-list>] [/ [<string>|<counter>]+]?",
    "content-visibility": "visible|auto|hidden",
    "counter-increment": "[<counter-name> <integer>?]+|none",
    "counter-reset": "[<counter-name> <integer>?|<reversed-counter-name> <integer>?]+|none",
    "counter-set": "[<counter-name> <integer>?]+|none",
    "cursor": "[[<url> [<x> <y>]? ,]* [auto|default|none|context-menu|help|pointer|progress|wait|cell|crosshair|text|vertical-text|alias|copy|move|no-drop|not-allowed|e-resize|n-resize|ne-resize|nw-resize|s-resize|se-resize|sw-resize|w-resize|ew-resize|ns-resize|nesw-resize|nwse-resize|col-resize|row-resize|all-scroll|zoom-in|zoom-out|grab|grabbing|hand|-webkit-grab|-webkit-grabbing|-webkit-zoom-in|-webkit-zoom-out|-moz-grab|-moz-grabbing|-moz-zoom-in|-moz-zoom-out]]",
    "d": "none|path( <string> )",
    "cx": "<length>|<percentage>",
    "cy": "<length>|<percentage>",
    "direction": "ltr|rtl",
    "display": "[<display-outside>||<display-inside>]|<display-listitem>|<display-internal>|<display-box>|<display-legacy>|<-non-standard-display>",
    "dominant-baseline": "auto|use-script|no-change|reset-size|ideographic|alphabetic|hanging|mathematical|central|middle|text-after-edge|text-before-edge",
    "empty-cells": "show|hide",
    "field-sizing": "content|fixed",
    "fill": "<paint>",
    "fill-opacity": "<number-zero-one>",
    "fill-rule": "nonzero|evenodd",
    "filter": "none|<filter-function-list>|<-ms-filter-function-list>",
    "flex": "none|[<'flex-grow'> <'flex-shrink'>?||<'flex-basis'>]",
    "flex-basis": "content|<'width'>",
    "flex-direction": "row|row-reverse|column|column-reverse",
    "flex-flow": "<'flex-direction'>||<'flex-wrap'>",
    "flex-grow": "<number>",
    "flex-shrink": "<number>",
    "flex-wrap": "nowrap|wrap|wrap-reverse",
    "float": "left|right|none|inline-start|inline-end",
    "font": "[[<'font-style'>||<font-variant-css2>||<'font-weight'>||<font-width-css3>]? <'font-size'> [/ <'line-height'>]? <'font-family'>#]|<system-family-name>|<-non-standard-font>",
    "font-family": "[<family-name>|<generic-family>]#",
    "font-feature-settings": "normal|<feature-tag-value>#",
    "font-kerning": "auto|normal|none",
    "font-language-override": "normal|<string>",
    "font-optical-sizing": "auto|none",
    "font-palette": "normal|light|dark|<palette-identifier>",
    "font-variation-settings": "normal|[<string> <number>]#",
    "font-size": "<absolute-size>|<relative-size>|<length-percentage>",
    "font-size-adjust": "none|[ex-height|cap-height|ch-width|ic-width|ic-height]? [from-font|<number>]",
    "font-smooth": "auto|never|always|<absolute-size>|<length>",
    "font-stretch": "<font-stretch-absolute>",
    "font-style": "normal|italic|oblique <angle>?",
    "font-synthesis": "none|[weight||style||small-caps||position]",
    "font-synthesis-position": "auto|none",
    "font-synthesis-small-caps": "auto|none",
    "font-synthesis-style": "auto|none",
    "font-synthesis-weight": "auto|none",
    "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]",
    "font-variant-alternates": "normal|[stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )]",
    "font-variant-caps": "normal|small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps",
    "font-variant-east-asian": "normal|[<east-asian-variant-values>||<east-asian-width-values>||ruby]",
    "font-variant-emoji": "normal|text|emoji|unicode",
    "font-variant-ligatures": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>]",
    "font-variant-numeric": "normal|[<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero]",
    "font-variant-position": "normal|sub|super",
    "font-weight": "<font-weight-absolute>|bolder|lighter",
    "forced-color-adjust": "auto|none|preserve-parent-color",
    "gap": "<'row-gap'> <'column-gap'>?",
    "grid": "<'grid-template'>|<'grid-template-rows'> / [auto-flow&&dense?] <'grid-auto-columns'>?|[auto-flow&&dense?] <'grid-auto-rows'>? / <'grid-template-columns'>",
    "grid-area": "<grid-line> [/ <grid-line>]{0,3}",
    "grid-auto-columns": "<track-size>+",
    "grid-auto-flow": "[row|column]||dense",
    "grid-auto-rows": "<track-size>+",
    "grid-column": "<grid-line> [/ <grid-line>]?",
    "grid-column-end": "<grid-line>",
    "grid-column-gap": "<length-percentage>",
    "grid-column-start": "<grid-line>",
    "grid-gap": "<'grid-row-gap'> <'grid-column-gap'>?",
    "grid-row": "<grid-line> [/ <grid-line>]?",
    "grid-row-end": "<grid-line>",
    "grid-row-gap": "<length-percentage>",
    "grid-row-start": "<grid-line>",
    "grid-template": "none|[<'grid-template-rows'> / <'grid-template-columns'>]|[<line-names>? <string> <track-size>? <line-names>?]+ [/ <explicit-track-list>]?",
    "grid-template-areas": "none|<string>+",
    "grid-template-columns": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
    "grid-template-rows": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
    "hanging-punctuation": "none|[first||[force-end|allow-end]||last]",
    "height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
    "hyphenate-character": "auto|<string>",
    "hyphenate-limit-chars": "[auto|<integer>]{1,3}",
    "hyphens": "none|manual|auto",
    "image-orientation": "from-image|<angle>|[<angle>? flip]",
    "image-rendering": "auto|crisp-edges|pixelated|optimizeSpeed|optimizeQuality|<-non-standard-image-rendering>",
    "image-resolution": "[from-image||<resolution>]&&snap?",
    "ime-mode": "auto|normal|active|inactive|disabled",
    "initial-letter": "normal|[<number> <integer>?]",
    "initial-letter-align": "[auto|alphabetic|hanging|ideographic]",
    "inline-size": "<'width'>",
    "input-security": "auto|none",
    "inset": "<'top'>{1,4}",
    "inset-block": "<'top'>{1,2}",
    "inset-block-end": "<'top'>",
    "inset-block-start": "<'top'>",
    "inset-inline": "<'top'>{1,2}",
    "inset-inline-end": "<'top'>",
    "inset-inline-start": "<'top'>",
    "interpolate-size": "numeric-only|allow-keywords",
    "isolation": "auto|isolate",
    "justify-content": "normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]",
    "justify-items": "normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]|legacy|legacy&&[left|right|center]",
    "justify-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]",
    "justify-tracks": "[normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]]#",
    "left": "<length>|<percentage>|auto",
    "letter-spacing": "normal|<length-percentage>",
    "line-break": "auto|loose|normal|strict|anywhere",
    "line-clamp": "none|<integer>",
    "line-height": "normal|<number>|<length>|<percentage>",
    "line-height-step": "<length>",
    "list-style": "<'list-style-type'>||<'list-style-position'>||<'list-style-image'>",
    "list-style-image": "<image>|none",
    "list-style-position": "inside|outside",
    "list-style-type": "<counter-style>|<string>|none",
    "margin": "[<length>|<percentage>|auto]{1,4}",
    "margin-block": "<'margin-left'>{1,2}",
    "margin-block-end": "<'margin-left'>",
    "margin-block-start": "<'margin-left'>",
    "margin-bottom": "<length>|<percentage>|auto",
    "margin-inline": "<'margin-left'>{1,2}",
    "margin-inline-end": "<'margin-left'>",
    "margin-inline-start": "<'margin-left'>",
    "margin-left": "<length>|<percentage>|auto",
    "margin-right": "<length>|<percentage>|auto",
    "margin-top": "<length>|<percentage>|auto",
    "margin-trim": "none|in-flow|all",
    "marker": "none|<url>",
    "marker-end": "none|<url>",
    "marker-mid": "none|<url>",
    "marker-start": "none|<url>",
    "mask": "<mask-layer>#",
    "mask-border": "<'mask-border-source'>||<'mask-border-slice'> [/ <'mask-border-width'>? [/ <'mask-border-outset'>]?]?||<'mask-border-repeat'>||<'mask-border-mode'>",
    "mask-border-mode": "luminance|alpha",
    "mask-border-outset": "[<length>|<number>]{1,4}",
    "mask-border-repeat": "[stretch|repeat|round|space]{1,2}",
    "mask-border-slice": "<number-percentage>{1,4} fill?",
    "mask-border-source": "none|<image>",
    "mask-border-width": "[<length-percentage>|<number>|auto]{1,4}",
    "mask-clip": "[<geometry-box>|no-clip]#",
    "mask-composite": "<compositing-operator>#",
    "mask-image": "<mask-reference>#",
    "mask-mode": "<masking-mode>#",
    "mask-origin": "<geometry-box>#",
    "mask-position": "<position>#",
    "mask-repeat": "<repeat-style>#",
    "mask-size": "<bg-size>#",
    "mask-type": "luminance|alpha",
    "masonry-auto-flow": "[pack|next]||[definite-first|ordered]",
    "math-depth": "auto-add|add( <integer> )|<integer>",
    "math-shift": "normal|compact",
    "math-style": "normal|compact",
    "max-block-size": "<'max-width'>",
    "max-height": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
    "max-inline-size": "<'max-width'>",
    "max-lines": "none|<integer>",
    "max-width": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
    "min-block-size": "<'min-width'>",
    "min-height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
    "min-inline-size": "<'min-width'>",
    "min-width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
    "mix-blend-mode": "<blend-mode>|plus-lighter",
    "object-fit": "fill|contain|cover|none|scale-down",
    "object-position": "<position>",
    "offset": "[<'offset-position'>? [<'offset-path'> [<'offset-distance'>||<'offset-rotate'>]?]?]! [/ <'offset-anchor'>]?",
    "offset-anchor": "auto|<position>",
    "offset-distance": "<length-percentage>",
    "offset-path": "none|<offset-path>||<coord-box>",
    "offset-position": "normal|auto|<position>",
    "offset-rotate": "[auto|reverse]||<angle>",
    "opacity": "<alpha-value>",
    "order": "<integer>",
    "orphans": "<integer>",
    "outline": "[<'outline-width'>||<'outline-style'>||<'outline-color'>]",
    "outline-color": "auto|<color>",
    "outline-offset": "<length>",
    "outline-style": "auto|<'border-style'>",
    "outline-width": "<line-width>",
    "overflow": "[visible|hidden|clip|scroll|auto]{1,2}|<-non-standard-overflow>",
    "overflow-anchor": "auto|none",
    "overflow-block": "visible|hidden|clip|scroll|auto",
    "overflow-clip-box": "padding-box|content-box",
    "overflow-clip-margin": "<visual-box>||<length [0,]>",
    "overflow-inline": "visible|hidden|clip|scroll|auto",
    "overflow-wrap": "normal|break-word|anywhere",
    "overflow-x": "visible|hidden|clip|scroll|auto",
    "overflow-y": "visible|hidden|clip|scroll|auto",
    "overlay": "none|auto",
    "overscroll-behavior": "[contain|none|auto]{1,2}",
    "overscroll-behavior-block": "contain|none|auto",
    "overscroll-behavior-inline": "contain|none|auto",
    "overscroll-behavior-x": "contain|none|auto",
    "overscroll-behavior-y": "contain|none|auto",
    "padding": "[<length>|<percentage>]{1,4}",
    "padding-block": "<'padding-left'>{1,2}",
    "padding-block-end": "<'padding-left'>",
    "padding-block-start": "<'padding-left'>",
    "padding-bottom": "<length>|<percentage>",
    "padding-inline": "<'padding-left'>{1,2}",
    "padding-inline-end": "<'padding-left'>",
    "padding-inline-start": "<'padding-left'>",
    "padding-left": "<length>|<percentage>",
    "padding-right": "<length>|<percentage>",
    "padding-top": "<length>|<percentage>",
    "page": "auto|<custom-ident>",
    "page-break-after": "auto|always|avoid|left|right|recto|verso",
    "page-break-before": "auto|always|avoid|left|right|recto|verso",
    "page-break-inside": "auto|avoid",
    "paint-order": "normal|[fill||stroke||markers]",
    "perspective": "none|<length>",
    "perspective-origin": "<position>",
    "place-content": "<'align-content'> <'justify-content'>?",
    "place-items": "<'align-items'> <'justify-items'>?",
    "place-self": "<'align-self'> <'justify-self'>?",
    "pointer-events": "auto|none|visiblePainted|visibleFill|visibleStroke|visible|painted|fill|stroke|all|inherit",
    "position": "static|relative|absolute|sticky|fixed|-webkit-sticky",
    "position-anchor": "auto|<anchor-name>",
    "position-area": "none|<position-area>",
    "position-try": "<'position-try-order'>? <'position-try-fallbacks'>",
    "position-try-fallbacks": "none|[[<dashed-ident>||<try-tactic>]|<'position-area'>]#",
    "position-try-order": "normal|<try-size>",
    "position-visibility": "always|[anchors-valid||anchors-visible||no-overflow]",
    "print-color-adjust": "economy|exact",
    "quotes": "none|auto|[<string> <string>]+",
    "r": "<length>|<percentage>",
    "resize": "none|both|horizontal|vertical|block|inline",
    "right": "<length>|<percentage>|auto",
    "rotate": "none|<angle>|[x|y|z|<number>{3}]&&<angle>",
    "row-gap": "normal|<length-percentage>",
    "ruby-align": "start|center|space-between|space-around",
    "ruby-merge": "separate|collapse|auto",
    "ruby-position": "[alternate||[over|under]]|inter-character",
    "rx": "<length>|<percentage>",
    "ry": "<length>|<percentage>",
    "scale": "none|[<number>|<percentage>]{1,3}",
    "scrollbar-color": "auto|<color>{2}",
    "scrollbar-gutter": "auto|stable&&both-edges?",
    "scrollbar-width": "auto|thin|none",
    "scroll-behavior": "auto|smooth",
    "scroll-margin": "<length>{1,4}",
    "scroll-margin-block": "<length>{1,2}",
    "scroll-margin-block-start": "<length>",
    "scroll-margin-block-end": "<length>",
    "scroll-margin-bottom": "<length>",
    "scroll-margin-inline": "<length>{1,2}",
    "scroll-margin-inline-start": "<length>",
    "scroll-margin-inline-end": "<length>",
    "scroll-margin-left": "<length>",
    "scroll-margin-right": "<length>",
    "scroll-margin-top": "<length>",
    "scroll-padding": "[auto|<length-percentage>]{1,4}",
    "scroll-padding-block": "[auto|<length-percentage>]{1,2}",
    "scroll-padding-block-start": "auto|<length-percentage>",
    "scroll-padding-block-end": "auto|<length-percentage>",
    "scroll-padding-bottom": "auto|<length-percentage>",
    "scroll-padding-inline": "[auto|<length-percentage>]{1,2}",
    "scroll-padding-inline-start": "auto|<length-percentage>",
    "scroll-padding-inline-end": "auto|<length-percentage>",
    "scroll-padding-left": "auto|<length-percentage>",
    "scroll-padding-right": "auto|<length-percentage>",
    "scroll-padding-top": "auto|<length-percentage>",
    "scroll-snap-align": "[none|start|end|center]{1,2}",
    "scroll-snap-coordinate": "none|<position>#",
    "scroll-snap-destination": "<position>",
    "scroll-snap-points-x": "none|repeat( <length-percentage> )",
    "scroll-snap-points-y": "none|repeat( <length-percentage> )",
    "scroll-snap-stop": "normal|always",
    "scroll-snap-type": "none|[x|y|block|inline|both] [mandatory|proximity]?",
    "scroll-snap-type-x": "none|mandatory|proximity",
    "scroll-snap-type-y": "none|mandatory|proximity",
    "scroll-timeline": "[<'scroll-timeline-name'>||<'scroll-timeline-axis'>]#",
    "scroll-timeline-axis": "[block|inline|x|y]#",
    "scroll-timeline-name": "[none|<dashed-ident>]#",
    "shape-image-threshold": "<alpha-value>",
    "shape-margin": "<length-percentage>",
    "shape-outside": "none|[<shape-box>||<basic-shape>]|<image>",
    "shape-rendering": "auto|optimizeSpeed|crispEdges|geometricPrecision",
    "stroke": "<paint>",
    "stroke-dasharray": "none|[<svg-length>+]#",
    "stroke-dashoffset": "<svg-length>",
    "stroke-linecap": "butt|round|square",
    "stroke-linejoin": "miter|round|bevel",
    "stroke-miterlimit": "<number-one-or-greater>",
    "stroke-opacity": "<'opacity'>",
    "stroke-width": "<svg-length>",
    "tab-size": "<integer>|<length>",
    "table-layout": "auto|fixed",
    "text-align": "start|end|left|right|center|justify|match-parent",
    "text-align-last": "auto|start|end|left|right|center|justify",
    "text-anchor": "start|middle|end",
    "text-combine-upright": "none|all|[digits <integer>?]",
    "text-decoration": "<'text-decoration-line'>||<'text-decoration-style'>||<'text-decoration-color'>||<'text-decoration-thickness'>",
    "text-decoration-color": "<color>",
    "text-decoration-line": "none|[underline||overline||line-through||blink]|spelling-error|grammar-error",
    "text-decoration-skip": "none|[objects||[spaces|[leading-spaces||trailing-spaces]]||edges||box-decoration]",
    "text-decoration-skip-ink": "auto|all|none",
    "text-decoration-style": "solid|double|dotted|dashed|wavy",
    "text-decoration-thickness": "auto|from-font|<length>|<percentage>",
    "text-emphasis": "<'text-emphasis-style'>||<'text-emphasis-color'>",
    "text-emphasis-color": "<color>",
    "text-emphasis-position": "auto|[over|under]&&[right|left]?",
    "text-emphasis-style": "none|[[filled|open]||[dot|circle|double-circle|triangle|sesame]]|<string>",
    "text-indent": "<length-percentage>&&hanging?&&each-line?",
    "text-justify": "auto|inter-character|inter-word|none",
    "text-orientation": "mixed|upright|sideways",
    "text-overflow": "[clip|ellipsis|<string>]{1,2}",
    "text-rendering": "auto|optimizeSpeed|optimizeLegibility|geometricPrecision",
    "text-shadow": "none|<shadow-t>#",
    "text-size-adjust": "none|auto|<percentage>",
    "text-spacing-trim": "space-all|normal|space-first|trim-start|trim-both|trim-all|auto",
    "text-transform": "none|capitalize|uppercase|lowercase|full-width|full-size-kana",
    "text-underline-offset": "auto|<length>|<percentage>",
    "text-underline-position": "auto|from-font|[under||[left|right]]",
    "text-wrap": "<'text-wrap-mode'>||<'text-wrap-style'>",
    "text-wrap-mode": "auto|wrap|nowrap",
    "text-wrap-style": "auto|balance|stable|pretty",
    "timeline-scope": "none|<dashed-ident>#",
    "top": "<length>|<percentage>|auto",
    "touch-action": "auto|none|[[pan-x|pan-left|pan-right]||[pan-y|pan-up|pan-down]||pinch-zoom]|manipulation",
    "transform": "none|<transform-list>",
    "transform-box": "content-box|border-box|fill-box|stroke-box|view-box",
    "transform-origin": "[<length-percentage>|left|center|right|top|bottom]|[[<length-percentage>|left|center|right]&&[<length-percentage>|top|center|bottom]] <length>?",
    "transform-style": "flat|preserve-3d",
    "transition": "<single-transition>#",
    "transition-behavior": "<transition-behavior-value>#",
    "transition-delay": "<time>#",
    "transition-duration": "<time>#",
    "transition-property": "none|<single-transition-property>#",
    "transition-timing-function": "<easing-function>#",
    "translate": "none|<length-percentage> [<length-percentage> <length>?]?",
    "unicode-bidi": "normal|embed|isolate|bidi-override|isolate-override|plaintext|-moz-isolate|-moz-isolate-override|-moz-plaintext|-webkit-isolate|-webkit-isolate-override|-webkit-plaintext",
    "user-select": "auto|text|none|contain|all",
    "vector-effect": "none|non-scaling-stroke|non-scaling-size|non-rotation|fixed-position",
    "vertical-align": "baseline|sub|super|text-top|text-bottom|middle|top|bottom|<percentage>|<length>",
    "view-timeline": "[<'view-timeline-name'> <'view-timeline-axis'>?]#",
    "view-timeline-axis": "[block|inline|x|y]#",
    "view-timeline-inset": "[[auto|<length-percentage>]{1,2}]#",
    "view-timeline-name": "none|<dashed-ident>#",
    "view-transition-name": "none|<custom-ident>",
    "visibility": "visible|hidden|collapse",
    "white-space": "normal|pre|nowrap|pre-wrap|pre-line|break-spaces|[<'white-space-collapse'>||<'text-wrap'>||<'white-space-trim'>]",
    "white-space-collapse": "collapse|discard|preserve|preserve-breaks|preserve-spaces|break-spaces",
    "widows": "<integer>",
    "width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
    "will-change": "auto|<animateable-feature>#",
    "word-break": "normal|break-all|keep-all|break-word|auto-phrase",
    "word-spacing": "normal|<length>",
    "word-wrap": "normal|break-word",
    "writing-mode": "horizontal-tb|vertical-rl|vertical-lr|sideways-rl|sideways-lr|<svg-writing-mode>",
    "x": "<length>|<percentage>",
    "y": "<length>|<percentage>",
    "z-index": "auto|<integer>",
    "zoom": "normal|reset|<number>|<percentage>",
    "-moz-background-clip": "padding|border",
    "-moz-border-radius-bottomleft": "<'border-bottom-left-radius'>",
    "-moz-border-radius-bottomright": "<'border-bottom-right-radius'>",
    "-moz-border-radius-topleft": "<'border-top-left-radius'>",
    "-moz-border-radius-topright": "<'border-bottom-right-radius'>",
    "-moz-control-character-visibility": "visible|hidden",
    "-moz-osx-font-smoothing": "auto|grayscale",
    "-moz-user-select": "none|text|all|-moz-none",
    "-ms-flex-align": "start|end|center|baseline|stretch",
    "-ms-flex-item-align": "auto|start|end|center|baseline|stretch",
    "-ms-flex-line-pack": "start|end|center|justify|distribute|stretch",
    "-ms-flex-negative": "<'flex-shrink'>",
    "-ms-flex-pack": "start|end|center|justify|distribute",
    "-ms-flex-order": "<integer>",
    "-ms-flex-positive": "<'flex-grow'>",
    "-ms-flex-preferred-size": "<'flex-basis'>",
    "-ms-interpolation-mode": "nearest-neighbor|bicubic",
    "-ms-grid-column-align": "start|end|center|stretch",
    "-ms-grid-row-align": "start|end|center|stretch",
    "-ms-hyphenate-limit-last": "none|always|column|page|spread",
    "-webkit-background-clip": "[<box>|border|padding|content|text]#",
    "-webkit-column-break-after": "always|auto|avoid",
    "-webkit-column-break-before": "always|auto|avoid",
    "-webkit-column-break-inside": "always|auto|avoid",
    "-webkit-font-smoothing": "auto|none|antialiased|subpixel-antialiased",
    "-webkit-mask-box-image": "[<url>|<gradient>|none] [<length-percentage>{4} <-webkit-mask-box-repeat>{2}]?",
    "-webkit-print-color-adjust": "economy|exact",
    "-webkit-text-security": "none|circle|disc|square",
    "-webkit-user-drag": "none|element|auto",
    "-webkit-user-select": "auto|none|text|all",
    "alignment-baseline": "auto|baseline|before-edge|text-before-edge|middle|central|after-edge|text-after-edge|ideographic|alphabetic|hanging|mathematical",
    "baseline-shift": "baseline|sub|super|<svg-length>",
    "behavior": "<url>+",
    "cue": "<'cue-before'> <'cue-after'>?",
    "cue-after": "<url> <decibel>?|none",
    "cue-before": "<url> <decibel>?|none",
    "glyph-orientation-horizontal": "<angle>",
    "glyph-orientation-vertical": "<angle>",
    "kerning": "auto|<svg-length>",
    "pause": "<'pause-before'> <'pause-after'>?",
    "pause-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "pause-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "rest": "<'rest-before'> <'rest-after'>?",
    "rest-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "rest-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "src": "[<url> [format( <string># )]?|local( <family-name> )]#",
    "speak": "auto|never|always",
    "speak-as": "normal|spell-out||digits||[literal-punctuation|no-punctuation]",
    "unicode-range": "<urange>#",
    "voice-balance": "<number>|left|center|right|leftwards|rightwards",
    "voice-duration": "auto|<time>",
    "voice-family": "[[<family-name>|<generic-voice>] ,]* [<family-name>|<generic-voice>]|preserve",
    "voice-pitch": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
    "voice-range": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
    "voice-rate": "[normal|x-slow|slow|medium|fast|x-fast]||<percentage>",
    "voice-stress": "normal|strong|moderate|none|reduced",
    "voice-volume": "silent|[[x-soft|soft|medium|loud|x-loud]||<decibel>]",
    "white-space-trim": "none|discard-before||discard-after||discard-inner"
  },
  "atrules": {
    "charset": {
      "prelude": "<string>",
      "descriptors": null
    },
    "counter-style": {
      "prelude": "<counter-style-name>",
      "descriptors": {
        "additive-symbols": "[<integer>&&<symbol>]#",
        "fallback": "<counter-style-name>",
        "negative": "<symbol> <symbol>?",
        "pad": "<integer>&&<symbol>",
        "prefix": "<symbol>",
        "range": "[[<integer>|infinite]{2}]#|auto",
        "speak-as": "auto|bullets|numbers|words|spell-out|<counter-style-name>",
        "suffix": "<symbol>",
        "symbols": "<symbol>+",
        "system": "cyclic|numeric|alphabetic|symbolic|additive|[fixed <integer>?]|[extends <counter-style-name>]"
      }
    },
    "document": {
      "prelude": "[<url>|url-prefix( <string> )|domain( <string> )|media-document( <string> )|regexp( <string> )]#",
      "descriptors": null
    },
    "font-palette-values": {
      "prelude": "<dashed-ident>",
      "descriptors": {
        "base-palette": "light|dark|<integer [0,]>",
        "font-family": "<family-name>#",
        "override-colors": "[<integer [0,]> <absolute-color-base>]#"
      }
    },
    "font-face": {
      "prelude": null,
      "descriptors": {
        "ascent-override": "normal|<percentage>",
        "descent-override": "normal|<percentage>",
        "font-display": "[auto|block|swap|fallback|optional]",
        "font-family": "<family-name>",
        "font-feature-settings": "normal|<feature-tag-value>#",
        "font-variation-settings": "normal|[<string> <number>]#",
        "font-stretch": "<font-stretch-absolute>{1,2}",
        "font-style": "normal|italic|oblique <angle>{0,2}",
        "font-weight": "<font-weight-absolute>{1,2}",
        "line-gap-override": "normal|<percentage>",
        "size-adjust": "<percentage>",
        "src": "[<url> [format( <string># )]?|local( <family-name> )]#",
        "unicode-range": "<urange>#"
      }
    },
    "font-feature-values": {
      "prelude": "<family-name>#",
      "descriptors": null
    },
    "import": {
      "prelude": "[<string>|<url>] [layer|layer( <layer-name> )]? [supports( [<supports-condition>|<declaration>] )]? <media-query-list>?",
      "descriptors": null
    },
    "keyframes": {
      "prelude": "<keyframes-name>",
      "descriptors": null
    },
    "layer": {
      "prelude": "[<layer-name>#|<layer-name>?]",
      "descriptors": null
    },
    "media": {
      "prelude": "<media-query-list>",
      "descriptors": null
    },
    "namespace": {
      "prelude": "<namespace-prefix>? [<string>|<url>]",
      "descriptors": null
    },
    "page": {
      "prelude": "<page-selector-list>",
      "descriptors": {
        "bleed": "auto|<length>",
        "marks": "none|[crop||cross]",
        "page-orientation": "upright|rotate-left|rotate-right",
        "size": "<length>{1,2}|auto|[<page-size>||[portrait|landscape]]"
      }
    },
    "position-try": {
      "prelude": "<dashed-ident>",
      "descriptors": {
        "top": "<'top'>",
        "left": "<'left'>",
        "bottom": "<'bottom'>",
        "right": "<'right'>",
        "inset-block-start": "<'inset-block-start'>",
        "inset-block-end": "<'inset-block-end'>",
        "inset-inline-start": "<'inset-inline-start'>",
        "inset-inline-end": "<'inset-inline-end'>",
        "inset-block": "<'inset-block'>",
        "inset-inline": "<'inset-inline'>",
        "inset": "<'inset'>",
        "margin-top": "<'margin-top'>",
        "margin-left": "<'margin-left'>",
        "margin-bottom": "<'margin-bottom'>",
        "margin-right": "<'margin-right'>",
        "margin-block-start": "<'margin-block-start'>",
        "margin-block-end": "<'margin-block-end'>",
        "margin-inline-start": "<'margin-inline-start'>",
        "margin-inline-end": "<'margin-inline-end'>",
        "margin": "<'margin'>",
        "margin-block": "<'margin-block'>",
        "margin-inline": "<'margin-inline'>",
        "width": "<'width'>",
        "height": "<'height'>",
        "min-width": "<'min-width'>",
        "min-height": "<'min-height'>",
        "max-width": "<'max-width'>",
        "max-height": "<'max-height'>",
        "block-size": "<'block-size'>",
        "inline-size": "<'inline-size'>",
        "min-block-size": "<'min-block-size'>",
        "min-inline-size": "<'min-inline-size'>",
        "max-block-size": "<'max-block-size'>",
        "max-inline-size": "<'max-inline-size'>",
        "align-self": "<'align-self'>|anchor-center",
        "justify-self": "<'justify-self'>|anchor-center"
      }
    },
    "property": {
      "prelude": "<custom-property-name>",
      "descriptors": {
        "syntax": "<string>",
        "inherits": "true|false",
        "initial-value": "<declaration-value>?"
      }
    },
    "scope": {
      "prelude": "[( <scope-start> )]? [to ( <scope-end> )]?",
      "descriptors": null
    },
    "starting-style": {
      "prelude": null,
      "descriptors": null
    },
    "supports": {
      "prelude": "<supports-condition>",
      "descriptors": null
    },
    "container": {
      "prelude": "[<container-name>]? <container-condition>",
      "descriptors": null
    },
    "nest": {
      "prelude": "<complex-selector-list>",
      "descriptors": null
    }
  }
};

// node_modules/css-tree/lib/syntax/node/index.js
var node_exports = {};
__export(node_exports, {
  AnPlusB: () => AnPlusB_exports,
  Atrule: () => Atrule_exports,
  AtrulePrelude: () => AtrulePrelude_exports,
  AttributeSelector: () => AttributeSelector_exports,
  Block: () => Block_exports,
  Brackets: () => Brackets_exports,
  CDC: () => CDC_exports,
  CDO: () => CDO_exports,
  ClassSelector: () => ClassSelector_exports,
  Combinator: () => Combinator_exports,
  Comment: () => Comment_exports,
  Condition: () => Condition_exports,
  Declaration: () => Declaration_exports,
  DeclarationList: () => DeclarationList_exports,
  Dimension: () => Dimension_exports,
  Feature: () => Feature_exports,
  FeatureFunction: () => FeatureFunction_exports,
  FeatureRange: () => FeatureRange_exports,
  Function: () => Function_exports,
  GeneralEnclosed: () => GeneralEnclosed_exports,
  Hash: () => Hash_exports,
  IdSelector: () => IdSelector_exports,
  Identifier: () => Identifier_exports,
  Layer: () => Layer_exports,
  LayerList: () => LayerList_exports,
  MediaQuery: () => MediaQuery_exports,
  MediaQueryList: () => MediaQueryList_exports,
  NestingSelector: () => NestingSelector_exports,
  Nth: () => Nth_exports,
  Number: () => Number_exports,
  Operator: () => Operator_exports,
  Parentheses: () => Parentheses_exports,
  Percentage: () => Percentage_exports,
  PseudoClassSelector: () => PseudoClassSelector_exports,
  PseudoElementSelector: () => PseudoElementSelector_exports,
  Ratio: () => Ratio_exports,
  Raw: () => Raw_exports,
  Rule: () => Rule_exports,
  Scope: () => Scope_exports,
  Selector: () => Selector_exports,
  SelectorList: () => SelectorList_exports,
  String: () => String_exports,
  StyleSheet: () => StyleSheet_exports,
  SupportsDeclaration: () => SupportsDeclaration_exports,
  TypeSelector: () => TypeSelector_exports,
  UnicodeRange: () => UnicodeRange_exports,
  Url: () => Url_exports,
  Value: () => Value_exports,
  WhiteSpace: () => WhiteSpace_exports
});

// node_modules/css-tree/lib/syntax/node/AnPlusB.js
var AnPlusB_exports = {};
__export(AnPlusB_exports, {
  generate: () => generate2,
  name: () => name,
  parse: () => parse3,
  structure: () => structure
});
var PLUSSIGN5 = 43;
var HYPHENMINUS5 = 45;
var N5 = 110;
var DISALLOW_SIGN2 = true;
var ALLOW_SIGN2 = false;
function checkInteger2(offset, disallowSign) {
  let pos = this.tokenStart + offset;
  const code2 = this.charCodeAt(pos);
  if (code2 === PLUSSIGN5 || code2 === HYPHENMINUS5) {
    if (disallowSign) {
      this.error("Number sign is not allowed");
    }
    pos++;
  }
  for (; pos < this.tokenEnd; pos++) {
    if (!isDigit(this.charCodeAt(pos))) {
      this.error("Integer is expected", pos);
    }
  }
}
function checkTokenIsInteger(disallowSign) {
  return checkInteger2.call(this, 0, disallowSign);
}
function expectCharCode(offset, code2) {
  if (!this.cmpChar(this.tokenStart + offset, code2)) {
    let msg = "";
    switch (code2) {
      case N5:
        msg = "N is expected";
        break;
      case HYPHENMINUS5:
        msg = "HyphenMinus is expected";
        break;
    }
    this.error(msg, this.tokenStart + offset);
  }
}
function consumeB2() {
  let offset = 0;
  let sign = 0;
  let type = this.tokenType;
  while (type === WhiteSpace || type === Comment) {
    type = this.lookupType(++offset);
  }
  if (type !== Number2) {
    if (this.isDelim(PLUSSIGN5, offset) || this.isDelim(HYPHENMINUS5, offset)) {
      sign = this.isDelim(PLUSSIGN5, offset) ? PLUSSIGN5 : HYPHENMINUS5;
      do {
        type = this.lookupType(++offset);
      } while (type === WhiteSpace || type === Comment);
      if (type !== Number2) {
        this.skip(offset);
        checkTokenIsInteger.call(this, DISALLOW_SIGN2);
      }
    } else {
      return null;
    }
  }
  if (offset > 0) {
    this.skip(offset);
  }
  if (sign === 0) {
    type = this.charCodeAt(this.tokenStart);
    if (type !== PLUSSIGN5 && type !== HYPHENMINUS5) {
      this.error("Number sign is expected");
    }
  }
  checkTokenIsInteger.call(this, sign !== 0);
  return sign === HYPHENMINUS5 ? "-" + this.consume(Number2) : this.consume(Number2);
}
var name = "AnPlusB";
var structure = {
  a: [String, null],
  b: [String, null]
};
function parse3() {
  const start = this.tokenStart;
  let a = null;
  let b = null;
  if (this.tokenType === Number2) {
    checkTokenIsInteger.call(this, ALLOW_SIGN2);
    b = this.consume(Number2);
  } else if (this.tokenType === Ident && this.cmpChar(this.tokenStart, HYPHENMINUS5)) {
    a = "-1";
    expectCharCode.call(this, 1, N5);
    switch (this.tokenEnd - this.tokenStart) {
      case 2:
        this.next();
        b = consumeB2.call(this);
        break;
      case 3:
        expectCharCode.call(this, 2, HYPHENMINUS5);
        this.next();
        this.skipSC();
        checkTokenIsInteger.call(this, DISALLOW_SIGN2);
        b = "-" + this.consume(Number2);
        break;
      default:
        expectCharCode.call(this, 2, HYPHENMINUS5);
        checkInteger2.call(this, 3, DISALLOW_SIGN2);
        this.next();
        b = this.substrToCursor(start + 2);
    }
  } else if (this.tokenType === Ident || this.isDelim(PLUSSIGN5) && this.lookupType(1) === Ident) {
    let sign = 0;
    a = "1";
    if (this.isDelim(PLUSSIGN5)) {
      sign = 1;
      this.next();
    }
    expectCharCode.call(this, 0, N5);
    switch (this.tokenEnd - this.tokenStart) {
      case 1:
        this.next();
        b = consumeB2.call(this);
        break;
      case 2:
        expectCharCode.call(this, 1, HYPHENMINUS5);
        this.next();
        this.skipSC();
        checkTokenIsInteger.call(this, DISALLOW_SIGN2);
        b = "-" + this.consume(Number2);
        break;
      default:
        expectCharCode.call(this, 1, HYPHENMINUS5);
        checkInteger2.call(this, 2, DISALLOW_SIGN2);
        this.next();
        b = this.substrToCursor(start + sign + 1);
    }
  } else if (this.tokenType === Dimension) {
    const code2 = this.charCodeAt(this.tokenStart);
    const sign = code2 === PLUSSIGN5 || code2 === HYPHENMINUS5;
    let i = this.tokenStart + sign;
    for (; i < this.tokenEnd; i++) {
      if (!isDigit(this.charCodeAt(i))) {
        break;
      }
    }
    if (i === this.tokenStart + sign) {
      this.error("Integer is expected", this.tokenStart + sign);
    }
    expectCharCode.call(this, i - this.tokenStart, N5);
    a = this.substring(start, i);
    if (i + 1 === this.tokenEnd) {
      this.next();
      b = consumeB2.call(this);
    } else {
      expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS5);
      if (i + 2 === this.tokenEnd) {
        this.next();
        this.skipSC();
        checkTokenIsInteger.call(this, DISALLOW_SIGN2);
        b = "-" + this.consume(Number2);
      } else {
        checkInteger2.call(this, i - this.tokenStart + 2, DISALLOW_SIGN2);
        this.next();
        b = this.substrToCursor(i + 1);
      }
    }
  } else {
    this.error();
  }
  if (a !== null && a.charCodeAt(0) === PLUSSIGN5) {
    a = a.substr(1);
  }
  if (b !== null && b.charCodeAt(0) === PLUSSIGN5) {
    b = b.substr(1);
  }
  return {
    type: "AnPlusB",
    loc: this.getLocation(start, this.tokenStart),
    a,
    b
  };
}
function generate2(node) {
  if (node.a) {
    const a = node.a === "+1" && "n" || node.a === "1" && "n" || node.a === "-1" && "-n" || node.a + "n";
    if (node.b) {
      const b = node.b[0] === "-" || node.b[0] === "+" ? node.b : "+" + node.b;
      this.tokenize(a + b);
    } else {
      this.tokenize(a);
    }
  } else {
    this.tokenize(node.b);
  }
}

// node_modules/css-tree/lib/syntax/node/Atrule.js
var Atrule_exports = {};
__export(Atrule_exports, {
  generate: () => generate3,
  name: () => name2,
  parse: () => parse4,
  structure: () => structure2,
  walkContext: () => walkContext
});
function consumeRaw() {
  return this.Raw(this.consumeUntilLeftCurlyBracketOrSemicolon, true);
}
function isDeclarationBlockAtrule() {
  for (let offset = 1, type; type = this.lookupType(offset); offset++) {
    if (type === RightCurlyBracket) {
      return true;
    }
    if (type === LeftCurlyBracket || type === AtKeyword) {
      return false;
    }
  }
  return false;
}
var name2 = "Atrule";
var walkContext = "atrule";
var structure2 = {
  name: String,
  prelude: ["AtrulePrelude", "Raw", null],
  block: ["Block", null]
};
function parse4(isDeclaration = false) {
  const start = this.tokenStart;
  let name50;
  let nameLowerCase;
  let prelude = null;
  let block = null;
  this.eat(AtKeyword);
  name50 = this.substrToCursor(start + 1);
  nameLowerCase = name50.toLowerCase();
  this.skipSC();
  if (this.eof === false && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon) {
    if (this.parseAtrulePrelude) {
      prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name50, isDeclaration), consumeRaw);
    } else {
      prelude = consumeRaw.call(this, this.tokenIndex);
    }
    this.skipSC();
  }
  switch (this.tokenType) {
    case Semicolon:
      this.next();
      break;
    case LeftCurlyBracket:
      if (hasOwnProperty.call(this.atrule, nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function") {
        block = this.atrule[nameLowerCase].block.call(this, isDeclaration);
      } else {
        block = this.Block(isDeclarationBlockAtrule.call(this));
      }
      break;
  }
  return {
    type: "Atrule",
    loc: this.getLocation(start, this.tokenStart),
    name: name50,
    prelude,
    block
  };
}
function generate3(node) {
  this.token(AtKeyword, "@" + node.name);
  if (node.prelude !== null) {
    this.node(node.prelude);
  }
  if (node.block) {
    this.node(node.block);
  } else {
    this.token(Semicolon, ";");
  }
}

// node_modules/css-tree/lib/syntax/node/AtrulePrelude.js
var AtrulePrelude_exports = {};
__export(AtrulePrelude_exports, {
  generate: () => generate4,
  name: () => name3,
  parse: () => parse5,
  structure: () => structure3,
  walkContext: () => walkContext2
});
var name3 = "AtrulePrelude";
var walkContext2 = "atrulePrelude";
var structure3 = {
  children: [[]]
};
function parse5(name50) {
  let children = null;
  if (name50 !== null) {
    name50 = name50.toLowerCase();
  }
  this.skipSC();
  if (hasOwnProperty.call(this.atrule, name50) && typeof this.atrule[name50].prelude === "function") {
    children = this.atrule[name50].prelude.call(this);
  } else {
    children = this.readSequence(this.scope.AtrulePrelude);
  }
  this.skipSC();
  if (this.eof !== true && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon) {
    this.error("Semicolon or block is expected");
  }
  return {
    type: "AtrulePrelude",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate4(node) {
  this.children(node);
}

// node_modules/css-tree/lib/syntax/node/AttributeSelector.js
var AttributeSelector_exports = {};
__export(AttributeSelector_exports, {
  generate: () => generate5,
  name: () => name4,
  parse: () => parse6,
  structure: () => structure4
});
var DOLLARSIGN = 36;
var ASTERISK2 = 42;
var EQUALSSIGN = 61;
var CIRCUMFLEXACCENT = 94;
var VERTICALLINE2 = 124;
var TILDE = 126;
function getAttributeName() {
  if (this.eof) {
    this.error("Unexpected end of input");
  }
  const start = this.tokenStart;
  let expectIdent = false;
  if (this.isDelim(ASTERISK2)) {
    expectIdent = true;
    this.next();
  } else if (!this.isDelim(VERTICALLINE2)) {
    this.eat(Ident);
  }
  if (this.isDelim(VERTICALLINE2)) {
    if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {
      this.next();
      this.eat(Ident);
    } else if (expectIdent) {
      this.error("Identifier is expected", this.tokenEnd);
    }
  } else if (expectIdent) {
    this.error("Vertical line is expected");
  }
  return {
    type: "Identifier",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start)
  };
}
function getOperator() {
  const start = this.tokenStart;
  const code2 = this.charCodeAt(start);
  if (code2 !== EQUALSSIGN && // =
  code2 !== TILDE && // ~=
  code2 !== CIRCUMFLEXACCENT && // ^=
  code2 !== DOLLARSIGN && // $=
  code2 !== ASTERISK2 && // *=
  code2 !== VERTICALLINE2) {
    this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
  }
  this.next();
  if (code2 !== EQUALSSIGN) {
    if (!this.isDelim(EQUALSSIGN)) {
      this.error("Equal sign is expected");
    }
    this.next();
  }
  return this.substrToCursor(start);
}
var name4 = "AttributeSelector";
var structure4 = {
  name: "Identifier",
  matcher: [String, null],
  value: ["String", "Identifier", null],
  flags: [String, null]
};
function parse6() {
  const start = this.tokenStart;
  let name50;
  let matcher = null;
  let value = null;
  let flags = null;
  this.eat(LeftSquareBracket);
  this.skipSC();
  name50 = getAttributeName.call(this);
  this.skipSC();
  if (this.tokenType !== RightSquareBracket) {
    if (this.tokenType !== Ident) {
      matcher = getOperator.call(this);
      this.skipSC();
      value = this.tokenType === String2 ? this.String() : this.Identifier();
      this.skipSC();
    }
    if (this.tokenType === Ident) {
      flags = this.consume(Ident);
      this.skipSC();
    }
  }
  this.eat(RightSquareBracket);
  return {
    type: "AttributeSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: name50,
    matcher,
    value,
    flags
  };
}
function generate5(node) {
  this.token(Delim, "[");
  this.node(node.name);
  if (node.matcher !== null) {
    this.tokenize(node.matcher);
    this.node(node.value);
  }
  if (node.flags !== null) {
    this.token(Ident, node.flags);
  }
  this.token(Delim, "]");
}

// node_modules/css-tree/lib/syntax/node/Block.js
var Block_exports = {};
__export(Block_exports, {
  generate: () => generate6,
  name: () => name5,
  parse: () => parse7,
  structure: () => structure5,
  walkContext: () => walkContext3
});
var AMPERSAND2 = 38;
function consumeRaw2() {
  return this.Raw(null, true);
}
function consumeRule() {
  return this.parseWithFallback(this.Rule, consumeRaw2);
}
function consumeRawDeclaration() {
  return this.Raw(this.consumeUntilSemicolonIncluded, true);
}
function consumeDeclaration() {
  if (this.tokenType === Semicolon) {
    return consumeRawDeclaration.call(this, this.tokenIndex);
  }
  const node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);
  if (this.tokenType === Semicolon) {
    this.next();
  }
  return node;
}
var name5 = "Block";
var walkContext3 = "block";
var structure5 = {
  children: [[
    "Atrule",
    "Rule",
    "Declaration"
  ]]
};
function parse7(isStyleBlock) {
  const consumer = isStyleBlock ? consumeDeclaration : consumeRule;
  const start = this.tokenStart;
  let children = this.createList();
  this.eat(LeftCurlyBracket);
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case RightCurlyBracket:
          break scan;
        case WhiteSpace:
        case Comment:
          this.next();
          break;
        case AtKeyword:
          children.push(this.parseWithFallback(this.Atrule.bind(this, isStyleBlock), consumeRaw2));
          break;
        default:
          if (isStyleBlock && this.isDelim(AMPERSAND2)) {
            children.push(consumeRule.call(this));
          } else {
            children.push(consumer.call(this));
          }
      }
    }
  if (!this.eof) {
    this.eat(RightCurlyBracket);
  }
  return {
    type: "Block",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate6(node) {
  this.token(LeftCurlyBracket, "{");
  this.children(node, (prev) => {
    if (prev.type === "Declaration") {
      this.token(Semicolon, ";");
    }
  });
  this.token(RightCurlyBracket, "}");
}

// node_modules/css-tree/lib/syntax/node/Brackets.js
var Brackets_exports = {};
__export(Brackets_exports, {
  generate: () => generate7,
  name: () => name6,
  parse: () => parse8,
  structure: () => structure6
});
var name6 = "Brackets";
var structure6 = {
  children: [[]]
};
function parse8(readSequence2, recognizer) {
  const start = this.tokenStart;
  let children = null;
  this.eat(LeftSquareBracket);
  children = readSequence2.call(this, recognizer);
  if (!this.eof) {
    this.eat(RightSquareBracket);
  }
  return {
    type: "Brackets",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate7(node) {
  this.token(Delim, "[");
  this.children(node);
  this.token(Delim, "]");
}

// node_modules/css-tree/lib/syntax/node/CDC.js
var CDC_exports = {};
__export(CDC_exports, {
  generate: () => generate8,
  name: () => name7,
  parse: () => parse9,
  structure: () => structure7
});
var name7 = "CDC";
var structure7 = [];
function parse9() {
  const start = this.tokenStart;
  this.eat(CDC);
  return {
    type: "CDC",
    loc: this.getLocation(start, this.tokenStart)
  };
}
function generate8() {
  this.token(CDC, "-->");
}

// node_modules/css-tree/lib/syntax/node/CDO.js
var CDO_exports = {};
__export(CDO_exports, {
  generate: () => generate9,
  name: () => name8,
  parse: () => parse10,
  structure: () => structure8
});
var name8 = "CDO";
var structure8 = [];
function parse10() {
  const start = this.tokenStart;
  this.eat(CDO);
  return {
    type: "CDO",
    loc: this.getLocation(start, this.tokenStart)
  };
}
function generate9() {
  this.token(CDO, "<!--");
}

// node_modules/css-tree/lib/syntax/node/ClassSelector.js
var ClassSelector_exports = {};
__export(ClassSelector_exports, {
  generate: () => generate10,
  name: () => name9,
  parse: () => parse11,
  structure: () => structure9
});
var FULLSTOP = 46;
var name9 = "ClassSelector";
var structure9 = {
  name: String
};
function parse11() {
  this.eatDelim(FULLSTOP);
  return {
    type: "ClassSelector",
    loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
    name: this.consume(Ident)
  };
}
function generate10(node) {
  this.token(Delim, ".");
  this.token(Ident, node.name);
}

// node_modules/css-tree/lib/syntax/node/Combinator.js
var Combinator_exports = {};
__export(Combinator_exports, {
  generate: () => generate11,
  name: () => name10,
  parse: () => parse12,
  structure: () => structure10
});
var PLUSSIGN6 = 43;
var SOLIDUS = 47;
var GREATERTHANSIGN2 = 62;
var TILDE2 = 126;
var name10 = "Combinator";
var structure10 = {
  name: String
};
function parse12() {
  const start = this.tokenStart;
  let name50;
  switch (this.tokenType) {
    case WhiteSpace:
      name50 = " ";
      break;
    case Delim:
      switch (this.charCodeAt(this.tokenStart)) {
        case GREATERTHANSIGN2:
        case PLUSSIGN6:
        case TILDE2:
          this.next();
          break;
        case SOLIDUS:
          this.next();
          this.eatIdent("deep");
          this.eatDelim(SOLIDUS);
          break;
        default:
          this.error("Combinator is expected");
      }
      name50 = this.substrToCursor(start);
      break;
  }
  return {
    type: "Combinator",
    loc: this.getLocation(start, this.tokenStart),
    name: name50
  };
}
function generate11(node) {
  this.tokenize(node.name);
}

// node_modules/css-tree/lib/syntax/node/Comment.js
var Comment_exports = {};
__export(Comment_exports, {
  generate: () => generate12,
  name: () => name11,
  parse: () => parse13,
  structure: () => structure11
});
var ASTERISK3 = 42;
var SOLIDUS2 = 47;
var name11 = "Comment";
var structure11 = {
  value: String
};
function parse13() {
  const start = this.tokenStart;
  let end = this.tokenEnd;
  this.eat(Comment);
  if (end - start + 2 >= 2 && this.charCodeAt(end - 2) === ASTERISK3 && this.charCodeAt(end - 1) === SOLIDUS2) {
    end -= 2;
  }
  return {
    type: "Comment",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substring(start + 2, end)
  };
}
function generate12(node) {
  this.token(Comment, "/*" + node.value + "*/");
}

// node_modules/css-tree/lib/syntax/node/Condition.js
var Condition_exports = {};
__export(Condition_exports, {
  generate: () => generate13,
  name: () => name12,
  parse: () => parse14,
  structure: () => structure12
});
var likelyFeatureToken = /* @__PURE__ */ new Set([Colon, RightParenthesis, EOF]);
var name12 = "Condition";
var structure12 = {
  kind: String,
  children: [[
    "Identifier",
    "Feature",
    "FeatureFunction",
    "FeatureRange",
    "SupportsDeclaration"
  ]]
};
function featureOrRange(kind) {
  if (this.lookupTypeNonSC(1) === Ident && likelyFeatureToken.has(this.lookupTypeNonSC(2))) {
    return this.Feature(kind);
  }
  return this.FeatureRange(kind);
}
var parentheses = {
  media: featureOrRange,
  container: featureOrRange,
  supports() {
    return this.SupportsDeclaration();
  }
};
function parse14(kind = "media") {
  const children = this.createList();
  scan: while (!this.eof) {
    switch (this.tokenType) {
      case Comment:
      case WhiteSpace:
        this.next();
        continue;
      case Ident:
        children.push(this.Identifier());
        break;
      case LeftParenthesis: {
        let term = this.parseWithFallback(
          () => parentheses[kind].call(this, kind),
          () => null
        );
        if (!term) {
          term = this.parseWithFallback(
            () => {
              this.eat(LeftParenthesis);
              const res = this.Condition(kind);
              this.eat(RightParenthesis);
              return res;
            },
            () => {
              return this.GeneralEnclosed(kind);
            }
          );
        }
        children.push(term);
        break;
      }
      case Function2: {
        let term = this.parseWithFallback(
          () => this.FeatureFunction(kind),
          () => null
        );
        if (!term) {
          term = this.GeneralEnclosed(kind);
        }
        children.push(term);
        break;
      }
      default:
        break scan;
    }
  }
  if (children.isEmpty) {
    this.error("Condition is expected");
  }
  return {
    type: "Condition",
    loc: this.getLocationFromList(children),
    kind,
    children
  };
}
function generate13(node) {
  node.children.forEach((child) => {
    if (child.type === "Condition") {
      this.token(LeftParenthesis, "(");
      this.node(child);
      this.token(RightParenthesis, ")");
    } else {
      this.node(child);
    }
  });
}

// node_modules/css-tree/lib/syntax/node/Declaration.js
var Declaration_exports = {};
__export(Declaration_exports, {
  generate: () => generate14,
  name: () => name13,
  parse: () => parse15,
  structure: () => structure13,
  walkContext: () => walkContext4
});
var EXCLAMATIONMARK3 = 33;
var NUMBERSIGN3 = 35;
var DOLLARSIGN2 = 36;
var AMPERSAND3 = 38;
var ASTERISK4 = 42;
var PLUSSIGN7 = 43;
var SOLIDUS3 = 47;
function consumeValueRaw() {
  return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, true);
}
function consumeCustomPropertyRaw() {
  return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, false);
}
function consumeValue() {
  const startValueToken = this.tokenIndex;
  const value = this.Value();
  if (value.type !== "Raw" && this.eof === false && this.tokenType !== Semicolon && this.isDelim(EXCLAMATIONMARK3) === false && this.isBalanceEdge(startValueToken) === false) {
    this.error();
  }
  return value;
}
var name13 = "Declaration";
var walkContext4 = "declaration";
var structure13 = {
  important: [Boolean, String],
  property: String,
  value: ["Value", "Raw"]
};
function parse15() {
  const start = this.tokenStart;
  const startToken = this.tokenIndex;
  const property4 = readProperty2.call(this);
  const customProperty = isCustomProperty(property4);
  const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
  const consumeRaw6 = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
  let important3 = false;
  let value;
  this.skipSC();
  this.eat(Colon);
  const valueStart = this.tokenIndex;
  if (!customProperty) {
    this.skipSC();
  }
  if (parseValue) {
    value = this.parseWithFallback(consumeValue, consumeRaw6);
  } else {
    value = consumeRaw6.call(this, this.tokenIndex);
  }
  if (customProperty && value.type === "Value" && value.children.isEmpty) {
    for (let offset = valueStart - this.tokenIndex; offset <= 0; offset++) {
      if (this.lookupType(offset) === WhiteSpace) {
        value.children.appendData({
          type: "WhiteSpace",
          loc: null,
          value: " "
        });
        break;
      }
    }
  }
  if (this.isDelim(EXCLAMATIONMARK3)) {
    important3 = getImportant.call(this);
    this.skipSC();
  }
  if (this.eof === false && this.tokenType !== Semicolon && this.isBalanceEdge(startToken) === false) {
    this.error();
  }
  return {
    type: "Declaration",
    loc: this.getLocation(start, this.tokenStart),
    important: important3,
    property: property4,
    value
  };
}
function generate14(node) {
  this.token(Ident, node.property);
  this.token(Colon, ":");
  this.node(node.value);
  if (node.important) {
    this.token(Delim, "!");
    this.token(Ident, node.important === true ? "important" : node.important);
  }
}
function readProperty2() {
  const start = this.tokenStart;
  if (this.tokenType === Delim) {
    switch (this.charCodeAt(this.tokenStart)) {
      case ASTERISK4:
      case DOLLARSIGN2:
      case PLUSSIGN7:
      case NUMBERSIGN3:
      case AMPERSAND3:
        this.next();
        break;
      case SOLIDUS3:
        this.next();
        if (this.isDelim(SOLIDUS3)) {
          this.next();
        }
        break;
    }
  }
  if (this.tokenType === Hash) {
    this.eat(Hash);
  } else {
    this.eat(Ident);
  }
  return this.substrToCursor(start);
}
function getImportant() {
  this.eat(Delim);
  this.skipSC();
  const important3 = this.consume(Ident);
  return important3 === "important" ? true : important3;
}

// node_modules/css-tree/lib/syntax/node/DeclarationList.js
var DeclarationList_exports = {};
__export(DeclarationList_exports, {
  generate: () => generate15,
  name: () => name14,
  parse: () => parse16,
  structure: () => structure14
});
var AMPERSAND4 = 38;
function consumeRaw3() {
  return this.Raw(this.consumeUntilSemicolonIncluded, true);
}
var name14 = "DeclarationList";
var structure14 = {
  children: [[
    "Declaration",
    "Atrule",
    "Rule"
  ]]
};
function parse16() {
  const children = this.createList();
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case WhiteSpace:
        case Comment:
        case Semicolon:
          this.next();
          break;
        case AtKeyword:
          children.push(this.parseWithFallback(this.Atrule.bind(this, true), consumeRaw3));
          break;
        default:
          if (this.isDelim(AMPERSAND4)) {
            children.push(this.parseWithFallback(this.Rule, consumeRaw3));
          } else {
            children.push(this.parseWithFallback(this.Declaration, consumeRaw3));
          }
      }
    }
  return {
    type: "DeclarationList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate15(node) {
  this.children(node, (prev) => {
    if (prev.type === "Declaration") {
      this.token(Semicolon, ";");
    }
  });
}

// node_modules/css-tree/lib/syntax/node/Dimension.js
var Dimension_exports = {};
__export(Dimension_exports, {
  generate: () => generate16,
  name: () => name15,
  parse: () => parse17,
  structure: () => structure15
});
var name15 = "Dimension";
var structure15 = {
  value: String,
  unit: String
};
function parse17() {
  const start = this.tokenStart;
  const value = this.consumeNumber(Dimension);
  return {
    type: "Dimension",
    loc: this.getLocation(start, this.tokenStart),
    value,
    unit: this.substring(start + value.length, this.tokenStart)
  };
}
function generate16(node) {
  this.token(Dimension, node.value + node.unit);
}

// node_modules/css-tree/lib/syntax/node/Feature.js
var Feature_exports = {};
__export(Feature_exports, {
  generate: () => generate17,
  name: () => name16,
  parse: () => parse18,
  structure: () => structure16
});
var SOLIDUS4 = 47;
var name16 = "Feature";
var structure16 = {
  kind: String,
  name: String,
  value: ["Identifier", "Number", "Dimension", "Ratio", "Function", null]
};
function parse18(kind) {
  const start = this.tokenStart;
  let name50;
  let value = null;
  this.eat(LeftParenthesis);
  this.skipSC();
  name50 = this.consume(Ident);
  this.skipSC();
  if (this.tokenType !== RightParenthesis) {
    this.eat(Colon);
    this.skipSC();
    switch (this.tokenType) {
      case Number2:
        if (this.lookupNonWSType(1) === Delim) {
          value = this.Ratio();
        } else {
          value = this.Number();
        }
        break;
      case Dimension:
        value = this.Dimension();
        break;
      case Ident:
        value = this.Identifier();
        break;
      case Function2:
        value = this.parseWithFallback(
          () => {
            const res = this.Function(this.readSequence, this.scope.Value);
            this.skipSC();
            if (this.isDelim(SOLIDUS4)) {
              this.error();
            }
            return res;
          },
          () => {
            return this.Ratio();
          }
        );
        break;
      default:
        this.error("Number, dimension, ratio or identifier is expected");
    }
    this.skipSC();
  }
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "Feature",
    loc: this.getLocation(start, this.tokenStart),
    kind,
    name: name50,
    value
  };
}
function generate17(node) {
  this.token(LeftParenthesis, "(");
  this.token(Ident, node.name);
  if (node.value !== null) {
    this.token(Colon, ":");
    this.node(node.value);
  }
  this.token(RightParenthesis, ")");
}

// node_modules/css-tree/lib/syntax/node/FeatureFunction.js
var FeatureFunction_exports = {};
__export(FeatureFunction_exports, {
  generate: () => generate18,
  name: () => name17,
  parse: () => parse19,
  structure: () => structure17
});
var name17 = "FeatureFunction";
var structure17 = {
  kind: String,
  feature: String,
  value: ["Declaration", "Selector"]
};
function getFeatureParser(kind, name50) {
  const featuresOfKind = this.features[kind] || {};
  const parser = featuresOfKind[name50];
  if (typeof parser !== "function") {
    this.error(`Unknown feature ${name50}()`);
  }
  return parser;
}
function parse19(kind = "unknown") {
  const start = this.tokenStart;
  const functionName = this.consumeFunctionName();
  const valueParser = getFeatureParser.call(this, kind, functionName.toLowerCase());
  this.skipSC();
  const value = this.parseWithFallback(
    () => {
      const startValueToken = this.tokenIndex;
      const value2 = valueParser.call(this);
      if (this.eof === false && this.isBalanceEdge(startValueToken) === false) {
        this.error();
      }
      return value2;
    },
    () => this.Raw(null, false)
  );
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "FeatureFunction",
    loc: this.getLocation(start, this.tokenStart),
    kind,
    feature: functionName,
    value
  };
}
function generate18(node) {
  this.token(Function2, node.feature + "(");
  this.node(node.value);
  this.token(RightParenthesis, ")");
}

// node_modules/css-tree/lib/syntax/node/FeatureRange.js
var FeatureRange_exports = {};
__export(FeatureRange_exports, {
  generate: () => generate19,
  name: () => name18,
  parse: () => parse20,
  structure: () => structure18
});
var SOLIDUS5 = 47;
var LESSTHANSIGN2 = 60;
var EQUALSSIGN2 = 61;
var GREATERTHANSIGN3 = 62;
var name18 = "FeatureRange";
var structure18 = {
  kind: String,
  left: ["Identifier", "Number", "Dimension", "Ratio", "Function"],
  leftComparison: String,
  middle: ["Identifier", "Number", "Dimension", "Ratio", "Function"],
  rightComparison: [String, null],
  right: ["Identifier", "Number", "Dimension", "Ratio", "Function", null]
};
function readTerm() {
  this.skipSC();
  switch (this.tokenType) {
    case Number2:
      if (this.isDelim(SOLIDUS5, this.lookupOffsetNonSC(1))) {
        return this.Ratio();
      } else {
        return this.Number();
      }
    case Dimension:
      return this.Dimension();
    case Ident:
      return this.Identifier();
    case Function2:
      return this.parseWithFallback(
        () => {
          const res = this.Function(this.readSequence, this.scope.Value);
          this.skipSC();
          if (this.isDelim(SOLIDUS5)) {
            this.error();
          }
          return res;
        },
        () => {
          return this.Ratio();
        }
      );
    default:
      this.error("Number, dimension, ratio or identifier is expected");
  }
}
function readComparison(expectColon) {
  this.skipSC();
  if (this.isDelim(LESSTHANSIGN2) || this.isDelim(GREATERTHANSIGN3)) {
    const value = this.source[this.tokenStart];
    this.next();
    if (this.isDelim(EQUALSSIGN2)) {
      this.next();
      return value + "=";
    }
    return value;
  }
  if (this.isDelim(EQUALSSIGN2)) {
    return "=";
  }
  this.error(`Expected ${expectColon ? '":", ' : ""}"<", ">", "=" or ")"`);
}
function parse20(kind = "unknown") {
  const start = this.tokenStart;
  this.skipSC();
  this.eat(LeftParenthesis);
  const left = readTerm.call(this);
  const leftComparison = readComparison.call(this, left.type === "Identifier");
  const middle = readTerm.call(this);
  let rightComparison = null;
  let right = null;
  if (this.lookupNonWSType(0) !== RightParenthesis) {
    rightComparison = readComparison.call(this);
    right = readTerm.call(this);
  }
  this.skipSC();
  this.eat(RightParenthesis);
  return {
    type: "FeatureRange",
    loc: this.getLocation(start, this.tokenStart),
    kind,
    left,
    leftComparison,
    middle,
    rightComparison,
    right
  };
}
function generate19(node) {
  this.token(LeftParenthesis, "(");
  this.node(node.left);
  this.tokenize(node.leftComparison);
  this.node(node.middle);
  if (node.right) {
    this.tokenize(node.rightComparison);
    this.node(node.right);
  }
  this.token(RightParenthesis, ")");
}

// node_modules/css-tree/lib/syntax/node/Function.js
var Function_exports = {};
__export(Function_exports, {
  generate: () => generate20,
  name: () => name19,
  parse: () => parse21,
  structure: () => structure19,
  walkContext: () => walkContext5
});
var name19 = "Function";
var walkContext5 = "function";
var structure19 = {
  name: String,
  children: [[]]
};
function parse21(readSequence2, recognizer) {
  const start = this.tokenStart;
  const name50 = this.consumeFunctionName();
  const nameLowerCase = name50.toLowerCase();
  let children;
  children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence2.call(this, recognizer);
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "Function",
    loc: this.getLocation(start, this.tokenStart),
    name: name50,
    children
  };
}
function generate20(node) {
  this.token(Function2, node.name + "(");
  this.children(node);
  this.token(RightParenthesis, ")");
}

// node_modules/css-tree/lib/syntax/node/GeneralEnclosed.js
var GeneralEnclosed_exports = {};
__export(GeneralEnclosed_exports, {
  generate: () => generate21,
  name: () => name20,
  parse: () => parse22,
  structure: () => structure20
});
var name20 = "GeneralEnclosed";
var structure20 = {
  kind: String,
  function: [String, null],
  children: [[]]
};
function parse22(kind) {
  const start = this.tokenStart;
  let functionName = null;
  if (this.tokenType === Function2) {
    functionName = this.consumeFunctionName();
  } else {
    this.eat(LeftParenthesis);
  }
  const children = this.parseWithFallback(
    () => {
      const startValueToken = this.tokenIndex;
      const children2 = this.readSequence(this.scope.Value);
      if (this.eof === false && this.isBalanceEdge(startValueToken) === false) {
        this.error();
      }
      return children2;
    },
    () => this.createSingleNodeList(
      this.Raw(null, false)
    )
  );
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "GeneralEnclosed",
    loc: this.getLocation(start, this.tokenStart),
    kind,
    function: functionName,
    children
  };
}
function generate21(node) {
  if (node.function) {
    this.token(Function2, node.function + "(");
  } else {
    this.token(LeftParenthesis, "(");
  }
  this.children(node);
  this.token(RightParenthesis, ")");
}

// node_modules/css-tree/lib/syntax/node/Hash.js
var Hash_exports = {};
__export(Hash_exports, {
  generate: () => generate22,
  name: () => name21,
  parse: () => parse23,
  structure: () => structure21,
  xxx: () => xxx
});
var xxx = "XXX";
var name21 = "Hash";
var structure21 = {
  value: String
};
function parse23() {
  const start = this.tokenStart;
  this.eat(Hash);
  return {
    type: "Hash",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start + 1)
  };
}
function generate22(node) {
  this.token(Hash, "#" + node.value);
}

// node_modules/css-tree/lib/syntax/node/Identifier.js
var Identifier_exports = {};
__export(Identifier_exports, {
  generate: () => generate23,
  name: () => name22,
  parse: () => parse24,
  structure: () => structure22
});
var name22 = "Identifier";
var structure22 = {
  name: String
};
function parse24() {
  return {
    type: "Identifier",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    name: this.consume(Ident)
  };
}
function generate23(node) {
  this.token(Ident, node.name);
}

// node_modules/css-tree/lib/syntax/node/IdSelector.js
var IdSelector_exports = {};
__export(IdSelector_exports, {
  generate: () => generate24,
  name: () => name23,
  parse: () => parse25,
  structure: () => structure23
});
var name23 = "IdSelector";
var structure23 = {
  name: String
};
function parse25() {
  const start = this.tokenStart;
  this.eat(Hash);
  return {
    type: "IdSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start + 1)
  };
}
function generate24(node) {
  this.token(Delim, "#" + node.name);
}

// node_modules/css-tree/lib/syntax/node/Layer.js
var Layer_exports = {};
__export(Layer_exports, {
  generate: () => generate25,
  name: () => name24,
  parse: () => parse26,
  structure: () => structure24
});
var FULLSTOP2 = 46;
var name24 = "Layer";
var structure24 = {
  name: String
};
function parse26() {
  let tokenStart = this.tokenStart;
  let name50 = this.consume(Ident);
  while (this.isDelim(FULLSTOP2)) {
    this.eat(Delim);
    name50 += "." + this.consume(Ident);
  }
  return {
    type: "Layer",
    loc: this.getLocation(tokenStart, this.tokenStart),
    name: name50
  };
}
function generate25(node) {
  this.tokenize(node.name);
}

// node_modules/css-tree/lib/syntax/node/LayerList.js
var LayerList_exports = {};
__export(LayerList_exports, {
  generate: () => generate26,
  name: () => name25,
  parse: () => parse27,
  structure: () => structure25
});
var name25 = "LayerList";
var structure25 = {
  children: [[
    "Layer"
  ]]
};
function parse27() {
  const children = this.createList();
  this.skipSC();
  while (!this.eof) {
    children.push(this.Layer());
    if (this.lookupTypeNonSC(0) !== Comma) {
      break;
    }
    this.skipSC();
    this.next();
    this.skipSC();
  }
  return {
    type: "LayerList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate26(node) {
  this.children(node, () => this.token(Comma, ","));
}

// node_modules/css-tree/lib/syntax/node/MediaQuery.js
var MediaQuery_exports = {};
__export(MediaQuery_exports, {
  generate: () => generate27,
  name: () => name26,
  parse: () => parse28,
  structure: () => structure26
});
var name26 = "MediaQuery";
var structure26 = {
  modifier: [String, null],
  mediaType: [String, null],
  condition: ["Condition", null]
};
function parse28() {
  const start = this.tokenStart;
  let modifier = null;
  let mediaType = null;
  let condition = null;
  this.skipSC();
  if (this.tokenType === Ident && this.lookupTypeNonSC(1) !== LeftParenthesis) {
    const ident = this.consume(Ident);
    const identLowerCase = ident.toLowerCase();
    if (identLowerCase === "not" || identLowerCase === "only") {
      this.skipSC();
      modifier = identLowerCase;
      mediaType = this.consume(Ident);
    } else {
      mediaType = ident;
    }
    switch (this.lookupTypeNonSC(0)) {
      case Ident: {
        this.skipSC();
        this.eatIdent("and");
        condition = this.Condition("media");
        break;
      }
      case LeftCurlyBracket:
      case Semicolon:
      case Comma:
      case EOF:
        break;
      default:
        this.error("Identifier or parenthesis is expected");
    }
  } else {
    switch (this.tokenType) {
      case Ident:
      case LeftParenthesis:
      case Function2: {
        condition = this.Condition("media");
        break;
      }
      case LeftCurlyBracket:
      case Semicolon:
      case EOF:
        break;
      default:
        this.error("Identifier or parenthesis is expected");
    }
  }
  return {
    type: "MediaQuery",
    loc: this.getLocation(start, this.tokenStart),
    modifier,
    mediaType,
    condition
  };
}
function generate27(node) {
  if (node.mediaType) {
    if (node.modifier) {
      this.token(Ident, node.modifier);
    }
    this.token(Ident, node.mediaType);
    if (node.condition) {
      this.token(Ident, "and");
      this.node(node.condition);
    }
  } else if (node.condition) {
    this.node(node.condition);
  }
}

// node_modules/css-tree/lib/syntax/node/MediaQueryList.js
var MediaQueryList_exports = {};
__export(MediaQueryList_exports, {
  generate: () => generate28,
  name: () => name27,
  parse: () => parse29,
  structure: () => structure27
});
var name27 = "MediaQueryList";
var structure27 = {
  children: [[
    "MediaQuery"
  ]]
};
function parse29() {
  const children = this.createList();
  this.skipSC();
  while (!this.eof) {
    children.push(this.MediaQuery());
    if (this.tokenType !== Comma) {
      break;
    }
    this.next();
  }
  return {
    type: "MediaQueryList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate28(node) {
  this.children(node, () => this.token(Comma, ","));
}

// node_modules/css-tree/lib/syntax/node/NestingSelector.js
var NestingSelector_exports = {};
__export(NestingSelector_exports, {
  generate: () => generate29,
  name: () => name28,
  parse: () => parse30,
  structure: () => structure28
});
var AMPERSAND5 = 38;
var name28 = "NestingSelector";
var structure28 = {};
function parse30() {
  const start = this.tokenStart;
  this.eatDelim(AMPERSAND5);
  return {
    type: "NestingSelector",
    loc: this.getLocation(start, this.tokenStart)
  };
}
function generate29() {
  this.token(Delim, "&");
}

// node_modules/css-tree/lib/syntax/node/Nth.js
var Nth_exports = {};
__export(Nth_exports, {
  generate: () => generate30,
  name: () => name29,
  parse: () => parse31,
  structure: () => structure29
});
var name29 = "Nth";
var structure29 = {
  nth: ["AnPlusB", "Identifier"],
  selector: ["SelectorList", null]
};
function parse31() {
  this.skipSC();
  const start = this.tokenStart;
  let end = start;
  let selector2 = null;
  let nth2;
  if (this.lookupValue(0, "odd") || this.lookupValue(0, "even")) {
    nth2 = this.Identifier();
  } else {
    nth2 = this.AnPlusB();
  }
  end = this.tokenStart;
  this.skipSC();
  if (this.lookupValue(0, "of")) {
    this.next();
    selector2 = this.SelectorList();
    end = this.tokenStart;
  }
  return {
    type: "Nth",
    loc: this.getLocation(start, end),
    nth: nth2,
    selector: selector2
  };
}
function generate30(node) {
  this.node(node.nth);
  if (node.selector !== null) {
    this.token(Ident, "of");
    this.node(node.selector);
  }
}

// node_modules/css-tree/lib/syntax/node/Number.js
var Number_exports = {};
__export(Number_exports, {
  generate: () => generate31,
  name: () => name30,
  parse: () => parse32,
  structure: () => structure30
});
var name30 = "Number";
var structure30 = {
  value: String
};
function parse32() {
  return {
    type: "Number",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: this.consume(Number2)
  };
}
function generate31(node) {
  this.token(Number2, node.value);
}

// node_modules/css-tree/lib/syntax/node/Operator.js
var Operator_exports = {};
__export(Operator_exports, {
  generate: () => generate32,
  name: () => name31,
  parse: () => parse33,
  structure: () => structure31
});
var name31 = "Operator";
var structure31 = {
  value: String
};
function parse33() {
  const start = this.tokenStart;
  this.next();
  return {
    type: "Operator",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start)
  };
}
function generate32(node) {
  this.tokenize(node.value);
}

// node_modules/css-tree/lib/syntax/node/Parentheses.js
var Parentheses_exports = {};
__export(Parentheses_exports, {
  generate: () => generate33,
  name: () => name32,
  parse: () => parse34,
  structure: () => structure32
});
var name32 = "Parentheses";
var structure32 = {
  children: [[]]
};
function parse34(readSequence2, recognizer) {
  const start = this.tokenStart;
  let children = null;
  this.eat(LeftParenthesis);
  children = readSequence2.call(this, recognizer);
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "Parentheses",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate33(node) {
  this.token(LeftParenthesis, "(");
  this.children(node);
  this.token(RightParenthesis, ")");
}

// node_modules/css-tree/lib/syntax/node/Percentage.js
var Percentage_exports = {};
__export(Percentage_exports, {
  generate: () => generate34,
  name: () => name33,
  parse: () => parse35,
  structure: () => structure33
});
var name33 = "Percentage";
var structure33 = {
  value: String
};
function parse35() {
  return {
    type: "Percentage",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: this.consumeNumber(Percentage)
  };
}
function generate34(node) {
  this.token(Percentage, node.value + "%");
}

// node_modules/css-tree/lib/syntax/node/PseudoClassSelector.js
var PseudoClassSelector_exports = {};
__export(PseudoClassSelector_exports, {
  generate: () => generate35,
  name: () => name34,
  parse: () => parse36,
  structure: () => structure34,
  walkContext: () => walkContext6
});
var name34 = "PseudoClassSelector";
var walkContext6 = "function";
var structure34 = {
  name: String,
  children: [["Raw"], null]
};
function parse36() {
  const start = this.tokenStart;
  let children = null;
  let name50;
  let nameLowerCase;
  this.eat(Colon);
  if (this.tokenType === Function2) {
    name50 = this.consumeFunctionName();
    nameLowerCase = name50.toLowerCase();
    if (this.lookupNonWSType(0) == RightParenthesis) {
      children = this.createList();
    } else if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
      this.skipSC();
      children = this.pseudo[nameLowerCase].call(this);
      this.skipSC();
    } else {
      children = this.createList();
      children.push(
        this.Raw(null, false)
      );
    }
    this.eat(RightParenthesis);
  } else {
    name50 = this.consume(Ident);
  }
  return {
    type: "PseudoClassSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: name50,
    children
  };
}
function generate35(node) {
  this.token(Colon, ":");
  if (node.children === null) {
    this.token(Ident, node.name);
  } else {
    this.token(Function2, node.name + "(");
    this.children(node);
    this.token(RightParenthesis, ")");
  }
}

// node_modules/css-tree/lib/syntax/node/PseudoElementSelector.js
var PseudoElementSelector_exports = {};
__export(PseudoElementSelector_exports, {
  generate: () => generate36,
  name: () => name35,
  parse: () => parse37,
  structure: () => structure35,
  walkContext: () => walkContext7
});
var name35 = "PseudoElementSelector";
var walkContext7 = "function";
var structure35 = {
  name: String,
  children: [["Raw"], null]
};
function parse37() {
  const start = this.tokenStart;
  let children = null;
  let name50;
  let nameLowerCase;
  this.eat(Colon);
  this.eat(Colon);
  if (this.tokenType === Function2) {
    name50 = this.consumeFunctionName();
    nameLowerCase = name50.toLowerCase();
    if (this.lookupNonWSType(0) == RightParenthesis) {
      children = this.createList();
    } else if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
      this.skipSC();
      children = this.pseudo[nameLowerCase].call(this);
      this.skipSC();
    } else {
      children = this.createList();
      children.push(
        this.Raw(null, false)
      );
    }
    this.eat(RightParenthesis);
  } else {
    name50 = this.consume(Ident);
  }
  return {
    type: "PseudoElementSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: name50,
    children
  };
}
function generate36(node) {
  this.token(Colon, ":");
  this.token(Colon, ":");
  if (node.children === null) {
    this.token(Ident, node.name);
  } else {
    this.token(Function2, node.name + "(");
    this.children(node);
    this.token(RightParenthesis, ")");
  }
}

// node_modules/css-tree/lib/syntax/node/Ratio.js
var Ratio_exports = {};
__export(Ratio_exports, {
  generate: () => generate37,
  name: () => name36,
  parse: () => parse38,
  structure: () => structure36
});
var SOLIDUS6 = 47;
function consumeTerm() {
  this.skipSC();
  switch (this.tokenType) {
    case Number2:
      return this.Number();
    case Function2:
      return this.Function(this.readSequence, this.scope.Value);
    default:
      this.error("Number of function is expected");
  }
}
var name36 = "Ratio";
var structure36 = {
  left: ["Number", "Function"],
  right: ["Number", "Function", null]
};
function parse38() {
  const start = this.tokenStart;
  const left = consumeTerm.call(this);
  let right = null;
  this.skipSC();
  if (this.isDelim(SOLIDUS6)) {
    this.eatDelim(SOLIDUS6);
    right = consumeTerm.call(this);
  }
  return {
    type: "Ratio",
    loc: this.getLocation(start, this.tokenStart),
    left,
    right
  };
}
function generate37(node) {
  this.node(node.left);
  this.token(Delim, "/");
  if (node.right) {
    this.node(node.right);
  } else {
    this.node(Number2, 1);
  }
}

// node_modules/css-tree/lib/syntax/node/Raw.js
var Raw_exports = {};
__export(Raw_exports, {
  generate: () => generate38,
  name: () => name37,
  parse: () => parse39,
  structure: () => structure37
});
function getOffsetExcludeWS() {
  if (this.tokenIndex > 0) {
    if (this.lookupType(-1) === WhiteSpace) {
      return this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset;
    }
  }
  return this.tokenStart;
}
var name37 = "Raw";
var structure37 = {
  value: String
};
function parse39(consumeUntil, excludeWhiteSpace) {
  const startOffset = this.getTokenStart(this.tokenIndex);
  let endOffset;
  this.skipUntilBalanced(this.tokenIndex, consumeUntil || this.consumeUntilBalanceEnd);
  if (excludeWhiteSpace && this.tokenStart > startOffset) {
    endOffset = getOffsetExcludeWS.call(this);
  } else {
    endOffset = this.tokenStart;
  }
  return {
    type: "Raw",
    loc: this.getLocation(startOffset, endOffset),
    value: this.substring(startOffset, endOffset)
  };
}
function generate38(node) {
  this.tokenize(node.value);
}

// node_modules/css-tree/lib/syntax/node/Rule.js
var Rule_exports = {};
__export(Rule_exports, {
  generate: () => generate39,
  name: () => name38,
  parse: () => parse40,
  structure: () => structure38,
  walkContext: () => walkContext8
});
function consumeRaw4() {
  return this.Raw(this.consumeUntilLeftCurlyBracket, true);
}
function consumePrelude() {
  const prelude = this.SelectorList();
  if (prelude.type !== "Raw" && this.eof === false && this.tokenType !== LeftCurlyBracket) {
    this.error();
  }
  return prelude;
}
var name38 = "Rule";
var walkContext8 = "rule";
var structure38 = {
  prelude: ["SelectorList", "Raw"],
  block: ["Block"]
};
function parse40() {
  const startToken = this.tokenIndex;
  const startOffset = this.tokenStart;
  let prelude;
  let block;
  if (this.parseRulePrelude) {
    prelude = this.parseWithFallback(consumePrelude, consumeRaw4);
  } else {
    prelude = consumeRaw4.call(this, startToken);
  }
  block = this.Block(true);
  return {
    type: "Rule",
    loc: this.getLocation(startOffset, this.tokenStart),
    prelude,
    block
  };
}
function generate39(node) {
  this.node(node.prelude);
  this.node(node.block);
}

// node_modules/css-tree/lib/syntax/node/Scope.js
var Scope_exports = {};
__export(Scope_exports, {
  generate: () => generate40,
  name: () => name39,
  parse: () => parse41,
  structure: () => structure39
});
var name39 = "Scope";
var structure39 = {
  root: ["SelectorList", "Raw", null],
  limit: ["SelectorList", "Raw", null]
};
function parse41() {
  let root = null;
  let limit = null;
  this.skipSC();
  const startOffset = this.tokenStart;
  if (this.tokenType === LeftParenthesis) {
    this.next();
    this.skipSC();
    root = this.parseWithFallback(
      this.SelectorList,
      () => this.Raw(false, true)
    );
    this.skipSC();
    this.eat(RightParenthesis);
  }
  if (this.lookupNonWSType(0) === Ident) {
    this.skipSC();
    this.eatIdent("to");
    this.skipSC();
    this.eat(LeftParenthesis);
    this.skipSC();
    limit = this.parseWithFallback(
      this.SelectorList,
      () => this.Raw(false, true)
    );
    this.skipSC();
    this.eat(RightParenthesis);
  }
  return {
    type: "Scope",
    loc: this.getLocation(startOffset, this.tokenStart),
    root,
    limit
  };
}
function generate40(node) {
  if (node.root) {
    this.token(LeftParenthesis, "(");
    this.node(node.root);
    this.token(RightParenthesis, ")");
  }
  if (node.limit) {
    this.token(Ident, "to");
    this.token(LeftParenthesis, "(");
    this.node(node.limit);
    this.token(RightParenthesis, ")");
  }
}

// node_modules/css-tree/lib/syntax/node/Selector.js
var Selector_exports = {};
__export(Selector_exports, {
  generate: () => generate41,
  name: () => name40,
  parse: () => parse42,
  structure: () => structure40
});
var name40 = "Selector";
var structure40 = {
  children: [[
    "TypeSelector",
    "IdSelector",
    "ClassSelector",
    "AttributeSelector",
    "PseudoClassSelector",
    "PseudoElementSelector",
    "Combinator"
  ]]
};
function parse42() {
  const children = this.readSequence(this.scope.Selector);
  if (this.getFirstListNode(children) === null) {
    this.error("Selector is expected");
  }
  return {
    type: "Selector",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate41(node) {
  this.children(node);
}

// node_modules/css-tree/lib/syntax/node/SelectorList.js
var SelectorList_exports = {};
__export(SelectorList_exports, {
  generate: () => generate42,
  name: () => name41,
  parse: () => parse43,
  structure: () => structure41,
  walkContext: () => walkContext9
});
var name41 = "SelectorList";
var walkContext9 = "selector";
var structure41 = {
  children: [[
    "Selector",
    "Raw"
  ]]
};
function parse43() {
  const children = this.createList();
  while (!this.eof) {
    children.push(this.Selector());
    if (this.tokenType === Comma) {
      this.next();
      continue;
    }
    break;
  }
  return {
    type: "SelectorList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate42(node) {
  this.children(node, () => this.token(Comma, ","));
}

// node_modules/css-tree/lib/syntax/node/String.js
var String_exports = {};
__export(String_exports, {
  generate: () => generate43,
  name: () => name42,
  parse: () => parse44,
  structure: () => structure42
});

// node_modules/css-tree/lib/utils/string.js
var string_exports = {};
__export(string_exports, {
  decode: () => decode,
  encode: () => encode2
});
var REVERSE_SOLIDUS = 92;
var QUOTATION_MARK = 34;
var APOSTROPHE2 = 39;
function decode(str) {
  const len = str.length;
  const firstChar = str.charCodeAt(0);
  const start = firstChar === QUOTATION_MARK || firstChar === APOSTROPHE2 ? 1 : 0;
  const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;
  let decoded = "";
  for (let i = start; i <= end; i++) {
    let code2 = str.charCodeAt(i);
    if (code2 === REVERSE_SOLIDUS) {
      if (i === end) {
        if (i !== len - 1) {
          decoded = str.substr(i + 1);
        }
        break;
      }
      code2 = str.charCodeAt(++i);
      if (isValidEscape(REVERSE_SOLIDUS, code2)) {
        const escapeStart = i - 1;
        const escapeEnd = consumeEscaped(str, escapeStart);
        i = escapeEnd - 1;
        decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
      } else {
        if (code2 === 13 && str.charCodeAt(i + 1) === 10) {
          i++;
        }
      }
    } else {
      decoded += str[i];
    }
  }
  return decoded;
}
function encode2(str, apostrophe) {
  const quote = apostrophe ? "'" : '"';
  const quoteCode = apostrophe ? APOSTROPHE2 : QUOTATION_MARK;
  let encoded = "";
  let wsBeforeHexIsNeeded = false;
  for (let i = 0; i < str.length; i++) {
    const code2 = str.charCodeAt(i);
    if (code2 === 0) {
      encoded += "";
      continue;
    }
    if (code2 <= 31 || code2 === 127) {
      encoded += "\\" + code2.toString(16);
      wsBeforeHexIsNeeded = true;
      continue;
    }
    if (code2 === quoteCode || code2 === REVERSE_SOLIDUS) {
      encoded += "\\" + str.charAt(i);
      wsBeforeHexIsNeeded = false;
    } else {
      if (wsBeforeHexIsNeeded && (isHexDigit(code2) || isWhiteSpace(code2))) {
        encoded += " ";
      }
      encoded += str.charAt(i);
      wsBeforeHexIsNeeded = false;
    }
  }
  return quote + encoded + quote;
}

// node_modules/css-tree/lib/syntax/node/String.js
var name42 = "String";
var structure42 = {
  value: String
};
function parse44() {
  return {
    type: "String",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: decode(this.consume(String2))
  };
}
function generate43(node) {
  this.token(String2, encode2(node.value));
}

// node_modules/css-tree/lib/syntax/node/StyleSheet.js
var StyleSheet_exports = {};
__export(StyleSheet_exports, {
  generate: () => generate44,
  name: () => name43,
  parse: () => parse45,
  structure: () => structure43,
  walkContext: () => walkContext10
});
var EXCLAMATIONMARK4 = 33;
function consumeRaw5() {
  return this.Raw(null, false);
}
var name43 = "StyleSheet";
var walkContext10 = "stylesheet";
var structure43 = {
  children: [[
    "Comment",
    "CDO",
    "CDC",
    "Atrule",
    "Rule",
    "Raw"
  ]]
};
function parse45() {
  const start = this.tokenStart;
  const children = this.createList();
  let child;
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case WhiteSpace:
          this.next();
          continue;
        case Comment:
          if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK4) {
            this.next();
            continue;
          }
          child = this.Comment();
          break;
        case CDO:
          child = this.CDO();
          break;
        case CDC:
          child = this.CDC();
          break;
        case AtKeyword:
          child = this.parseWithFallback(this.Atrule, consumeRaw5);
          break;
        default:
          child = this.parseWithFallback(this.Rule, consumeRaw5);
      }
      children.push(child);
    }
  return {
    type: "StyleSheet",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate44(node) {
  this.children(node);
}

// node_modules/css-tree/lib/syntax/node/SupportsDeclaration.js
var SupportsDeclaration_exports = {};
__export(SupportsDeclaration_exports, {
  generate: () => generate45,
  name: () => name44,
  parse: () => parse46,
  structure: () => structure44
});
var name44 = "SupportsDeclaration";
var structure44 = {
  declaration: "Declaration"
};
function parse46() {
  const start = this.tokenStart;
  this.eat(LeftParenthesis);
  this.skipSC();
  const declaration = this.Declaration();
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "SupportsDeclaration",
    loc: this.getLocation(start, this.tokenStart),
    declaration
  };
}
function generate45(node) {
  this.token(LeftParenthesis, "(");
  this.node(node.declaration);
  this.token(RightParenthesis, ")");
}

// node_modules/css-tree/lib/syntax/node/TypeSelector.js
var TypeSelector_exports = {};
__export(TypeSelector_exports, {
  generate: () => generate46,
  name: () => name45,
  parse: () => parse47,
  structure: () => structure45
});
var ASTERISK5 = 42;
var VERTICALLINE3 = 124;
function eatIdentifierOrAsterisk() {
  if (this.tokenType !== Ident && this.isDelim(ASTERISK5) === false) {
    this.error("Identifier or asterisk is expected");
  }
  this.next();
}
var name45 = "TypeSelector";
var structure45 = {
  name: String
};
function parse47() {
  const start = this.tokenStart;
  if (this.isDelim(VERTICALLINE3)) {
    this.next();
    eatIdentifierOrAsterisk.call(this);
  } else {
    eatIdentifierOrAsterisk.call(this);
    if (this.isDelim(VERTICALLINE3)) {
      this.next();
      eatIdentifierOrAsterisk.call(this);
    }
  }
  return {
    type: "TypeSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start)
  };
}
function generate46(node) {
  this.tokenize(node.name);
}

// node_modules/css-tree/lib/syntax/node/UnicodeRange.js
var UnicodeRange_exports = {};
__export(UnicodeRange_exports, {
  generate: () => generate47,
  name: () => name46,
  parse: () => parse48,
  structure: () => structure46
});
var PLUSSIGN8 = 43;
var HYPHENMINUS6 = 45;
var QUESTIONMARK3 = 63;
function eatHexSequence(offset, allowDash) {
  let len = 0;
  for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {
    const code2 = this.charCodeAt(pos);
    if (code2 === HYPHENMINUS6 && allowDash && len !== 0) {
      eatHexSequence.call(this, offset + len + 1, false);
      return -1;
    }
    if (!isHexDigit(code2)) {
      this.error(
        allowDash && len !== 0 ? "Hyphen minus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input",
        pos
      );
    }
    if (++len > 6) {
      this.error("Too many hex digits", pos);
    }
    ;
  }
  this.next();
  return len;
}
function eatQuestionMarkSequence(max) {
  let count = 0;
  while (this.isDelim(QUESTIONMARK3)) {
    if (++count > max) {
      this.error("Too many question marks");
    }
    this.next();
  }
}
function startsWith2(code2) {
  if (this.charCodeAt(this.tokenStart) !== code2) {
    this.error((code2 === PLUSSIGN8 ? "Plus sign" : "Hyphen minus") + " is expected");
  }
}
function scanUnicodeRange() {
  let hexLength = 0;
  switch (this.tokenType) {
    case Number2:
      hexLength = eatHexSequence.call(this, 1, true);
      if (this.isDelim(QUESTIONMARK3)) {
        eatQuestionMarkSequence.call(this, 6 - hexLength);
        break;
      }
      if (this.tokenType === Dimension || this.tokenType === Number2) {
        startsWith2.call(this, HYPHENMINUS6);
        eatHexSequence.call(this, 1, false);
        break;
      }
      break;
    case Dimension:
      hexLength = eatHexSequence.call(this, 1, true);
      if (hexLength > 0) {
        eatQuestionMarkSequence.call(this, 6 - hexLength);
      }
      break;
    default:
      this.eatDelim(PLUSSIGN8);
      if (this.tokenType === Ident) {
        hexLength = eatHexSequence.call(this, 0, true);
        if (hexLength > 0) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
        }
        break;
      }
      if (this.isDelim(QUESTIONMARK3)) {
        this.next();
        eatQuestionMarkSequence.call(this, 5);
        break;
      }
      this.error("Hex digit or question mark is expected");
  }
}
var name46 = "UnicodeRange";
var structure46 = {
  value: String
};
function parse48() {
  const start = this.tokenStart;
  this.eatIdent("u");
  scanUnicodeRange.call(this);
  return {
    type: "UnicodeRange",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start)
  };
}
function generate47(node) {
  this.tokenize(node.value);
}

// node_modules/css-tree/lib/syntax/node/Url.js
var Url_exports = {};
__export(Url_exports, {
  generate: () => generate48,
  name: () => name47,
  parse: () => parse49,
  structure: () => structure47
});

// node_modules/css-tree/lib/utils/url.js
var url_exports = {};
__export(url_exports, {
  decode: () => decode2,
  encode: () => encode3
});
var SPACE3 = 32;
var REVERSE_SOLIDUS2 = 92;
var QUOTATION_MARK2 = 34;
var APOSTROPHE3 = 39;
var LEFTPARENTHESIS3 = 40;
var RIGHTPARENTHESIS3 = 41;
function decode2(str) {
  const len = str.length;
  let start = 4;
  let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS3 ? len - 2 : len - 1;
  let decoded = "";
  while (start < end && isWhiteSpace(str.charCodeAt(start))) {
    start++;
  }
  while (start < end && isWhiteSpace(str.charCodeAt(end))) {
    end--;
  }
  for (let i = start; i <= end; i++) {
    let code2 = str.charCodeAt(i);
    if (code2 === REVERSE_SOLIDUS2) {
      if (i === end) {
        if (i !== len - 1) {
          decoded = str.substr(i + 1);
        }
        break;
      }
      code2 = str.charCodeAt(++i);
      if (isValidEscape(REVERSE_SOLIDUS2, code2)) {
        const escapeStart = i - 1;
        const escapeEnd = consumeEscaped(str, escapeStart);
        i = escapeEnd - 1;
        decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
      } else {
        if (code2 === 13 && str.charCodeAt(i + 1) === 10) {
          i++;
        }
      }
    } else {
      decoded += str[i];
    }
  }
  return decoded;
}
function encode3(str) {
  let encoded = "";
  let wsBeforeHexIsNeeded = false;
  for (let i = 0; i < str.length; i++) {
    const code2 = str.charCodeAt(i);
    if (code2 === 0) {
      encoded += "";
      continue;
    }
    if (code2 <= 31 || code2 === 127) {
      encoded += "\\" + code2.toString(16);
      wsBeforeHexIsNeeded = true;
      continue;
    }
    if (code2 === SPACE3 || code2 === REVERSE_SOLIDUS2 || code2 === QUOTATION_MARK2 || code2 === APOSTROPHE3 || code2 === LEFTPARENTHESIS3 || code2 === RIGHTPARENTHESIS3) {
      encoded += "\\" + str.charAt(i);
      wsBeforeHexIsNeeded = false;
    } else {
      if (wsBeforeHexIsNeeded && isHexDigit(code2)) {
        encoded += " ";
      }
      encoded += str.charAt(i);
      wsBeforeHexIsNeeded = false;
    }
  }
  return "url(" + encoded + ")";
}

// node_modules/css-tree/lib/syntax/node/Url.js
var name47 = "Url";
var structure47 = {
  value: String
};
function parse49() {
  const start = this.tokenStart;
  let value;
  switch (this.tokenType) {
    case Url:
      value = decode2(this.consume(Url));
      break;
    case Function2:
      if (!this.cmpStr(this.tokenStart, this.tokenEnd, "url(")) {
        this.error("Function name must be `url`");
      }
      this.eat(Function2);
      this.skipSC();
      value = decode(this.consume(String2));
      this.skipSC();
      if (!this.eof) {
        this.eat(RightParenthesis);
      }
      break;
    default:
      this.error("Url or Function is expected");
  }
  return {
    type: "Url",
    loc: this.getLocation(start, this.tokenStart),
    value
  };
}
function generate48(node) {
  this.token(Url, encode3(node.value));
}

// node_modules/css-tree/lib/syntax/node/Value.js
var Value_exports = {};
__export(Value_exports, {
  generate: () => generate49,
  name: () => name48,
  parse: () => parse50,
  structure: () => structure48
});
var name48 = "Value";
var structure48 = {
  children: [[]]
};
function parse50() {
  const start = this.tokenStart;
  const children = this.readSequence(this.scope.Value);
  return {
    type: "Value",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate49(node) {
  this.children(node);
}

// node_modules/css-tree/lib/syntax/node/WhiteSpace.js
var WhiteSpace_exports = {};
__export(WhiteSpace_exports, {
  generate: () => generate50,
  name: () => name49,
  parse: () => parse51,
  structure: () => structure49
});
var SPACE4 = Object.freeze({
  type: "WhiteSpace",
  loc: null,
  value: " "
});
var name49 = "WhiteSpace";
var structure49 = {
  value: String
};
function parse51() {
  this.eat(WhiteSpace);
  return SPACE4;
}
function generate50(node) {
  this.token(WhiteSpace, node.value);
}

// node_modules/css-tree/lib/syntax/config/lexer.js
var lexer_default = {
  generic: true,
  cssWideKeywords,
  ...data_default,
  node: node_exports
};

// node_modules/css-tree/lib/syntax/scope/index.js
var scope_exports = {};
__export(scope_exports, {
  AtrulePrelude: () => atrulePrelude_default,
  Selector: () => selector_default,
  Value: () => value_default
});

// node_modules/css-tree/lib/syntax/scope/default.js
var NUMBERSIGN4 = 35;
var ASTERISK6 = 42;
var PLUSSIGN9 = 43;
var HYPHENMINUS7 = 45;
var SOLIDUS7 = 47;
var U2 = 117;
function defaultRecognizer(context) {
  switch (this.tokenType) {
    case Hash:
      return this.Hash();
    case Comma:
      return this.Operator();
    case LeftParenthesis:
      return this.Parentheses(this.readSequence, context.recognizer);
    case LeftSquareBracket:
      return this.Brackets(this.readSequence, context.recognizer);
    case String2:
      return this.String();
    case Dimension:
      return this.Dimension();
    case Percentage:
      return this.Percentage();
    case Number2:
      return this.Number();
    case Function2:
      return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context.recognizer);
    case Url:
      return this.Url();
    case Ident:
      if (this.cmpChar(this.tokenStart, U2) && this.cmpChar(this.tokenStart + 1, PLUSSIGN9)) {
        return this.UnicodeRange();
      } else {
        return this.Identifier();
      }
    case Delim: {
      const code2 = this.charCodeAt(this.tokenStart);
      if (code2 === SOLIDUS7 || code2 === ASTERISK6 || code2 === PLUSSIGN9 || code2 === HYPHENMINUS7) {
        return this.Operator();
      }
      if (code2 === NUMBERSIGN4) {
        this.error("Hex or identifier is expected", this.tokenStart + 1);
      }
      break;
    }
  }
}

// node_modules/css-tree/lib/syntax/scope/atrulePrelude.js
var atrulePrelude_default = {
  getNode: defaultRecognizer
};

// node_modules/css-tree/lib/syntax/scope/selector.js
var NUMBERSIGN5 = 35;
var AMPERSAND6 = 38;
var ASTERISK7 = 42;
var PLUSSIGN10 = 43;
var SOLIDUS8 = 47;
var FULLSTOP3 = 46;
var GREATERTHANSIGN4 = 62;
var VERTICALLINE4 = 124;
var TILDE3 = 126;
function onWhiteSpace(next, children) {
  if (children.last !== null && children.last.type !== "Combinator" && next !== null && next.type !== "Combinator") {
    children.push({
      // FIXME: this.Combinator() should be used instead
      type: "Combinator",
      loc: null,
      name: " "
    });
  }
}
function getNode() {
  switch (this.tokenType) {
    case LeftSquareBracket:
      return this.AttributeSelector();
    case Hash:
      return this.IdSelector();
    case Colon:
      if (this.lookupType(1) === Colon) {
        return this.PseudoElementSelector();
      } else {
        return this.PseudoClassSelector();
      }
    case Ident:
      return this.TypeSelector();
    case Number2:
    case Percentage:
      return this.Percentage();
    case Dimension:
      if (this.charCodeAt(this.tokenStart) === FULLSTOP3) {
        this.error("Identifier is expected", this.tokenStart + 1);
      }
      break;
    case Delim: {
      const code2 = this.charCodeAt(this.tokenStart);
      switch (code2) {
        case PLUSSIGN10:
        case GREATERTHANSIGN4:
        case TILDE3:
        case SOLIDUS8:
          return this.Combinator();
        case FULLSTOP3:
          return this.ClassSelector();
        case ASTERISK7:
        case VERTICALLINE4:
          return this.TypeSelector();
        case NUMBERSIGN5:
          return this.IdSelector();
        case AMPERSAND6:
          return this.NestingSelector();
      }
      break;
    }
  }
}
var selector_default = {
  onWhiteSpace,
  getNode
};

// node_modules/css-tree/lib/syntax/function/expression.js
function expression_default() {
  return this.createSingleNodeList(
    this.Raw(null, false)
  );
}

// node_modules/css-tree/lib/syntax/function/var.js
function var_default() {
  const children = this.createList();
  this.skipSC();
  children.push(this.Identifier());
  this.skipSC();
  if (this.tokenType === Comma) {
    children.push(this.Operator());
    const startIndex = this.tokenIndex;
    const value = this.parseCustomProperty ? this.Value(null) : this.Raw(this.consumeUntilExclamationMarkOrSemicolon, false);
    if (value.type === "Value" && value.children.isEmpty) {
      for (let offset = startIndex - this.tokenIndex; offset <= 0; offset++) {
        if (this.lookupType(offset) === WhiteSpace) {
          value.children.appendData({
            type: "WhiteSpace",
            loc: null,
            value: " "
          });
          break;
        }
      }
    }
    children.push(value);
  }
  return children;
}

// node_modules/css-tree/lib/syntax/scope/value.js
function isPlusMinusOperator(node) {
  return node !== null && node.type === "Operator" && (node.value[node.value.length - 1] === "-" || node.value[node.value.length - 1] === "+");
}
var value_default = {
  getNode: defaultRecognizer,
  onWhiteSpace(next, children) {
    if (isPlusMinusOperator(next)) {
      next.value = " " + next.value;
    }
    if (isPlusMinusOperator(children.last)) {
      children.last.value += " ";
    }
  },
  "expression": expression_default,
  "var": var_default
};

// node_modules/css-tree/lib/syntax/atrule/container.js
var nonContainerNameKeywords = /* @__PURE__ */ new Set(["none", "and", "not", "or"]);
var container_default = {
  parse: {
    prelude() {
      const children = this.createList();
      if (this.tokenType === Ident) {
        const name50 = this.substring(this.tokenStart, this.tokenEnd);
        if (!nonContainerNameKeywords.has(name50.toLowerCase())) {
          children.push(this.Identifier());
        }
      }
      children.push(this.Condition("container"));
      return children;
    },
    block(nested = false) {
      return this.Block(nested);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/font-face.js
var font_face_default = {
  parse: {
    prelude: null,
    block() {
      return this.Block(true);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/import.js
function parseWithFallback(parse53, fallback) {
  return this.parseWithFallback(
    () => {
      try {
        return parse53.call(this);
      } finally {
        this.skipSC();
        if (this.lookupNonWSType(0) !== RightParenthesis) {
          this.error();
        }
      }
    },
    fallback || (() => this.Raw(null, true))
  );
}
var parseFunctions = {
  layer() {
    this.skipSC();
    const children = this.createList();
    const node = parseWithFallback.call(this, this.Layer);
    if (node.type !== "Raw" || node.value !== "") {
      children.push(node);
    }
    return children;
  },
  supports() {
    this.skipSC();
    const children = this.createList();
    const node = parseWithFallback.call(
      this,
      this.Declaration,
      () => parseWithFallback.call(this, () => this.Condition("supports"))
    );
    if (node.type !== "Raw" || node.value !== "") {
      children.push(node);
    }
    return children;
  }
};
var import_default3 = {
  parse: {
    prelude() {
      const children = this.createList();
      switch (this.tokenType) {
        case String2:
          children.push(this.String());
          break;
        case Url:
        case Function2:
          children.push(this.Url());
          break;
        default:
          this.error("String or url() is expected");
      }
      this.skipSC();
      if (this.tokenType === Ident && this.cmpStr(this.tokenStart, this.tokenEnd, "layer")) {
        children.push(this.Identifier());
      } else if (this.tokenType === Function2 && this.cmpStr(this.tokenStart, this.tokenEnd, "layer(")) {
        children.push(this.Function(null, parseFunctions));
      }
      this.skipSC();
      if (this.tokenType === Function2 && this.cmpStr(this.tokenStart, this.tokenEnd, "supports(")) {
        children.push(this.Function(null, parseFunctions));
      }
      if (this.lookupNonWSType(0) === Ident || this.lookupNonWSType(0) === LeftParenthesis) {
        children.push(this.MediaQueryList());
      }
      return children;
    },
    block: null
  }
};

// node_modules/css-tree/lib/syntax/atrule/layer.js
var layer_default = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.LayerList()
      );
    },
    block() {
      return this.Block(false);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/media.js
var media_default = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.MediaQueryList()
      );
    },
    block(nested = false) {
      return this.Block(nested);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/nest.js
var nest_default = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.SelectorList()
      );
    },
    block() {
      return this.Block(true);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/page.js
var page_default = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.SelectorList()
      );
    },
    block() {
      return this.Block(true);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/scope.js
var scope_default = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.Scope()
      );
    },
    block(nested = false) {
      return this.Block(nested);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/starting-style.js
var starting_style_default = {
  parse: {
    prelude: null,
    block(nested = false) {
      return this.Block(nested);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/supports.js
var supports_default = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.Condition("supports")
      );
    },
    block(nested = false) {
      return this.Block(nested);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/index.js
var atrule_default = {
  container: container_default,
  "font-face": font_face_default,
  import: import_default3,
  layer: layer_default,
  media: media_default,
  nest: nest_default,
  page: page_default,
  scope: scope_default,
  "starting-style": starting_style_default,
  supports: supports_default
};

// node_modules/css-tree/lib/syntax/pseudo/lang.js
function parseLanguageRangeList() {
  const children = this.createList();
  this.skipSC();
  loop: while (!this.eof) {
    switch (this.tokenType) {
      case Ident:
        children.push(this.Identifier());
        break;
      case String2:
        children.push(this.String());
        break;
      case Comma:
        children.push(this.Operator());
        break;
      case RightParenthesis:
        break loop;
      default:
        this.error("Identifier, string or comma is expected");
    }
    this.skipSC();
  }
  return children;
}

// node_modules/css-tree/lib/syntax/pseudo/index.js
var selectorList = {
  parse() {
    return this.createSingleNodeList(
      this.SelectorList()
    );
  }
};
var selector = {
  parse() {
    return this.createSingleNodeList(
      this.Selector()
    );
  }
};
var identList = {
  parse() {
    return this.createSingleNodeList(
      this.Identifier()
    );
  }
};
var langList = {
  parse: parseLanguageRangeList
};
var nth = {
  parse() {
    return this.createSingleNodeList(
      this.Nth()
    );
  }
};
var pseudo_default = {
  "dir": identList,
  "has": selectorList,
  "lang": langList,
  "matches": selectorList,
  "is": selectorList,
  "-moz-any": selectorList,
  "-webkit-any": selectorList,
  "where": selectorList,
  "not": selectorList,
  "nth-child": nth,
  "nth-last-child": nth,
  "nth-last-of-type": nth,
  "nth-of-type": nth,
  "slotted": selector,
  "host": selector,
  "host-context": selector
};

// node_modules/css-tree/lib/syntax/node/index-parse.js
var index_parse_exports = {};
__export(index_parse_exports, {
  AnPlusB: () => parse3,
  Atrule: () => parse4,
  AtrulePrelude: () => parse5,
  AttributeSelector: () => parse6,
  Block: () => parse7,
  Brackets: () => parse8,
  CDC: () => parse9,
  CDO: () => parse10,
  ClassSelector: () => parse11,
  Combinator: () => parse12,
  Comment: () => parse13,
  Condition: () => parse14,
  Declaration: () => parse15,
  DeclarationList: () => parse16,
  Dimension: () => parse17,
  Feature: () => parse18,
  FeatureFunction: () => parse19,
  FeatureRange: () => parse20,
  Function: () => parse21,
  GeneralEnclosed: () => parse22,
  Hash: () => parse23,
  IdSelector: () => parse25,
  Identifier: () => parse24,
  Layer: () => parse26,
  LayerList: () => parse27,
  MediaQuery: () => parse28,
  MediaQueryList: () => parse29,
  NestingSelector: () => parse30,
  Nth: () => parse31,
  Number: () => parse32,
  Operator: () => parse33,
  Parentheses: () => parse34,
  Percentage: () => parse35,
  PseudoClassSelector: () => parse36,
  PseudoElementSelector: () => parse37,
  Ratio: () => parse38,
  Raw: () => parse39,
  Rule: () => parse40,
  Scope: () => parse41,
  Selector: () => parse42,
  SelectorList: () => parse43,
  String: () => parse44,
  StyleSheet: () => parse45,
  SupportsDeclaration: () => parse46,
  TypeSelector: () => parse47,
  UnicodeRange: () => parse48,
  Url: () => parse49,
  Value: () => parse50,
  WhiteSpace: () => parse51
});

// node_modules/css-tree/lib/syntax/config/parser.js
var parser_default = {
  parseContext: {
    default: "StyleSheet",
    stylesheet: "StyleSheet",
    atrule: "Atrule",
    atrulePrelude(options) {
      return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
    },
    mediaQueryList: "MediaQueryList",
    mediaQuery: "MediaQuery",
    condition(options) {
      return this.Condition(options.kind);
    },
    rule: "Rule",
    selectorList: "SelectorList",
    selector: "Selector",
    block() {
      return this.Block(true);
    },
    declarationList: "DeclarationList",
    declaration: "Declaration",
    value: "Value"
  },
  features: {
    supports: {
      selector() {
        return this.Selector();
      }
    },
    container: {
      style() {
        return this.Declaration();
      }
    }
  },
  scope: scope_exports,
  atrule: atrule_default,
  pseudo: pseudo_default,
  node: index_parse_exports
};

// node_modules/css-tree/lib/syntax/config/walker.js
var walker_default = {
  node: node_exports
};

// node_modules/css-tree/lib/syntax/index.js
var syntax_default = create_default({
  ...lexer_default,
  ...parser_default,
  ...walker_default
});

// node_modules/css-tree/lib/utils/clone.js
function clone2(node) {
  const result = {};
  for (const key of Object.keys(node)) {
    let value = node[key];
    if (value) {
      if (Array.isArray(value) || value instanceof List) {
        value = value.map(clone2);
      } else if (value.constructor === Object) {
        value = clone2(value);
      }
    }
    result[key] = value;
  }
  return result;
}

// node_modules/css-tree/lib/utils/ident.js
var ident_exports = {};
__export(ident_exports, {
  decode: () => decode3,
  encode: () => encode4
});
var REVERSE_SOLIDUS3 = 92;
function decode3(str) {
  const end = str.length - 1;
  let decoded = "";
  for (let i = 0; i < str.length; i++) {
    let code2 = str.charCodeAt(i);
    if (code2 === REVERSE_SOLIDUS3) {
      if (i === end) {
        break;
      }
      code2 = str.charCodeAt(++i);
      if (isValidEscape(REVERSE_SOLIDUS3, code2)) {
        const escapeStart = i - 1;
        const escapeEnd = consumeEscaped(str, escapeStart);
        i = escapeEnd - 1;
        decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
      } else {
        if (code2 === 13 && str.charCodeAt(i + 1) === 10) {
          i++;
        }
      }
    } else {
      decoded += str[i];
    }
  }
  return decoded;
}
function encode4(str) {
  let encoded = "";
  if (str.length === 1 && str.charCodeAt(0) === 45) {
    return "\\-";
  }
  for (let i = 0; i < str.length; i++) {
    const code2 = str.charCodeAt(i);
    if (code2 === 0) {
      encoded += "";
      continue;
    }
    if (
      // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F ...
      // Note: Do not compare with 0x0001 since 0x0000 is precessed before
      code2 <= 31 || code2 === 127 || // [or] ... is in the range [0-9] (U+0030 to U+0039),
      code2 >= 48 && code2 <= 57 && // If the character is the first character ...
      (i === 0 || // If the character is the second character ... and the first character is a "-" (U+002D)
      i === 1 && str.charCodeAt(0) === 45)
    ) {
      encoded += "\\" + code2.toString(16) + " ";
      continue;
    }
    if (isName(code2)) {
      encoded += str.charAt(i);
    } else {
      encoded += "\\" + str.charAt(i);
    }
  }
  return encoded;
}

// node_modules/css-tree/lib/index.js
var {
  tokenize: tokenize2,
  parse: parse52,
  generate: generate51,
  lexer,
  createLexer,
  walk: walk2,
  find,
  findLast,
  findAll,
  toPlainObject,
  fromPlainObject,
  fork
} = syntax_default;

// node_modules/@unocss/transformer-directives/dist/index.mjs
async function handleApply(ctx, node) {
  const { code: code2, uno, options, filename } = ctx;
  await Promise.all(node.block.children.map(async (childNode) => {
    if (childNode.type === "Raw") return transformDirectives(code2, uno, options, filename, childNode.value, childNode.loc.start.offset);
    await parseApply(ctx, node, childNode);
  }).toArray());
}
async function parseApply({ code: code2, uno, applyVariable }, node, childNode) {
  var _a;
  const original = code2.original;
  let body;
  if (childNode.type === "Atrule" && childNode.name === "apply" && childNode.prelude && childNode.prelude.type === "Raw") body = removeQuotes(childNode.prelude.value.trim());
  else if (childNode.type === "Declaration" && applyVariable.includes(childNode.property) && (childNode.value.type === "Value" || childNode.value.type === "Raw")) {
    let rawValue = original.slice(childNode.value.loc.start.offset, childNode.value.loc.end.offset).trim();
    rawValue = removeQuotes(rawValue);
    body = rawValue.split(/\s+/g).filter(Boolean).map((i) => removeQuotes(i)).join(" ");
  }
  if (!body) return;
  body = removeComments(body);
  const classNames = expandVariantGroup(body).split(/\s+/g).map((className) => className.trim().replace(/\\/, ""));
  const utils = (await Promise.all(classNames.map((i) => uno.parseToken(i, "-")))).filter(notNull).flat().sort((a, b) => a[0] - b[0]).sort((a, b) => (a[3] ? uno.parentOrders.get(a[3]) ?? 0 : 0) - (b[3] ? uno.parentOrders.get(b[3]) ?? 0 : 0)).reduce((acc, item) => {
    const target = acc.find((i) => i[1] === item[1] && i[3] === item[3]);
    if (target) target[2] += item[2];
    else acc.push([...item]);
    return acc;
  }, []);
  if (!utils.length) return;
  let semicolonOffset = original[childNode.loc.end.offset] === ";" ? 1 : original[childNode.loc.end.offset] === "@" ? -1 : 0;
  for (const i of utils) {
    const [, _selector, body$1, parent, meta] = i;
    const selectorOrGroup = (_selector == null ? void 0 : _selector.replace(regexScopePlaceholder, " ")) || _selector;
    if (parent || selectorOrGroup && selectorOrGroup !== ".\\-" || (meta == null ? void 0 : meta.noMerge)) {
      let newSelector = generate51(node.prelude);
      const className = code2.slice(node.prelude.loc.start.offset, node.prelude.loc.end.offset);
      if (meta == null ? void 0 : meta.noMerge) newSelector = selectorOrGroup;
      else if (selectorOrGroup && selectorOrGroup !== ".\\-") {
        const ruleAST = parse52(`${selectorOrGroup}{}`, { context: "rule" });
        const prelude = clone2(node.prelude);
        (_a = prelude.children) == null ? void 0 : _a.forEach((child) => {
          var _a2;
          const selectorListAst = clone2(ruleAST.prelude);
          const classSelectors = new List();
          (_a2 = selectorListAst == null ? void 0 : selectorListAst.children) == null ? void 0 : _a2.forEach((selectorAst) => {
            var _a3;
            classSelectors.appendList((_a3 = selectorAst == null ? void 0 : selectorAst.children) == null ? void 0 : _a3.filter((i$1) => i$1.type === "ClassSelector" && i$1.name === "\\-"));
          });
          classSelectors.forEach((i$1) => Object.assign(i$1, clone2(child)));
          Object.assign(child, selectorListAst);
        });
        newSelector = generate51(prelude);
      }
      let css = `${newSelector.includes(".\\-") ? className.split(",").map((e2) => newSelector.replace(/.\\-/g, e2.trim())).join(",") : newSelector}{${body$1}}`;
      if (parent) if (parent.includes(" $$ ")) {
        const [first, ...parentSelectors] = parent.split(" $$ ").reverse();
        css = `${parentSelectors.reduce((p, c, i$1) => i$1 === parentSelectors.length - 1 ? `${p}{${c}{${css}}}${"}".repeat(i$1)}` : `${p}{${c}`, first)}`;
      } else if (parent === ".\\-") css = `${className}{${css}}`;
      else css = `${parent}{${css}}`;
      semicolonOffset = 0;
      code2.appendLeft(node.loc.end.offset, css);
    } else if (body$1.includes("@")) code2.appendRight(original.length, body$1);
    else code2.appendRight(childNode.loc.end.offset + semicolonOffset, body$1);
  }
  code2.remove(childNode.loc.start.offset, childNode.loc.end.offset + semicolonOffset);
}
function removeQuotes(value) {
  return value.replace(/^(['"])(.*)\1$/, "$2");
}
function removeComments(value) {
  return value.replace(/(\/\*(?:.|\n)*?\*\/)|(\/\/.*)/g, "");
}
async function transformIconString(uno, icon, color) {
  var _a, _b, _c;
  const presetIcons2 = (_b = (_a = uno.config.presets) == null ? void 0 : _a.flat()) == null ? void 0 : _b.find((i) => i.name === "@unocss/preset-icons");
  if (!presetIcons2) {
    console.warn("@unocss/preset-icons not found, icon() directive will be keep as-is");
    return;
  }
  const { scale = 1, prefix = "i-", collections: customCollections, customizations = {}, autoInstall = false, iconifyCollectionsNames, collectionsNodeResolvePath, unit } = presetIcons2.options;
  const api = presetIcons2.api;
  const loaderOptions = {
    addXmlNs: true,
    scale,
    customCollections,
    autoInstall,
    cwd: collectionsNodeResolvePath,
    warn: void 0,
    customizations: {
      ...customizations,
      trimCustomSvg: true,
      async iconCustomizer(collection, icon$1, props) {
        var _a2;
        await ((_a2 = customizations.iconCustomizer) == null ? void 0 : _a2.call(customizations, collection, icon$1, props));
        if (unit) {
          if (!props.width) props.width = `${scale}${unit}`;
          if (!props.height) props.height = `${scale}${unit}`;
        }
      }
    }
  };
  const loader = await ((_c = api.createNodeLoader) == null ? void 0 : _c.call(api)) || (async () => void 0);
  for (const p of toArray(prefix)) if (icon.startsWith(p)) {
    icon = icon.slice(p.length);
    const parsed = await api.parseIconWithLoader(icon, loader, loaderOptions, iconifyCollectionsNames);
    if (parsed) return `url("data:image/svg+xml;utf8,${color ? api.encodeSvgForCss(parsed.svg).replace(/currentcolor/gi, color) : api.encodeSvgForCss(parsed.svg)}")`;
  }
}
async function handleFunction({ code: code2, uno, options }, node) {
  const { throwOnMissing = true } = options;
  switch (node.name) {
    case "theme": {
      if (!node.children.size) throw new Error("theme() expect exact one argument");
      if (node.children.first.type !== "String") throw new Error("theme() expect a string argument");
      let defaultValueLoc;
      if (node.children.size > 1) {
        const remains = node.children.toArray().slice(1);
        if (!(remains[0].type === "Operator" && remains[0].value === ",")) throw new Error("theme() expect a comma between expression string and default value");
        if (remains.length > 1) defaultValueLoc = [remains[1].loc.start.offset, node.children.last.loc.end.offset];
      }
      const themeStr = node.children.first.value;
      let value = transformThemeString(themeStr, uno.config.theme, !defaultValueLoc && throwOnMissing);
      if (!value && defaultValueLoc) value = code2.slice(defaultValueLoc[0], defaultValueLoc[1]);
      if (value) code2.overwrite(node.loc.start.offset, node.loc.end.offset, value);
      break;
    }
    case "icon": {
      const params = node.children.toArray().filter((node$1) => node$1.type === "String").map((node$1) => node$1.value);
      if (params.length === 0) throw new Error("icon() expects at least one argument");
      let [icon, color] = params;
      if (color) color = encodeURIComponent(transformThemeFn(color, uno.config.theme, throwOnMissing));
      const value = await transformIconString(uno, icon, color);
      if (value) code2.overwrite(node.loc.start.offset, node.loc.end.offset, value);
      break;
    }
  }
}
var screenRuleRE = /(@screen [^{]+)(.+)/g;
function handleScreen({ code: code2, uno }, node) {
  var _a;
  let breakpointName = "";
  let prefix = "";
  if (((_a = node.prelude) == null ? void 0 : _a.type) === "Raw") breakpointName = node.prelude.value.trim();
  if (!breakpointName) return;
  const match = breakpointName.match(/^(?:(lt|at)-)?(\w+)$/);
  if (match) {
    prefix = match[1];
    breakpointName = match[2];
  }
  const resolveBreakpoints3 = () => {
    const key = uno.config.presets.some((p) => p.name === "@unocss/preset-wind4") ? "breakpoint" : "breakpoints";
    const breakpoints2 = uno.config.theme[key];
    return breakpoints2 ? Object.entries(breakpoints2).sort((a, b) => Number.parseInt(a[1].replace(/[a-z]+/gi, "")) - Number.parseInt(b[1].replace(/[a-z]+/gi, ""))).map(([point, size]) => ({
      point,
      size
    })) : void 0;
  };
  const variantEntries = (resolveBreakpoints3() ?? []).map(({ point, size }, idx) => [
    point,
    size,
    idx
  ]);
  const generateMediaQuery = (breakpointName$1, prefix$1) => {
    const [, size, idx] = variantEntries.find((i) => i[0] === breakpointName$1);
    if (prefix$1) if (prefix$1 === "lt") return `@media (max-width: ${calcMaxWidthBySize(size)})`;
    else if (prefix$1 === "at") return `@media (min-width: ${size})${variantEntries[idx + 1] ? ` and (max-width: ${calcMaxWidthBySize(variantEntries[idx + 1][1])})` : ""}`;
    else throw new Error(`breakpoint variant not supported: ${prefix$1}`);
    return `@media (min-width: ${size})`;
  };
  if (!variantEntries.find((i) => i[0] === breakpointName)) throw new Error(`breakpoint ${breakpointName} not found`);
  const offset = node.loc.start.offset;
  const str = code2.original.slice(offset, node.loc.end.offset);
  const matches = Array.from(str.matchAll(screenRuleRE));
  if (!matches.length) return;
  for (const match$1 of matches) code2.overwrite(offset + match$1.index, offset + match$1.index + match$1[1].length, `${generateMediaQuery(breakpointName, prefix)}`);
}
async function transformDirectives(code2, uno, options, filename, originalCode, offset) {
  let { applyVariable } = options;
  const varStyle = options.varStyle;
  if (applyVariable === void 0) {
    if (varStyle !== void 0) applyVariable = varStyle ? [`${varStyle}apply`] : [];
    applyVariable = [
      "--at-apply",
      "--uno-apply",
      "--uno"
    ];
  }
  applyVariable = toArray(applyVariable || []);
  const isHasApply = (code$1) => code$1.includes("@apply") || applyVariable.some((s) => code$1.includes(s));
  const parseCode = originalCode || code2.original;
  const hasApply = isHasApply(parseCode);
  const hasScreen = parseCode.includes("@screen");
  const hasFn = hasThemeFn(parseCode) || hasIconFn(parseCode);
  if (!hasApply && !hasFn && !hasScreen) return;
  const ast = parse52(parseCode, {
    parseCustomProperty: true,
    parseAtrulePrelude: false,
    positions: true,
    filename,
    offset
  });
  if (ast.type !== "StyleSheet") return;
  const stack = [];
  const ctx = {
    options,
    applyVariable,
    uno,
    code: code2,
    filename,
    offset
  };
  const processNode = async (node, _item, _list) => {
    if (hasScreen && node.type === "Atrule" && node.name === "screen") handleScreen(ctx, node);
    else if (node.type === "Function") await handleFunction(ctx, node);
    else if (hasApply && node.type === "Rule") await handleApply(ctx, node);
  };
  walk2(ast, (...args) => stack.push(processNode(...args)));
  await Promise.all(stack);
  const oldCode = code2.toString();
  if (!isHasApply(oldCode)) {
    const newCode = oldCode.replace(/([^{}]+)\{\s*\}\s*/g, (m, selector2) => {
      if (/^[\s\w\-.,#:[\]=*"'>~+^$|()\\]+$/.test(selector2.trim())) return "";
      return m;
    });
    if (newCode !== oldCode) code2.update(0, code2.original.length, newCode);
  }
}
function transformerDirectives(options = {}) {
  return {
    name: "@unocss/transformer-directives",
    enforce: options == null ? void 0 : options.enforce,
    idFilter: (id) => cssIdRE.test(id),
    transform: (code2, id, ctx) => {
      return transformDirectives(code2, ctx.uno, options, id);
    }
  };
}

// node_modules/@unocss/transformer-variant-group/dist/index.mjs
function transformerVariantGroup(options = {}) {
  return {
    name: "@unocss/transformer-variant-group",
    enforce: "pre",
    transform(s) {
      const result = parseVariantGroup(s, options.separators);
      return { get highlightAnnotations() {
        return [...result.groupsByOffset.values()].flatMap((group) => group.items);
      } };
    }
  };
}

// node_modules/unocss/dist/index.mjs
function defineConfig(config) {
  return config;
}
export {
  BetterMap,
  CountableSet,
  DEFAULT_LAYERS,
  LAYER_DEFAULT,
  LAYER_IMPORTS,
  LAYER_PREFLIGHTS,
  LAYER_SHORTCUTS,
  TwoKeyMap,
  UnoGenerator,
  VirtualKey,
  attributifyRE,
  clearIdenticalEntries,
  clone,
  collapseVariantGroup,
  createGenerator,
  createNanoEvents,
  cssIdRE,
  defaultSplitRE,
  defineConfig,
  definePreset,
  e,
  entriesToCss,
  escapeRegExp,
  escapeSelector,
  expandVariantGroup,
  extractorSplit as extractorDefault,
  extractorSplit,
  hasScopePlaceholder,
  isAttributifySelector,
  isCountableSet,
  isObject,
  isRawUtil,
  isStaticRule,
  isStaticShortcut,
  isString,
  isValidSelector,
  makeRegexClassGroup,
  mergeConfigs,
  mergeDeep,
  noop,
  normalizeCSSEntries,
  normalizeCSSValues,
  normalizeVariant,
  notNull,
  parseVariantGroup,
  src_default as presetAttributify,
  browser_default as presetIcons,
  src_default2 as presetMini,
  src_default3 as presetTagify,
  src_default4 as presetTypography,
  src_default6 as presetUno,
  src_default7 as presetWebFonts,
  src_default8 as presetWind,
  src_default5 as presetWind3,
  src_default9 as presetWind4,
  regexScopePlaceholder,
  resolveConfig,
  resolvePreset,
  resolvePresets,
  resolveShortcuts,
  splitWithVariantGroupRE,
  symbols,
  toArray,
  toEscapedSelector,
  transformerAttributifyJsx,
  transformerCompileClass,
  transformerDirectives,
  transformerVariantGroup,
  uniq,
  uniqueBy,
  validateFilterRE,
  warnOnce,
  withLayer
};
//# sourceMappingURL=unocss.js.map
